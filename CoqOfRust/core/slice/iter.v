(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module slice.
  Module iter.
    Module Impl_core_iter_traits_collect_IntoIterator_for_ref__slice_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*     type Item = &'a T; *)
      Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
      
      (*     type IntoIter = Iter<'a, T>; *)
      Definition _IntoIter (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [ T ].
      
      (*
          fn into_iter(self) -> Iter<'a, T> {
              self.iter()
          }
      *)
      Definition into_iter (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "iter", [] |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("IntoIter", InstanceField.Ty (_IntoIter T));
            ("into_iter", InstanceField.Method (into_iter T))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_for_ref__slice_T.
    
    Module Impl_core_iter_traits_collect_IntoIterator_for_ref_mut_slice_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*     type Item = &'a mut T; *)
      Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [ T ].
      
      (*     type IntoIter = IterMut<'a, T>; *)
      Definition _IntoIter (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ].
      
      (*
          fn into_iter(self) -> IterMut<'a, T> {
              self.iter_mut()
          }
      *)
      Definition into_iter (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "iter_mut", [] |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("IntoIter", InstanceField.Ty (_IntoIter T));
            ("into_iter", InstanceField.Method (into_iter T))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_for_ref_mut_slice_T.
    
    (* StructRecord
      {
        name := "Iter";
        ty_params := [ "T" ];
        fields :=
          [
            ("ptr", Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ]);
            ("end_or_len", Ty.apply (Ty.path "*const") [ T ]);
            ("_marker",
              Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.apply (Ty.path "&") [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("Iter").field(&self.as_slice()).finish()
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugTuple",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Iter" |) ]
                      |)
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                            "as_slice",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Iter_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_Iter_T.
    
    Module Impl_core_marker_Send_where_core_marker_Sync_T_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Sync_T_for_core_slice_iter_Iter_T.
    
    Module Impl_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T]) -> Self {
              let ptr = slice.as_ptr();
              // SAFETY: Similar to `IterMut::new`.
              unsafe {
                  let end_or_len = if T::IS_ZST { invalid(slice.len()) } else { ptr.add(slice.len()) };
      
                  Self { ptr: NonNull::new_unchecked(ptr as *mut T), end_or_len, _marker: PhantomData }
              }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              let~ ptr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "as_ptr", [] |),
                    [ M.read (| slice |) ]
                  |)
                |) in
              let~ end_or_len :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (| "core::ptr::invalid", [ T ] |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| slice |) ]
                                |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*const") [ T ],
                                "add",
                                []
                              |),
                              [
                                M.read (| ptr |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| slice |) ]
                                |)
                              ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::slice::iter::Iter"
                  [
                    ("ptr",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                          "new_unchecked",
                          []
                        |),
                        [ M.rust_cast (M.read (| ptr |)) ]
                      |));
                    ("end_or_len", M.read (| end_or_len |));
                    ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub fn as_slice(&self) -> &'a [T] {
              self.make_slice()
          }
      *)
      Definition as_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                "make_slice",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_slice" (as_slice T).
    End Impl_core_slice_iter_Iter_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [ T ].
      
      (*
          fn clone(&self) -> Self {
              Iter { ptr: self.ptr, end_or_len: self.end_or_len, _marker: self._marker }
          }
      *)
      Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::Iter"
              [
                ("ptr",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Iter",
                      "ptr"
                    |)
                  |));
                ("end_or_len",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Iter",
                      "end_or_len"
                    |)
                  |));
                ("_marker",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Iter",
                      "_marker"
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_Iter_T.
    
    Module Impl_core_convert_AsRef_slice_T_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [ T ].
      
      (*
          fn as_ref(&self) -> &[T] {
              self.as_slice()
          }
      *)
      Definition as_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                "as_slice",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::AsRef"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "slice") [ T ] ]
          (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T)) ].
    End Impl_core_convert_AsRef_slice_T_for_core_slice_iter_Iter_T.
    
    (* StructRecord
      {
        name := "IterMut";
        ty_params := [ "T" ];
        fields :=
          [
            ("ptr", Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ]);
            ("end_or_len", Ty.apply (Ty.path "*mut") [ T ]);
            ("_marker",
              Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.apply (Ty.path "&mut") [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("IterMut").field(&self.make_slice()).finish()
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugTuple",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "IterMut" |) ]
                      |)
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ],
                            "make_slice",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_IterMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_IterMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_IterMut_T.
    
    Module Impl_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T]) -> Self {
              let ptr = slice.as_mut_ptr();
              // SAFETY: There are several things here:
              //
              // `ptr` has been obtained by `slice.as_ptr()` where `slice` is a valid
              // reference thus it is non-NUL and safe to use and pass to
              // `NonNull::new_unchecked` .
              //
              // Adding `slice.len()` to the starting pointer gives a pointer
              // at the end of `slice`. `end` will never be dereferenced, only checked
              // for direct pointer equality with `ptr` to check if the iterator is
              // done.
              //
              // In the case of a ZST, the end pointer is just the length.  It's never
              // used as a pointer at all, and thus it's fine to have no provenance.
              //
              // See the `next_unchecked!` and `is_empty!` macros as well as the
              // `post_inc_start` method for more information.
              unsafe {
                  let end_or_len =
                      if T::IS_ZST { invalid_mut(slice.len()) } else { ptr.add(slice.len()) };
      
                  Self { ptr: NonNull::new_unchecked(ptr), end_or_len, _marker: PhantomData }
              }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              let~ ptr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ T ],
                      "as_mut_ptr",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |) in
              let~ end_or_len :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (| "core::ptr::invalid_mut", [ T ] |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| slice |) ]
                                |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ T ],
                                "add",
                                []
                              |),
                              [
                                M.read (| ptr |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| slice |) ]
                                |)
                              ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::slice::iter::IterMut"
                  [
                    ("ptr",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                          "new_unchecked",
                          []
                        |),
                        [ M.read (| ptr |) ]
                      |));
                    ("end_or_len", M.read (| end_or_len |));
                    ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub fn into_slice(self) -> &'a mut [T] {
              // SAFETY: the iterator was created from a mutable slice with pointer
              // `self.ptr` and length `len!(self)`. This guarantees that all the prerequisites
              // for `from_raw_parts_mut` are fulfilled.
              unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }
          }
      *)
      Definition into_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::slice::raw::from_raw_parts_mut", [ T ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::slice::iter::IterMut",
                        "ptr"
                      |)
                    |)
                  ]
                |);
                M.read (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ len :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ T ],
                                  "addr",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "core::slice::iter::IterMut",
                                      "end_or_len"
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          len));
                      fun γ =>
                        ltac:(M.monadic
                          (let~ end_ :=
                            M.copy (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.apply (Ty.path "*mut") [ T ] ],
                                  "cast",
                                  [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ] ]
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::IterMut",
                                    "end_or_len"
                                  |)
                                ]
                              |)
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                                "sub_ptr",
                                []
                              |),
                              [
                                M.read (| end_ |);
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::IterMut",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |)
                          |)))
                    ]
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "into_slice" (into_slice T).
      
      (*
          pub fn as_slice(&self) -> &[T] {
              self.make_slice()
          }
      *)
      Definition as_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ],
                "make_slice",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_slice" (as_slice T).
      
      (*
          pub fn as_mut_slice(&mut self) -> &mut [T] {
              // SAFETY: the iterator was created from a mutable slice with pointer
              // `self.ptr` and length `len!(self)`. This guarantees that all the prerequisites
              // for `from_raw_parts_mut` are fulfilled.
              unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }
          }
      *)
      Definition as_mut_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "core::slice::raw::from_raw_parts_mut", [ T ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::IterMut",
                        "ptr"
                      |)
                    |)
                  ]
                |);
                M.read (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ len :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ T ],
                                  "addr",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::IterMut",
                                      "end_or_len"
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          len));
                      fun γ =>
                        ltac:(M.monadic
                          (let~ end_ :=
                            M.copy (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.apply (Ty.path "*mut") [ T ] ],
                                  "cast",
                                  [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ] ]
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::IterMut",
                                    "end_or_len"
                                  |)
                                ]
                              |)
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                                "sub_ptr",
                                []
                              |),
                              [
                                M.read (| end_ |);
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::IterMut",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |)
                          |)))
                    ]
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_mut_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_mut_slice" (as_mut_slice T).
    End Impl_core_slice_iter_IterMut_T.
    
    Module Impl_core_convert_AsRef_slice_T_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ].
      
      (*
          fn as_ref(&self) -> &[T] {
              self.as_slice()
          }
      *)
      Definition as_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ],
                "as_slice",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::AsRef"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "slice") [ T ] ]
          (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T)) ].
    End Impl_core_convert_AsRef_slice_T_for_core_slice_iter_IterMut_T.
    
    (* Trait *)
    (* Empty module 'SplitIter' *)
    
    (* StructRecord
      {
        name := "Split";
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("pred", P);
            ("finished", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a [T], pred: P) -> Self {
              Self { v: slice, pred, finished: false }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            Value.StructRecord
              "core::slice::iter::Split"
              [
                ("v", M.read (| slice |));
                ("pred", M.read (| pred |));
                ("finished", Value.Bool false)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
      
      (*
          pub fn as_slice(&self) -> &'a [T] {
              if self.finished { &[] } else { &self.v }
          }
      *)
      Definition as_slice (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Split",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Split",
                            "v"
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_slice :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "as_slice" (as_slice T P).
    End Impl_core_slice_iter_Split_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("Split").field("v", &self.v).field("finished", &self.finished).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Formatter",
                              "debug_struct",
                              []
                            |),
                            [ M.read (| f |); M.read (| Value.String "Split" |) ]
                          |)
                        |);
                        M.read (| Value.String "v" |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Split",
                            "v"
                          |))
                      ]
                    |);
                    M.read (| Value.String "finished" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::Split",
                        "finished"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ].
      
      (*
          fn clone(&self) -> Self {
              Split { v: self.v, pred: self.pred.clone(), finished: self.finished }
          }
      *)
      Definition clone (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::Split"
              [
                ("v",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Split",
                      "v"
                    |)
                  |));
                ("pred",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", P, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::Split",
                        "pred"
                      |)
                    ]
                  |));
                ("finished",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Split",
                      "finished"
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T P)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.finished {
                  return None;
              }
      
              match self.v.iter().position(|x| (self.pred)(x)) {
                  None => self.finish(),
                  Some(idx) => {
                      let ret = Some(&self.v[..idx]);
                      self.v = &self.v[idx + 1..];
                      ret
                  }
              }
          }
      *)
      Definition next (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::Split",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                          [],
                          "position",
                          [
                            Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                              (Ty.path "bool")
                          ]
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Split",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::function::FnMut",
                                              P,
                                              [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                              "call_mut",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::Split",
                                                "pred"
                                              |);
                                              Value.Tuple [ M.read (| x |) ]
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::slice::iter::SplitIter",
                                Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ],
                                [],
                                "finish",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let idx := M.copy (| γ0_0 |) in
                          let~ ret :=
                            M.alloc (|
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::Split",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [ ("end_", M.read (| idx |)) ]
                                    ]
                                  |)
                                ]
                            |) in
                          let~ _ :=
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::Split",
                                "v"
                              |),
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [ T ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeFrom")
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Split",
                                      "v"
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::RangeFrom"
                                    [
                                      ("start",
                                        BinOp.Wrap.add
                                          Integer.Usize
                                          (M.read (| idx |))
                                          (Value.Integer 1))
                                    ]
                                ]
                              |)
                            |) in
                          ret))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.finished {
                  (0, Some(0))
              } else {
                  // If the predicate doesn't match anything, we yield one slice.
                  // If it matches every element, we yield `len() + 1` empty slices.
                  (1, Some(self.v.len() + 1))
              }
          }
      *)
      Definition size_hint (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Split",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                BinOp.Wrap.add
                                  Integer.Usize
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [ T ],
                                      "len",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::Split",
                                          "v"
                                        |)
                                      |)
                                    ]
                                  |))
                                  (Value.Integer 1)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.finished {
                  return None;
              }
      
              match self.v.iter().rposition(|x| (self.pred)(x)) {
                  None => self.finish(),
                  Some(idx) => {
                      let ret = Some(&self.v[idx + 1..]);
                      self.v = &self.v[..idx];
                      ret
                  }
              }
          }
      *)
      Definition next_back (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::Split",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                          [],
                          "rposition",
                          [
                            Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                              (Ty.path "bool")
                          ]
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Split",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::function::FnMut",
                                              P,
                                              [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                              "call_mut",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::Split",
                                                "pred"
                                              |);
                                              Value.Tuple [ M.read (| x |) ]
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::slice::iter::SplitIter",
                                Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ],
                                [],
                                "finish",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let idx := M.copy (| γ0_0 |) in
                          let~ ret :=
                            M.alloc (|
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeFrom")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::Split",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeFrom"
                                        [
                                          ("start",
                                            BinOp.Wrap.add
                                              Integer.Usize
                                              (M.read (| idx |))
                                              (Value.Integer 1))
                                        ]
                                    ]
                                  |)
                                ]
                            |) in
                          let~ _ :=
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::Split",
                                "v"
                              |),
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [ T ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeTo")
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Split",
                                      "v"
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::RangeTo"
                                    [ ("end_", M.read (| idx |)) ]
                                ]
                              |)
                            |) in
                          ret))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    Module Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ].
      
      (*
          fn finish(&mut self) -> Option<&'a [T]> {
              if self.finished {
                  None
              } else {
                  self.finished = true;
                  Some(self.v)
              }
          }
      *)
      Definition finish (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Split",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Split",
                            "finished"
                          |),
                          Value.Bool true
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::Split",
                                "v"
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::slice::iter::SplitIter"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("finish", InstanceField.Method (finish T P)) ].
    End Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
      Definition Self (T P : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_Split_T_P.
    
    (* StructRecord
      {
        name := "SplitInclusive";
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("pred", P);
            ("finished", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a [T], pred: P) -> Self {
              let finished = slice.is_empty();
              Self { v: slice, pred, finished }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            M.read (|
              let~ finished :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ T ],
                      "is_empty",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::slice::iter::SplitInclusive"
                  [
                    ("v", M.read (| slice |));
                    ("pred", M.read (| pred |));
                    ("finished", M.read (| finished |))
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_SplitInclusive_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SplitInclusive")
                  .field("v", &self.v)
                  .field("finished", &self.finished)
                  .finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Formatter",
                              "debug_struct",
                              []
                            |),
                            [ M.read (| f |); M.read (| Value.String "SplitInclusive" |) ]
                          |)
                        |);
                        M.read (| Value.String "v" |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitInclusive",
                            "v"
                          |))
                      ]
                    |);
                    M.read (| Value.String "finished" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::SplitInclusive",
                        "finished"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [ T; P ].
      
      (*
          fn clone(&self) -> Self {
              SplitInclusive { v: self.v, pred: self.pred.clone(), finished: self.finished }
          }
      *)
      Definition clone (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::SplitInclusive"
              [
                ("v",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::SplitInclusive",
                      "v"
                    |)
                  |));
                ("pred",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", P, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::SplitInclusive",
                        "pred"
                      |)
                    ]
                  |));
                ("finished",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::SplitInclusive",
                      "finished"
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T P)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [ T; P ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.finished {
                  return None;
              }
      
              let idx =
                  self.v.iter().position(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(self.v.len());
              if idx == self.v.len() {
                  self.finished = true;
              }
              let ret = Some(&self.v[..idx]);
              self.v = &self.v[idx..];
              ret
          }
      *)
      Definition next (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusive",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ idx :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                          "unwrap_or",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                              "map",
                              [
                                Ty.path "usize";
                                Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                                  [],
                                  "position",
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                                      (Ty.path "bool")
                                  ]
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "iter",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::SplitInclusive",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let x := M.copy (| γ |) in
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      P,
                                                      [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                                      "call_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::slice::iter::SplitInclusive",
                                                        "pred"
                                                      |);
                                                      Value.Tuple [ M.read (| x |) ]
                                                    ]
                                                  |)))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let idx := M.copy (| γ |) in
                                              BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| idx |))
                                                (Value.Integer 1)))
                                        ]
                                      |)
                                    | _ => M.impossible (||)
                                    end))
                            ]
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "len",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusive",
                                  "v"
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| idx |))
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "len",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::SplitInclusive",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusive",
                                  "finished"
                                |),
                                Value.Bool true
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret :=
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ]
                              ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusive",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                [ ("end_", M.read (| idx |)) ]
                            ]
                          |)
                        ]
                    |) in
                  let~ _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::SplitInclusive",
                        "v"
                      |),
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply (Ty.path "slice") [ T ],
                          [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ] ],
                          "index",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::SplitInclusive",
                              "v"
                            |)
                          |);
                          Value.StructRecord
                            "core::ops::range::RangeFrom"
                            [ ("start", M.read (| idx |)) ]
                        ]
                      |)
                    |) in
                  ret
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.finished {
                  (0, Some(0))
              } else {
                  // If the predicate doesn't match anything, we yield one slice.
                  // If it matches every element, we yield `len()` one-element slices,
                  // or a single empty slice.
                  (1, Some(cmp::max(1, self.v.len())))
              }
          }
      *)
      Definition size_hint (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitInclusive",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                                  [
                                    Value.Integer 1;
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "len",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::SplitInclusive",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.finished {
                  return None;
              }
      
              // The last index of self.v is already checked and found to match
              // by the last iteration, so we start searching a new match
              // one index to the left.
              let remainder = if self.v.is_empty() { &[] } else { &self.v[..(self.v.len() - 1)] };
              let idx = remainder.iter().rposition(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(0);
              if idx == 0 {
                  self.finished = true;
              }
              let ret = Some(&self.v[idx..]);
              self.v = &self.v[..idx];
              ret
          }
      *)
      Definition next_back (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusive",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ remainder :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "is_empty",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::SplitInclusive",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::index::Index",
                                    Ty.apply (Ty.path "slice") [ T ],
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeTo")
                                        [ Ty.path "usize" ]
                                    ],
                                    "index",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::SplitInclusive",
                                        "v"
                                      |)
                                    |);
                                    Value.StructRecord
                                      "core::ops::range::RangeTo"
                                      [
                                        ("end_",
                                          BinOp.Wrap.sub
                                            Integer.Usize
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [ T ],
                                                "len",
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "core::slice::iter::SplitInclusive",
                                                    "v"
                                                  |)
                                                |)
                                              ]
                                            |))
                                            (Value.Integer 1))
                                      ]
                                  ]
                                |)
                              |)))
                        ]
                      |)
                    |) in
                  let~ idx :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                          "unwrap_or",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                              "map",
                              [
                                Ty.path "usize";
                                Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                                  [],
                                  "rposition",
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                                      (Ty.path "bool")
                                  ]
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "iter",
                                        []
                                      |),
                                      [ M.read (| remainder |) ]
                                    |)
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let x := M.copy (| γ |) in
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      P,
                                                      [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                                      "call_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::slice::iter::SplitInclusive",
                                                        "pred"
                                                      |);
                                                      Value.Tuple [ M.read (| x |) ]
                                                    ]
                                                  |)))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let idx := M.copy (| γ |) in
                                              BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| idx |))
                                                (Value.Integer 1)))
                                        ]
                                      |)
                                    | _ => M.impossible (||)
                                    end))
                            ]
                          |);
                          Value.Integer 0
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| idx |)) (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusive",
                                  "finished"
                                |),
                                Value.Bool true
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret :=
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ]
                              ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusive",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::RangeFrom"
                                [ ("start", M.read (| idx |)) ]
                            ]
                          |)
                        ]
                    |) in
                  let~ _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::SplitInclusive",
                        "v"
                      |),
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply (Ty.path "slice") [ T ],
                          [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ] ],
                          "index",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::SplitInclusive",
                              "v"
                            |)
                          |);
                          Value.StructRecord
                            "core::ops::range::RangeTo"
                            [ ("end_", M.read (| idx |)) ]
                        ]
                      |)
                    |) in
                  ret
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusive") [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusive_T_P.
    
    (* StructRecord
      {
        name := "SplitMut";
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("pred", P);
            ("finished", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {
              Self { v: slice, pred, finished: false }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            Value.StructRecord
              "core::slice::iter::SplitMut"
              [
                ("v", M.read (| slice |));
                ("pred", M.read (| pred |));
                ("finished", Value.Bool false)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_SplitMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SplitMut").field("v", &self.v).field("finished", &self.finished).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Formatter",
                              "debug_struct",
                              []
                            |),
                            [ M.read (| f |); M.read (| Value.String "SplitMut" |) ]
                          |)
                        |);
                        M.read (| Value.String "v" |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitMut",
                            "v"
                          |))
                      ]
                    |);
                    M.read (| Value.String "finished" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::SplitMut",
                        "finished"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
    
    Module Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ].
      
      (*
          fn finish(&mut self) -> Option<&'a mut [T]> {
              if self.finished {
                  None
              } else {
                  self.finished = true;
                  Some(mem::take(&mut self.v))
              }
          }
      *)
      Definition finish (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitMut",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitMut",
                            "finished"
                          |),
                          Value.Bool true
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_function (|
                                "core::mem::take",
                                [ Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ] ]
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitMut",
                                  "v"
                                |)
                              ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::slice::iter::SplitIter"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("finish", InstanceField.Method (finish T P)) ].
    End Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.finished {
                  return None;
              }
      
              match self.v.iter().position(|x| (self.pred)(x)) {
                  None => self.finish(),
                  Some(idx) => {
                      let tmp = mem::take(&mut self.v);
                      // idx is the index of the element we are splitting on. We want to set self to the
                      // region after idx, and return the subslice before and not including idx.
                      // So first we split after idx
                      let (head, tail) = tmp.split_at_mut(idx + 1);
                      self.v = tail;
                      // Then return the subslice up to but not including the found element
                      Some(&mut head[..idx])
                  }
              }
          }
      *)
      Definition next (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitMut",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                          [],
                          "position",
                          [
                            Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                              (Ty.path "bool")
                          ]
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::SplitMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::function::FnMut",
                                              P,
                                              [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                              "call_mut",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::SplitMut",
                                                "pred"
                                              |);
                                              Value.Tuple [ M.read (| x |) ]
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::slice::iter::SplitIter",
                                Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ],
                                [],
                                "finish",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let idx := M.copy (| γ0_0 |) in
                          let~ tmp :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "core::mem::take",
                                  [ Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ] ]
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::SplitMut",
                                    "v"
                                  |)
                                ]
                              |)
                            |) in
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "split_at_mut",
                                  []
                                |),
                                [
                                  M.read (| tmp |);
                                  BinOp.Wrap.add Integer.Usize (M.read (| idx |)) (Value.Integer 1)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let head := M.copy (| γ0_0 |) in
                                  let tail := M.copy (| γ0_1 |) in
                                  let~ _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::SplitMut",
                                        "v"
                                      |),
                                      M.read (| tail |)
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::index::IndexMut",
                                            Ty.apply (Ty.path "slice") [ T ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::ops::range::RangeTo")
                                                [ Ty.path "usize" ]
                                            ],
                                            "index_mut",
                                            []
                                          |),
                                          [
                                            M.read (| head |);
                                            Value.StructRecord
                                              "core::ops::range::RangeTo"
                                              [ ("end_", M.read (| idx |)) ]
                                          ]
                                        |)
                                      ]
                                  |)))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.finished {
                  (0, Some(0))
              } else {
                  // If the predicate doesn't match anything, we yield one slice.
                  // If it matches every element, we yield `len() + 1` empty slices.
                  (1, Some(self.v.len() + 1))
              }
          }
      *)
      Definition size_hint (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitMut",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                BinOp.Wrap.add
                                  Integer.Usize
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [ T ],
                                      "len",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::SplitMut",
                                          "v"
                                        |)
                                      |)
                                    ]
                                  |))
                                  (Value.Integer 1)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.finished {
                  return None;
              }
      
              let idx_opt = {
                  // work around borrowck limitations
                  let pred = &mut self.pred;
                  self.v.iter().rposition(|x| ( *pred)(x))
              };
              match idx_opt {
                  None => self.finish(),
                  Some(idx) => {
                      let tmp = mem::take(&mut self.v);
                      let (head, tail) = tmp.split_at_mut(idx);
                      self.v = head;
                      Some(&mut tail[1..])
                  }
              }
          }
      *)
      Definition next_back (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitMut",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ idx_opt :=
                    M.copy (|
                      let~ pred :=
                        M.alloc (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitMut",
                            "pred"
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                            [],
                            "rposition",
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                                (Ty.path "bool")
                            ]
                          |),
                          [
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "iter",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::SplitMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let x := M.copy (| γ |) in
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                P,
                                                [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                                "call_mut",
                                                []
                                              |),
                                              [ M.read (| pred |); Value.Tuple [ M.read (| x |) ] ]
                                            |)))
                                      ]
                                    |)
                                  | _ => M.impossible (||)
                                  end))
                          ]
                        |)
                      |)
                    |) in
                  M.match_operator (|
                    idx_opt,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::slice::iter::SplitIter",
                                Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ],
                                [],
                                "finish",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let idx := M.copy (| γ0_0 |) in
                          let~ tmp :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "core::mem::take",
                                  [ Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ] ]
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::SplitMut",
                                    "v"
                                  |)
                                ]
                              |)
                            |) in
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "split_at_mut",
                                  []
                                |),
                                [ M.read (| tmp |); M.read (| idx |) ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let head := M.copy (| γ0_0 |) in
                                  let tail := M.copy (| γ0_1 |) in
                                  let~ _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::SplitMut",
                                        "v"
                                      |),
                                      M.read (| head |)
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::index::IndexMut",
                                            Ty.apply (Ty.path "slice") [ T ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::ops::range::RangeFrom")
                                                [ Ty.path "usize" ]
                                            ],
                                            "index_mut",
                                            []
                                          |),
                                          [
                                            M.read (| tail |);
                                            Value.StructRecord
                                              "core::ops::range::RangeFrom"
                                              [ ("start", Value.Integer 1) ]
                                          ]
                                        |)
                                      ]
                                  |)))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitMut_T_P.
    
    (* StructRecord
      {
        name := "SplitInclusiveMut";
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("pred", P);
            ("finished", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_slice_iter_SplitInclusiveMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusiveMut") [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {
              let finished = slice.is_empty();
              Self { v: slice, pred, finished }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            M.read (|
              let~ finished :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ T ],
                      "is_empty",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::slice::iter::SplitInclusiveMut"
                  [
                    ("v", M.read (| slice |));
                    ("pred", M.read (| pred |));
                    ("finished", M.read (| finished |))
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_SplitInclusiveMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusiveMut") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SplitInclusiveMut")
                  .field("v", &self.v)
                  .field("finished", &self.finished)
                  .finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Formatter",
                              "debug_struct",
                              []
                            |),
                            [ M.read (| f |); M.read (| Value.String "SplitInclusiveMut" |) ]
                          |)
                        |);
                        M.read (| Value.String "v" |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitInclusiveMut",
                            "v"
                          |))
                      ]
                    |);
                    M.read (| Value.String "finished" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::SplitInclusiveMut",
                        "finished"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusiveMut") [ T; P ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.finished {
                  return None;
              }
      
              let idx_opt = {
                  // work around borrowck limitations
                  let pred = &mut self.pred;
                  self.v.iter().position(|x| ( *pred)(x))
              };
              let idx = idx_opt.map(|idx| idx + 1).unwrap_or(self.v.len());
              if idx == self.v.len() {
                  self.finished = true;
              }
              let tmp = mem::take(&mut self.v);
              let (head, tail) = tmp.split_at_mut(idx);
              self.v = tail;
              Some(head)
          }
      *)
      Definition next (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ idx_opt :=
                    M.copy (|
                      let~ pred :=
                        M.alloc (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitInclusiveMut",
                            "pred"
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                            [],
                            "position",
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                                (Ty.path "bool")
                            ]
                          |),
                          [
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "iter",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::SplitInclusiveMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let x := M.copy (| γ |) in
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                P,
                                                [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                                "call_mut",
                                                []
                                              |),
                                              [ M.read (| pred |); Value.Tuple [ M.read (| x |) ] ]
                                            |)))
                                      ]
                                    |)
                                  | _ => M.impossible (||)
                                  end))
                          ]
                        |)
                      |)
                    |) in
                  let~ idx :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                          "unwrap_or",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                              "map",
                              [
                                Ty.path "usize";
                                Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                              ]
                            |),
                            [
                              M.read (| idx_opt |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let idx := M.copy (| γ |) in
                                              BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| idx |))
                                                (Value.Integer 1)))
                                        ]
                                      |)
                                    | _ => M.impossible (||)
                                    end))
                            ]
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "len",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "v"
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| idx |))
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "len",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::SplitInclusiveMut",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "finished"
                                |),
                                Value.Bool true
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ tmp :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::mem::take",
                          [ Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ] ]
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitInclusiveMut",
                            "v"
                          |)
                        ]
                      |)
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [ T ],
                          "split_at_mut",
                          []
                        |),
                        [ M.read (| tmp |); M.read (| idx |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let head := M.copy (| γ0_0 |) in
                          let tail := M.copy (| γ0_1 |) in
                          let~ _ :=
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::SplitInclusiveMut",
                                "v"
                              |),
                              M.read (| tail |)
                            |) in
                          M.alloc (|
                            Value.StructTuple "core::option::Option::Some" [ M.read (| head |) ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.finished {
                  (0, Some(0))
              } else {
                  // If the predicate doesn't match anything, we yield one slice.
                  // If it matches every element, we yield `len()` one-element slices,
                  // or a single empty slice.
                  (1, Some(cmp::max(1, self.v.len())))
              }
          }
      *)
      Definition size_hint (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitInclusiveMut",
                            "finished"
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                                  [
                                    Value.Integer 1;
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "len",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::SplitInclusiveMut",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusiveMut") [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.finished {
                  return None;
              }
      
              let idx_opt = if self.v.is_empty() {
                  None
              } else {
                  // work around borrowck limitations
                  let pred = &mut self.pred;
      
                  // The last index of self.v is already checked and found to match
                  // by the last iteration, so we start searching a new match
                  // one index to the left.
                  let remainder = &self.v[..(self.v.len() - 1)];
                  remainder.iter().rposition(|x| ( *pred)(x))
              };
              let idx = idx_opt.map(|idx| idx + 1).unwrap_or(0);
              if idx == 0 {
                  self.finished = true;
              }
              let tmp = mem::take(&mut self.v);
              let (head, tail) = tmp.split_at_mut(idx);
              self.v = head;
              Some(tail)
          }
      *)
      Definition next_back (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "finished"
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ idx_opt :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "is_empty",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::SplitInclusiveMut",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ pred :=
                                M.alloc (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::SplitInclusiveMut",
                                    "pred"
                                  |)
                                |) in
                              let~ remainder :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::SplitInclusiveMut",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [
                                          ("end_",
                                            BinOp.Wrap.sub
                                              Integer.Usize
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "slice") [ T ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "core::slice::iter::SplitInclusiveMut",
                                                      "v"
                                                    |)
                                                  |)
                                                ]
                                              |))
                                              (Value.Integer 1))
                                        ]
                                    ]
                                  |)
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                                    [],
                                    "rposition",
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                                        (Ty.path "bool")
                                    ]
                                  |),
                                  [
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [ T ],
                                          "iter",
                                          []
                                        |),
                                        [ M.read (| remainder |) ]
                                      |)
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let x := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::function::FnMut",
                                                        P,
                                                        [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ]
                                                        ],
                                                        "call_mut",
                                                        []
                                                      |),
                                                      [
                                                        M.read (| pred |);
                                                        Value.Tuple [ M.read (| x |) ]
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  ]
                                |)
                              |)))
                        ]
                      |)
                    |) in
                  let~ idx :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                          "unwrap_or",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                              "map",
                              [
                                Ty.path "usize";
                                Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                              ]
                            |),
                            [
                              M.read (| idx_opt |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let idx := M.copy (| γ |) in
                                              BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| idx |))
                                                (Value.Integer 1)))
                                        ]
                                      |)
                                    | _ => M.impossible (||)
                                    end))
                            ]
                          |);
                          Value.Integer 0
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| idx |)) (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::SplitInclusiveMut",
                                  "finished"
                                |),
                                Value.Bool true
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ tmp :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::mem::take",
                          [ Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ] ]
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::SplitInclusiveMut",
                            "v"
                          |)
                        ]
                      |)
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [ T ],
                          "split_at_mut",
                          []
                        |),
                        [ M.read (| tmp |); M.read (| idx |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let head := M.copy (| γ0_0 |) in
                          let tail := M.copy (| γ0_1 |) in
                          let~ _ :=
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::SplitInclusiveMut",
                                "v"
                              |),
                              M.read (| head |)
                            |) in
                          M.alloc (|
                            Value.StructTuple "core::option::Option::Some" [ M.read (| tail |) ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitInclusiveMut") [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitInclusiveMut_T_P.
    
    (* StructRecord
      {
        name := "RSplit";
        ty_params := [ "T"; "P" ];
        fields := [ ("inner", Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ]) ];
      } *)
    
    Module Impl_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a [T], pred: P) -> Self {
              Self { inner: Split::new(slice, pred) }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            Value.StructRecord
              "core::slice::iter::RSplit"
              [
                ("inner",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ],
                      "new",
                      []
                    |),
                    [ M.read (| slice |); M.read (| pred |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("RSplit")
                  .field("v", &self.inner.v)
                  .field("finished", &self.inner.finished)
                  .finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Formatter",
                              "debug_struct",
                              []
                            |),
                            [ M.read (| f |); M.read (| Value.String "RSplit" |) ]
                          |)
                        |);
                        M.read (| Value.String "v" |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.SubPointer.get_struct_record_field (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::RSplit",
                              "inner"
                            |),
                            "core::slice::iter::Split",
                            "v"
                          |))
                      ]
                    |);
                    M.read (| Value.String "finished" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::RSplit",
                          "inner"
                        |),
                        "core::slice::iter::Split",
                        "finished"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [ T; P ].
      
      (*
          fn clone(&self) -> Self {
              RSplit { inner: self.inner.clone() }
          }
      *)
      Definition clone (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::RSplit"
              [
                ("inner",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::RSplit",
                        "inner"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T P)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_P_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [ T; P ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              self.inner.next_back()
          }
      *)
      Definition next (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ],
                [],
                "next_back",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::RSplit",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.inner.size_hint()
          }
      *)
      Definition size_hint (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ],
                [],
                "size_hint",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::RSplit",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              self.inner.next()
          }
      *)
      Definition next_back (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ],
                [],
                "next",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::RSplit",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [ T; P ].
      
      (*
          fn finish(&mut self) -> Option<&'a [T]> {
              self.inner.finish()
          }
      *)
      Definition finish (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::slice::iter::SplitIter",
                Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ],
                [],
                "finish",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::RSplit",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::slice::iter::SplitIter"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("finish", InstanceField.Method (finish T P)) ].
    End Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplit") [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplit_T_P.
    
    (* StructRecord
      {
        name := "RSplitMut";
        ty_params := [ "T"; "P" ];
        fields := [ ("inner", Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ]) ];
      } *)
    
    Module Impl_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {
              Self { inner: SplitMut::new(slice, pred) }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ slice; pred ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let pred := M.alloc (| pred |) in
            Value.StructRecord
              "core::slice::iter::RSplitMut"
              [
                ("inner",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ],
                      "new",
                      []
                    |),
                    [ M.read (| slice |); M.read (| pred |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_RSplitMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("RSplitMut")
                  .field("v", &self.inner.v)
                  .field("finished", &self.inner.finished)
                  .finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Formatter",
                              "debug_struct",
                              []
                            |),
                            [ M.read (| f |); M.read (| Value.String "RSplitMut" |) ]
                          |)
                        |);
                        M.read (| Value.String "v" |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.SubPointer.get_struct_record_field (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::RSplitMut",
                              "inner"
                            |),
                            "core::slice::iter::SplitMut",
                            "v"
                          |))
                      ]
                    |);
                    M.read (| Value.String "finished" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::RSplitMut",
                          "inner"
                        |),
                        "core::slice::iter::SplitMut",
                        "finished"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
    
    Module Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [ T; P ].
      
      (*
          fn finish(&mut self) -> Option<&'a mut [T]> {
              self.inner.finish()
          }
      *)
      Definition finish (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::slice::iter::SplitIter",
                Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ],
                [],
                "finish",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::RSplitMut",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::slice::iter::SplitIter"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("finish", InstanceField.Method (finish T P)) ].
    End Impl_core_slice_iter_SplitIter_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [ T; P ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              self.inner.next_back()
          }
      *)
      Definition next (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ],
                [],
                "next_back",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::RSplitMut",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.inner.size_hint()
          }
      *)
      Definition size_hint (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ],
                [],
                "size_hint",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::RSplitMut",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              self.inner.next()
          }
      *)
      Definition next_back (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ],
                [],
                "next",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::RSplitMut",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitMut") [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitMut_T_P.
    
    (* StructRecord
      {
        name := "GenericSplitN";
        ty_params := [ "I" ];
        fields := [ ("iter", I); ("count", Ty.path "usize") ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_I_for_core_slice_iter_GenericSplitN_I.
      Definition Self (I : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GenericSplitN") [ I ].
      
      (* Debug *)
      Definition fmt (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "GenericSplitN" |);
                M.read (| Value.String "iter" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::GenericSplitN",
                    "iter"
                  |));
                M.read (| Value.String "count" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::GenericSplitN",
                      "count"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (I : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self I)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt I)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_I_for_core_slice_iter_GenericSplitN_I.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_slice_iter_SplitIter_I_for_core_slice_iter_GenericSplitN_I.
      Definition Self (T I : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GenericSplitN") [ I ].
      
      (*     type Item = T; *)
      Definition _Item (T I : Ty.t) : Ty.t := T.
      
      (*
          fn next(&mut self) -> Option<T> {
              match self.count {
                  0 => None,
                  1 => {
                      self.count -= 1;
                      self.iter.finish()
                  }
                  _ => {
                      self.count -= 1;
                      self.iter.next()
                  }
              }
          }
      *)
      Definition next (T I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T I in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::GenericSplitN",
                  "count"
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 1 |) in
                      let~ _ :=
                        let β :=
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::GenericSplitN",
                            "count"
                          |) in
                        M.write (|
                          β,
                          BinOp.Wrap.sub Integer.Usize (M.read (| β |)) (Value.Integer 1)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::slice::iter::SplitIter",
                            I,
                            [],
                            "finish",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::GenericSplitN",
                              "iter"
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ :=
                        let β :=
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::GenericSplitN",
                            "count"
                          |) in
                        M.write (|
                          β,
                          BinOp.Wrap.sub Integer.Usize (M.read (| β |)) (Value.Integer 1)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            I,
                            [],
                            "next",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::GenericSplitN",
                              "iter"
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let (lower, upper_opt) = self.iter.size_hint();
              (
                  cmp::min(self.count, lower),
                  Some(upper_opt.map_or(self.count, |upper| cmp::min(self.count, upper))),
              )
          }
      *)
      Definition size_hint (T I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T I in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      I,
                      [],
                      "size_hint",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::GenericSplitN",
                        "iter"
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let lower := M.copy (| γ0_0 |) in
                      let upper_opt := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GenericSplitN",
                                    "count"
                                  |)
                                |);
                                M.read (| lower |)
                              ]
                            |);
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                    "map_or",
                                    [
                                      Ty.path "usize";
                                      Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                                    ]
                                  |),
                                  [
                                    M.read (| upper_opt |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::GenericSplitN",
                                        "count"
                                      |)
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let upper := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      M.get_function (|
                                                        "core::cmp::min",
                                                        [ Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.read (| self |),
                                                            "core::slice::iter::GenericSplitN",
                                                            "count"
                                                          |)
                                                        |);
                                                        M.read (| upper |)
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  ]
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T I : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T I)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T I));
            ("next", InstanceField.Method (next T I));
            ("size_hint", InstanceField.Method (size_hint T I))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_slice_iter_SplitIter_I_for_core_slice_iter_GenericSplitN_I.
    
    (* StructRecord
      {
        name := "SplitN";
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("inner",
              Ty.apply
                (Ty.path "core::slice::iter::GenericSplitN")
                [ Ty.apply (Ty.path "core::slice::iter::Split") [ T; P ] ])
          ];
      } *)
    
    Module Impl_core_slice_iter_SplitN_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitN") [ T; P ].
      
      (*
          pub(super) fn new(s: Split<'a, T, P>, n: usize) -> Self {
              Self { inner: GenericSplitN { iter: s, count: n } }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ s; n ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            let n := M.alloc (| n |) in
            Value.StructRecord
              "core::slice::iter::SplitN"
              [
                ("inner",
                  Value.StructRecord
                    "core::slice::iter::GenericSplitN"
                    [ ("iter", M.read (| s |)); ("count", M.read (| n |)) ])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_SplitN_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitN_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitN") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SplitN").field("inner", &self.inner).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "SplitN" |) ]
                      |)
                    |);
                    M.read (| Value.String "inner" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::SplitN",
                        "inner"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitN_T_P.
    
    (* StructRecord
      {
        name := "RSplitN";
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("inner",
              Ty.apply
                (Ty.path "core::slice::iter::GenericSplitN")
                [ Ty.apply (Ty.path "core::slice::iter::RSplit") [ T; P ] ])
          ];
      } *)
    
    Module Impl_core_slice_iter_RSplitN_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitN") [ T; P ].
      
      (*
          pub(super) fn new(s: RSplit<'a, T, P>, n: usize) -> Self {
              Self { inner: GenericSplitN { iter: s, count: n } }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ s; n ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            let n := M.alloc (| n |) in
            Value.StructRecord
              "core::slice::iter::RSplitN"
              [
                ("inner",
                  Value.StructRecord
                    "core::slice::iter::GenericSplitN"
                    [ ("iter", M.read (| s |)); ("count", M.read (| n |)) ])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_RSplitN_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitN_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitN") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("RSplitN").field("inner", &self.inner).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "RSplitN" |) ]
                      |)
                    |);
                    M.read (| Value.String "inner" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::RSplitN",
                        "inner"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitN_T_P.
    
    (* StructRecord
      {
        name := "SplitNMut";
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("inner",
              Ty.apply
                (Ty.path "core::slice::iter::GenericSplitN")
                [ Ty.apply (Ty.path "core::slice::iter::SplitMut") [ T; P ] ])
          ];
      } *)
    
    Module Impl_core_slice_iter_SplitNMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitNMut") [ T; P ].
      
      (*
          pub(super) fn new(s: SplitMut<'a, T, P>, n: usize) -> Self {
              Self { inner: GenericSplitN { iter: s, count: n } }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ s; n ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            let n := M.alloc (| n |) in
            Value.StructRecord
              "core::slice::iter::SplitNMut"
              [
                ("inner",
                  Value.StructRecord
                    "core::slice::iter::GenericSplitN"
                    [ ("iter", M.read (| s |)); ("count", M.read (| n |)) ])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_SplitNMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitNMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::SplitNMut") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SplitNMut").field("inner", &self.inner).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "SplitNMut" |) ]
                      |)
                    |);
                    M.read (| Value.String "inner" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::SplitNMut",
                        "inner"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_SplitNMut_T_P.
    
    (* StructRecord
      {
        name := "RSplitNMut";
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("inner",
              Ty.apply
                (Ty.path "core::slice::iter::GenericSplitN")
                [ Ty.apply (Ty.path "core::slice::iter::RSplitMut") [ T; P ] ])
          ];
      } *)
    
    Module Impl_core_slice_iter_RSplitNMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitNMut") [ T; P ].
      
      (*
          pub(super) fn new(s: RSplitMut<'a, T, P>, n: usize) -> Self {
              Self { inner: GenericSplitN { iter: s, count: n } }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ s; n ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            let n := M.alloc (| n |) in
            Value.StructRecord
              "core::slice::iter::RSplitNMut"
              [
                ("inner",
                  Value.StructRecord
                    "core::slice::iter::GenericSplitN"
                    [ ("iter", M.read (| s |)); ("count", M.read (| n |)) ])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_RSplitNMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitNMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RSplitNMut") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("RSplitNMut").field("inner", &self.inner).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "RSplitNMut" |) ]
                      |)
                    |);
                    M.read (| Value.String "inner" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::RSplitNMut",
                        "inner"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_P_Tuple_ref__T__for_core_slice_iter_RSplitNMut_T_P.
    
    (* StructRecord
      {
        name := "Windows";
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("size", Ty.path "core::num::nonzero::NonZeroUsize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Windows" |);
                M.read (| Value.String "v" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::Windows",
                    "v"
                  |));
                M.read (| Value.String "size" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Windows",
                      "size"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Windows_T.
    
    Module Impl_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T], size: NonZeroUsize) -> Self {
              Self { v: slice, size }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice; size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let size := M.alloc (| size |) in
            Value.StructRecord
              "core::slice::iter::Windows"
              [ ("v", M.read (| slice |)); ("size", M.read (| size |)) ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
    End Impl_core_slice_iter_Windows_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [ T ].
      
      (*
          fn clone(&self) -> Self {
              Windows { v: self.v, size: self.size }
          }
      *)
      Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::Windows"
              [
                ("v",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Windows",
                      "v"
                    |)
                  |));
                ("size",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Windows",
                      "size"
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [ T ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.size.get() > self.v.len() {
                  None
              } else {
                  let ret = Some(&self.v[..self.size.get()]);
                  self.v = &self.v[1..];
                  ret
              }
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.gt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Windows",
                                      "size"
                                    |)
                                  |)
                                ]
                              |))
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Windows",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ ret :=
                        M.alloc (|
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [ T ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeTo")
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Windows",
                                      "v"
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::RangeTo"
                                    [
                                      ("end_",
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::num::nonzero::NonZeroUsize",
                                            "get",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::Windows",
                                                "size"
                                              |)
                                            |)
                                          ]
                                        |))
                                    ]
                                ]
                              |)
                            ]
                        |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Windows",
                            "v"
                          |),
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ]
                              ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::Windows",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::RangeFrom"
                                [ ("start", Value.Integer 1) ]
                            ]
                          |)
                        |) in
                      ret))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.size.get() > self.v.len() {
                  (0, Some(0))
              } else {
                  let size = self.v.len() - self.size.get() + 1;
                  (size, Some(size))
              }
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.gt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Windows",
                                      "size"
                                    |)
                                  |)
                                ]
                              |))
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Windows",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ size :=
                        M.alloc (|
                          BinOp.Wrap.add
                            Integer.Usize
                            (BinOp.Wrap.sub
                              Integer.Usize
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Windows",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Windows",
                                      "size"
                                    |)
                                  |)
                                ]
                              |)))
                            (Value.Integer 1)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| size |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| size |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::Windows") [ T ],
                [],
                "len",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              let (end, overflow) = self.size.get().overflowing_add(n);
              if end > self.v.len() || overflow {
                  self.v = &[];
                  None
              } else {
                  let nth = &self.v[n..end];
                  self.v = &self.v[n + 1..];
                  Some(nth)
              }
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "overflowing_add", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::num::nonzero::NonZeroUsize",
                          "get",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::Windows",
                              "size"
                            |)
                          |)
                        ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.Pure.gt
                                        (M.read (| end_ |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ T ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::Windows",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Windows",
                                    "v"
                                  |),
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ nth :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::Windows",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [ ("start", M.read (| n |)); ("end_", M.read (| end_ |)) ]
                                    ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Windows",
                                    "v"
                                  |),
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeFrom")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::Windows",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeFrom"
                                        [
                                          ("start",
                                            BinOp.Wrap.add
                                              Integer.Usize
                                              (M.read (| n |))
                                              (Value.Integer 1))
                                        ]
                                    ]
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| nth |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              if self.size.get() > self.v.len() {
                  None
              } else {
                  let start = self.v.len() - self.size.get();
                  Some(&self.v[start..])
              }
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.gt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "core::slice::iter::Windows",
                                      "size"
                                    |)
                                  |)
                                ]
                              |))
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "core::slice::iter::Windows",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start :=
                        M.alloc (|
                          BinOp.Wrap.sub
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::Windows",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::num::nonzero::NonZeroUsize",
                                "get",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::Windows",
                                    "size"
                                  |)
                                |)
                              ]
                            |))
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.apply (Ty.path "slice") [ T ],
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeFrom")
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::Windows",
                                    "v"
                                  |)
                                |);
                                Value.StructRecord
                                  "core::ops::range::RangeFrom"
                                  [ ("start", M.read (| start |)) ]
                              ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              // SAFETY: since the caller guarantees that `i` is in bounds,
              // which means that `i` cannot overflow an `isize`, and the
              // slice created by `from_raw_parts` is a subslice of `self.v`
              // thus is guaranteed to be valid for the lifetime `'a` of `self.v`.
              unsafe { from_raw_parts(self.v.as_ptr().add(idx), self.size.get()) }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.call_closure (|
              M.get_function (| "core::slice::raw::from_raw_parts", [ T ] |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ T ],
                        "as_ptr",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Windows",
                            "v"
                          |)
                        |)
                      ]
                    |);
                    M.read (| idx |)
                  ]
                |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::num::nonzero::NonZeroUsize",
                    "get",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::Windows",
                        "size"
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.size.get() > self.v.len() {
                  None
              } else {
                  let ret = Some(&self.v[self.v.len() - self.size.get()..]);
                  self.v = &self.v[..self.v.len() - 1];
                  ret
              }
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.gt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Windows",
                                      "size"
                                    |)
                                  |)
                                ]
                              |))
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Windows",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ ret :=
                        M.alloc (|
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [ T ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeFrom")
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Windows",
                                      "v"
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::RangeFrom"
                                    [
                                      ("start",
                                        BinOp.Wrap.sub
                                          Integer.Usize
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [ T ],
                                              "len",
                                              []
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "core::slice::iter::Windows",
                                                  "v"
                                                |)
                                              |)
                                            ]
                                          |))
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::num::nonzero::NonZeroUsize",
                                              "get",
                                              []
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "core::slice::iter::Windows",
                                                  "size"
                                                |)
                                              |)
                                            ]
                                          |)))
                                    ]
                                ]
                              |)
                            ]
                        |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Windows",
                            "v"
                          |),
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ]
                              ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::Windows",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                [
                                  ("end_",
                                    BinOp.Wrap.sub
                                      Integer.Usize
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [ T ],
                                          "len",
                                          []
                                        |),
                                        [
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "core::slice::iter::Windows",
                                              "v"
                                            |)
                                          |)
                                        ]
                                      |))
                                      (Value.Integer 1))
                                ]
                            ]
                          |)
                        |) in
                      ret))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let (end, overflow) = self.v.len().overflowing_sub(n);
              if end < self.size.get() || overflow {
                  self.v = &[];
                  None
              } else {
                  let ret = &self.v[end - self.size.get()..end];
                  self.v = &self.v[..end - 1];
                  Some(ret)
              }
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "overflowing_sub", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::Windows",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.Pure.lt
                                        (M.read (| end_ |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::num::nonzero::NonZeroUsize",
                                            "get",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::Windows",
                                                "size"
                                              |)
                                            |)
                                          ]
                                        |)),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Windows",
                                    "v"
                                  |),
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ ret :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::Windows",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [
                                          ("start",
                                            BinOp.Wrap.sub
                                              Integer.Usize
                                              (M.read (| end_ |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                                  "get",
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "core::slice::iter::Windows",
                                                      "size"
                                                    |)
                                                  |)
                                                ]
                                              |)));
                                          ("end_", M.read (| end_ |))
                                        ]
                                    ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Windows",
                                    "v"
                                  |),
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::Windows",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [
                                          ("end_",
                                            BinOp.Wrap.sub
                                              Integer.Usize
                                              (M.read (| end_ |))
                                              (Value.Integer 1))
                                        ]
                                    ]
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| ret |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Windows_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Windows_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Windows") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Windows_T.
    
    (* StructRecord
      {
        name := "Chunks";
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("chunk_size", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Chunks" |);
                M.read (| Value.String "v" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::Chunks",
                    "v"
                  |));
                M.read (| Value.String "chunk_size" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Chunks",
                      "chunk_size"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T], size: usize) -> Self {
              Self { v: slice, chunk_size: size }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice; size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let size := M.alloc (| size |) in
            Value.StructRecord
              "core::slice::iter::Chunks"
              [ ("v", M.read (| slice |)); ("chunk_size", M.read (| size |)) ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
    End Impl_core_slice_iter_Chunks_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ].
      
      (*
          fn clone(&self) -> Self {
              Chunks { v: self.v, chunk_size: self.chunk_size }
          }
      *)
      Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::Chunks"
              [
                ("v",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Chunks",
                      "v"
                    |)
                  |));
                ("chunk_size",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::Chunks",
                      "chunk_size"
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let chunksz = cmp::min(self.v.len(), self.chunk_size);
                  let (fst, snd) = self.v.split_at(chunksz);
                  self.v = snd;
                  Some(fst)
              }
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ chunksz :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Chunks",
                                      "v"
                                    |)
                                  |)
                                ]
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::Chunks",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::Chunks",
                                  "v"
                                |)
                              |);
                              M.read (| chunksz |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |),
                                  M.read (| snd |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| fst |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.v.is_empty() {
                  (0, Some(0))
              } else {
                  let n = self.v.len() / self.chunk_size;
                  let rem = self.v.len() % self.chunk_size;
                  let n = if rem > 0 { n + 1 } else { n };
                  (n, Some(n))
              }
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ n :=
                        M.alloc (|
                          BinOp.Wrap.div
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::Chunks",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ rem :=
                        M.alloc (|
                          BinOp.Wrap.rem
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::Chunks",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ n :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.gt (M.read (| rem |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    BinOp.Wrap.add Integer.Usize (M.read (| n |)) (Value.Integer 1)
                                  |)));
                              fun γ => ltac:(M.monadic n)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| n |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ],
                [],
                "len",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              let (start, overflow) = n.overflowing_mul(self.chunk_size);
              if start >= self.v.len() || overflow {
                  self.v = &[];
                  None
              } else {
                  let end = match start.checked_add(self.chunk_size) {
                      Some(sum) => cmp::min(self.v.len(), sum),
                      None => self.v.len(),
                  };
                  let nth = &self.v[start..end];
                  self.v = &self.v[end..];
                  Some(nth)
              }
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::Chunks",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let start := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.Pure.ge
                                        (M.read (| start |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ T ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::Chunks",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |),
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ end_ :=
                                M.copy (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "usize",
                                          "checked_add",
                                          []
                                        |),
                                        [
                                          M.read (| start |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "core::slice::iter::Chunks",
                                              "chunk_size"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let sum := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_function (|
                                                "core::cmp::min",
                                                [ Ty.path "usize" ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "slice") [ T ],
                                                    "len",
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::slice::iter::Chunks",
                                                        "v"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.read (| sum |)
                                              ]
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [ T ],
                                                "len",
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "core::slice::iter::Chunks",
                                                    "v"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)))
                                    ]
                                  |)
                                |) in
                              let~ nth :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::Chunks",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [ ("start", M.read (| start |)); ("end_", M.read (| end_ |))
                                        ]
                                    ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |),
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeFrom")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::Chunks",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::RangeFrom"
                                        [ ("start", M.read (| end_ |)) ]
                                    ]
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| nth |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              if self.v.is_empty() {
                  None
              } else {
                  let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;
                  Some(&self.v[start..])
              }
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start :=
                        M.alloc (|
                          BinOp.Wrap.mul
                            Integer.Usize
                            (BinOp.Wrap.div
                              Integer.Usize
                              (BinOp.Wrap.sub
                                Integer.Usize
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "core::slice::iter::Chunks",
                                        "v"
                                      |)
                                    |)
                                  ]
                                |))
                                (Value.Integer 1))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "core::slice::iter::Chunks",
                                  "chunk_size"
                                |)
                              |)))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "core::slice::iter::Chunks",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.apply (Ty.path "slice") [ T ],
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeFrom")
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |)
                                |);
                                Value.StructRecord
                                  "core::ops::range::RangeFrom"
                                  [ ("start", M.read (| start |)) ]
                              ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let start = idx * self.chunk_size;
              // SAFETY: the caller guarantees that `i` is in bounds,
              // which means that `start` must be in bounds of the
              // underlying `self.v` slice, and we made sure that `len`
              // is also in bounds of `self.v`. Thus, `start` cannot overflow
              // an `isize`, and the slice constructed by `from_raw_parts`
              // is a subslice of `self.v` which is guaranteed to be valid
              // for the lifetime `'a` of `self.v`.
              unsafe {
                  let len = cmp::min(self.v.len().unchecked_sub(start), self.chunk_size);
                  from_raw_parts(self.v.as_ptr().add(start), len)
              }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ start :=
                M.alloc (|
                  BinOp.Wrap.mul
                    Integer.Usize
                    (M.read (| idx |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::Chunks",
                        "chunk_size"
                      |)
                    |))
                |) in
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "unchecked_sub", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "len",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::Chunks",
                                  "v"
                                |)
                              |)
                            ]
                          |);
                          M.read (| start |)
                        ]
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::Chunks",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::slice::raw::from_raw_parts", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "add", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [ T ],
                            "as_ptr",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::Chunks",
                                "v"
                              |)
                            |)
                          ]
                        |);
                        M.read (| start |)
                      ]
                    |);
                    M.read (| len |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let remainder = self.v.len() % self.chunk_size;
                  let chunksz = if remainder != 0 { remainder } else { self.chunk_size };
                  // SAFETY: split_at_unchecked requires the argument be less than or
                  // equal to the length. This is guaranteed, but subtle: `chunksz`
                  // will always either be `self.v.len() % self.chunk_size`, which
                  // will always evaluate to strictly less than `self.v.len()` (or
                  // panic, in the case that `self.chunk_size` is zero), or it can be
                  // `self.chunk_size`, in the case that the length is exactly
                  // divisible by the chunk size.
                  //
                  // While it seems like using `self.chunk_size` in this case could
                  // lead to a value greater than `self.v.len()`, it cannot: if
                  // `self.chunk_size` were greater than `self.v.len()`, then
                  // `self.v.len() % self.chunk_size` would return nonzero (note that
                  // in this branch of the `if`, we already know that `self.v` is
                  // non-empty).
                  let (fst, snd) = unsafe { self.v.split_at_unchecked(self.v.len() - chunksz) };
                  self.v = fst;
                  Some(snd)
              }
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ remainder :=
                        M.alloc (|
                          BinOp.Wrap.rem
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::Chunks",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ chunksz :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ne (M.read (| remainder |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  remainder));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "chunk_size"
                                  |)))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at_unchecked",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::Chunks",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub
                                Integer.Usize
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::Chunks",
                                        "v"
                                      |)
                                    |)
                                  ]
                                |))
                                (M.read (| chunksz |))
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::Chunks",
                                    "v"
                                  |),
                                  M.read (| fst |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| snd |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &[];
                  None
              } else {
                  let start = (len - 1 - n) * self.chunk_size;
                  let end = match start.checked_add(self.chunk_size) {
                      Some(res) => cmp::min(self.v.len(), res),
                      None => self.v.len(),
                  };
                  let nth_back = &self.v[start..end];
                  self.v = &self.v[..start];
                  Some(nth_back)
              }
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        [ Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ] ],
                      [],
                      "len",
                      []
                    |),
                    [ self ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.ge (M.read (| n |)) (M.read (| len |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Chunks",
                            "v"
                          |),
                          (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start :=
                        M.alloc (|
                          BinOp.Wrap.mul
                            Integer.Usize
                            (BinOp.Wrap.sub
                              Integer.Usize
                              (BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (Value.Integer 1))
                              (M.read (| n |)))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::Chunks",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ end_ :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "usize", "checked_add", [] |),
                                [
                                  M.read (| start |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::Chunks",
                                      "chunk_size"
                                    |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let res := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ T ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::Chunks",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.read (| res |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "len",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::Chunks",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      let~ nth_back :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ] ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::Chunks",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::Range"
                                [ ("start", M.read (| start |)); ("end_", M.read (| end_ |)) ]
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::Chunks",
                            "v"
                          |),
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ]
                              ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::Chunks",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                [ ("end_", M.read (| start |)) ]
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| nth_back |) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Chunks_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Chunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Chunks") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Chunks_T.
    
    (* StructRecord
      {
        name := "ChunksMut";
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("chunk_size", Ty.path "usize");
            ("_marker",
              Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.apply (Ty.path "&mut") [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "ChunksMut" |);
                M.read (| Value.String "v" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ChunksMut",
                    "v"
                  |));
                M.read (| Value.String "chunk_size" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ChunksMut",
                    "chunk_size"
                  |));
                M.read (| Value.String "_marker" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::ChunksMut",
                      "_marker"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {
              Self { v: slice, chunk_size: size, _marker: PhantomData }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice; size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let size := M.alloc (| size |) in
            Value.StructRecord
              "core::slice::iter::ChunksMut"
              [
                ("v", M.read (| slice |));
                ("chunk_size", M.read (| size |));
                ("_marker", Value.StructTuple "core::marker::PhantomData" [])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
    End Impl_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let sz = cmp::min(self.v.len(), self.chunk_size);
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, tail) = unsafe { self.v.split_at_mut(sz) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *head })
              }
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ sz :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::ChunksMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksMut",
                                  "v"
                                |)
                              |);
                              M.read (| sz |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |),
                                  M.read (| tail |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| head |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.v.is_empty() {
                  (0, Some(0))
              } else {
                  let n = self.v.len() / self.chunk_size;
                  let rem = self.v.len() % self.chunk_size;
                  let n = if rem > 0 { n + 1 } else { n };
                  (n, Some(n))
              }
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ n :=
                        M.alloc (|
                          BinOp.Wrap.div
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::ChunksMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ rem :=
                        M.alloc (|
                          BinOp.Wrap.rem
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::ChunksMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ n :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.gt (M.read (| rem |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    BinOp.Wrap.add Integer.Usize (M.read (| n |)) (Value.Integer 1)
                                  |)));
                              fun γ => ltac:(M.monadic n)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| n |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ],
                [],
                "len",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {
              let (start, overflow) = n.overflowing_mul(self.chunk_size);
              if start >= self.v.len() || overflow {
                  self.v = &mut [];
                  None
              } else {
                  let end = match start.checked_add(self.chunk_size) {
                      Some(sum) => cmp::min(self.v.len(), sum),
                      None => self.v.len(),
                  };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, tail) = unsafe { self.v.split_at_mut(end) };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (_, nth) = unsafe { head.split_at_mut(start) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth })
              }
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::ChunksMut",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let start := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.Pure.ge
                                        (M.read (| start |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              [ Ty.apply (Ty.path "slice") [ T ] ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::ChunksMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |),
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ end_ :=
                                M.copy (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "usize",
                                          "checked_add",
                                          []
                                        |),
                                        [
                                          M.read (| start |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "core::slice::iter::ChunksMut",
                                              "chunk_size"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let sum := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_function (|
                                                "core::cmp::min",
                                                [ Ty.path "usize" ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "*mut")
                                                      [ Ty.apply (Ty.path "slice") [ T ] ],
                                                    "len",
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::slice::iter::ChunksMut",
                                                        "v"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.read (| sum |)
                                              ]
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "*mut")
                                                  [ Ty.apply (Ty.path "slice") [ T ] ],
                                                "len",
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "core::slice::iter::ChunksMut",
                                                    "v"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)))
                                    ]
                                  |)
                                |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        [ Ty.apply (Ty.path "slice") [ T ] ],
                                      "split_at_mut",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::ChunksMut",
                                          "v"
                                        |)
                                      |);
                                      M.read (| end_ |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let head := M.copy (| γ0_0 |) in
                                      let tail := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "*mut")
                                                [ Ty.apply (Ty.path "slice") [ T ] ],
                                              "split_at_mut",
                                              []
                                            |),
                                            [ M.read (| head |); M.read (| start |) ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_tuple_field (| γ, 0 |) in
                                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                              let nth := M.copy (| γ0_1 |) in
                                              let~ _ :=
                                                M.write (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "core::slice::iter::ChunksMut",
                                                    "v"
                                                  |),
                                                  M.read (| tail |)
                                                |) in
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [ M.read (| nth |) ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              if self.v.is_empty() {
                  None
              } else {
                  let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *self.v.get_unchecked_mut(start..) })
              }
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start :=
                        M.alloc (|
                          BinOp.Wrap.mul
                            Integer.Usize
                            (BinOp.Wrap.div
                              Integer.Usize
                              (BinOp.Wrap.sub
                                Integer.Usize
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "core::slice::iter::ChunksMut",
                                        "v"
                                      |)
                                    |)
                                  ]
                                |))
                                (Value.Integer 1))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "core::slice::iter::ChunksMut",
                                  "chunk_size"
                                |)
                              |)))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "core::slice::iter::ChunksMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "get_unchecked_mut",
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeFrom")
                                    [ Ty.path "usize" ]
                                ]
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |);
                                Value.StructRecord
                                  "core::ops::range::RangeFrom"
                                  [ ("start", M.read (| start |)) ]
                              ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let start = idx * self.chunk_size;
              // SAFETY: see comments for `Chunks::__iterator_get_unchecked` and `self.v`.
              //
              // Also note that the caller also guarantees that we're never called
              // with the same index again, and that no other methods that will
              // access this subslice are called, so it is valid for the returned
              // slice to be mutable.
              unsafe {
                  let len = cmp::min(self.v.len().unchecked_sub(start), self.chunk_size);
                  from_raw_parts_mut(self.v.as_mut_ptr().add(start), len)
              }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ start :=
                M.alloc (|
                  BinOp.Wrap.mul
                    Integer.Usize
                    (M.read (| idx |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ChunksMut",
                        "chunk_size"
                      |)
                    |))
                |) in
              M.alloc (|
                M.read (|
                  let~ len :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "unchecked_sub", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::ChunksMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |);
                              M.read (| start |)
                            ]
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::ChunksMut",
                              "chunk_size"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts_mut", [ T ] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [ T ],
                            "add",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "as_mut_ptr",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |);
                            M.read (| start |)
                          ]
                        |);
                        M.read (| len |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let remainder = self.v.len() % self.chunk_size;
                  let sz = if remainder != 0 { remainder } else { self.chunk_size };
                  let len = self.v.len();
                  // SAFETY: Similar to `Chunks::next_back`
                  let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *tail })
              }
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ remainder :=
                        M.alloc (|
                          BinOp.Wrap.rem
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::ChunksMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ sz :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ne (M.read (| remainder |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  remainder));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "chunk_size"
                                  |)))
                            ]
                          |)
                        |) in
                      let~ len :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "len",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksMut",
                                  "v"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut_unchecked",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksMut",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (M.read (| sz |))
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksMut",
                                    "v"
                                  |),
                                  M.read (| head |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| tail |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &mut [];
                  None
              } else {
                  let start = (len - 1 - n) * self.chunk_size;
                  let end = match start.checked_add(self.chunk_size) {
                      Some(res) => cmp::min(self.v.len(), res),
                      None => self.v.len(),
                  };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (temp, _tail) = unsafe { self.v.split_at_mut(end) };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, nth_back) = unsafe { temp.split_at_mut(start) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth_back })
              }
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        [ Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ] ],
                      [],
                      "len",
                      []
                    |),
                    [ self ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.ge (M.read (| n |)) (M.read (| len |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::ChunksMut",
                            "v"
                          |),
                          (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start :=
                        M.alloc (|
                          BinOp.Wrap.mul
                            Integer.Usize
                            (BinOp.Wrap.sub
                              Integer.Usize
                              (BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (Value.Integer 1))
                              (M.read (| n |)))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::ChunksMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ end_ :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "usize", "checked_add", [] |),
                                [
                                  M.read (| start |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::ChunksMut",
                                      "chunk_size"
                                    |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let res := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              [ Ty.apply (Ty.path "slice") [ T ] ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::ChunksMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.read (| res |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          [ Ty.apply (Ty.path "slice") [ T ] ],
                                        "len",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::ChunksMut",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksMut",
                                  "v"
                                |)
                              |);
                              M.read (| end_ |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let temp := M.copy (| γ0_0 |) in
                              let _tail := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        [ Ty.apply (Ty.path "slice") [ T ] ],
                                      "split_at_mut",
                                      []
                                    |),
                                    [ M.read (| temp |); M.read (| start |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let head := M.copy (| γ0_0 |) in
                                      let nth_back := M.copy (| γ0_1 |) in
                                      let~ _ :=
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::ChunksMut",
                                            "v"
                                          |),
                                          M.read (| head |)
                                        |) in
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [ M.read (| nth_back |) ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_ChunksMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_ChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::ChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_ChunksMut_T.
    
    (* StructRecord
      {
        name := "ChunksExact";
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("rem", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("chunk_size", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "ChunksExact" |);
                M.read (| Value.String "v" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ChunksExact",
                    "v"
                  |));
                M.read (| Value.String "rem" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ChunksExact",
                    "rem"
                  |));
                M.read (| Value.String "chunk_size" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::ChunksExact",
                      "chunk_size"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {
              let rem = slice.len() % chunk_size;
              let fst_len = slice.len() - rem;
              // SAFETY: 0 <= fst_len <= slice.len() by construction above
              let (fst, snd) = unsafe { slice.split_at_unchecked(fst_len) };
              Self { v: fst, rem: snd, chunk_size }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice; chunk_size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let chunk_size := M.alloc (| chunk_size |) in
            M.read (|
              let~ rem :=
                M.alloc (|
                  BinOp.Wrap.rem
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [ M.read (| slice |) ]
                    |))
                    (M.read (| chunk_size |))
                |) in
              let~ fst_len :=
                M.alloc (|
                  BinOp.Wrap.sub
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [ M.read (| slice |) ]
                    |))
                    (M.read (| rem |))
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ T ],
                      "split_at_unchecked",
                      []
                    |),
                    [ M.read (| slice |); M.read (| fst_len |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let fst := M.copy (| γ0_0 |) in
                      let snd := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::ChunksExact"
                          [
                            ("v", M.read (| fst |));
                            ("rem", M.read (| snd |));
                            ("chunk_size", M.read (| chunk_size |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub fn remainder(&self) -> &'a [T] {
              self.rem
          }
      *)
      Definition remainder (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "core::slice::iter::ChunksExact",
                "rem"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_remainder :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "remainder" (remainder T).
    End Impl_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ].
      
      (*
          fn clone(&self) -> Self {
              ChunksExact { v: self.v, rem: self.rem, chunk_size: self.chunk_size }
          }
      *)
      Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::ChunksExact"
              [
                ("v",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::ChunksExact",
                      "v"
                    |)
                  |));
                ("rem",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::ChunksExact",
                      "rem"
                    |)
                  |));
                ("chunk_size",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::ChunksExact",
                      "chunk_size"
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  let (fst, snd) = self.v.split_at(self.chunk_size);
                  self.v = snd;
                  Some(fst)
              }
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::ChunksExact",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExact",
                                  "chunk_size"
                                |)
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExact",
                                  "v"
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExact",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksExact",
                                    "v"
                                  |),
                                  M.read (| snd |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| fst |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let n = self.v.len() / self.chunk_size;
              (n, Some(n))
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ n :=
                M.alloc (|
                  BinOp.Wrap.div
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::ChunksExact",
                            "v"
                          |)
                        |)
                      ]
                    |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ChunksExact",
                        "chunk_size"
                      |)
                    |))
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| n |);
                    Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ],
                [],
                "len",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              let (start, overflow) = n.overflowing_mul(self.chunk_size);
              if start >= self.v.len() || overflow {
                  self.v = &[];
                  None
              } else {
                  let (_, snd) = self.v.split_at(start);
                  self.v = snd;
                  self.next()
              }
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::ChunksExact",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let start := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.Pure.ge
                                        (M.read (| start |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ T ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::ChunksExact",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksExact",
                                    "v"
                                  |),
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [ T ],
                                      "split_at",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::ChunksExact",
                                          "v"
                                        |)
                                      |);
                                      M.read (| start |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let snd := M.copy (| γ0_1 |) in
                                      let~ _ :=
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::ChunksExact",
                                            "v"
                                          |),
                                          M.read (| snd |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::ChunksExact")
                                              [ T ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ],
                [],
                "next_back",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let start = idx * self.chunk_size;
              // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.
              unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ start :=
                M.alloc (|
                  BinOp.Wrap.mul
                    Integer.Usize
                    (M.read (| idx |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ChunksExact",
                        "chunk_size"
                      |)
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::slice::raw::from_raw_parts", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "add", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [ T ],
                            "as_ptr",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::ChunksExact",
                                "v"
                              |)
                            |)
                          ]
                        |);
                        M.read (| start |)
                      ]
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ChunksExact",
                        "chunk_size"
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);
                  self.v = fst;
                  Some(snd)
              }
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::ChunksExact",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExact",
                                  "chunk_size"
                                |)
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExact",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub
                                Integer.Usize
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::ChunksExact",
                                        "v"
                                      |)
                                    |)
                                  ]
                                |))
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksExact",
                                    "chunk_size"
                                  |)
                                |))
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksExact",
                                    "v"
                                  |),
                                  M.read (| fst |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| snd |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &[];
                  None
              } else {
                  let start = (len - 1 - n) * self.chunk_size;
                  let end = start + self.chunk_size;
                  let nth_back = &self.v[start..end];
                  self.v = &self.v[..start];
                  Some(nth_back)
              }
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        [ Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ] ],
                      [],
                      "len",
                      []
                    |),
                    [ self ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.ge (M.read (| n |)) (M.read (| len |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::ChunksExact",
                            "v"
                          |),
                          (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start :=
                        M.alloc (|
                          BinOp.Wrap.mul
                            Integer.Usize
                            (BinOp.Wrap.sub
                              Integer.Usize
                              (BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (Value.Integer 1))
                              (M.read (| n |)))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::ChunksExact",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ end_ :=
                        M.alloc (|
                          BinOp.Wrap.add
                            Integer.Usize
                            (M.read (| start |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::ChunksExact",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ nth_back :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ] ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExact",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::Range"
                                [ ("start", M.read (| start |)); ("end_", M.read (| end_ |)) ]
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::ChunksExact",
                            "v"
                          |),
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ]
                              ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExact",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                [ ("end_", M.read (| start |)) ]
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| nth_back |) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.v.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "is_empty", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ChunksExact",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksExact_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksExact_T.
    
    (* StructRecord
      {
        name := "ChunksExactMut";
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("rem", Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("chunk_size", Ty.path "usize");
            ("_marker",
              Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.apply (Ty.path "&mut") [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field4_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "ChunksExactMut" |);
                M.read (| Value.String "v" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ChunksExactMut",
                    "v"
                  |));
                M.read (| Value.String "rem" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ChunksExactMut",
                    "rem"
                  |));
                M.read (| Value.String "chunk_size" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ChunksExactMut",
                    "chunk_size"
                  |));
                M.read (| Value.String "_marker" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::ChunksExactMut",
                      "_marker"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], chunk_size: usize) -> Self {
              let rem = slice.len() % chunk_size;
              let fst_len = slice.len() - rem;
              // SAFETY: 0 <= fst_len <= slice.len() by construction above
              let (fst, snd) = unsafe { slice.split_at_mut_unchecked(fst_len) };
              Self { v: fst, rem: snd, chunk_size, _marker: PhantomData }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice; chunk_size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let chunk_size := M.alloc (| chunk_size |) in
            M.read (|
              let~ rem :=
                M.alloc (|
                  BinOp.Wrap.rem
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [ M.read (| slice |) ]
                    |))
                    (M.read (| chunk_size |))
                |) in
              let~ fst_len :=
                M.alloc (|
                  BinOp.Wrap.sub
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [ M.read (| slice |) ]
                    |))
                    (M.read (| rem |))
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ T ],
                      "split_at_mut_unchecked",
                      []
                    |),
                    [ M.read (| slice |); M.read (| fst_len |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let fst := M.copy (| γ0_0 |) in
                      let snd := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::ChunksExactMut"
                          [
                            ("v", M.read (| fst |));
                            ("rem", M.read (| snd |));
                            ("chunk_size", M.read (| chunk_size |));
                            ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub fn into_remainder(self) -> &'a mut [T] {
              self.rem
          }
      *)
      Definition into_remainder (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                self,
                "core::slice::iter::ChunksExactMut",
                "rem"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_remainder :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "into_remainder" (into_remainder T).
    End Impl_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  // SAFETY: self.chunk_size is inbounds because we compared above against self.v.len()
                  let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *head })
              }
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::ChunksExactMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExactMut",
                                  "chunk_size"
                                |)
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExactMut",
                                  "v"
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExactMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksExactMut",
                                    "v"
                                  |),
                                  M.read (| tail |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| head |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let n = self.v.len() / self.chunk_size;
              (n, Some(n))
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ n :=
                M.alloc (|
                  BinOp.Wrap.div
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                        "len",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::ChunksExactMut",
                            "v"
                          |)
                        |)
                      ]
                    |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ChunksExactMut",
                        "chunk_size"
                      |)
                    |))
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| n |);
                    Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ],
                [],
                "len",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {
              let (start, overflow) = n.overflowing_mul(self.chunk_size);
              if start >= self.v.len() || overflow {
                  self.v = &mut [];
                  None
              } else {
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (_, snd) = unsafe { self.v.split_at_mut(start) };
                  self.v = snd;
                  self.next()
              }
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::ChunksExactMut",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let start := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.Pure.ge
                                        (M.read (| start |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              [ Ty.apply (Ty.path "slice") [ T ] ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::ChunksExactMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksExactMut",
                                    "v"
                                  |),
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        [ Ty.apply (Ty.path "slice") [ T ] ],
                                      "split_at_mut",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::ChunksExactMut",
                                          "v"
                                        |)
                                      |);
                                      M.read (| start |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let snd := M.copy (| γ0_1 |) in
                                      let~ _ :=
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::ChunksExactMut",
                                            "v"
                                          |),
                                          M.read (| snd |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::ChunksExactMut")
                                              [ T ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ],
                [],
                "next_back",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let start = idx * self.chunk_size;
              // SAFETY: see comments for `Chunks::__iterator_get_unchecked` and `self.v`.
              unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ start :=
                M.alloc (|
                  BinOp.Wrap.mul
                    Integer.Usize
                    (M.read (| idx |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ChunksExactMut",
                        "chunk_size"
                      |)
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::slice::raw::from_raw_parts_mut", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                            "as_mut_ptr",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::ChunksExactMut",
                                "v"
                              |)
                            |)
                          ]
                        |);
                        M.read (| start |)
                      ]
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ChunksExactMut",
                        "chunk_size"
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  // SAFETY: This subtraction is inbounds because of the check above
                  let (head, tail) = unsafe { self.v.split_at_mut(self.v.len() - self.chunk_size) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *tail })
              }
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::ChunksExactMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExactMut",
                                  "chunk_size"
                                |)
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ChunksExactMut",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub
                                Integer.Usize
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::ChunksExactMut",
                                        "v"
                                      |)
                                    |)
                                  ]
                                |))
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksExactMut",
                                    "chunk_size"
                                  |)
                                |))
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksExactMut",
                                    "v"
                                  |),
                                  M.read (| head |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| tail |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &mut [];
                  None
              } else {
                  let start = (len - 1 - n) * self.chunk_size;
                  let end = start + self.chunk_size;
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (temp, _tail) = unsafe { mem::replace(&mut self.v, &mut []).split_at_mut(end) };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, nth_back) = unsafe { temp.split_at_mut(start) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth_back })
              }
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        [ Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ] ],
                      [],
                      "len",
                      []
                    |),
                    [ self ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.ge (M.read (| n |)) (M.read (| len |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::ChunksExactMut",
                            "v"
                          |),
                          (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ start :=
                        M.alloc (|
                          BinOp.Wrap.mul
                            Integer.Usize
                            (BinOp.Wrap.sub
                              Integer.Usize
                              (BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (Value.Integer 1))
                              (M.read (| n |)))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::ChunksExactMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ end_ :=
                        M.alloc (|
                          BinOp.Wrap.add
                            Integer.Usize
                            (M.read (| start |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::ChunksExactMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_function (|
                                  "core::mem::replace",
                                  [ Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ] ]
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ChunksExactMut",
                                    "v"
                                  |);
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                ]
                              |);
                              M.read (| end_ |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let temp := M.copy (| γ0_0 |) in
                              let _tail := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        [ Ty.apply (Ty.path "slice") [ T ] ],
                                      "split_at_mut",
                                      []
                                    |),
                                    [ M.read (| temp |); M.read (| start |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let head := M.copy (| γ0_0 |) in
                                      let nth_back := M.copy (| γ0_1 |) in
                                      let~ _ :=
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::ChunksExactMut",
                                            "v"
                                          |),
                                          M.read (| head |)
                                        |) in
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [ M.read (| nth_back |) ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.v.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                "is_empty",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ChunksExactMut",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_ChunksExactMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_ChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_ChunksExactMut_T.
    
    (* StructRecord
      {
        name := "ArrayWindows";
        ty_params := [ "T" ];
        fields :=
          [
            ("slice_head", Ty.apply (Ty.path "*const") [ T ]);
            ("num", Ty.path "usize");
            ("marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "array") [ T ] ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayWindows_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "ArrayWindows" |);
                M.read (| Value.String "slice_head" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ArrayWindows",
                    "slice_head"
                  |));
                M.read (| Value.String "num" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ArrayWindows",
                    "num"
                  |));
                M.read (| Value.String "marker" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::ArrayWindows",
                      "marker"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayWindows_T.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_slice_iter_ArrayWindows_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ T ].
      
      (* Clone *)
      Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::ArrayWindows"
              [
                ("slice_head",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "*const") [ T ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayWindows",
                        "slice_head"
                      |)
                    ]
                  |));
                ("num",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Ty.path "usize", [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayWindows",
                        "num"
                      |)
                    ]
                  |));
                ("marker",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "core::marker::PhantomData")
                        [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "array") [ T ] ] ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayWindows",
                        "marker"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_for_core_slice_iter_ArrayWindows_T.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_slice_iter_ArrayWindows_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_T_for_core_slice_iter_ArrayWindows_T.
    
    Module Impl_core_slice_iter_ArrayWindows_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T]) -> Self {
              let num_windows = slice.len().saturating_sub(N - 1);
              Self { slice_head: slice.as_ptr(), num: num_windows, marker: PhantomData }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              let~ num_windows :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "saturating_sub", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                        [ M.read (| slice |) ]
                      |);
                      BinOp.Wrap.sub
                        Integer.Usize
                        (M.read (| M.get_constant (| "core::slice::iter::N" |) |))
                        (Value.Integer 1)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::slice::iter::ArrayWindows"
                  [
                    ("slice_head",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [ T ],
                          "as_ptr",
                          []
                        |),
                        [ M.read (| slice |) ]
                      |));
                    ("num", M.read (| num_windows |));
                    ("marker", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
    End Impl_core_slice_iter_ArrayWindows_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayWindows_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ T ].
      
      (*     type Item = &'a [T; N]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "array") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<Self::Item> {
              if self.num == 0 {
                  return None;
              }
              // SAFETY:
              // This is safe because it's indexing into a slice guaranteed to be length > N.
              let ret = unsafe { &*self.slice_head.cast::<[T; N]>() };
              // SAFETY: Guaranteed that there are at least 1 item remaining otherwise
              // earlier branch would've been hit
              self.slice_head = unsafe { self.slice_head.add(1) };
      
              self.num -= 1;
              Some(ret)
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |)
                                    |))
                                    (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [ T ],
                          "cast",
                          [ Ty.apply (Ty.path "array") [ T ] ]
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::ArrayWindows",
                              "slice_head"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayWindows",
                        "slice_head"
                      |),
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [ T ],
                          "add",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::ArrayWindows",
                              "slice_head"
                            |)
                          |);
                          Value.Integer 1
                        ]
                      |)
                    |) in
                  let~ _ :=
                    let β :=
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayWindows",
                        "num"
                      |) in
                    M.write (|
                      β,
                      BinOp.Wrap.sub Integer.Usize (M.read (| β |)) (Value.Integer 1)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::Some" [ M.read (| ret |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              (self.num, Some(self.num))
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ArrayWindows",
                    "num"
                  |)
                |);
                Value.StructTuple
                  "core::option::Option::Some"
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayWindows",
                        "num"
                      |)
                    |)
                  ]
              ]))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.num
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                self,
                "core::slice::iter::ArrayWindows",
                "num"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              if self.num <= n {
                  self.num = 0;
                  return None;
              }
              // SAFETY:
              // This is safe because it's indexing into a slice guaranteed to be length > N.
              let ret = unsafe { &*self.slice_head.add(n).cast::<[T; N]>() };
              // SAFETY: Guaranteed that there are at least n items remaining
              self.slice_head = unsafe { self.slice_head.add(n + 1) };
      
              self.num -= n + 1;
              Some(ret)
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.le
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |)
                                    |))
                                    (M.read (| n |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |),
                                      Value.Integer 0
                                    |) in
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [ T ],
                          "cast",
                          [ Ty.apply (Ty.path "array") [ T ] ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*const") [ T ],
                              "add",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ArrayWindows",
                                  "slice_head"
                                |)
                              |);
                              M.read (| n |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayWindows",
                        "slice_head"
                      |),
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [ T ],
                          "add",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::ArrayWindows",
                              "slice_head"
                            |)
                          |);
                          BinOp.Wrap.add Integer.Usize (M.read (| n |)) (Value.Integer 1)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    let β :=
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayWindows",
                        "num"
                      |) in
                    M.write (|
                      β,
                      BinOp.Wrap.sub
                        Integer.Usize
                        (M.read (| β |))
                        (BinOp.Wrap.add Integer.Usize (M.read (| n |)) (Value.Integer 1))
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::Some" [ M.read (| ret |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.nth(self.num.checked_sub(1)?)
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ T ],
                    [],
                    "nth",
                    []
                  |),
                  [
                    self;
                    M.read (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "usize", "checked_sub", [] |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "core::slice::iter::ArrayWindows",
                                      "num"
                                    |)
                                  |);
                                  Value.Integer 1
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                [ Ty.apply (Ty.path "array") [ T ] ]
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |)
                  ]
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayWindows_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayWindows_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T; N]> {
              if self.num == 0 {
                  return None;
              }
              // SAFETY: Guaranteed that there are n items remaining, n-1 for 0-indexing.
              let ret = unsafe { &*self.slice_head.add(self.num - 1).cast::<[T; N]>() };
              self.num -= 1;
              Some(ret)
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |)
                                    |))
                                    (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [ T ],
                          "cast",
                          [ Ty.apply (Ty.path "array") [ T ] ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*const") [ T ],
                              "add",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ArrayWindows",
                                  "slice_head"
                                |)
                              |);
                              BinOp.Wrap.sub
                                Integer.Usize
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ArrayWindows",
                                    "num"
                                  |)
                                |))
                                (Value.Integer 1)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    let β :=
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayWindows",
                        "num"
                      |) in
                    M.write (|
                      β,
                      BinOp.Wrap.sub Integer.Usize (M.read (| β |)) (Value.Integer 1)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::Some" [ M.read (| ret |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<&'a [T; N]> {
              if self.num <= n {
                  self.num = 0;
                  return None;
              }
              // SAFETY: Guaranteed that there are n items remaining, n-1 for 0-indexing.
              let ret = unsafe { &*self.slice_head.add(self.num - (n + 1)).cast::<[T; N]>() };
              self.num -= n + 1;
              Some(ret)
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.le
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |)
                                    |))
                                    (M.read (| n |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::ArrayWindows",
                                        "num"
                                      |),
                                      Value.Integer 0
                                    |) in
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ ret :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [ T ],
                          "cast",
                          [ Ty.apply (Ty.path "array") [ T ] ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*const") [ T ],
                              "add",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::ArrayWindows",
                                  "slice_head"
                                |)
                              |);
                              BinOp.Wrap.sub
                                Integer.Usize
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::ArrayWindows",
                                    "num"
                                  |)
                                |))
                                (BinOp.Wrap.add Integer.Usize (M.read (| n |)) (Value.Integer 1))
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    let β :=
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayWindows",
                        "num"
                      |) in
                    M.write (|
                      β,
                      BinOp.Wrap.sub
                        Integer.Usize
                        (M.read (| β |))
                        (BinOp.Wrap.add Integer.Usize (M.read (| n |)) (Value.Integer 1))
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::Some" [ M.read (| ret |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayWindows_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayWindows_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayWindows") [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.num == 0
          }
      *)
      Definition is_empty (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Pure.eq
              (M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayWindows",
                  "num"
                |)
              |))
              (Value.Integer 0)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayWindows_T.
    
    (* StructRecord
      {
        name := "ArrayChunks";
        ty_params := [ "T" ];
        fields :=
          [
            ("iter",
              Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.apply (Ty.path "array") [ T ] ]);
            ("rem", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayChunks_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "ArrayChunks" |);
                M.read (| Value.String "iter" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |));
                M.read (| Value.String "rem" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::ArrayChunks",
                      "rem"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayChunks_T.
    
    Module Impl_core_slice_iter_ArrayChunks_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T]) -> Self {
              let (array_slice, rem) = slice.as_chunks();
              Self { iter: array_slice.iter(), rem }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ T ],
                      "as_chunks",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let array_slice := M.copy (| γ0_0 |) in
                      let rem := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::ArrayChunks"
                          [
                            ("iter",
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ Ty.apply (Ty.path "array") [ T ] ],
                                  "iter",
                                  []
                                |),
                                [ M.read (| array_slice |) ]
                              |));
                            ("rem", M.read (| rem |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub fn remainder(&self) -> &'a [T] {
              self.rem
          }
      *)
      Definition remainder (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "core::slice::iter::ArrayChunks",
                "rem"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_remainder :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "remainder" (remainder T).
    End Impl_core_slice_iter_ArrayChunks_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_ArrayChunks_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ T ].
      
      (*
          fn clone(&self) -> Self {
              ArrayChunks { iter: self.iter.clone(), rem: self.rem }
          }
      *)
      Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::ArrayChunks"
              [
                ("iter",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "core::slice::iter::Iter")
                        [ Ty.apply (Ty.path "array") [ T ] ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::ArrayChunks",
                        "iter"
                      |)
                    ]
                  |));
                ("rem",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::ArrayChunks",
                      "rem"
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_ArrayChunks_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayChunks_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ T ].
      
      (*     type Item = &'a [T; N]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "array") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T; N]> {
              self.iter.next()
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "next",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunks",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.iter.size_hint()
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "size_hint",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunks",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.iter.count()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "count",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              self.iter.nth(n)
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "nth",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunks",
                  "iter"
                |);
                M.read (| n |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              self.iter.last()
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "last",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::slice::iter::ArrayChunks",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> &'a [T; N] {
              // SAFETY: The safety guarantees of `__iterator_get_unchecked` are
              // transferred to the caller.
              unsafe { self.iter.__iterator_get_unchecked(i) }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; i ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let i := M.alloc (| i |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "__iterator_get_unchecked",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunks",
                  "iter"
                |);
                M.read (| i |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayChunks_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayChunks_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T; N]> {
              self.iter.next_back()
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "next_back",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunks",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              self.iter.nth_back(n)
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "nth_back",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunks",
                  "iter"
                |);
                M.read (| n |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayChunks_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayChunks_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.iter.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "is_empty",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunks",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayChunks_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ArrayChunks_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ArrayChunks_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ArrayChunks_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ArrayChunks_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ArrayChunks_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ArrayChunks_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ArrayChunks_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunks") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ArrayChunks_T.
    
    (* StructRecord
      {
        name := "ArrayChunksMut";
        ty_params := [ "T" ];
        fields :=
          [
            ("iter",
              Ty.apply (Ty.path "core::slice::iter::IterMut") [ Ty.apply (Ty.path "array") [ T ] ]);
            ("rem", Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "ArrayChunksMut" |);
                M.read (| Value.String "iter" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |));
                M.read (| Value.String "rem" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::ArrayChunksMut",
                      "rem"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_ArrayChunksMut_T.
    
    Module Impl_core_slice_iter_ArrayChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T]) -> Self {
              let (array_slice, rem) = slice.as_chunks_mut();
              Self { iter: array_slice.iter_mut(), rem }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ T ],
                      "as_chunks_mut",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let array_slice := M.copy (| γ0_0 |) in
                      let rem := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::ArrayChunksMut"
                          [
                            ("iter",
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ Ty.apply (Ty.path "array") [ T ] ],
                                  "iter_mut",
                                  []
                                |),
                                [ M.read (| array_slice |) ]
                              |));
                            ("rem", M.read (| rem |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub fn into_remainder(self) -> &'a mut [T] {
              self.rem
          }
      *)
      Definition into_remainder (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                self,
                "core::slice::iter::ArrayChunksMut",
                "rem"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_remainder :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "into_remainder" (into_remainder T).
    End Impl_core_slice_iter_ArrayChunksMut_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ T ].
      
      (*     type Item = &'a mut [T; N]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "array") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T; N]> {
              self.iter.next()
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "next",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunksMut",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.iter.size_hint()
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "size_hint",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunksMut",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.iter.count()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "count",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              self.iter.nth(n)
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "nth",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunksMut",
                  "iter"
                |);
                M.read (| n |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              self.iter.last()
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "last",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::slice::iter::ArrayChunksMut",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> &'a mut [T; N] {
              // SAFETY: The safety guarantees of `__iterator_get_unchecked` are transferred to
              // the caller.
              unsafe { self.iter.__iterator_get_unchecked(i) }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; i ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let i := M.alloc (| i |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "__iterator_get_unchecked",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunksMut",
                  "iter"
                |);
                M.read (| i |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_ArrayChunksMut_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T; N]> {
              self.iter.next_back()
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "next_back",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunksMut",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              self.iter.nth_back(n)
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "nth_back",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunksMut",
                  "iter"
                |);
                M.read (| n |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_ArrayChunksMut_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.iter.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply
                  (Ty.path "core::slice::iter::IterMut")
                  [ Ty.apply (Ty.path "array") [ T ] ],
                [],
                "is_empty",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::iter::ArrayChunksMut",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_ArrayChunksMut_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ArrayChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_ArrayChunksMut_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ArrayChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_ArrayChunksMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ArrayChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_ArrayChunksMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ArrayChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::ArrayChunksMut") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_ArrayChunksMut_T.
    
    (* StructRecord
      {
        name := "RChunks";
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("chunk_size", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "RChunks" |);
                M.read (| Value.String "v" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::RChunks",
                    "v"
                  |));
                M.read (| Value.String "chunk_size" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::RChunks",
                      "chunk_size"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T], size: usize) -> Self {
              Self { v: slice, chunk_size: size }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice; size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let size := M.alloc (| size |) in
            Value.StructRecord
              "core::slice::iter::RChunks"
              [ ("v", M.read (| slice |)); ("chunk_size", M.read (| size |)) ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
    End Impl_core_slice_iter_RChunks_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ].
      
      (*
          fn clone(&self) -> Self {
              RChunks { v: self.v, chunk_size: self.chunk_size }
          }
      *)
      Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::RChunks"
              [
                ("v",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::RChunks",
                      "v"
                    |)
                  |));
                ("chunk_size",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::RChunks",
                      "chunk_size"
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let len = self.v.len();
                  let chunksz = cmp::min(len, self.chunk_size);
                  // SAFETY: split_at_unchecked just requires the argument be less
                  // than the length. This could only happen if the expression `len -
                  // chunksz` overflows. This could only happen if `chunksz > len`,
                  // which is impossible as we initialize it as the `min` of `len` and
                  // `self.chunk_size`.
                  let (fst, snd) = unsafe { self.v.split_at_unchecked(len - chunksz) };
                  self.v = fst;
                  Some(snd)
              }
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "len",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunks",
                                  "v"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      let~ chunksz :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                            [
                              M.read (| len |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunks",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at_unchecked",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunks",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (M.read (| chunksz |))
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |),
                                  M.read (| fst |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| snd |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.v.is_empty() {
                  (0, Some(0))
              } else {
                  let n = self.v.len() / self.chunk_size;
                  let rem = self.v.len() % self.chunk_size;
                  let n = if rem > 0 { n + 1 } else { n };
                  (n, Some(n))
              }
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ n :=
                        M.alloc (|
                          BinOp.Wrap.div
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunks",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ rem :=
                        M.alloc (|
                          BinOp.Wrap.rem
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunks",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ n :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.gt (M.read (| rem |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    BinOp.Wrap.add Integer.Usize (M.read (| n |)) (Value.Integer 1)
                                  |)));
                              fun γ => ltac:(M.monadic n)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| n |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ],
                [],
                "len",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              let (end, overflow) = n.overflowing_mul(self.chunk_size);
              if end >= self.v.len() || overflow {
                  self.v = &[];
                  None
              } else {
                  // Can't underflow because of the check above
                  let end = self.v.len() - end;
                  let start = match end.checked_sub(self.chunk_size) {
                      Some(sum) => sum,
                      None => 0,
                  };
                  let nth = &self.v[start..end];
                  self.v = &self.v[0..start];
                  Some(nth)
              }
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::RChunks",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.Pure.ge
                                        (M.read (| end_ |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ T ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::RChunks",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |),
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ end_ :=
                                M.alloc (|
                                  BinOp.Wrap.sub
                                    Integer.Usize
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "len",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::RChunks",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |))
                                    (M.read (| end_ |))
                                |) in
                              let~ start :=
                                M.copy (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "usize",
                                          "checked_sub",
                                          []
                                        |),
                                        [
                                          M.read (| end_ |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "core::slice::iter::RChunks",
                                              "chunk_size"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let sum := M.copy (| γ0_0 |) in
                                          sum));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                                    ]
                                  |)
                                |) in
                              let~ nth :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::RChunks",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [ ("start", M.read (| start |)); ("end_", M.read (| end_ |))
                                        ]
                                    ]
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |),
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "slice") [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::RChunks",
                                          "v"
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [ ("start", Value.Integer 0); ("end_", M.read (| start |)) ]
                                    ]
                                  |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| nth |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              if self.v.is_empty() {
                  None
              } else {
                  let rem = self.v.len() % self.chunk_size;
                  let end = if rem == 0 { self.chunk_size } else { rem };
                  Some(&self.v[0..end])
              }
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ rem :=
                        M.alloc (|
                          BinOp.Wrap.rem
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "core::slice::iter::RChunks",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ end_ :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.eq (M.read (| rem |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunks",
                                    "chunk_size"
                                  |)));
                              fun γ => ltac:(M.monadic rem)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.apply (Ty.path "slice") [ T ],
                                [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ]
                                ],
                                "index",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |)
                                |);
                                Value.StructRecord
                                  "core::ops::range::Range"
                                  [ ("start", Value.Integer 0); ("end_", M.read (| end_ |)) ]
                              ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let end = self.v.len() - idx * self.chunk_size;
              let start = match end.checked_sub(self.chunk_size) {
                  None => 0,
                  Some(start) => start,
              };
              // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.
              unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ end_ :=
                M.alloc (|
                  BinOp.Wrap.sub
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunks",
                            "v"
                          |)
                        |)
                      ]
                    |))
                    (BinOp.Wrap.mul
                      Integer.Usize
                      (M.read (| idx |))
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::RChunks",
                          "chunk_size"
                        |)
                      |)))
                |) in
              let~ start :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "checked_sub", [] |),
                        [
                          M.read (| end_ |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::RChunks",
                              "chunk_size"
                            |)
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let start := M.copy (| γ0_0 |) in
                          start))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::slice::raw::from_raw_parts", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "add", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [ T ],
                            "as_ptr",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunks",
                                "v"
                              |)
                            |)
                          ]
                        |);
                        M.read (| start |)
                      ]
                    |);
                    BinOp.Wrap.sub Integer.Usize (M.read (| end_ |)) (M.read (| start |))
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let remainder = self.v.len() % self.chunk_size;
                  let chunksz = if remainder != 0 { remainder } else { self.chunk_size };
                  // SAFETY: similar to Chunks::next_back
                  let (fst, snd) = unsafe { self.v.split_at_unchecked(chunksz) };
                  self.v = snd;
                  Some(fst)
              }
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ remainder :=
                        M.alloc (|
                          BinOp.Wrap.rem
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunks",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ chunksz :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ne (M.read (| remainder |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  remainder));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "chunk_size"
                                  |)))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at_unchecked",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunks",
                                  "v"
                                |)
                              |);
                              M.read (| chunksz |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |),
                                  M.read (| snd |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| fst |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &[];
                  None
              } else {
                  // can't underflow because `n < len`
                  let offset_from_end = (len - 1 - n) * self.chunk_size;
                  let end = self.v.len() - offset_from_end;
                  let start = end.saturating_sub(self.chunk_size);
                  let nth_back = &self.v[start..end];
                  self.v = &self.v[end..];
                  Some(nth_back)
              }
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        [ Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ] ],
                      [],
                      "len",
                      []
                    |),
                    [ self ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.ge (M.read (| n |)) (M.read (| len |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunks",
                            "v"
                          |),
                          (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ offset_from_end :=
                        M.alloc (|
                          BinOp.Wrap.mul
                            Integer.Usize
                            (BinOp.Wrap.sub
                              Integer.Usize
                              (BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (Value.Integer 1))
                              (M.read (| n |)))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunks",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ end_ :=
                        M.alloc (|
                          BinOp.Wrap.sub
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunks",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (| offset_from_end |))
                        |) in
                      let~ start :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "saturating_sub", [] |),
                            [
                              M.read (| end_ |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunks",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      let~ nth_back :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ] ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunks",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::Range"
                                [ ("start", M.read (| start |)); ("end_", M.read (| end_ |)) ]
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunks",
                            "v"
                          |),
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ]
                              ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunks",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::RangeFrom"
                                [ ("start", M.read (| end_ |)) ]
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| nth_back |) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunks_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunks_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunks") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunks_T.
    
    (* StructRecord
      {
        name := "RChunksMut";
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("chunk_size", Ty.path "usize");
            ("_marker",
              Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.apply (Ty.path "&mut") [ T ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "RChunksMut" |);
                M.read (| Value.String "v" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::RChunksMut",
                    "v"
                  |));
                M.read (| Value.String "chunk_size" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::RChunksMut",
                    "chunk_size"
                  |));
                M.read (| Value.String "_marker" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::RChunksMut",
                      "_marker"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {
              Self { v: slice, chunk_size: size, _marker: PhantomData }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice; size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let size := M.alloc (| size |) in
            Value.StructRecord
              "core::slice::iter::RChunksMut"
              [
                ("v", M.read (| slice |));
                ("chunk_size", M.read (| size |));
                ("_marker", Value.StructTuple "core::marker::PhantomData" [])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
    End Impl_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let sz = cmp::min(self.v.len(), self.chunk_size);
                  let len = self.v.len();
                  // SAFETY: split_at_mut_unchecked just requires the argument be less
                  // than the length. This could only happen if the expression
                  // `len - sz` overflows. This could only happen if `sz >
                  // len`, which is impossible as we initialize it as the `min` of
                  // `self.v.len()` (e.g. `len`) and `self.chunk_size`.
                  let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *tail })
              }
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ sz :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::RChunksMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      let~ len :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "len",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksMut",
                                  "v"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut_unchecked",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksMut",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (M.read (| sz |))
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |),
                                  M.read (| head |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| tail |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.v.is_empty() {
                  (0, Some(0))
              } else {
                  let n = self.v.len() / self.chunk_size;
                  let rem = self.v.len() % self.chunk_size;
                  let n = if rem > 0 { n + 1 } else { n };
                  (n, Some(n))
              }
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ n :=
                        M.alloc (|
                          BinOp.Wrap.div
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ rem :=
                        M.alloc (|
                          BinOp.Wrap.rem
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ n :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.gt (M.read (| rem |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    BinOp.Wrap.add Integer.Usize (M.read (| n |)) (Value.Integer 1)
                                  |)));
                              fun γ => ltac:(M.monadic n)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| n |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ],
                [],
                "len",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {
              let (end, overflow) = n.overflowing_mul(self.chunk_size);
              if end >= self.v.len() || overflow {
                  self.v = &mut [];
                  None
              } else {
                  // Can't underflow because of the check above
                  let end = self.v.len() - end;
                  let start = match end.checked_sub(self.chunk_size) {
                      Some(sum) => sum,
                      None => 0,
                  };
                  // SAFETY: This type ensures that self.v is a valid pointer with a correct len.
                  // Therefore the bounds check in split_at_mut guarantees the split point is inbounds.
                  let (head, tail) = unsafe { self.v.split_at_mut(start) };
                  // SAFETY: This type ensures that self.v is a valid pointer with a correct len.
                  // Therefore the bounds check in split_at_mut guarantees the split point is inbounds.
                  let (nth, _) = unsafe { tail.split_at_mut(end - start) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth })
              }
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::RChunksMut",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.Pure.ge
                                        (M.read (| end_ |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              [ Ty.apply (Ty.path "slice") [ T ] ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::RChunksMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |),
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ end_ :=
                                M.alloc (|
                                  BinOp.Wrap.sub
                                    Integer.Usize
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          [ Ty.apply (Ty.path "slice") [ T ] ],
                                        "len",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::RChunksMut",
                                            "v"
                                          |)
                                        |)
                                      ]
                                    |))
                                    (M.read (| end_ |))
                                |) in
                              let~ start :=
                                M.copy (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "usize",
                                          "checked_sub",
                                          []
                                        |),
                                        [
                                          M.read (| end_ |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "core::slice::iter::RChunksMut",
                                              "chunk_size"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let sum := M.copy (| γ0_0 |) in
                                          sum));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                                    ]
                                  |)
                                |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        [ Ty.apply (Ty.path "slice") [ T ] ],
                                      "split_at_mut",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::RChunksMut",
                                          "v"
                                        |)
                                      |);
                                      M.read (| start |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let head := M.copy (| γ0_0 |) in
                                      let tail := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "*mut")
                                                [ Ty.apply (Ty.path "slice") [ T ] ],
                                              "split_at_mut",
                                              []
                                            |),
                                            [
                                              M.read (| tail |);
                                              BinOp.Wrap.sub
                                                Integer.Usize
                                                (M.read (| end_ |))
                                                (M.read (| start |))
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_tuple_field (| γ, 0 |) in
                                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                              let nth := M.copy (| γ0_0 |) in
                                              let~ _ :=
                                                M.write (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "core::slice::iter::RChunksMut",
                                                    "v"
                                                  |),
                                                  M.read (| head |)
                                                |) in
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [ M.read (| nth |) ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(self) -> Option<Self::Item> {
              if self.v.is_empty() {
                  None
              } else {
                  let rem = self.v.len() % self.chunk_size;
                  let end = if rem == 0 { self.chunk_size } else { rem };
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *self.v.get_unchecked_mut(0..end) })
              }
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ rem :=
                        M.alloc (|
                          BinOp.Wrap.rem
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "core::slice::iter::RChunksMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ end_ :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.eq (M.read (| rem |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunksMut",
                                    "chunk_size"
                                  |)));
                              fun γ => ltac:(M.monadic rem)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "get_unchecked_mut",
                                [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ] ]
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |);
                                Value.StructRecord
                                  "core::ops::range::Range"
                                  [ ("start", Value.Integer 0); ("end_", M.read (| end_ |)) ]
                              ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let end = self.v.len() - idx * self.chunk_size;
              let start = match end.checked_sub(self.chunk_size) {
                  None => 0,
                  Some(start) => start,
              };
              // SAFETY: see comments for `RChunks::__iterator_get_unchecked` and
              // `ChunksMut::__iterator_get_unchecked`, `self.v`.
              unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ end_ :=
                M.alloc (|
                  BinOp.Wrap.sub
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                        "len",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunksMut",
                            "v"
                          |)
                        |)
                      ]
                    |))
                    (BinOp.Wrap.mul
                      Integer.Usize
                      (M.read (| idx |))
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::RChunksMut",
                          "chunk_size"
                        |)
                      |)))
                |) in
              let~ start :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "checked_sub", [] |),
                        [
                          M.read (| end_ |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::iter::RChunksMut",
                              "chunk_size"
                            |)
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let start := M.copy (| γ0_0 |) in
                          start))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::slice::raw::from_raw_parts_mut", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                            "as_mut_ptr",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksMut",
                                "v"
                              |)
                            |)
                          ]
                        |);
                        M.read (| start |)
                      ]
                    |);
                    BinOp.Wrap.sub Integer.Usize (M.read (| end_ |)) (M.read (| start |))
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.v.is_empty() {
                  None
              } else {
                  let remainder = self.v.len() % self.chunk_size;
                  let sz = if remainder != 0 { remainder } else { self.chunk_size };
                  // SAFETY: Similar to `Chunks::next_back`
                  let (head, tail) = unsafe { self.v.split_at_mut_unchecked(sz) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *head })
              }
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ remainder :=
                        M.alloc (|
                          BinOp.Wrap.rem
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ sz :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.ne (M.read (| remainder |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  remainder));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "chunk_size"
                                  |)))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut_unchecked",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksMut",
                                  "v"
                                |)
                              |);
                              M.read (| sz |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |),
                                  M.read (| tail |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| head |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &mut [];
                  None
              } else {
                  // can't underflow because `n < len`
                  let offset_from_end = (len - 1 - n) * self.chunk_size;
                  let end = self.v.len() - offset_from_end;
                  let start = end.saturating_sub(self.chunk_size);
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (tmp, tail) = unsafe { self.v.split_at_mut(end) };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (_, nth_back) = unsafe { tmp.split_at_mut(start) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth_back })
              }
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        [ Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ] ],
                      [],
                      "len",
                      []
                    |),
                    [ self ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.ge (M.read (| n |)) (M.read (| len |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunksMut",
                            "v"
                          |),
                          (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ offset_from_end :=
                        M.alloc (|
                          BinOp.Wrap.mul
                            Integer.Usize
                            (BinOp.Wrap.sub
                              Integer.Usize
                              (BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (Value.Integer 1))
                              (M.read (| n |)))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ end_ :=
                        M.alloc (|
                          BinOp.Wrap.sub
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (| offset_from_end |))
                        |) in
                      let~ start :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "usize", "saturating_sub", [] |),
                            [
                              M.read (| end_ |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksMut",
                                  "v"
                                |)
                              |);
                              M.read (| end_ |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let tmp := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        [ Ty.apply (Ty.path "slice") [ T ] ],
                                      "split_at_mut",
                                      []
                                    |),
                                    [ M.read (| tmp |); M.read (| start |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let nth_back := M.copy (| γ0_1 |) in
                                      let~ _ :=
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::RChunksMut",
                                            "v"
                                          |),
                                          M.read (| tail |)
                                        |) in
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [ M.read (| nth_back |) ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_RChunksMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_RChunksMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::RChunksMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_RChunksMut_T.
    
    (* StructRecord
      {
        name := "RChunksExact";
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("rem", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("chunk_size", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "RChunksExact" |);
                M.read (| Value.String "v" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::RChunksExact",
                    "v"
                  |));
                M.read (| Value.String "rem" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::RChunksExact",
                    "rem"
                  |));
                M.read (| Value.String "chunk_size" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::RChunksExact",
                      "chunk_size"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ].
      
      (*
          pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {
              let rem = slice.len() % chunk_size;
              // SAFETY: 0 <= rem <= slice.len() by construction above
              let (fst, snd) = unsafe { slice.split_at_unchecked(rem) };
              Self { v: snd, rem: fst, chunk_size }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice; chunk_size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let chunk_size := M.alloc (| chunk_size |) in
            M.read (|
              let~ rem :=
                M.alloc (|
                  BinOp.Wrap.rem
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [ M.read (| slice |) ]
                    |))
                    (M.read (| chunk_size |))
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ T ],
                      "split_at_unchecked",
                      []
                    |),
                    [ M.read (| slice |); M.read (| rem |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let fst := M.copy (| γ0_0 |) in
                      let snd := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::RChunksExact"
                          [
                            ("v", M.read (| snd |));
                            ("rem", M.read (| fst |));
                            ("chunk_size", M.read (| chunk_size |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub fn remainder(&self) -> &'a [T] {
              self.rem
          }
      *)
      Definition remainder (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "core::slice::iter::RChunksExact",
                "rem"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_remainder :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "remainder" (remainder T).
    End Impl_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_clone_Clone_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ].
      
      (*
          fn clone(&self) -> RChunksExact<'a, T> {
              RChunksExact { v: self.v, rem: self.rem, chunk_size: self.chunk_size }
          }
      *)
      Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::slice::iter::RChunksExact"
              [
                ("v",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::RChunksExact",
                      "v"
                    |)
                  |));
                ("rem",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::RChunksExact",
                      "rem"
                    |)
                  |));
                ("chunk_size",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::RChunksExact",
                      "chunk_size"
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);
                  self.v = fst;
                  Some(snd)
              }
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::RChunksExact",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExact",
                                  "chunk_size"
                                |)
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExact",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub
                                Integer.Usize
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::RChunksExact",
                                        "v"
                                      |)
                                    |)
                                  ]
                                |))
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksExact",
                                    "chunk_size"
                                  |)
                                |))
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksExact",
                                    "v"
                                  |),
                                  M.read (| fst |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| snd |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let n = self.v.len() / self.chunk_size;
              (n, Some(n))
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ n :=
                M.alloc (|
                  BinOp.Wrap.div
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunksExact",
                            "v"
                          |)
                        |)
                      ]
                    |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::RChunksExact",
                        "chunk_size"
                      |)
                    |))
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| n |);
                    Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ],
                [],
                "len",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<Self::Item> {
              let (end, overflow) = n.overflowing_mul(self.chunk_size);
              if end >= self.v.len() || overflow {
                  self.v = &[];
                  None
              } else {
                  let (fst, _) = self.v.split_at(self.v.len() - end);
                  self.v = fst;
                  self.next()
              }
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::RChunksExact",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.Pure.ge
                                        (M.read (| end_ |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ T ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::RChunksExact",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksExact",
                                    "v"
                                  |),
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [ T ],
                                      "split_at",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::RChunksExact",
                                          "v"
                                        |)
                                      |);
                                      BinOp.Wrap.sub
                                        Integer.Usize
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ T ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::RChunksExact",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |))
                                        (M.read (| end_ |))
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let fst := M.copy (| γ0_0 |) in
                                      let~ _ :=
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::RChunksExact",
                                            "v"
                                          |),
                                          M.read (| fst |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::RChunksExact")
                                              [ T ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ],
                [],
                "next_back",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let end = self.v.len() - idx * self.chunk_size;
              let start = end - self.chunk_size;
              // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.
              unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ end_ :=
                M.alloc (|
                  BinOp.Wrap.sub
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunksExact",
                            "v"
                          |)
                        |)
                      ]
                    |))
                    (BinOp.Wrap.mul
                      Integer.Usize
                      (M.read (| idx |))
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::RChunksExact",
                          "chunk_size"
                        |)
                      |)))
                |) in
              let~ start :=
                M.alloc (|
                  BinOp.Wrap.sub
                    Integer.Usize
                    (M.read (| end_ |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::RChunksExact",
                        "chunk_size"
                      |)
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::slice::raw::from_raw_parts", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "add", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [ T ],
                            "as_ptr",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksExact",
                                "v"
                              |)
                            |)
                          ]
                        |);
                        M.read (| start |)
                      ]
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::RChunksExact",
                        "chunk_size"
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  let (fst, snd) = self.v.split_at(self.chunk_size);
                  self.v = snd;
                  Some(fst)
              }
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::RChunksExact",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExact",
                                  "chunk_size"
                                |)
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExact",
                                  "v"
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExact",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let fst := M.copy (| γ0_0 |) in
                              let snd := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksExact",
                                    "v"
                                  |),
                                  M.read (| snd |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| fst |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &[];
                  None
              } else {
                  // now that we know that `n` corresponds to a chunk,
                  // none of these operations can underflow/overflow
                  let offset = (len - n) * self.chunk_size;
                  let start = self.v.len() - offset;
                  let end = start + self.chunk_size;
                  let nth_back = &self.v[start..end];
                  self.v = &self.v[end..];
                  Some(nth_back)
              }
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        [ Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ] ],
                      [],
                      "len",
                      []
                    |),
                    [ self ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.ge (M.read (| n |)) (M.read (| len |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunksExact",
                            "v"
                          |),
                          (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ offset :=
                        M.alloc (|
                          BinOp.Wrap.mul
                            Integer.Usize
                            (BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (M.read (| n |)))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksExact",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ start :=
                        M.alloc (|
                          BinOp.Wrap.sub
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksExact",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (| offset |))
                        |) in
                      let~ end_ :=
                        M.alloc (|
                          BinOp.Wrap.add
                            Integer.Usize
                            (M.read (| start |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksExact",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ nth_back :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ] ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExact",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::Range"
                                [ ("start", M.read (| start |)); ("end_", M.read (| end_ |)) ]
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunksExact",
                            "v"
                          |),
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [ T ],
                              [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ]
                              ],
                              "index",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExact",
                                  "v"
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::RangeFrom"
                                [ ("start", M.read (| end_ |)) ]
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| nth_back |) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.v.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "is_empty", [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::RChunksExact",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksExact_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksExact_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExact") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksExact_T.
    
    (* StructRecord
      {
        name := "RChunksExactMut";
        ty_params := [ "T" ];
        fields :=
          [
            ("v", Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("rem", Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("chunk_size", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "RChunksExactMut" |);
                M.read (| Value.String "v" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::RChunksExactMut",
                    "v"
                  |));
                M.read (| Value.String "rem" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::RChunksExactMut",
                    "rem"
                  |));
                M.read (| Value.String "chunk_size" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::iter::RChunksExactMut",
                      "chunk_size"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], chunk_size: usize) -> Self {
              let rem = slice.len() % chunk_size;
              // SAFETY: 0 <= rem <= slice.len() by construction above
              let (fst, snd) = unsafe { slice.split_at_mut_unchecked(rem) };
              Self { v: snd, rem: fst, chunk_size }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ slice; chunk_size ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let chunk_size := M.alloc (| chunk_size |) in
            M.read (|
              let~ rem :=
                M.alloc (|
                  BinOp.Wrap.rem
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [ M.read (| slice |) ]
                    |))
                    (M.read (| chunk_size |))
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ T ],
                      "split_at_mut_unchecked",
                      []
                    |),
                    [ M.read (| slice |); M.read (| rem |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let fst := M.copy (| γ0_0 |) in
                      let snd := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::iter::RChunksExactMut"
                          [
                            ("v", M.read (| snd |));
                            ("rem", M.read (| fst |));
                            ("chunk_size", M.read (| chunk_size |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub fn into_remainder(self) -> &'a mut [T] {
              self.rem
          }
      *)
      Definition into_remainder (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                self,
                "core::slice::iter::RChunksExactMut",
                "rem"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_remainder :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "into_remainder" (into_remainder T).
    End Impl_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<&'a mut [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  let len = self.v.len();
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, tail) = unsafe { self.v.split_at_mut(len - self.chunk_size) };
                  self.v = head;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *tail })
              }
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::RChunksExactMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExactMut",
                                  "chunk_size"
                                |)
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "len",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExactMut",
                                  "v"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExactMut",
                                  "v"
                                |)
                              |);
                              BinOp.Wrap.sub
                                Integer.Usize
                                (M.read (| len |))
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksExactMut",
                                    "chunk_size"
                                  |)
                                |))
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksExactMut",
                                    "v"
                                  |),
                                  M.read (| head |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| tail |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let n = self.v.len() / self.chunk_size;
              (n, Some(n))
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ n :=
                M.alloc (|
                  BinOp.Wrap.div
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                        "len",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunksExactMut",
                            "v"
                          |)
                        |)
                      ]
                    |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::RChunksExactMut",
                        "chunk_size"
                      |)
                    |))
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| n |);
                    Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ]
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              self.len()
          }
      *)
      Definition count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ],
                [],
                "len",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {
              let (end, overflow) = n.overflowing_mul(self.chunk_size);
              if end >= self.v.len() || overflow {
                  self.v = &mut [];
                  None
              } else {
                  let len = self.v.len();
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (fst, _) = unsafe { self.v.split_at_mut(len - end) };
                  self.v = fst;
                  self.next()
              }
          }
      *)
      Definition nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "overflowing_mul", [] |),
                    [
                      M.read (| n |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::RChunksExactMut",
                          "chunk_size"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let end_ := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.Pure.ge
                                        (M.read (| end_ |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              [ Ty.apply (Ty.path "slice") [ T ] ],
                                            "len",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::slice::iter::RChunksExactMut",
                                                "v"
                                              |)
                                            |)
                                          ]
                                        |)),
                                      ltac:(M.monadic (M.read (| overflow |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksExactMut",
                                    "v"
                                  |),
                                  (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                                |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ len :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        [ Ty.apply (Ty.path "slice") [ T ] ],
                                      "len",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::RChunksExactMut",
                                          "v"
                                        |)
                                      |)
                                    ]
                                  |)
                                |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        [ Ty.apply (Ty.path "slice") [ T ] ],
                                      "split_at_mut",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::slice::iter::RChunksExactMut",
                                          "v"
                                        |)
                                      |);
                                      BinOp.Wrap.sub
                                        Integer.Usize
                                        (M.read (| len |))
                                        (M.read (| end_ |))
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let fst := M.copy (| γ0_0 |) in
                                      let~ _ :=
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::RChunksExactMut",
                                            "v"
                                          |),
                                          M.read (| fst |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::RChunksExactMut")
                                              [ T ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ],
                [],
                "next_back",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {
              let end = self.v.len() - idx * self.chunk_size;
              let start = end - self.chunk_size;
              // SAFETY: see comments for `RChunksMut::__iterator_get_unchecked` and `self.v`.
              unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }
          }
      *)
      Definition __iterator_get_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ end_ :=
                M.alloc (|
                  BinOp.Wrap.sub
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                        "len",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunksExactMut",
                            "v"
                          |)
                        |)
                      ]
                    |))
                    (BinOp.Wrap.mul
                      Integer.Usize
                      (M.read (| idx |))
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::iter::RChunksExactMut",
                          "chunk_size"
                        |)
                      |)))
                |) in
              let~ start :=
                M.alloc (|
                  BinOp.Wrap.sub
                    Integer.Usize
                    (M.read (| end_ |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::RChunksExactMut",
                        "chunk_size"
                      |)
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::slice::raw::from_raw_parts_mut", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                            "as_mut_ptr",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksExactMut",
                                "v"
                              |)
                            |)
                          ]
                        |);
                        M.read (| start |)
                      ]
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::RChunksExactMut",
                        "chunk_size"
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("count", InstanceField.Method (count T));
            ("nth", InstanceField.Method (nth T));
            ("last", InstanceField.Method (last T));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut [T]> {
              if self.v.len() < self.chunk_size {
                  None
              } else {
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *head })
              }
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                  "len",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::iter::RChunksExactMut",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExactMut",
                                  "chunk_size"
                                |)
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExactMut",
                                  "v"
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExactMut",
                                  "chunk_size"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksExactMut",
                                    "v"
                                  |),
                                  M.read (| tail |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| head |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
              let len = self.len();
              if n >= len {
                  self.v = &mut [];
                  None
              } else {
                  // now that we know that `n` corresponds to a chunk,
                  // none of these operations can underflow/overflow
                  let offset = (len - n) * self.chunk_size;
                  let start = self.v.len() - offset;
                  let end = start + self.chunk_size;
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (tmp, tail) = unsafe { self.v.split_at_mut(end) };
                  // SAFETY: The self.v contract ensures that any split_at_mut is valid.
                  let (_, nth_back) = unsafe { tmp.split_at_mut(start) };
                  self.v = tail;
                  // SAFETY: Nothing else points to or will point to the contents of this slice.
                  Some(unsafe { &mut *nth_back })
              }
          }
      *)
      Definition nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::exact_size::ExactSizeIterator",
                      Ty.apply
                        (Ty.path "&mut")
                        [ Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ] ],
                      [],
                      "len",
                      []
                    |),
                    [ self ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.ge (M.read (| n |)) (M.read (| len |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::iter::RChunksExactMut",
                            "v"
                          |),
                          (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |))
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ offset :=
                        M.alloc (|
                          BinOp.Wrap.mul
                            Integer.Usize
                            (BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (M.read (| n |)))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksExactMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      let~ start :=
                        M.alloc (|
                          BinOp.Wrap.sub
                            Integer.Usize
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                                "len",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::RChunksExactMut",
                                    "v"
                                  |)
                                |)
                              ]
                            |))
                            (M.read (| offset |))
                        |) in
                      let~ end_ :=
                        M.alloc (|
                          BinOp.Wrap.add
                            Integer.Usize
                            (M.read (| start |))
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::RChunksExactMut",
                                "chunk_size"
                              |)
                            |))
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                              "split_at_mut",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::RChunksExactMut",
                                  "v"
                                |)
                              |);
                              M.read (| end_ |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let tmp := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        [ Ty.apply (Ty.path "slice") [ T ] ],
                                      "split_at_mut",
                                      []
                                    |),
                                    [ M.read (| tmp |); M.read (| start |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let nth_back := M.copy (| γ0_1 |) in
                                      let~ _ :=
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::iter::RChunksExactMut",
                                            "v"
                                          |),
                                          M.read (| tail |)
                                        |) in
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [ M.read (| nth_back |) ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back T));
            ("nth_back", InstanceField.Method (nth_back T))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.v.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "slice") [ T ] ],
                "is_empty",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::iter::RChunksExactMut",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_RChunksExactMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_core_slice_iter_RChunksExactMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_Iter_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Iter_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_Iter_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_slice_iter_IterMut_T.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ].
      
      (*     const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT (T : Ty.t) : Value.t :=
        let Self : Ty.t := Self T in
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant (value_MAY_HAVE_SIDE_EFFECT T)) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_slice_iter_IterMut_T.
    
    (* StructRecord
      {
        name := "GroupBy";
        ty_params := [ "T"; "P" ];
        fields :=
          [ ("slice", Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ]); ("predicate", P)
          ];
      } *)
    
    Module Impl_core_slice_iter_GroupBy_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GroupBy") [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a [T], predicate: P) -> Self {
              GroupBy { slice, predicate }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ slice; predicate ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let predicate := M.alloc (| predicate |) in
            Value.StructRecord
              "core::slice::iter::GroupBy"
              [ ("slice", M.read (| slice |)); ("predicate", M.read (| predicate |)) ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_GroupBy_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupBy_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GroupBy") [ T; P ].
      
      (*     type Item = &'a [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<Self::Item> {
              if self.slice.is_empty() {
                  None
              } else {
                  let mut len = 1;
                  let mut iter = self.slice.windows(2);
                  while let Some([l, r]) = iter.next() {
                      if (self.predicate)(l, r) { len += 1 } else { break }
                  }
                  let (head, tail) = self.slice.split_at(len);
                  self.slice = tail;
                  Some(head)
              }
          }
      *)
      Definition next (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GroupBy",
                                    "slice"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len := M.alloc (| Value.Integer 1 |) in
                      let~ iter :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "windows",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::GroupBy",
                                  "slice"
                                |)
                              |);
                              Value.Integer 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.loop (|
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply (Ty.path "core::slice::iter::Windows") [ T ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let γ0_0 := M.read (| γ0_0 |) in
                                    let γ2_0 := M.SubPointer.get_slice_index (| γ0_0, 0 |) in
                                    let γ2_1 := M.SubPointer.get_slice_index (| γ0_0, 1 |) in
                                    let l := M.alloc (| γ2_0 |) in
                                    let r := M.alloc (| γ2_1 |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      P,
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply (Ty.path "&") [ T ];
                                                            Ty.apply (Ty.path "&") [ T ]
                                                          ]
                                                      ],
                                                      "call_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::slice::iter::GroupBy",
                                                        "predicate"
                                                      |);
                                                      Value.Tuple [ M.read (| l |); M.read (| r |) ]
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            let β := len in
                                            M.write (|
                                              β,
                                              BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| β |))
                                                (Value.Integer 1)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::GroupBy",
                                  "slice"
                                |)
                              |);
                              M.read (| len |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GroupBy",
                                    "slice"
                                  |),
                                  M.read (| tail |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| head |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.slice.is_empty() { (0, Some(0)) } else { (1, Some(self.slice.len())) }
          }
      *)
      Definition size_hint (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GroupBy",
                                    "slice"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::GroupBy",
                                        "slice"
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::GroupBy") [ T; P ],
                [],
                "next_back",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P));
            ("last", InstanceField.Method (last T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupBy_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupBy_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GroupBy") [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<Self::Item> {
              if self.slice.is_empty() {
                  None
              } else {
                  let mut len = 1;
                  let mut iter = self.slice.windows(2);
                  while let Some([l, r]) = iter.next_back() {
                      if (self.predicate)(l, r) { len += 1 } else { break }
                  }
                  let (head, tail) = self.slice.split_at(self.slice.len() - len);
                  self.slice = head;
                  Some(tail)
              }
          }
      *)
      Definition next_back (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GroupBy",
                                    "slice"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len := M.alloc (| Value.Integer 1 |) in
                      let~ iter :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "windows",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::GroupBy",
                                  "slice"
                                |)
                              |);
                              Value.Integer 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.loop (|
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::double_ended::DoubleEndedIterator",
                                            Ty.apply (Ty.path "core::slice::iter::Windows") [ T ],
                                            [],
                                            "next_back",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let γ0_0 := M.read (| γ0_0 |) in
                                    let γ2_0 := M.SubPointer.get_slice_index (| γ0_0, 0 |) in
                                    let γ2_1 := M.SubPointer.get_slice_index (| γ0_0, 1 |) in
                                    let l := M.alloc (| γ2_0 |) in
                                    let r := M.alloc (| γ2_1 |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      P,
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply (Ty.path "&") [ T ];
                                                            Ty.apply (Ty.path "&") [ T ]
                                                          ]
                                                      ],
                                                      "call_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::slice::iter::GroupBy",
                                                        "predicate"
                                                      |);
                                                      Value.Tuple [ M.read (| l |); M.read (| r |) ]
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            let β := len in
                                            M.write (|
                                              β,
                                              BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| β |))
                                                (Value.Integer 1)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::GroupBy",
                                  "slice"
                                |)
                              |);
                              BinOp.Wrap.sub
                                Integer.Usize
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::GroupBy",
                                        "slice"
                                      |)
                                    |)
                                  ]
                                |))
                                (M.read (| len |))
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GroupBy",
                                    "slice"
                                  |),
                                  M.read (| head |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| tail |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupBy_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupBy_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GroupBy") [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupBy_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_GroupBy_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GroupBy") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("GroupBy").field("slice", &self.slice).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "GroupBy" |) ]
                      |)
                    |);
                    M.read (| Value.String "slice" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::GroupBy",
                        "slice"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_GroupBy_T_P.
    
    (* StructRecord
      {
        name := "GroupByMut";
        ty_params := [ "T"; "P" ];
        fields :=
          [
            ("slice", Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("predicate", P)
          ];
      } *)
    
    Module Impl_core_slice_iter_GroupByMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GroupByMut") [ T; P ].
      
      (*
          pub(super) fn new(slice: &'a mut [T], predicate: P) -> Self {
              GroupByMut { slice, predicate }
          }
      *)
      Definition new (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ slice; predicate ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let predicate := M.alloc (| predicate |) in
            Value.StructRecord
              "core::slice::iter::GroupByMut"
              [ ("slice", M.read (| slice |)); ("predicate", M.read (| predicate |)) ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T P : Ty.t),
        M.IsAssociatedFunction (Self T P) "new" (new T P).
    End Impl_core_slice_iter_GroupByMut_T_P.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupByMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GroupByMut") [ T; P ].
      
      (*     type Item = &'a mut [T]; *)
      Definition _Item (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ].
      
      (*
          fn next(&mut self) -> Option<Self::Item> {
              if self.slice.is_empty() {
                  None
              } else {
                  let mut len = 1;
                  let mut iter = self.slice.windows(2);
                  while let Some([l, r]) = iter.next() {
                      if (self.predicate)(l, r) { len += 1 } else { break }
                  }
                  let slice = mem::take(&mut self.slice);
                  let (head, tail) = slice.split_at_mut(len);
                  self.slice = tail;
                  Some(head)
              }
          }
      *)
      Definition next (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GroupByMut",
                                    "slice"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len := M.alloc (| Value.Integer 1 |) in
                      let~ iter :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "windows",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::GroupByMut",
                                  "slice"
                                |)
                              |);
                              Value.Integer 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.loop (|
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply (Ty.path "core::slice::iter::Windows") [ T ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let γ0_0 := M.read (| γ0_0 |) in
                                    let γ2_0 := M.SubPointer.get_slice_index (| γ0_0, 0 |) in
                                    let γ2_1 := M.SubPointer.get_slice_index (| γ0_0, 1 |) in
                                    let l := M.alloc (| γ2_0 |) in
                                    let r := M.alloc (| γ2_1 |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      P,
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply (Ty.path "&") [ T ];
                                                            Ty.apply (Ty.path "&") [ T ]
                                                          ]
                                                      ],
                                                      "call_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::slice::iter::GroupByMut",
                                                        "predicate"
                                                      |);
                                                      Value.Tuple [ M.read (| l |); M.read (| r |) ]
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            let β := len in
                                            M.write (|
                                              β,
                                              BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| β |))
                                                (Value.Integer 1)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      let~ slice :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::mem::take",
                              [ Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ] ]
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::GroupByMut",
                                "slice"
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at_mut",
                              []
                            |),
                            [ M.read (| slice |); M.read (| len |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GroupByMut",
                                    "slice"
                                  |),
                                  M.read (| tail |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| head |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.slice.is_empty() { (0, Some(0)) } else { (1, Some(self.slice.len())) }
          }
      *)
      Definition size_hint (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GroupByMut",
                                    "slice"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 1;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::slice::iter::GroupByMut",
                                        "slice"
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(mut self) -> Option<Self::Item> {
              self.next_back()
          }
      *)
      Definition last (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::GroupByMut") [ T; P ],
                [],
                "next_back",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T P));
            ("next", InstanceField.Method (next T P));
            ("size_hint", InstanceField.Method (size_hint T P));
            ("last", InstanceField.Method (last T P))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupByMut_T_P.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupByMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GroupByMut") [ T; P ].
      
      (*
          fn next_back(&mut self) -> Option<Self::Item> {
              if self.slice.is_empty() {
                  None
              } else {
                  let mut len = 1;
                  let mut iter = self.slice.windows(2);
                  while let Some([l, r]) = iter.next_back() {
                      if (self.predicate)(l, r) { len += 1 } else { break }
                  }
                  let slice = mem::take(&mut self.slice);
                  let (head, tail) = slice.split_at_mut(slice.len() - len);
                  self.slice = head;
                  Some(tail)
              }
          }
      *)
      Definition next_back (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "is_empty",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GroupByMut",
                                    "slice"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len := M.alloc (| Value.Integer 1 |) in
                      let~ iter :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "windows",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::iter::GroupByMut",
                                  "slice"
                                |)
                              |);
                              Value.Integer 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.loop (|
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::double_ended::DoubleEndedIterator",
                                            Ty.apply (Ty.path "core::slice::iter::Windows") [ T ],
                                            [],
                                            "next_back",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let γ0_0 := M.read (| γ0_0 |) in
                                    let γ2_0 := M.SubPointer.get_slice_index (| γ0_0, 0 |) in
                                    let γ2_1 := M.SubPointer.get_slice_index (| γ0_0, 1 |) in
                                    let l := M.alloc (| γ2_0 |) in
                                    let r := M.alloc (| γ2_1 |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      P,
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply (Ty.path "&") [ T ];
                                                            Ty.apply (Ty.path "&") [ T ]
                                                          ]
                                                      ],
                                                      "call_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::slice::iter::GroupByMut",
                                                        "predicate"
                                                      |);
                                                      Value.Tuple [ M.read (| l |); M.read (| r |) ]
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            let β := len in
                                            M.write (|
                                              β,
                                              BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| β |))
                                                (Value.Integer 1)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      let~ slice :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::mem::take",
                              [ Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ] ]
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::iter::GroupByMut",
                                "slice"
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at_mut",
                              []
                            |),
                            [
                              M.read (| slice |);
                              BinOp.Wrap.sub
                                Integer.Usize
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| slice |) ]
                                |))
                                (M.read (| len |))
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let head := M.copy (| γ0_0 |) in
                              let tail := M.copy (| γ0_1 |) in
                              let~ _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::iter::GroupByMut",
                                    "slice"
                                  |),
                                  M.read (| head |)
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| tail |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T P)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupByMut_T_P.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupByMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GroupByMut") [ T; P ].
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_ops_function_FnMut_P_Tuple_ref__T_ref__T__for_core_slice_iter_GroupByMut_T_P.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_GroupByMut_T_P.
      Definition Self (T P : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::GroupByMut") [ T; P ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("GroupByMut").field("slice", &self.slice).finish()
          }
      *)
      Definition fmt (T P : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T P in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "GroupByMut" |) ]
                      |)
                    |);
                    M.read (| Value.String "slice" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::slice::iter::GroupByMut",
                        "slice"
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T P : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T P)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T P)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_core_slice_iter_GroupByMut_T_P.
  End iter.
End slice.
