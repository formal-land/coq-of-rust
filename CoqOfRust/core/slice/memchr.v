(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module slice.
  Module memchr.
    Definition value_LO_USIZE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.path "usize",
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (| Ty.path "usize", "repeat_u8", [], [] |),
            [ Value.Integer IntegerKind.U8 1 ]
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_LO_USIZE :
      M.IsFunction.C "core::slice::memchr::LO_USIZE" value_LO_USIZE.
    Admitted.
    Global Typeclasses Opaque value_LO_USIZE.
    
    Definition value_HI_USIZE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.path "usize",
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (| Ty.path "usize", "repeat_u8", [], [] |),
            [ Value.Integer IntegerKind.U8 128 ]
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_HI_USIZE :
      M.IsFunction.C "core::slice::memchr::HI_USIZE" value_HI_USIZE.
    Admitted.
    Global Typeclasses Opaque value_HI_USIZE.
    
    Definition value_USIZE_BYTES (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.path "usize",
          M.call_closure (|
            Ty.path "usize",
            M.get_function (| "core::mem::size_of", [], [ Ty.path "usize" ] |),
            []
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_USIZE_BYTES :
      M.IsFunction.C "core::slice::memchr::USIZE_BYTES" value_USIZE_BYTES.
    Admitted.
    Global Typeclasses Opaque value_USIZE_BYTES.
    
    (*
    const fn contains_zero_byte(x: usize) -> bool {
        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0
    }
    *)
    Definition contains_zero_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| Ty.path "usize", x |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.ne,
            [
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.bit_and,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.bit_and,
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (| Ty.path "usize", "wrapping_sub", [], [] |),
                        [
                          M.read (| x |);
                          M.read (|
                            get_constant (| "core::slice::memchr::LO_USIZE", Ty.path "usize" |)
                          |)
                        ]
                      |);
                      M.call_closure (| Ty.path "usize", UnOp.not, [ M.read (| x |) ] |)
                    ]
                  |);
                  M.read (| get_constant (| "core::slice::memchr::HI_USIZE", Ty.path "usize" |) |)
                ]
              |);
              Value.Integer IntegerKind.Usize 0
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_contains_zero_byte :
      M.IsFunction.C "core::slice::memchr::contains_zero_byte" contains_zero_byte.
    Admitted.
    Global Typeclasses Opaque contains_zero_byte.
    
    (*
    pub const fn memchr(x: u8, text: &[u8]) -> Option<usize> {
        // Fast path for small slices.
        if text.len() < 2 * USIZE_BYTES {
            return memchr_naive(x, text);
        }
    
        memchr_aligned(x, text)
    }
    *)
    Definition memchr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x; text ] =>
        ltac:(M.monadic
          (let x := M.alloc (| Ty.path "u8", x |) in
          let text :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              text
            |) in
          M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| text |) |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.mul,
                                      [
                                        Value.Integer IntegerKind.Usize 2;
                                        M.read (|
                                          get_constant (|
                                            "core::slice::memchr::USIZE_BYTES",
                                            Ty.path "usize"
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_function (| "core::slice::memchr::memchr_naive", [], [] |),
                                  [
                                    M.read (| x |);
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |)
                                  ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                    M.get_function (| "core::slice::memchr::memchr_aligned", [], [] |),
                    [
                      M.read (| x |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |)
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_memchr :
      M.IsFunction.C "core::slice::memchr::memchr" memchr.
    Admitted.
    Global Typeclasses Opaque memchr.
    
    (*
    const fn memchr_naive(x: u8, text: &[u8]) -> Option<usize> {
        let mut i = 0;
    
        // FIXME(const-hack): Replace with `text.iter().pos(|c| *c == x)`.
        while i < text.len() {
            if text[i] == x {
                return Some(i);
            }
    
            i += 1;
        }
    
        None
    }
    *)
    Definition memchr_naive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x; text ] =>
        ltac:(M.monadic
          (let x := M.alloc (| Ty.path "u8", x |) in
          let text :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              text
            |) in
          M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ i : Ty.path "usize" := Value.Integer IntegerKind.Usize 0 in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.alloc (|
                          Ty.tuple [],
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.lt,
                                          [
                                            M.read (| i |);
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| text |) |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    Ty.path "bool",
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (|
                                                          M.SubPointer.get_array_field (|
                                                            M.deref (| M.read (| text |) |),
                                                            M.read (| i |)
                                                          |)
                                                        |);
                                                        M.read (| x |)
                                                      ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    Value.StructTuple
                                                      "core::option::Option::Some"
                                                      []
                                                      [ Ty.path "usize" ]
                                                      [ M.read (| i |) ]
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (Value.Tuple []))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      let β := i in
                                      M.write (|
                                        β,
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.add,
                                          [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                        |)
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.never_to_any (| M.read (| M.break (||) |) |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)
                                  |)))
                            ]
                          |)
                        |)))
                    |)
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                  Value.StructTuple "core::option::Option::None" [] [ Ty.path "usize" ] []
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_memchr_naive :
      M.IsFunction.C "core::slice::memchr::memchr_naive" memchr_naive.
    Admitted.
    Global Typeclasses Opaque memchr_naive.
    
    (*
    const fn memchr_aligned(x: u8, text: &[u8]) -> Option<usize> {
        // The runtime version behaves the same as the compiletime version, it's
        // just more optimized.
        const_eval_select!(
            @capture { x: u8, text: &[u8] } -> Option<usize>:
            if const {
                memchr_naive(x, text)
            } else {
                // Scan for a single byte value by reading two `usize` words at a time.
                //
                // Split `text` in three parts
                // - unaligned initial part, before the first word aligned address in text
                // - body, scan by 2 words at a time
                // - the last remaining part, < 2 word size
    
                // search up to an aligned boundary
                let len = text.len();
                let ptr = text.as_ptr();
                let mut offset = ptr.align_offset(USIZE_BYTES);
    
                if offset > 0 {
                    offset = offset.min(len);
                    let slice = &text[..offset];
                    if let Some(index) = memchr_naive(x, slice) {
                        return Some(index);
                    }
                }
    
                // search the body of the text
                let repeated_x = usize::repeat_u8(x);
                while offset <= len - 2 * USIZE_BYTES {
                    // SAFETY: the while's predicate guarantees a distance of at least 2 * usize_bytes
                    // between the offset and the end of the slice.
                    unsafe {
                        let u = *(ptr.add(offset) as *const usize);
                        let v = *(ptr.add(offset + USIZE_BYTES) as *const usize);
    
                        // break if there is a matching byte
                        let zu = contains_zero_byte(u ^ repeated_x);
                        let zv = contains_zero_byte(v ^ repeated_x);
                        if zu || zv {
                            break;
                        }
                    }
                    offset += USIZE_BYTES * 2;
                }
    
                // Find the byte after the point the body loop stopped.
                // FIXME(const-hack): Use `?` instead.
                // FIXME(const-hack, fee1-dead): use range slicing
                let slice =
                // SAFETY: offset is within bounds
                    unsafe { super::from_raw_parts(text.as_ptr().add(offset), text.len() - offset) };
                if let Some(i) = memchr_naive(x, slice) { Some(offset + i) } else { None }
            }
        )
    }
    *)
    Definition memchr_aligned (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x; text ] =>
        ltac:(M.monadic
          (let x := M.alloc (| Ty.path "u8", x |) in
          let text :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              text
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
            M.get_function (|
              "core::intrinsics::const_eval_select",
              [],
              [
                Ty.tuple
                  [
                    Ty.path "u8";
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ];
                Ty.function
                  [
                    Ty.path "u8";
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ]
                  (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]);
                Ty.function
                  [
                    Ty.path "u8";
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ]
                  (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]);
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
              ]
            |),
            [
              Value.Tuple [ M.read (| x |); M.read (| text |) ];
              M.get_function (| "core::slice::memchr::memchr_aligned.compiletime", [], [] |);
              M.get_function (| "core::slice::memchr::memchr_aligned.runtime", [], [] |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_memchr_aligned :
      M.IsFunction.C "core::slice::memchr::memchr_aligned" memchr_aligned.
    Admitted.
    Global Typeclasses Opaque memchr_aligned.
    
    (*
    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {
        // Scan for a single byte value by reading two `usize` words at a time.
        //
        // Split `text` in three parts:
        // - unaligned tail, after the last word aligned address in text,
        // - body, scanned by 2 words at a time,
        // - the first remaining bytes, < 2 word size.
        let len = text.len();
        let ptr = text.as_ptr();
        type Chunk = usize;
    
        let (min_aligned_offset, max_aligned_offset) = {
            // We call this just to obtain the length of the prefix and suffix.
            // In the middle we always process two chunks at once.
            // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size differences
            // which are handled by `align_to`.
            let (prefix, _, suffix) = unsafe { text.align_to::<(Chunk, Chunk)>() };
            (prefix.len(), len - suffix.len())
        };
    
        let mut offset = max_aligned_offset;
        if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {
            return Some(offset + index);
        }
    
        // Search the body of the text, make sure we don't cross min_aligned_offset.
        // offset is always aligned, so just testing `>` is sufficient and avoids possible
        // overflow.
        let repeated_x = usize::repeat_u8(x);
        let chunk_bytes = mem::size_of::<Chunk>();
    
        while offset > min_aligned_offset {
            // SAFETY: offset starts at len - suffix.len(), as long as it is greater than
            // min_aligned_offset (prefix.len()) the remaining distance is at least 2 * chunk_bytes.
            unsafe {
                let u = *(ptr.add(offset - 2 * chunk_bytes) as *const Chunk);
                let v = *(ptr.add(offset - chunk_bytes) as *const Chunk);
    
                // Break if there is a matching byte.
                let zu = contains_zero_byte(u ^ repeated_x);
                let zv = contains_zero_byte(v ^ repeated_x);
                if zu || zv {
                    break;
                }
            }
            offset -= 2 * chunk_bytes;
        }
    
        // Find the byte before the point the body loop stopped.
        text[..offset].iter().rposition(|elt| *elt == x)
    }
    *)
    Definition memrchr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x; text ] =>
        ltac:(M.monadic
          (let x := M.alloc (| Ty.path "u8", x |) in
          let text :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              text
            |) in
          M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ len : Ty.path "usize" :=
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |) ]
                  |) in
                let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                  M.call_closure (|
                    Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "as_ptr",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |) ]
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                  M.match_operator (|
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                    M.alloc (|
                      Ty.tuple [ Ty.path "usize"; Ty.path "usize" ],
                      M.match_operator (|
                        Ty.tuple [ Ty.path "usize"; Ty.path "usize" ],
                        M.alloc (|
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.tuple [ Ty.path "usize"; Ty.path "usize" ] ]
                                ];
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ],
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [ Ty.tuple [ Ty.path "usize"; Ty.path "usize" ] ]
                                  ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              "align_to",
                              [],
                              [ Ty.tuple [ Ty.path "usize"; Ty.path "usize" ] ]
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                              let prefix :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  γ0_0
                                |) in
                              let suffix :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  γ0_2
                                |) in
                              Value.Tuple
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| prefix |) |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.sub,
                                    [
                                      M.read (| len |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| suffix |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                ]))
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let min_aligned_offset := M.copy (| Ty.path "usize", γ0_0 |) in
                          let max_aligned_offset := M.copy (| Ty.path "usize", γ0_1 |) in
                          M.read (|
                            let~ offset : Ty.path "usize" := M.read (| max_aligned_offset |) in
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "usize" ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                []
                                                [ Ty.path "u8" ],
                                              [],
                                              [],
                                              "rposition",
                                              [],
                                              [
                                                Ty.function
                                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
                                                  (Ty.path "bool")
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.alloc (|
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [ Ty.path "u8" ],
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      []
                                                      [ Ty.path "u8" ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        []
                                                        [ Ty.path "u8" ],
                                                      "iter",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ],
                                                            M.get_trait_method (|
                                                              "core::ops::index::Index",
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              [],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::RangeFrom")
                                                                  []
                                                                  [ Ty.path "usize" ]
                                                              ],
                                                              "index",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| text |) |)
                                                              |);
                                                              Value.mkStructRecord
                                                                "core::ops::range::RangeFrom"
                                                                []
                                                                [ Ty.path "usize" ]
                                                                [ ("start", M.read (| offset |)) ]
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |);
                                              M.closure
                                                (fun γ =>
                                                  ltac:(M.monadic
                                                    match γ with
                                                    | [ α0 ] =>
                                                      ltac:(M.monadic
                                                        (M.match_operator (|
                                                          Ty.path "bool",
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [ Ty.path "u8" ],
                                                            α0
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let elt :=
                                                                  M.copy (|
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      []
                                                                      [ Ty.path "u8" ],
                                                                    γ
                                                                  |) in
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  BinOp.eq,
                                                                  [
                                                                    M.read (|
                                                                      M.deref (| M.read (| elt |) |)
                                                                    |);
                                                                    M.read (| x |)
                                                                  ]
                                                                |)))
                                                          ]
                                                        |)))
                                                    | _ => M.impossible "wrong number of arguments"
                                                    end))
                                            ]
                                          |)
                                        |) in
                                      let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let index := M.copy (| Ty.path "usize", γ0_0 |) in
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              []
                                              [ Ty.path "usize" ]
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  BinOp.Wrap.add,
                                                  [ M.read (| offset |); M.read (| index |) ]
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (Value.Tuple []))
                                ]
                              |) in
                            let~ repeated_x : Ty.path "usize" :=
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.path "usize",
                                  "repeat_u8",
                                  [],
                                  []
                                |),
                                [ M.read (| x |) ]
                              |) in
                            let~ chunk_bytes : Ty.path "usize" :=
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_function (| "core::mem::size_of", [], [ Ty.path "usize" ] |),
                                []
                              |) in
                            let~ _ : Ty.tuple [] :=
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      Ty.tuple [],
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    Ty.path "bool",
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.gt,
                                                      [
                                                        M.read (| offset |);
                                                        M.read (| min_aligned_offset |)
                                                      ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.read (|
                                                    let~ u : Ty.path "usize" :=
                                                      M.read (|
                                                        M.deref (|
                                                          M.cast
                                                            (Ty.apply
                                                              (Ty.path "*const")
                                                              []
                                                              [ Ty.path "usize" ])
                                                            (M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "*const")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "*const")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                "add",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.read (| ptr |);
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  BinOp.Wrap.sub,
                                                                  [
                                                                    M.read (| offset |);
                                                                    M.call_closure (|
                                                                      Ty.path "usize",
                                                                      BinOp.Wrap.mul,
                                                                      [
                                                                        Value.Integer
                                                                          IntegerKind.Usize
                                                                          2;
                                                                        M.read (| chunk_bytes |)
                                                                      ]
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |))
                                                        |)
                                                      |) in
                                                    let~ v : Ty.path "usize" :=
                                                      M.read (|
                                                        M.deref (|
                                                          M.cast
                                                            (Ty.apply
                                                              (Ty.path "*const")
                                                              []
                                                              [ Ty.path "usize" ])
                                                            (M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "*const")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "*const")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                "add",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.read (| ptr |);
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  BinOp.Wrap.sub,
                                                                  [
                                                                    M.read (| offset |);
                                                                    M.read (| chunk_bytes |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |))
                                                        |)
                                                      |) in
                                                    let~ zu : Ty.path "bool" :=
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        M.get_function (|
                                                          "core::slice::memchr::contains_zero_byte",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            BinOp.Wrap.bit_xor,
                                                            [
                                                              M.read (| u |);
                                                              M.read (| repeated_x |)
                                                            ]
                                                          |)
                                                        ]
                                                      |) in
                                                    let~ zv : Ty.path "bool" :=
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        M.get_function (|
                                                          "core::slice::memchr::contains_zero_byte",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            BinOp.Wrap.bit_xor,
                                                            [
                                                              M.read (| v |);
                                                              M.read (| repeated_x |)
                                                            ]
                                                          |)
                                                        ]
                                                      |) in
                                                    M.alloc (|
                                                      Ty.tuple [],
                                                      M.match_operator (|
                                                        Ty.tuple [],
                                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ :=
                                                                M.use
                                                                  (M.alloc (|
                                                                    Ty.path "bool",
                                                                    LogicalOp.or (|
                                                                      M.read (| zu |),
                                                                      ltac:(M.monadic
                                                                        (M.read (| zv |)))
                                                                    |)
                                                                  |)) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ |),
                                                                  Value.Bool true
                                                                |) in
                                                              M.never_to_any (|
                                                                M.read (| M.break (||) |)
                                                              |)));
                                                          fun γ => ltac:(M.monadic (Value.Tuple []))
                                                        ]
                                                      |)
                                                    |)
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  let β := offset in
                                                  M.write (|
                                                    β,
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.sub,
                                                      [
                                                        M.read (| β |);
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          BinOp.Wrap.mul,
                                                          [
                                                            Value.Integer IntegerKind.Usize 2;
                                                            M.read (| chunk_bytes |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.never_to_any (|
                                                M.read (|
                                                  let~ _ : Ty.tuple [] :=
                                                    M.never_to_any (|
                                                      M.read (| M.break (||) |)
                                                    |) in
                                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                                |)
                                              |)))
                                        ]
                                      |)
                                    |)))
                                |)
                              |) in
                            M.alloc (|
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
                                  [],
                                  [],
                                  "rposition",
                                  [],
                                  [
                                    Ty.function
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
                                      (Ty.path "bool")
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        []
                                        [ Ty.path "u8" ],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          []
                                          [ Ty.path "u8" ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                          "iter",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ],
                                                M.get_trait_method (|
                                                  "core::ops::index::Index",
                                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                                  [],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::ops::range::RangeTo")
                                                      []
                                                      [ Ty.path "usize" ]
                                                  ],
                                                  "index",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| text |) |)
                                                  |);
                                                  Value.mkStructRecord
                                                    "core::ops::range::RangeTo"
                                                    []
                                                    [ Ty.path "usize" ]
                                                    [ ("end_", M.read (| offset |)) ]
                                                ]
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Ty.path "bool",
                                              M.alloc (|
                                                Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                                α0
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let elt :=
                                                      M.copy (|
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                                        γ
                                                      |) in
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (| M.deref (| M.read (| elt |) |) |);
                                                        M.read (| x |)
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end))
                                ]
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_memrchr :
      M.IsFunction.C "core::slice::memchr::memrchr" memrchr.
    Admitted.
    Global Typeclasses Opaque memrchr.
    
    Module memrchr.
      Axiom Chunk : (Ty.path "core::slice::memchr::memrchr::Chunk") = (Ty.path "usize").
    End memrchr.
  End memchr.
End slice.
