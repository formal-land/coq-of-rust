(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module slice.
  Module memchr.
    Definition value_LO_USIZE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (| Ty.path "usize", "repeat_u8", [], [] |),
            [ Value.Integer IntegerKind.U8 1 ]
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_LO_USIZE :
      M.IsFunction.C "core::slice::memchr::LO_USIZE" value_LO_USIZE.
    Admitted.
    Global Typeclasses Opaque value_LO_USIZE.
    
    Definition value_HI_USIZE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (| Ty.path "usize", "repeat_u8", [], [] |),
            [ Value.Integer IntegerKind.U8 128 ]
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_HI_USIZE :
      M.IsFunction.C "core::slice::memchr::HI_USIZE" value_HI_USIZE.
    Admitted.
    Global Typeclasses Opaque value_HI_USIZE.
    
    Definition value_USIZE_BYTES (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "usize",
            M.get_function (| "core::mem::size_of", [], [ Ty.path "usize" ] |),
            []
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_USIZE_BYTES :
      M.IsFunction.C "core::slice::memchr::USIZE_BYTES" value_USIZE_BYTES.
    Admitted.
    Global Typeclasses Opaque value_USIZE_BYTES.
    
    (*
    const fn contains_zero_byte(x: usize) -> bool {
        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0
    }
    *)
    Definition contains_zero_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          BinOp.ne (|
            BinOp.bit_and
              (BinOp.bit_and
                (M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "wrapping_sub", [], [] |),
                  [
                    M.read (| x |);
                    M.read (| get_constant (| "core::slice::memchr::LO_USIZE", Ty.path "usize" |) |)
                  ]
                |))
                (UnOp.not (| M.read (| x |) |)))
              (M.read (| get_constant (| "core::slice::memchr::HI_USIZE", Ty.path "usize" |) |)),
            Value.Integer IntegerKind.Usize 0
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_contains_zero_byte :
      M.IsFunction.C "core::slice::memchr::contains_zero_byte" contains_zero_byte.
    Admitted.
    Global Typeclasses Opaque contains_zero_byte.
    
    (*
    pub const fn memchr(x: u8, text: &[u8]) -> Option<usize> {
        // Fast path for small slices.
        if text.len() < 2 * USIZE_BYTES {
            return memchr_naive(x, text);
        }
    
        memchr_aligned(x, text)
    }
    *)
    Definition memchr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x; text ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let text := M.alloc (| text |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.lt (|
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| text |) |)
                                      |)
                                    ]
                                  |),
                                  BinOp.Wrap.mul (|
                                    Value.Integer IntegerKind.Usize 2,
                                    M.read (|
                                      get_constant (|
                                        "core::slice::memchr::USIZE_BYTES",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  |)
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_function (|
                                      "core::slice::memchr::memchr_naive",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (| x |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| text |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                    M.get_function (| "core::slice::memchr::memchr_aligned", [], [] |),
                    [
                      M.read (| x |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |)
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_memchr :
      M.IsFunction.C "core::slice::memchr::memchr" memchr.
    Admitted.
    Global Typeclasses Opaque memchr.
    
    (*
    const fn memchr_naive(x: u8, text: &[u8]) -> Option<usize> {
        let mut i = 0;
    
        // FIXME(const-hack): Replace with `text.iter().pos(|c| *c == x)`.
        while i < text.len() {
            if text[i] == x {
                return Some(i);
            }
    
            i += 1;
        }
    
        None
    }
    *)
    Definition memchr_naive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x; text ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let text := M.alloc (| text |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ i : Ty.path "usize" := M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
                let~ _ : Ty.tuple [] :=
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.lt (|
                                      M.read (| i |),
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| text |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Some (Ty.tuple []),
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.eq (|
                                                M.read (|
                                                  M.SubPointer.get_array_field (|
                                                    M.deref (| M.read (| text |) |),
                                                    M.read (| i |)
                                                  |)
                                                |),
                                                M.read (| x |)
                                              |)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [ M.read (| i |) ]
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  let β := i in
                                  M.write (|
                                    β,
                                    BinOp.Wrap.add (|
                                      M.read (| β |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_memchr_naive :
      M.IsFunction.C "core::slice::memchr::memchr_naive" memchr_naive.
    Admitted.
    Global Typeclasses Opaque memchr_naive.
    
    (*
    const fn memchr_aligned(x: u8, text: &[u8]) -> Option<usize> {
        // The runtime version behaves the same as the compiletime version, it's
        // just more optimized.
        const_eval_select!(
            @capture { x: u8, text: &[u8] } -> Option<usize>:
            if const {
                memchr_naive(x, text)
            } else {
                // Scan for a single byte value by reading two `usize` words at a time.
                //
                // Split `text` in three parts
                // - unaligned initial part, before the first word aligned address in text
                // - body, scan by 2 words at a time
                // - the last remaining part, < 2 word size
    
                // search up to an aligned boundary
                let len = text.len();
                let ptr = text.as_ptr();
                let mut offset = ptr.align_offset(USIZE_BYTES);
    
                if offset > 0 {
                    offset = offset.min(len);
                    let slice = &text[..offset];
                    if let Some(index) = memchr_naive(x, slice) {
                        return Some(index);
                    }
                }
    
                // search the body of the text
                let repeated_x = usize::repeat_u8(x);
                while offset <= len - 2 * USIZE_BYTES {
                    // SAFETY: the while's predicate guarantees a distance of at least 2 * usize_bytes
                    // between the offset and the end of the slice.
                    unsafe {
                        let u = *(ptr.add(offset) as *const usize);
                        let v = *(ptr.add(offset + USIZE_BYTES) as *const usize);
    
                        // break if there is a matching byte
                        let zu = contains_zero_byte(u ^ repeated_x);
                        let zv = contains_zero_byte(v ^ repeated_x);
                        if zu || zv {
                            break;
                        }
                    }
                    offset += USIZE_BYTES * 2;
                }
    
                // Find the byte after the point the body loop stopped.
                // FIXME(const-hack): Use `?` instead.
                // FIXME(const-hack, fee1-dead): use range slicing
                let slice =
                // SAFETY: offset is within bounds
                    unsafe { super::from_raw_parts(text.as_ptr().add(offset), text.len() - offset) };
                if let Some(i) = memchr_naive(x, slice) { Some(offset + i) } else { None }
            }
        )
    }
    *)
    Definition memchr_aligned (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x; text ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let text := M.alloc (| text |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
            M.get_function (|
              "core::intrinsics::const_eval_select",
              [],
              [
                Ty.tuple
                  [
                    Ty.path "u8";
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ];
                Ty.function
                  [
                    Ty.path "u8";
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ]
                  (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]);
                Ty.function
                  [
                    Ty.path "u8";
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ]
                  (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]);
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
              ]
            |),
            [
              Value.Tuple [ M.read (| x |); M.read (| text |) ];
              M.get_function (| "core::slice::memchr::memchr_aligned.compiletime", [], [] |);
              M.get_function (| "core::slice::memchr::memchr_aligned.runtime", [], [] |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_memchr_aligned :
      M.IsFunction.C "core::slice::memchr::memchr_aligned" memchr_aligned.
    Admitted.
    Global Typeclasses Opaque memchr_aligned.
    
    (*
    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {
        // Scan for a single byte value by reading two `usize` words at a time.
        //
        // Split `text` in three parts:
        // - unaligned tail, after the last word aligned address in text,
        // - body, scanned by 2 words at a time,
        // - the first remaining bytes, < 2 word size.
        let len = text.len();
        let ptr = text.as_ptr();
        type Chunk = usize;
    
        let (min_aligned_offset, max_aligned_offset) = {
            // We call this just to obtain the length of the prefix and suffix.
            // In the middle we always process two chunks at once.
            // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size differences
            // which are handled by `align_to`.
            let (prefix, _, suffix) = unsafe { text.align_to::<(Chunk, Chunk)>() };
            (prefix.len(), len - suffix.len())
        };
    
        let mut offset = max_aligned_offset;
        if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {
            return Some(offset + index);
        }
    
        // Search the body of the text, make sure we don't cross min_aligned_offset.
        // offset is always aligned, so just testing `>` is sufficient and avoids possible
        // overflow.
        let repeated_x = usize::repeat_u8(x);
        let chunk_bytes = mem::size_of::<Chunk>();
    
        while offset > min_aligned_offset {
            // SAFETY: offset starts at len - suffix.len(), as long as it is greater than
            // min_aligned_offset (prefix.len()) the remaining distance is at least 2 * chunk_bytes.
            unsafe {
                let u = *(ptr.add(offset - 2 * chunk_bytes) as *const Chunk);
                let v = *(ptr.add(offset - chunk_bytes) as *const Chunk);
    
                // Break if there is a matching byte.
                let zu = contains_zero_byte(u ^ repeated_x);
                let zv = contains_zero_byte(v ^ repeated_x);
                if zu || zv {
                    break;
                }
            }
            offset -= 2 * chunk_bytes;
        }
    
        // Find the byte before the point the body loop stopped.
        text[..offset].iter().rposition(|elt| *elt == x)
    }
    *)
    Definition memrchr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x; text ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let text := M.alloc (| text |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ len : Ty.path "usize" :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |) ]
                    |)
                  |) in
                let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |) ]
                    |)
                  |) in
                M.match_operator (|
                  None,
                  M.match_operator (|
                    None,
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [ Ty.tuple [ Ty.path "usize"; Ty.path "usize" ] ]
                              ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "align_to",
                          [],
                          [ Ty.tuple [ Ty.path "usize"; Ty.path "usize" ] ]
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                          let prefix := M.copy (| γ0_0 |) in
                          let suffix := M.copy (| γ0_2 |) in
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| prefix |) |)
                                    |)
                                  ]
                                |);
                                BinOp.Wrap.sub (|
                                  M.read (| len |),
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| suffix |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              ]
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let min_aligned_offset := M.copy (| γ0_0 |) in
                        let max_aligned_offset := M.copy (| γ0_1 |) in
                        let~ offset : Ty.path "usize" := M.copy (| max_aligned_offset |) in
                        let~ _ : Ty.tuple [] :=
                          M.match_operator (|
                            Some (Ty.tuple []),
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            []
                                            [ Ty.path "u8" ],
                                          [],
                                          [],
                                          "rposition",
                                          [],
                                          [
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
                                              ]
                                              (Ty.path "bool")
                                          ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  []
                                                  [ Ty.path "u8" ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                                  "iter",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [ Ty.path "u8" ]
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::ops::index::Index",
                                                          Ty.apply
                                                            (Ty.path "slice")
                                                            []
                                                            [ Ty.path "u8" ],
                                                          [],
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ops::range::RangeFrom")
                                                              []
                                                              [ Ty.path "usize" ]
                                                          ],
                                                          "index",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| text |) |)
                                                          |);
                                                          Value.StructRecord
                                                            "core::ops::range::RangeFrom"
                                                            [ ("start", M.read (| offset |)) ]
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |);
                                          M.closure
                                            (fun γ =>
                                              ltac:(M.monadic
                                                match γ with
                                                | [ α0 ] =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Some
                                                        (Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ]
                                                          ]
                                                          (Ty.path "bool")),
                                                      M.alloc (| α0 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let elt := M.copy (| γ |) in
                                                            BinOp.eq (|
                                                              M.read (|
                                                                M.deref (| M.read (| elt |) |)
                                                              |),
                                                              M.read (| x |)
                                                            |)))
                                                      ]
                                                    |)))
                                                | _ => M.impossible "wrong number of arguments"
                                                end))
                                        ]
                                      |)
                                    |) in
                                  let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let index := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "core::option::Option::Some"
                                            [
                                              BinOp.Wrap.add (|
                                                M.read (| offset |),
                                                M.read (| index |)
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        let~ repeated_x : Ty.path "usize" :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (| Ty.path "usize", "repeat_u8", [], [] |),
                              [ M.read (| x |) ]
                            |)
                          |) in
                        let~ chunk_bytes : Ty.path "usize" :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_function (| "core::mem::size_of", [], [ Ty.path "usize" ] |),
                              []
                            |)
                          |) in
                        let~ _ : Ty.tuple [] :=
                          M.loop (|
                            Ty.tuple [],
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            BinOp.gt (|
                                              M.read (| offset |),
                                              M.read (| min_aligned_offset |)
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ : Ty.tuple [] :=
                                        let~ u : Ty.path "usize" :=
                                          M.copy (|
                                            M.deref (|
                                              M.cast
                                                (Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ])
                                                (M.call_closure (|
                                                  Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                                    "add",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (| ptr |);
                                                    BinOp.Wrap.sub (|
                                                      M.read (| offset |),
                                                      BinOp.Wrap.mul (|
                                                        Value.Integer IntegerKind.Usize 2,
                                                        M.read (| chunk_bytes |)
                                                      |)
                                                    |)
                                                  ]
                                                |))
                                            |)
                                          |) in
                                        let~ v : Ty.path "usize" :=
                                          M.copy (|
                                            M.deref (|
                                              M.cast
                                                (Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ])
                                                (M.call_closure (|
                                                  Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                                    "add",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (| ptr |);
                                                    BinOp.Wrap.sub (|
                                                      M.read (| offset |),
                                                      M.read (| chunk_bytes |)
                                                    |)
                                                  ]
                                                |))
                                            |)
                                          |) in
                                        let~ zu : Ty.path "bool" :=
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              M.get_function (|
                                                "core::slice::memchr::contains_zero_byte",
                                                [],
                                                []
                                              |),
                                              [
                                                BinOp.bit_xor
                                                  (M.read (| u |))
                                                  (M.read (| repeated_x |))
                                              ]
                                            |)
                                          |) in
                                        let~ zv : Ty.path "bool" :=
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              M.get_function (|
                                                "core::slice::memchr::contains_zero_byte",
                                                [],
                                                []
                                              |),
                                              [
                                                BinOp.bit_xor
                                                  (M.read (| v |))
                                                  (M.read (| repeated_x |))
                                              ]
                                            |)
                                          |) in
                                        M.match_operator (|
                                          Some (Ty.tuple []),
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      LogicalOp.or (|
                                                        M.read (| zu |),
                                                        ltac:(M.monadic (M.read (| zv |)))
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          let β := offset in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.sub (|
                                              M.read (| β |),
                                              BinOp.Wrap.mul (|
                                                Value.Integer IntegerKind.Usize 2,
                                                M.read (| chunk_bytes |)
                                              |)
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let~ _ : Ty.tuple [] :=
                                              M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |)))
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
                              [],
                              [],
                              "rposition",
                              [],
                              [
                                Ty.function
                                  [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ] ]
                                  (Ty.path "bool")
                              ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u8" ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "iter",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ops::range::RangeTo")
                                                  []
                                                  [ Ty.path "usize" ]
                                              ],
                                              "index",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| text |) |)
                                              |);
                                              Value.StructRecord
                                                "core::ops::range::RangeTo"
                                                [ ("end_", M.read (| offset |)) ]
                                            ]
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      ltac:(M.monadic
                                        (M.match_operator (|
                                          Some
                                            (Ty.function
                                              [
                                                Ty.tuple
                                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
                                              ]
                                              (Ty.path "bool")),
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let elt := M.copy (| γ |) in
                                                BinOp.eq (|
                                                  M.read (| M.deref (| M.read (| elt |) |) |),
                                                  M.read (| x |)
                                                |)))
                                          ]
                                        |)))
                                    | _ => M.impossible "wrong number of arguments"
                                    end))
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_memrchr :
      M.IsFunction.C "core::slice::memchr::memrchr" memrchr.
    Admitted.
    Global Typeclasses Opaque memrchr.
    
    Module memrchr.
      Axiom Chunk : (Ty.path "core::slice::memchr::memrchr::Chunk") = (Ty.path "usize").
    End memrchr.
  End memchr.
End slice.
