(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module slice.
  Module sort.
    (* StructRecord
      {
        name := "InsertionHole";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("src", Ty.apply (Ty.path "*const") [] [ T ]);
            ("dest", Ty.apply (Ty.path "*mut") [] [ T ])
          ];
      } *)
    
    Module Impl_core_ops_drop_Drop_for_core_slice_sort_InsertionHole_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::sort::InsertionHole") [] [ T ].
      
      (*
          fn drop(&mut self) {
              // SAFETY: This is a helper class. Please refer to its usage for correctness. Namely, one
              // must be sure that `src` and `dst` does not overlap as required by
              // `ptr::copy_nonoverlapping` and are both valid for writes.
              unsafe {
                  ptr::copy_nonoverlapping(self.src, self.dest, 1);
              }
          }
      *)
      Definition drop (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::sort::InsertionHole",
                          "src"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::sort::InsertionHole",
                          "dest"
                        |)
                      |);
                      Value.Integer 1
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::drop::Drop"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("drop", InstanceField.Method (drop T)) ].
    End Impl_core_ops_drop_Drop_for_core_slice_sort_InsertionHole_T.
    
    (*
    unsafe fn insert_tail<T, F>(v: &mut [T], is_less: &mut F)
    where
        F: FnMut(&T, &T) -> bool,
    {
        debug_assert!(v.len() >= 2);
    
        let arr_ptr = v.as_mut_ptr();
        let i = v.len() - 1;
    
        // SAFETY: caller must ensure v is at least len 2.
        unsafe {
            // See insert_head which talks about why this approach is beneficial.
            let i_ptr = arr_ptr.add(i);
    
            // It's important that we use i_ptr here. If this check is positive and we continue,
            // We want to make sure that no other copy of the value was seen by is_less.
            // Otherwise we would have to copy it back.
            if is_less(&*i_ptr, &*i_ptr.sub(1)) {
                // It's important, that we use tmp for comparison from now on. As it is the value that
                // will be copied back. And notionally we could have created a divergence if we copy
                // back the wrong value.
                let tmp = mem::ManuallyDrop::new(ptr::read(i_ptr));
                // Intermediate state of the insertion process is always tracked by `hole`, which
                // serves two purposes:
                // 1. Protects integrity of `v` from panics in `is_less`.
                // 2. Fills the remaining hole in `v` in the end.
                //
                // Panic safety:
                //
                // If `is_less` panics at any point during the process, `hole` will get dropped and
                // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it
                // initially held exactly once.
                let mut hole = InsertionHole { src: &*tmp, dest: i_ptr.sub(1) };
                ptr::copy_nonoverlapping(hole.dest, i_ptr, 1);
    
                // SAFETY: We know i is at least 1.
                for j in (0..(i - 1)).rev() {
                    let j_ptr = arr_ptr.add(j);
                    if !is_less(&*tmp, &*j_ptr) {
                        break;
                    }
    
                    ptr::copy_nonoverlapping(j_ptr, hole.dest, 1);
                    hole.dest = j_ptr;
                }
                // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.
            }
        }
    }
    *)
    Definition insert_tail (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let is_less := M.alloc (| is_less |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (BinOp.Pure.ge
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [] [ T ],
                                              "len",
                                              []
                                            |),
                                            [ M.read (| v |) ]
                                          |))
                                          (Value.Integer 2))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [] |),
                                      [ M.read (| Value.String "assertion failed: v.len() >= 2" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ arr_ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ T ],
                    "as_mut_ptr",
                    []
                  |),
                  [ M.read (| v |) ]
                |)
              |) in
            let~ i :=
              M.alloc (|
                BinOp.Wrap.sub
                  Integer.Usize
                  (M.call_closure (|
                    M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "len", [] |),
                    [ M.read (| v |) ]
                  |))
                  (Value.Integer 1)
              |) in
            let~ i_ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "add", [] |),
                  [ M.read (| arr_ptr |); M.read (| i |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::function::FnMut",
                              F,
                              [
                                Ty.tuple
                                  [ Ty.apply (Ty.path "&") [] [ T ]; Ty.apply (Ty.path "&") [] [ T ]
                                  ]
                              ],
                              "call_mut",
                              []
                            |),
                            [
                              M.read (| is_less |);
                              Value.Tuple
                                [
                                  M.read (| i_ptr |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [] [ T ],
                                      "sub",
                                      []
                                    |),
                                    [ M.read (| i_ptr |); Value.Integer 1 ]
                                  |)
                                ]
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ tmp :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ T ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_function (| "core::ptr::read", [ T ] |),
                              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| i_ptr |)) ]
                            |)
                          ]
                        |)
                      |) in
                    let~ hole :=
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::sort::InsertionHole"
                          [
                            ("src",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ T ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ tmp ]
                              |));
                            ("dest",
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                  "sub",
                                  []
                                |),
                                [ M.read (| i_ptr |); Value.Integer 1 ]
                              |))
                          ]
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                          [
                            (* MutToConstPointer *)
                            M.pointer_coercion
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  hole,
                                  "core::slice::sort::InsertionHole",
                                  "dest"
                                |)
                              |));
                            M.read (| i_ptr |);
                            Value.Integer 1
                          ]
                        |)
                      |) in
                    M.use
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::rev::Rev")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ]
                                ],
                              [],
                              "into_iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  [],
                                  "rev",
                                  []
                                |),
                                [
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [
                                      ("start", Value.Integer 0);
                                      ("end_",
                                        BinOp.Wrap.sub
                                          Integer.Usize
                                          (M.read (| i |))
                                          (Value.Integer 1))
                                    ]
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                ltac:(M.monadic
                                  (let~ _ :=
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::rev::Rev")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ops::range::Range")
                                                  []
                                                  [ Ty.path "usize" ]
                                              ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let j := M.copy (| γ0_0 |) in
                                            let~ j_ptr :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "*mut") [] [ T ],
                                                    "add",
                                                    []
                                                  |),
                                                  [ M.read (| arr_ptr |); M.read (| j |) ]
                                                |)
                                              |) in
                                            let~ _ :=
                                              M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            UnOp.Pure.not
                                                              (M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::function::FnMut",
                                                                  F,
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ T ];
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ T ]
                                                                      ]
                                                                  ],
                                                                  "call_mut",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| is_less |);
                                                                  Value.Tuple
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::ops::deref::Deref",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::mem::manually_drop::ManuallyDrop")
                                                                            []
                                                                            [ T ],
                                                                          [],
                                                                          "deref",
                                                                          []
                                                                        |),
                                                                        [ tmp ]
                                                                      |);
                                                                      M.read (| j_ptr |)
                                                                    ]
                                                                ]
                                                              |))
                                                          |)) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (| M.break (||) |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |) in
                                            let~ _ :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_function (|
                                                    "core::intrinsics::copy_nonoverlapping",
                                                    [ T ]
                                                  |),
                                                  [
                                                    (* MutToConstPointer *)
                                                    M.pointer_coercion (M.read (| j_ptr |));
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        hole,
                                                        "core::slice::sort::InsertionHole",
                                                        "dest"
                                                      |)
                                                    |);
                                                    Value.Integer 1
                                                  ]
                                                |)
                                              |) in
                                            let~ _ :=
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  hole,
                                                  "core::slice::sort::InsertionHole",
                                                  "dest"
                                                |),
                                                M.read (| j_ptr |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |))));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_insert_tail : M.IsFunction "core::slice::sort::insert_tail" insert_tail.
    
    (*
    unsafe fn insert_head<T, F>(v: &mut [T], is_less: &mut F)
    where
        F: FnMut(&T, &T) -> bool,
    {
        debug_assert!(v.len() >= 2);
    
        // SAFETY: caller must ensure v is at least len 2.
        unsafe {
            if is_less(v.get_unchecked(1), v.get_unchecked(0)) {
                let arr_ptr = v.as_mut_ptr();
    
                // There are three ways to implement insertion here:
                //
                // 1. Swap adjacent elements until the first one gets to its final destination.
                //    However, this way we copy data around more than is necessary. If elements are big
                //    structures (costly to copy), this method will be slow.
                //
                // 2. Iterate until the right place for the first element is found. Then shift the
                //    elements succeeding it to make room for it and finally place it into the
                //    remaining hole. This is a good method.
                //
                // 3. Copy the first element into a temporary variable. Iterate until the right place
                //    for it is found. As we go along, copy every traversed element into the slot
                //    preceding it. Finally, copy data from the temporary variable into the remaining
                //    hole. This method is very good. Benchmarks demonstrated slightly better
                //    performance than with the 2nd method.
                //
                // All methods were benchmarked, and the 3rd showed best results. So we chose that one.
                let tmp = mem::ManuallyDrop::new(ptr::read(arr_ptr));
    
                // Intermediate state of the insertion process is always tracked by `hole`, which
                // serves two purposes:
                // 1. Protects integrity of `v` from panics in `is_less`.
                // 2. Fills the remaining hole in `v` in the end.
                //
                // Panic safety:
                //
                // If `is_less` panics at any point during the process, `hole` will get dropped and
                // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it
                // initially held exactly once.
                let mut hole = InsertionHole { src: &*tmp, dest: arr_ptr.add(1) };
                ptr::copy_nonoverlapping(arr_ptr.add(1), arr_ptr.add(0), 1);
    
                for i in 2..v.len() {
                    if !is_less(&v.get_unchecked(i), &*tmp) {
                        break;
                    }
                    ptr::copy_nonoverlapping(arr_ptr.add(i), arr_ptr.add(i - 1), 1);
                    hole.dest = arr_ptr.add(i);
                }
                // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.
            }
        }
    }
    *)
    Definition insert_head (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let is_less := M.alloc (| is_less |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (BinOp.Pure.ge
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [] [ T ],
                                              "len",
                                              []
                                            |),
                                            [ M.read (| v |) ]
                                          |))
                                          (Value.Integer 2))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [] |),
                                      [ M.read (| Value.String "assertion failed: v.len() >= 2" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::function::FnMut",
                              F,
                              [
                                Ty.tuple
                                  [ Ty.apply (Ty.path "&") [] [ T ]; Ty.apply (Ty.path "&") [] [ T ]
                                  ]
                              ],
                              "call_mut",
                              []
                            |),
                            [
                              M.read (| is_less |);
                              Value.Tuple
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "get_unchecked",
                                      [ Ty.path "usize" ]
                                    |),
                                    [ M.read (| v |); Value.Integer 1 ]
                                  |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "get_unchecked",
                                      [ Ty.path "usize" ]
                                    |),
                                    [ M.read (| v |); Value.Integer 0 ]
                                  |)
                                ]
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ arr_ptr :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "as_mut_ptr",
                            []
                          |),
                          [ M.read (| v |) ]
                        |)
                      |) in
                    let~ tmp :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ T ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_function (| "core::ptr::read", [ T ] |),
                              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| arr_ptr |)) ]
                            |)
                          ]
                        |)
                      |) in
                    let~ hole :=
                      M.alloc (|
                        Value.StructRecord
                          "core::slice::sort::InsertionHole"
                          [
                            ("src",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ T ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ tmp ]
                              |));
                            ("dest",
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                  "add",
                                  []
                                |),
                                [ M.read (| arr_ptr |); Value.Integer 1 ]
                              |))
                          ]
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                          [
                            (* MutToConstPointer *)
                            M.pointer_coercion
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                  "add",
                                  []
                                |),
                                [ M.read (| arr_ptr |); Value.Integer 1 ]
                              |));
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "add",
                                []
                              |),
                              [ M.read (| arr_ptr |); Value.Integer 0 ]
                            |);
                            Value.Integer 1
                          ]
                        |)
                      |) in
                    M.use
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              [],
                              "into_iter",
                              []
                            |),
                            [
                              Value.StructRecord
                                "core::ops::range::Range"
                                [
                                  ("start", Value.Integer 2);
                                  ("end_",
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "len",
                                        []
                                      |),
                                      [ M.read (| v |) ]
                                    |))
                                ]
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                ltac:(M.monadic
                                  (let~ _ :=
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let i := M.copy (| γ0_0 |) in
                                            let~ _ :=
                                              M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            UnOp.Pure.not
                                                              (M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::function::FnMut",
                                                                  F,
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ T ];
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ T ]
                                                                      ]
                                                                  ],
                                                                  "call_mut",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| is_less |);
                                                                  Value.Tuple
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [ T ],
                                                                          "get_unchecked",
                                                                          [ Ty.path "usize" ]
                                                                        |),
                                                                        [
                                                                          M.read (| v |);
                                                                          M.read (| i |)
                                                                        ]
                                                                      |);
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::ops::deref::Deref",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::mem::manually_drop::ManuallyDrop")
                                                                            []
                                                                            [ T ],
                                                                          [],
                                                                          "deref",
                                                                          []
                                                                        |),
                                                                        [ tmp ]
                                                                      |)
                                                                    ]
                                                                ]
                                                              |))
                                                          |)) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (| M.break (||) |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |) in
                                            let~ _ :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_function (|
                                                    "core::intrinsics::copy_nonoverlapping",
                                                    [ T ]
                                                  |),
                                                  [
                                                    (* MutToConstPointer *)
                                                    M.pointer_coercion
                                                      (M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                                          "add",
                                                          []
                                                        |),
                                                        [ M.read (| arr_ptr |); M.read (| i |) ]
                                                      |));
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply (Ty.path "*mut") [] [ T ],
                                                        "add",
                                                        []
                                                      |),
                                                      [
                                                        M.read (| arr_ptr |);
                                                        BinOp.Wrap.sub
                                                          Integer.Usize
                                                          (M.read (| i |))
                                                          (Value.Integer 1)
                                                      ]
                                                    |);
                                                    Value.Integer 1
                                                  ]
                                                |)
                                              |) in
                                            let~ _ :=
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  hole,
                                                  "core::slice::sort::InsertionHole",
                                                  "dest"
                                                |),
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "*mut") [] [ T ],
                                                    "add",
                                                    []
                                                  |),
                                                  [ M.read (| arr_ptr |); M.read (| i |) ]
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |))));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_insert_head : M.IsFunction "core::slice::sort::insert_head" insert_head.
    
    (*
    pub(super) fn insertion_sort_shift_left<T, F>(v: &mut [T], offset: usize, is_less: &mut F)
    where
        F: FnMut(&T, &T) -> bool,
    {
        let len = v.len();
    
        // Using assert here improves performance.
        assert!(offset != 0 && offset <= len);
    
        // Shift each element of the unsorted region v[i..] as far left as is needed to make v sorted.
        for i in offset..len {
            // SAFETY: we tested that `offset` must be at least 1, so this loop is only entered if len
            // >= 2. The range is exclusive and we know `i` must be at least 1 so this slice has at
            // >least len 2.
            unsafe {
                insert_tail(&mut v[..=i], is_less);
            }
        }
    }
    *)
    Definition insertion_sort_shift_left
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; offset; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let offset := M.alloc (| offset |) in
          let is_less := M.alloc (| is_less |) in
          M.read (|
            let~ len :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "len", [] |),
                  [ M.read (| v |) ]
                |)
              |) in
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (LogicalOp.and (|
                                BinOp.Pure.ne (M.read (| offset |)) (Value.Integer 0),
                                ltac:(M.monadic
                                  (BinOp.Pure.le (M.read (| offset |)) (M.read (| len |))))
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic", [] |),
                            [
                              M.read (|
                                Value.String "assertion failed: offset != 0 && offset <= len"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.use
              (M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      [],
                      "into_iter",
                      []
                    |),
                    [
                      Value.StructRecord
                        "core::ops::range::Range"
                        [ ("start", M.read (| offset |)); ("end_", M.read (| len |)) ]
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        ltac:(M.monadic
                          (let~ _ :=
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    "next",
                                    []
                                  |),
                                  [ iter ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let i := M.copy (| γ0_0 |) in
                                    let~ _ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_function (|
                                            "core::slice::sort::insert_tail",
                                            [ T; F ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::index::IndexMut",
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::RangeToInclusive")
                                                    []
                                                    [ Ty.path "usize" ]
                                                ],
                                                "index_mut",
                                                []
                                              |),
                                              [
                                                M.read (| v |);
                                                Value.StructRecord
                                                  "core::ops::range::RangeToInclusive"
                                                  [ ("end_", M.read (| i |)) ]
                                              ]
                                            |);
                                            M.read (| is_less |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_insertion_sort_shift_left :
      M.IsFunction "core::slice::sort::insertion_sort_shift_left" insertion_sort_shift_left.
    
    (*
    fn insertion_sort_shift_right<T, F>(v: &mut [T], offset: usize, is_less: &mut F)
    where
        F: FnMut(&T, &T) -> bool,
    {
        let len = v.len();
    
        // Using assert here improves performance.
        assert!(offset != 0 && offset <= len && len >= 2);
    
        // Shift each element of the unsorted region v[..i] as far left as is needed to make v sorted.
        for i in (0..offset).rev() {
            // SAFETY: we tested that `offset` must be at least 1, so this loop is only entered if len
            // >= 2.We ensured that the slice length is always at least 2 long. We know that start_found
            // will be at least one less than end, and the range is exclusive. Which gives us i always
            // <= (end - 2).
            unsafe {
                insert_head(&mut v[i..len], is_less);
            }
        }
    }
    *)
    Definition insertion_sort_shift_right
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; offset; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let offset := M.alloc (| offset |) in
          let is_less := M.alloc (| is_less |) in
          M.read (|
            let~ len :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "len", [] |),
                  [ M.read (| v |) ]
                |)
              |) in
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (LogicalOp.and (|
                                LogicalOp.and (|
                                  BinOp.Pure.ne (M.read (| offset |)) (Value.Integer 0),
                                  ltac:(M.monadic
                                    (BinOp.Pure.le (M.read (| offset |)) (M.read (| len |))))
                                |),
                                ltac:(M.monadic
                                  (BinOp.Pure.ge (M.read (| len |)) (Value.Integer 2)))
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic", [] |),
                            [
                              M.read (|
                                Value.String
                                  "assertion failed: offset != 0 && offset <= len && len >= 2"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.use
              (M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::rev::Rev")
                        []
                        [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                      [],
                      "into_iter",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          [],
                          "rev",
                          []
                        |),
                        [
                          Value.StructRecord
                            "core::ops::range::Range"
                            [ ("start", Value.Integer 0); ("end_", M.read (| offset |)) ]
                        ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        ltac:(M.monadic
                          (let~ _ :=
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::rev::Rev")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                    [],
                                    "next",
                                    []
                                  |),
                                  [ iter ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let i := M.copy (| γ0_0 |) in
                                    let~ _ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_function (|
                                            "core::slice::sort::insert_head",
                                            [ T; F ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::index::IndexMut",
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::Range")
                                                    []
                                                    [ Ty.path "usize" ]
                                                ],
                                                "index_mut",
                                                []
                                              |),
                                              [
                                                M.read (| v |);
                                                Value.StructRecord
                                                  "core::ops::range::Range"
                                                  [
                                                    ("start", M.read (| i |));
                                                    ("end_", M.read (| len |))
                                                  ]
                                              ]
                                            |);
                                            M.read (| is_less |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_insertion_sort_shift_right :
      M.IsFunction "core::slice::sort::insertion_sort_shift_right" insertion_sort_shift_right.
    
    (*
    fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool
    where
        F: FnMut(&T, &T) -> bool,
    {
        // Maximum number of adjacent out-of-order pairs that will get shifted.
        const MAX_STEPS: usize = 5;
        // If the slice is shorter than this, don't shift any elements.
        const SHORTEST_SHIFTING: usize = 50;
    
        let len = v.len();
        let mut i = 1;
    
        for _ in 0..MAX_STEPS {
            // SAFETY: We already explicitly did the bound checking with `i < len`.
            // All our subsequent indexing is only in the range `0 <= index < len`
            unsafe {
                // Find the next pair of adjacent out-of-order elements.
                while i < len && !is_less(v.get_unchecked(i), v.get_unchecked(i - 1)) {
                    i += 1;
                }
            }
    
            // Are we done?
            if i == len {
                return true;
            }
    
            // Don't shift elements on short arrays, that has a performance cost.
            if len < SHORTEST_SHIFTING {
                return false;
            }
    
            // Swap the found pair of elements. This puts them in correct order.
            v.swap(i - 1, i);
    
            if i >= 2 {
                // Shift the smaller element to the left.
                insertion_sort_shift_left(&mut v[..i], i - 1, is_less);
    
                // Shift the greater element to the right.
                insertion_sort_shift_right(&mut v[..i], 1, is_less);
            }
        }
    
        // Didn't manage to sort the slice in the limited number of steps.
        false
    }
    *)
    Definition partial_insertion_sort (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let is_less := M.alloc (| is_less |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        []
                      |),
                      [ M.read (| v |) ]
                    |)
                  |) in
                let~ i := M.alloc (| Value.Integer 1 |) in
                let~ _ :=
                  M.use
                    (M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            [],
                            "into_iter",
                            []
                          |),
                          [
                            Value.StructRecord
                              "core::ops::range::Range"
                              [
                                ("start", Value.Integer 0);
                                ("end_",
                                  M.read (|
                                    M.get_constant (|
                                      "core::slice::sort::partial_insertion_sort::MAX_STEPS"
                                    |)
                                  |))
                              ]
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let iter := M.copy (| γ |) in
                            M.loop (|
                              ltac:(M.monadic
                                (let~ _ :=
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          "next",
                                          []
                                        |),
                                        [ iter ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let~ _ :=
                                            M.loop (|
                                              ltac:(M.monadic
                                                (M.match_operator (|
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              LogicalOp.and (|
                                                                BinOp.Pure.lt
                                                                  (M.read (| i |))
                                                                  (M.read (| len |)),
                                                                ltac:(M.monadic
                                                                  (UnOp.Pure.not
                                                                    (M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::ops::function::FnMut",
                                                                        F,
                                                                        [
                                                                          Ty.tuple
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                []
                                                                                [ T ];
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                []
                                                                                [ T ]
                                                                            ]
                                                                        ],
                                                                        "call_mut",
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.read (| is_less |);
                                                                        Value.Tuple
                                                                          [
                                                                            M.call_closure (|
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  []
                                                                                  [ T ],
                                                                                "get_unchecked",
                                                                                [ Ty.path "usize" ]
                                                                              |),
                                                                              [
                                                                                M.read (| v |);
                                                                                M.read (| i |)
                                                                              ]
                                                                            |);
                                                                            M.call_closure (|
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  []
                                                                                  [ T ],
                                                                                "get_unchecked",
                                                                                [ Ty.path "usize" ]
                                                                              |),
                                                                              [
                                                                                M.read (| v |);
                                                                                BinOp.Wrap.sub
                                                                                  Integer.Usize
                                                                                  (M.read (| i |))
                                                                                  (Value.Integer 1)
                                                                              ]
                                                                            |)
                                                                          ]
                                                                      ]
                                                                    |))))
                                                              |)
                                                            |)) in
                                                        let _ :=
                                                          M.is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        let~ _ :=
                                                          let β := i in
                                                          M.write (|
                                                            β,
                                                            BinOp.Wrap.add
                                                              Integer.Usize
                                                              (M.read (| β |))
                                                              (Value.Integer 1)
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              let~ _ :=
                                                                M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (| M.break (||) |)
                                                                  |)
                                                                |) in
                                                              M.alloc (| Value.Tuple [] |)
                                                            |)
                                                          |)
                                                        |)))
                                                  ]
                                                |)))
                                            |) in
                                          let~ _ :=
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          BinOp.Pure.eq
                                                            (M.read (| i |))
                                                            (M.read (| len |))
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (| M.return_ (| Value.Bool true |) |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |) in
                                          let~ _ :=
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          BinOp.Pure.lt
                                                            (M.read (| len |))
                                                            (M.read (|
                                                              M.get_constant (|
                                                                "core::slice::sort::partial_insertion_sort::SHORTEST_SHIFTING"
                                                              |)
                                                            |))
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          M.return_ (| Value.Bool false |)
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |) in
                                          let~ _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "slice") [] [ T ],
                                                  "swap",
                                                  []
                                                |),
                                                [
                                                  M.read (| v |);
                                                  BinOp.Wrap.sub
                                                    Integer.Usize
                                                    (M.read (| i |))
                                                    (Value.Integer 1);
                                                  M.read (| i |)
                                                ]
                                              |)
                                            |) in
                                          M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.use
                                                      (M.alloc (|
                                                        BinOp.Pure.ge
                                                          (M.read (| i |))
                                                          (Value.Integer 2)
                                                      |)) in
                                                  let _ :=
                                                    M.is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  let~ _ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_function (|
                                                          "core::slice::sort::insertion_sort_shift_left",
                                                          [ T; F ]
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::index::IndexMut",
                                                              Ty.apply (Ty.path "slice") [] [ T ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::RangeTo")
                                                                  []
                                                                  [ Ty.path "usize" ]
                                                              ],
                                                              "index_mut",
                                                              []
                                                            |),
                                                            [
                                                              M.read (| v |);
                                                              Value.StructRecord
                                                                "core::ops::range::RangeTo"
                                                                [ ("end_", M.read (| i |)) ]
                                                            ]
                                                          |);
                                                          BinOp.Wrap.sub
                                                            Integer.Usize
                                                            (M.read (| i |))
                                                            (Value.Integer 1);
                                                          M.read (| is_less |)
                                                        ]
                                                      |)
                                                    |) in
                                                  let~ _ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_function (|
                                                          "core::slice::sort::insertion_sort_shift_right",
                                                          [ T; F ]
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::index::IndexMut",
                                                              Ty.apply (Ty.path "slice") [] [ T ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::RangeTo")
                                                                  []
                                                                  [ Ty.path "usize" ]
                                                              ],
                                                              "index_mut",
                                                              []
                                                            |),
                                                            [
                                                              M.read (| v |);
                                                              Value.StructRecord
                                                                "core::ops::range::RangeTo"
                                                                [ ("end_", M.read (| i |)) ]
                                                            ]
                                                          |);
                                                          Value.Integer 1;
                                                          M.read (| is_less |)
                                                        ]
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)));
                                              fun γ =>
                                                ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |)))
                                    ]
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                            |)))
                      ]
                    |)) in
                M.alloc (| Value.Bool false |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_partial_insertion_sort :
      M.IsFunction "core::slice::sort::partial_insertion_sort" partial_insertion_sort.
    
    Module partial_insertion_sort.
      Definition value_MAX_STEPS : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer 5 |))).
      
      Definition value_SHORTEST_SHIFTING : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer 50 |))).
    End partial_insertion_sort.
    
    (*
    pub fn heapsort<T, F>(v: &mut [T], mut is_less: F)
    where
        F: FnMut(&T, &T) -> bool,
    {
        // This binary heap respects the invariant `parent >= child`.
        let mut sift_down = |v: &mut [T], mut node| {
            loop {
                // Children of `node`.
                let mut child = 2 * node + 1;
                if child >= v.len() {
                    break;
                }
    
                // Choose the greater child.
                if child + 1 < v.len() {
                    // We need a branch to be sure not to out-of-bounds index,
                    // but it's highly predictable.  The comparison, however,
                    // is better done branchless, especially for primitives.
                    child += is_less(&v[child], &v[child + 1]) as usize;
                }
    
                // Stop if the invariant holds at `node`.
                if !is_less(&v[node], &v[child]) {
                    break;
                }
    
                // Swap `node` with the greater child, move one step down, and continue sifting.
                v.swap(node, child);
                node = child;
            }
        };
    
        // Build the heap in linear time.
        for i in (0..v.len() / 2).rev() {
            sift_down(v, i);
        }
    
        // Pop maximal elements from the heap.
        for i in (1..v.len()).rev() {
            v.swap(0, i);
            sift_down(&mut v[..i], 0);
        }
    }
    *)
    Definition heapsort (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let is_less := M.alloc (| is_less |) in
          M.read (|
            let~ sift_down :=
              M.alloc (|
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        M.match_operator (|
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let v := M.copy (| γ |) in
                                M.match_operator (|
                                  M.alloc (| α1 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let node := M.copy (| γ |) in
                                        M.read (|
                                          M.loop (|
                                            ltac:(M.monadic
                                              (let~ child :=
                                                M.alloc (|
                                                  BinOp.Wrap.add
                                                    Integer.Usize
                                                    (BinOp.Wrap.mul
                                                      Integer.Usize
                                                      (Value.Integer 2)
                                                      (M.read (| node |)))
                                                    (Value.Integer 1)
                                                |) in
                                              let~ _ :=
                                                M.match_operator (|
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              BinOp.Pure.ge
                                                                (M.read (| child |))
                                                                (M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ T ],
                                                                    "len",
                                                                    []
                                                                  |),
                                                                  [ M.read (| v |) ]
                                                                |))
                                                            |)) in
                                                        let _ :=
                                                          M.is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (| M.break (||) |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |) in
                                              let~ _ :=
                                                M.match_operator (|
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              BinOp.Pure.lt
                                                                (BinOp.Wrap.add
                                                                  Integer.Usize
                                                                  (M.read (| child |))
                                                                  (Value.Integer 1))
                                                                (M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ T ],
                                                                    "len",
                                                                    []
                                                                  |),
                                                                  [ M.read (| v |) ]
                                                                |))
                                                            |)) in
                                                        let _ :=
                                                          M.is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        let~ _ :=
                                                          let β := child in
                                                          M.write (|
                                                            β,
                                                            BinOp.Wrap.add
                                                              Integer.Usize
                                                              (M.read (| β |))
                                                              (M.rust_cast
                                                                (M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::function::FnMut",
                                                                    F,
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ T ];
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ T ]
                                                                        ]
                                                                    ],
                                                                    "call_mut",
                                                                    []
                                                                  |),
                                                                  [
                                                                    is_less;
                                                                    Value.Tuple
                                                                      [
                                                                        M.SubPointer.get_array_field (|
                                                                          M.read (| v |),
                                                                          child
                                                                        |);
                                                                        M.SubPointer.get_array_field (|
                                                                          M.read (| v |),
                                                                          M.alloc (|
                                                                            BinOp.Wrap.add
                                                                              Integer.Usize
                                                                              (M.read (| child |))
                                                                              (Value.Integer 1)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                  ]
                                                                |)))
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |) in
                                              let~ _ :=
                                                M.match_operator (|
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              UnOp.Pure.not
                                                                (M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::function::FnMut",
                                                                    F,
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ T ];
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ T ]
                                                                        ]
                                                                    ],
                                                                    "call_mut",
                                                                    []
                                                                  |),
                                                                  [
                                                                    is_less;
                                                                    Value.Tuple
                                                                      [
                                                                        M.SubPointer.get_array_field (|
                                                                          M.read (| v |),
                                                                          node
                                                                        |);
                                                                        M.SubPointer.get_array_field (|
                                                                          M.read (| v |),
                                                                          child
                                                                        |)
                                                                      ]
                                                                  ]
                                                                |))
                                                            |)) in
                                                        let _ :=
                                                          M.is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (| M.break (||) |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |) in
                                              let~ _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply (Ty.path "slice") [] [ T ],
                                                      "swap",
                                                      []
                                                    |),
                                                    [
                                                      M.read (| v |);
                                                      M.read (| node |);
                                                      M.read (| child |)
                                                    ]
                                                  |)
                                                |) in
                                              let~ _ := M.write (| node, M.read (| child |) |) in
                                              M.alloc (| Value.Tuple [] |)))
                                          |)
                                        |)))
                                  ]
                                |)))
                          ]
                        |)
                      | _ => M.impossible (||)
                      end))
              |) in
            let~ _ :=
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::rev::Rev")
                          []
                          [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                        [],
                        "into_iter",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            [],
                            "rev",
                            []
                          |),
                          [
                            Value.StructRecord
                              "core::ops::range::Range"
                              [
                                ("start", Value.Integer 0);
                                ("end_",
                                  BinOp.Wrap.div
                                    Integer.Usize
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "len",
                                        []
                                      |),
                                      [ M.read (| v |) ]
                                    |))
                                    (Value.Integer 2))
                              ]
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let~ _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::rev::Rev")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let i := M.copy (| γ0_0 |) in
                                      let~ _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::function::FnMut",
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&mut")
                                                        []
                                                        [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                                      Ty.path "usize"
                                                    ]
                                                ]
                                                (Ty.tuple []),
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                                    Ty.path "usize"
                                                  ]
                                              ],
                                              "call_mut",
                                              []
                                            |),
                                            [
                                              sift_down;
                                              Value.Tuple [ M.read (| v |); M.read (| i |) ]
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.use
              (M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::rev::Rev")
                        []
                        [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                      [],
                      "into_iter",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          [],
                          "rev",
                          []
                        |),
                        [
                          Value.StructRecord
                            "core::ops::range::Range"
                            [
                              ("start", Value.Integer 1);
                              ("end_",
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| v |) ]
                                |))
                            ]
                        ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        ltac:(M.monadic
                          (let~ _ :=
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::rev::Rev")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                    [],
                                    "next",
                                    []
                                  |),
                                  [ iter ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let i := M.copy (| γ0_0 |) in
                                    let~ _ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "swap",
                                            []
                                          |),
                                          [ M.read (| v |); Value.Integer 0; M.read (| i |) ]
                                        |)
                                      |) in
                                    let~ _ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::function::FnMut",
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                                    Ty.path "usize"
                                                  ]
                                              ]
                                              (Ty.tuple []),
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ T ] ];
                                                  Ty.path "usize"
                                                ]
                                            ],
                                            "call_mut",
                                            []
                                          |),
                                          [
                                            sift_down;
                                            Value.Tuple
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::index::IndexMut",
                                                    Ty.apply (Ty.path "slice") [] [ T ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::ops::range::RangeTo")
                                                        []
                                                        [ Ty.path "usize" ]
                                                    ],
                                                    "index_mut",
                                                    []
                                                  |),
                                                  [
                                                    M.read (| v |);
                                                    Value.StructRecord
                                                      "core::ops::range::RangeTo"
                                                      [ ("end_", M.read (| i |)) ]
                                                  ]
                                                |);
                                                Value.Integer 0
                                              ]
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_heapsort : M.IsFunction "core::slice::sort::heapsort" heapsort.
    
    (*
    fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize
    where
        F: FnMut(&T, &T) -> bool,
    {
        // Number of elements in a typical block.
        const BLOCK: usize = 128;
    
        // The partitioning algorithm repeats the following steps until completion:
        //
        // 1. Trace a block from the left side to identify elements greater than or equal to the pivot.
        // 2. Trace a block from the right side to identify elements smaller than the pivot.
        // 3. Exchange the identified elements between the left and right side.
        //
        // We keep the following variables for a block of elements:
        //
        // 1. `block` - Number of elements in the block.
        // 2. `start` - Start pointer into the `offsets` array.
        // 3. `end` - End pointer into the `offsets` array.
        // 4. `offsets` - Indices of out-of-order elements within the block.
    
        // The current block on the left side (from `l` to `l.add(block_l)`).
        let mut l = v.as_mut_ptr();
        let mut block_l = BLOCK;
        let mut start_l = ptr::null_mut();
        let mut end_l = ptr::null_mut();
        let mut offsets_l = [MaybeUninit::<u8>::uninit(); BLOCK];
    
        // The current block on the right side (from `r.sub(block_r)` to `r`).
        // SAFETY: The documentation for .add() specifically mention that `vec.as_ptr().add(vec.len())` is always safe
        let mut r = unsafe { l.add(v.len()) };
        let mut block_r = BLOCK;
        let mut start_r = ptr::null_mut();
        let mut end_r = ptr::null_mut();
        let mut offsets_r = [MaybeUninit::<u8>::uninit(); BLOCK];
    
        // FIXME: When we get VLAs, try creating one array of length `min(v.len(), 2 * BLOCK)` rather
        // than two fixed-size arrays of length `BLOCK`. VLAs might be more cache-efficient.
    
        // Returns the number of elements between pointers `l` (inclusive) and `r` (exclusive).
        fn width<T>(l: *mut T, r: *mut T) -> usize {
            assert!(mem::size_of::<T>() > 0);
            // FIXME: this should *likely* use `offset_from`, but more
            // investigation is needed (including running tests in miri).
            (r.addr() - l.addr()) / mem::size_of::<T>()
        }
    
        loop {
            // We are done with partitioning block-by-block when `l` and `r` get very close. Then we do
            // some patch-up work in order to partition the remaining elements in between.
            let is_done = width(l, r) <= 2 * BLOCK;
    
            if is_done {
                // Number of remaining elements (still not compared to the pivot).
                let mut rem = width(l, r);
                if start_l < end_l || start_r < end_r {
                    rem -= BLOCK;
                }
    
                // Adjust block sizes so that the left and right block don't overlap, but get perfectly
                // aligned to cover the whole remaining gap.
                if start_l < end_l {
                    block_r = rem;
                } else if start_r < end_r {
                    block_l = rem;
                } else {
                    // There were the same number of elements to switch on both blocks during the last
                    // iteration, so there are no remaining elements on either block. Cover the remaining
                    // items with roughly equally-sized blocks.
                    block_l = rem / 2;
                    block_r = rem - block_l;
                }
                debug_assert!(block_l <= BLOCK && block_r <= BLOCK);
                debug_assert!(width(l, r) == block_l + block_r);
            }
    
            if start_l == end_l {
                // Trace `block_l` elements from the left side.
                start_l = MaybeUninit::slice_as_mut_ptr(&mut offsets_l);
                end_l = start_l;
                let mut elem = l;
    
                for i in 0..block_l {
                    // SAFETY: The unsafety operations below involve the usage of the `offset`.
                    //         According to the conditions required by the function, we satisfy them because:
                    //         1. `offsets_l` is stack-allocated, and thus considered separate allocated object.
                    //         2. The function `is_less` returns a `bool`.
                    //            Casting a `bool` will never overflow `isize`.
                    //         3. We have guaranteed that `block_l` will be `<= BLOCK`.
                    //            Plus, `end_l` was initially set to the begin pointer of `offsets_` which was declared on the stack.
                    //            Thus, we know that even in the worst case (all invocations of `is_less` returns false) we will only be at most 1 byte pass the end.
                    //        Another unsafety operation here is dereferencing `elem`.
                    //        However, `elem` was initially the begin pointer to the slice which is always valid.
                    unsafe {
                        // Branchless comparison.
                        *end_l = i as u8;
                        end_l = end_l.add(!is_less(&*elem, pivot) as usize);
                        elem = elem.add(1);
                    }
                }
            }
    
            if start_r == end_r {
                // Trace `block_r` elements from the right side.
                start_r = MaybeUninit::slice_as_mut_ptr(&mut offsets_r);
                end_r = start_r;
                let mut elem = r;
    
                for i in 0..block_r {
                    // SAFETY: The unsafety operations below involve the usage of the `offset`.
                    //         According to the conditions required by the function, we satisfy them because:
                    //         1. `offsets_r` is stack-allocated, and thus considered separate allocated object.
                    //         2. The function `is_less` returns a `bool`.
                    //            Casting a `bool` will never overflow `isize`.
                    //         3. We have guaranteed that `block_r` will be `<= BLOCK`.
                    //            Plus, `end_r` was initially set to the begin pointer of `offsets_` which was declared on the stack.
                    //            Thus, we know that even in the worst case (all invocations of `is_less` returns true) we will only be at most 1 byte pass the end.
                    //        Another unsafety operation here is dereferencing `elem`.
                    //        However, `elem` was initially `1 * sizeof(T)` past the end and we decrement it by `1 * sizeof(T)` before accessing it.
                    //        Plus, `block_r` was asserted to be less than `BLOCK` and `elem` will therefore at most be pointing to the beginning of the slice.
                    unsafe {
                        // Branchless comparison.
                        elem = elem.sub(1);
                        *end_r = i as u8;
                        end_r = end_r.add(is_less(&*elem, pivot) as usize);
                    }
                }
            }
    
            // Number of out-of-order elements to swap between the left and right side.
            let count = cmp::min(width(start_l, end_l), width(start_r, end_r));
    
            if count > 0 {
                macro_rules! left {
                    () => {
                        l.add(usize::from( *start_l))
                    };
                }
                macro_rules! right {
                    () => {
                        r.sub(usize::from( *start_r) + 1)
                    };
                }
    
                // Instead of swapping one pair at the time, it is more efficient to perform a cyclic
                // permutation. This is not strictly equivalent to swapping, but produces a similar
                // result using fewer memory operations.
    
                // SAFETY: The use of `ptr::read` is valid because there is at least one element in
                // both `offsets_l` and `offsets_r`, so `left!` is a valid pointer to read from.
                //
                // The uses of `left!` involve calls to `offset` on `l`, which points to the
                // beginning of `v`. All the offsets pointed-to by `start_l` are at most `block_l`, so
                // these `offset` calls are safe as all reads are within the block. The same argument
                // applies for the uses of `right!`.
                //
                // The calls to `start_l.offset` are valid because there are at most `count-1` of them,
                // plus the final one at the end of the unsafe block, where `count` is the minimum number
                // of collected offsets in `offsets_l` and `offsets_r`, so there is no risk of there not
                // being enough elements. The same reasoning applies to the calls to `start_r.offset`.
                //
                // The calls to `copy_nonoverlapping` are safe because `left!` and `right!` are guaranteed
                // not to overlap, and are valid because of the reasoning above.
                unsafe {
                    let tmp = ptr::read(left!());
                    ptr::copy_nonoverlapping(right!(), left!(), 1);
    
                    for _ in 1..count {
                        start_l = start_l.add(1);
                        ptr::copy_nonoverlapping(left!(), right!(), 1);
                        start_r = start_r.add(1);
                        ptr::copy_nonoverlapping(right!(), left!(), 1);
                    }
    
                    ptr::copy_nonoverlapping(&tmp, right!(), 1);
                    mem::forget(tmp);
                    start_l = start_l.add(1);
                    start_r = start_r.add(1);
                }
            }
    
            if start_l == end_l {
                // All out-of-order elements in the left block were moved. Move to the next block.
    
                // block-width-guarantee
                // SAFETY: if `!is_done` then the slice width is guaranteed to be at least `2*BLOCK` wide. There
                // are at most `BLOCK` elements in `offsets_l` because of its size, so the `offset` operation is
                // safe. Otherwise, the debug assertions in the `is_done` case guarantee that
                // `width(l, r) == block_l + block_r`, namely, that the block sizes have been adjusted to account
                // for the smaller number of remaining elements.
                l = unsafe { l.add(block_l) };
            }
    
            if start_r == end_r {
                // All out-of-order elements in the right block were moved. Move to the previous block.
    
                // SAFETY: Same argument as [block-width-guarantee]. Either this is a full block `2*BLOCK`-wide,
                // or `block_r` has been adjusted for the last handful of elements.
                r = unsafe { r.sub(block_r) };
            }
    
            if is_done {
                break;
            }
        }
    
        // All that remains now is at most one block (either the left or the right) with out-of-order
        // elements that need to be moved. Such remaining elements can be simply shifted to the end
        // within their block.
    
        if start_l < end_l {
            // The left block remains.
            // Move its remaining out-of-order elements to the far right.
            debug_assert_eq!(width(l, r), block_l);
            while start_l < end_l {
                // remaining-elements-safety
                // SAFETY: while the loop condition holds there are still elements in `offsets_l`, so it
                // is safe to point `end_l` to the previous element.
                //
                // The `ptr::swap` is safe if both its arguments are valid for reads and writes:
                //  - Per the debug assert above, the distance between `l` and `r` is `block_l`
                //    elements, so there can be at most `block_l` remaining offsets between `start_l`
                //    and `end_l`. This means `r` will be moved at most `block_l` steps back, which
                //    makes the `r.offset` calls valid (at that point `l == r`).
                //  - `offsets_l` contains valid offsets into `v` collected during the partitioning of
                //    the last block, so the `l.offset` calls are valid.
                unsafe {
                    end_l = end_l.sub(1);
                    ptr::swap(l.add(usize::from( *end_l)), r.sub(1));
                    r = r.sub(1);
                }
            }
            width(v.as_mut_ptr(), r)
        } else if start_r < end_r {
            // The right block remains.
            // Move its remaining out-of-order elements to the far left.
            debug_assert_eq!(width(l, r), block_r);
            while start_r < end_r {
                // SAFETY: See the reasoning in [remaining-elements-safety].
                unsafe {
                    end_r = end_r.sub(1);
                    ptr::swap(l, r.sub(usize::from( *end_r) + 1));
                    l = l.add(1);
                }
            }
            width(v.as_mut_ptr(), l)
        } else {
            // Nothing else to do, we're done.
            width(v.as_mut_ptr(), l)
        }
    }
    *)
    Definition partition_in_blocks (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; pivot; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let pivot := M.alloc (| pivot |) in
          let is_less := M.alloc (| is_less |) in
          M.read (|
            let~ l :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ T ],
                    "as_mut_ptr",
                    []
                  |),
                  [ M.read (| v |) ]
                |)
              |) in
            let~ block_l :=
              M.copy (| M.get_constant (| "core::slice::sort::partition_in_blocks::BLOCK" |) |) in
            let~ start_l :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::ptr::null_mut", [ Ty.path "u8" ] |),
                  []
                |)
              |) in
            let~ end_l :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::ptr::null_mut", [ Ty.path "u8" ] |),
                  []
                |)
              |) in
            let~ offsets_l :=
              M.alloc (|
                repeat
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Ty.path "u8" ],
                      "uninit",
                      []
                    |),
                    []
                  |))
                  128
              |) in
            let~ r :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "add", [] |),
                  [
                    M.read (| l |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        []
                      |),
                      [ M.read (| v |) ]
                    |)
                  ]
                |)
              |) in
            let~ block_r :=
              M.copy (| M.get_constant (| "core::slice::sort::partition_in_blocks::BLOCK" |) |) in
            let~ start_r :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::ptr::null_mut", [ Ty.path "u8" ] |),
                  []
                |)
              |) in
            let~ end_r :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::ptr::null_mut", [ Ty.path "u8" ] |),
                  []
                |)
              |) in
            let~ offsets_r :=
              M.alloc (|
                repeat
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Ty.path "u8" ],
                      "uninit",
                      []
                    |),
                    []
                  |))
                  128
              |) in
            let~ _ :=
              M.loop (|
                ltac:(M.monadic
                  (let~ is_done :=
                    M.alloc (|
                      BinOp.Pure.le
                        (M.call_closure (|
                          M.get_function (| "core::slice::sort::partition_in_blocks.width", [] |),
                          [ M.read (| l |); M.read (| r |) ]
                        |))
                        (BinOp.Wrap.mul
                          Integer.Usize
                          (Value.Integer 2)
                          (M.read (|
                            M.get_constant (| "core::slice::sort::partition_in_blocks::BLOCK" |)
                          |)))
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_done in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ rem :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::slice::sort::partition_in_blocks.width",
                                    []
                                  |),
                                  [ M.read (| l |); M.read (| r |) ]
                                |)
                              |) in
                            let~ _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            LogicalOp.or (|
                                              BinOp.Pure.lt
                                                (M.read (| start_l |))
                                                (M.read (| end_l |)),
                                              ltac:(M.monadic
                                                (BinOp.Pure.lt
                                                  (M.read (| start_r |))
                                                  (M.read (| end_r |))))
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ :=
                                        let β := rem in
                                        M.write (|
                                          β,
                                          BinOp.Wrap.sub
                                            Integer.Usize
                                            (M.read (| β |))
                                            (M.read (|
                                              M.get_constant (|
                                                "core::slice::sort::partition_in_blocks::BLOCK"
                                              |)
                                            |))
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            let~ _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            BinOp.Pure.lt
                                              (M.read (| start_l |))
                                              (M.read (| end_l |))
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ := M.write (| block_r, M.read (| rem |) |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    BinOp.Pure.lt
                                                      (M.read (| start_r |))
                                                      (M.read (| end_r |))
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              let~ _ := M.write (| block_l, M.read (| rem |) |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let~ _ :=
                                                M.write (|
                                                  block_l,
                                                  BinOp.Wrap.div
                                                    Integer.Usize
                                                    (M.read (| rem |))
                                                    (Value.Integer 2)
                                                |) in
                                              let~ _ :=
                                                M.write (|
                                                  block_r,
                                                  BinOp.Wrap.sub
                                                    Integer.Usize
                                                    (M.read (| rem |))
                                                    (M.read (| block_l |))
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            let~ _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ :=
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      UnOp.Pure.not
                                                        (LogicalOp.and (|
                                                          BinOp.Pure.le
                                                            (M.read (| block_l |))
                                                            (M.read (|
                                                              M.get_constant (|
                                                                "core::slice::sort::partition_in_blocks::BLOCK"
                                                              |)
                                                            |)),
                                                          ltac:(M.monadic
                                                            (BinOp.Pure.le
                                                              (M.read (| block_r |))
                                                              (M.read (|
                                                                M.get_constant (|
                                                                  "core::slice::sort::partition_in_blocks::BLOCK"
                                                                |)
                                                              |))))
                                                        |))
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.call_closure (|
                                                      M.get_function (|
                                                        "core::panicking::panic",
                                                        []
                                                      |),
                                                      [
                                                        M.read (|
                                                          Value.String
                                                            "assertion failed: block_l <= BLOCK && block_r <= BLOCK"
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            let~ _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ :=
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      UnOp.Pure.not
                                                        (BinOp.Pure.eq
                                                          (M.call_closure (|
                                                            M.get_function (|
                                                              "core::slice::sort::partition_in_blocks.width",
                                                              []
                                                            |),
                                                            [ M.read (| l |); M.read (| r |) ]
                                                          |))
                                                          (BinOp.Wrap.add
                                                            Integer.Usize
                                                            (M.read (| block_l |))
                                                            (M.read (| block_r |))))
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.call_closure (|
                                                      M.get_function (|
                                                        "core::panicking::panic",
                                                        []
                                                      |),
                                                      [
                                                        M.read (|
                                                          Value.String
                                                            "assertion failed: width(l, r) == block_l + block_r"
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| start_l |)) (M.read (| end_l |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              M.write (|
                                start_l,
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ],
                                    "slice_as_mut_ptr",
                                    []
                                  |),
                                  [ (* Unsize *) M.pointer_coercion offsets_l ]
                                |)
                              |) in
                            let~ _ := M.write (| end_l, M.read (| start_l |) |) in
                            let~ elem := M.copy (| l |) in
                            M.use
                              (M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::collect::IntoIterator",
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ],
                                      [],
                                      "into_iter",
                                      []
                                    |),
                                    [
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [ ("start", Value.Integer 0); ("end_", M.read (| block_l |))
                                        ]
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let iter := M.copy (| γ |) in
                                      M.loop (|
                                        ltac:(M.monadic
                                          (let~ _ :=
                                            M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path "core::ops::range::Range")
                                                      []
                                                      [ Ty.path "usize" ],
                                                    [],
                                                    "next",
                                                    []
                                                  |),
                                                  [ iter ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let _ :=
                                                      M.is_struct_tuple (|
                                                        γ,
                                                        "core::option::Option::None"
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (| M.read (| M.break (||) |) |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let i := M.copy (| γ0_0 |) in
                                                    let~ _ :=
                                                      M.write (|
                                                        M.read (| end_l |),
                                                        M.rust_cast (M.read (| i |))
                                                      |) in
                                                    let~ _ :=
                                                      M.write (|
                                                        end_l,
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "*mut")
                                                              []
                                                              [ Ty.path "u8" ],
                                                            "add",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| end_l |);
                                                            M.rust_cast
                                                              (UnOp.Pure.not
                                                                (M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::function::FnMut",
                                                                    F,
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ T ];
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ T ]
                                                                        ]
                                                                    ],
                                                                    "call_mut",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.read (| is_less |);
                                                                    Value.Tuple
                                                                      [
                                                                        M.read (| elem |);
                                                                        M.read (| pivot |)
                                                                      ]
                                                                  ]
                                                                |)))
                                                          ]
                                                        |)
                                                      |) in
                                                    let~ _ :=
                                                      M.write (|
                                                        elem,
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "*mut") [] [ T ],
                                                            "add",
                                                            []
                                                          |),
                                                          [ M.read (| elem |); Value.Integer 1 ]
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                      |)))
                                ]
                              |))));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| start_r |)) (M.read (| end_r |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              M.write (|
                                start_r,
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ],
                                    "slice_as_mut_ptr",
                                    []
                                  |),
                                  [ (* Unsize *) M.pointer_coercion offsets_r ]
                                |)
                              |) in
                            let~ _ := M.write (| end_r, M.read (| start_r |) |) in
                            let~ elem := M.copy (| r |) in
                            M.use
                              (M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::collect::IntoIterator",
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ],
                                      [],
                                      "into_iter",
                                      []
                                    |),
                                    [
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [ ("start", Value.Integer 0); ("end_", M.read (| block_r |))
                                        ]
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let iter := M.copy (| γ |) in
                                      M.loop (|
                                        ltac:(M.monadic
                                          (let~ _ :=
                                            M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path "core::ops::range::Range")
                                                      []
                                                      [ Ty.path "usize" ],
                                                    [],
                                                    "next",
                                                    []
                                                  |),
                                                  [ iter ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let _ :=
                                                      M.is_struct_tuple (|
                                                        γ,
                                                        "core::option::Option::None"
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (| M.read (| M.break (||) |) |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let i := M.copy (| γ0_0 |) in
                                                    let~ _ :=
                                                      M.write (|
                                                        elem,
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "*mut") [] [ T ],
                                                            "sub",
                                                            []
                                                          |),
                                                          [ M.read (| elem |); Value.Integer 1 ]
                                                        |)
                                                      |) in
                                                    let~ _ :=
                                                      M.write (|
                                                        M.read (| end_r |),
                                                        M.rust_cast (M.read (| i |))
                                                      |) in
                                                    let~ _ :=
                                                      M.write (|
                                                        end_r,
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "*mut")
                                                              []
                                                              [ Ty.path "u8" ],
                                                            "add",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| end_r |);
                                                            M.rust_cast
                                                              (M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::function::FnMut",
                                                                  F,
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ T ];
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ T ]
                                                                      ]
                                                                  ],
                                                                  "call_mut",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| is_less |);
                                                                  Value.Tuple
                                                                    [
                                                                      M.read (| elem |);
                                                                      M.read (| pivot |)
                                                                    ]
                                                                ]
                                                              |))
                                                          ]
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                      |)))
                                ]
                              |))));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ count :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                        [
                          M.call_closure (|
                            M.get_function (| "core::slice::sort::partition_in_blocks.width", [] |),
                            [ M.read (| start_l |); M.read (| end_l |) ]
                          |);
                          M.call_closure (|
                            M.get_function (| "core::slice::sort::partition_in_blocks.width", [] |),
                            [ M.read (| start_r |); M.read (| end_r |) ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.gt (M.read (| count |)) (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ tmp :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_function (| "core::ptr::read", [ T ] |),
                                  [
                                    (* MutToConstPointer *)
                                    M.pointer_coercion
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                          "add",
                                          []
                                        |),
                                        [
                                          M.read (| l |);
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::convert::From",
                                              Ty.path "usize",
                                              [ Ty.path "u8" ],
                                              "from",
                                              []
                                            |),
                                            [ M.read (| M.read (| start_l |) |) ]
                                          |)
                                        ]
                                      |))
                                  ]
                                |)
                              |) in
                            let~ _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::copy_nonoverlapping",
                                    [ T ]
                                  |),
                                  [
                                    (* MutToConstPointer *)
                                    M.pointer_coercion
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                          "sub",
                                          []
                                        |),
                                        [
                                          M.read (| r |);
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.call_closure (|
                                              M.get_trait_method (|
                                                "core::convert::From",
                                                Ty.path "usize",
                                                [ Ty.path "u8" ],
                                                "from",
                                                []
                                              |),
                                              [ M.read (| M.read (| start_r |) |) ]
                                            |))
                                            (Value.Integer 1)
                                        ]
                                      |));
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [] [ T ],
                                        "add",
                                        []
                                      |),
                                      [
                                        M.read (| l |);
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::convert::From",
                                            Ty.path "usize",
                                            [ Ty.path "u8" ],
                                            "from",
                                            []
                                          |),
                                          [ M.read (| M.read (| start_l |) |) ]
                                        |)
                                      ]
                                    |);
                                    Value.Integer 1
                                  ]
                                |)
                              |) in
                            let~ _ :=
                              M.use
                                (M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::collect::IntoIterator",
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ],
                                        [],
                                        "into_iter",
                                        []
                                      |),
                                      [
                                        Value.StructRecord
                                          "core::ops::range::Range"
                                          [ ("start", Value.Integer 1); ("end_", M.read (| count |))
                                          ]
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let iter := M.copy (| γ |) in
                                        M.loop (|
                                          ltac:(M.monadic
                                            (let~ _ :=
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path "core::ops::range::Range")
                                                        []
                                                        [ Ty.path "usize" ],
                                                      [],
                                                      "next",
                                                      []
                                                    |),
                                                    [ iter ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let _ :=
                                                        M.is_struct_tuple (|
                                                          γ,
                                                          "core::option::Option::None"
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (| M.break (||) |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let~ _ :=
                                                        M.write (|
                                                          start_l,
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "*mut")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              "add",
                                                              []
                                                            |),
                                                            [ M.read (| start_l |); Value.Integer 1
                                                            ]
                                                          |)
                                                        |) in
                                                      let~ _ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_function (|
                                                              "core::intrinsics::copy_nonoverlapping",
                                                              [ T ]
                                                            |),
                                                            [
                                                              (* MutToConstPointer *)
                                                              M.pointer_coercion
                                                                (M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "*mut")
                                                                      []
                                                                      [ T ],
                                                                    "add",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.read (| l |);
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::convert::From",
                                                                        Ty.path "usize",
                                                                        [ Ty.path "u8" ],
                                                                        "from",
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.read (|
                                                                          M.read (| start_l |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  ]
                                                                |));
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "*mut")
                                                                    []
                                                                    [ T ],
                                                                  "sub",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| r |);
                                                                  BinOp.Wrap.add
                                                                    Integer.Usize
                                                                    (M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::convert::From",
                                                                        Ty.path "usize",
                                                                        [ Ty.path "u8" ],
                                                                        "from",
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.read (|
                                                                          M.read (| start_r |)
                                                                        |)
                                                                      ]
                                                                    |))
                                                                    (Value.Integer 1)
                                                                ]
                                                              |);
                                                              Value.Integer 1
                                                            ]
                                                          |)
                                                        |) in
                                                      let~ _ :=
                                                        M.write (|
                                                          start_r,
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "*mut")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              "add",
                                                              []
                                                            |),
                                                            [ M.read (| start_r |); Value.Integer 1
                                                            ]
                                                          |)
                                                        |) in
                                                      let~ _ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_function (|
                                                              "core::intrinsics::copy_nonoverlapping",
                                                              [ T ]
                                                            |),
                                                            [
                                                              (* MutToConstPointer *)
                                                              M.pointer_coercion
                                                                (M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "*mut")
                                                                      []
                                                                      [ T ],
                                                                    "sub",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.read (| r |);
                                                                    BinOp.Wrap.add
                                                                      Integer.Usize
                                                                      (M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::convert::From",
                                                                          Ty.path "usize",
                                                                          [ Ty.path "u8" ],
                                                                          "from",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.read (|
                                                                            M.read (| start_r |)
                                                                          |)
                                                                        ]
                                                                      |))
                                                                      (Value.Integer 1)
                                                                  ]
                                                                |));
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "*mut")
                                                                    []
                                                                    [ T ],
                                                                  "add",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| l |);
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::convert::From",
                                                                      Ty.path "usize",
                                                                      [ Ty.path "u8" ],
                                                                      "from",
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.read (|
                                                                        M.read (| start_l |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |);
                                                              Value.Integer 1
                                                            ]
                                                          |)
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                        |)))
                                  ]
                                |)) in
                            let~ _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::copy_nonoverlapping",
                                    [ T ]
                                  |),
                                  [
                                    tmp;
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [] [ T ],
                                        "sub",
                                        []
                                      |),
                                      [
                                        M.read (| r |);
                                        BinOp.Wrap.add
                                          Integer.Usize
                                          (M.call_closure (|
                                            M.get_trait_method (|
                                              "core::convert::From",
                                              Ty.path "usize",
                                              [ Ty.path "u8" ],
                                              "from",
                                              []
                                            |),
                                            [ M.read (| M.read (| start_r |) |) ]
                                          |))
                                          (Value.Integer 1)
                                      ]
                                    |);
                                    Value.Integer 1
                                  ]
                                |)
                              |) in
                            let~ _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_function (| "core::mem::forget", [ T ] |),
                                  [ M.read (| tmp |) ]
                                |)
                              |) in
                            let~ _ :=
                              M.write (|
                                start_l,
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                    "add",
                                    []
                                  |),
                                  [ M.read (| start_l |); Value.Integer 1 ]
                                |)
                              |) in
                            let~ _ :=
                              M.write (|
                                start_r,
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                    "add",
                                    []
                                  |),
                                  [ M.read (| start_r |); Value.Integer 1 ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| start_l |)) (M.read (| end_l |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              M.write (|
                                l,
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ T ],
                                    "add",
                                    []
                                  |),
                                  [ M.read (| l |); M.read (| block_l |) ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| start_r |)) (M.read (| end_r |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              M.write (|
                                r,
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ T ],
                                    "sub",
                                    []
                                  |),
                                  [ M.read (| r |); M.read (| block_r |) ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use is_done in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |)))
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (| BinOp.Pure.lt (M.read (| start_l |)) (M.read (| end_l |)) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use (M.alloc (| Value.Bool true |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    Value.Tuple
                                      [
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_function (|
                                              "core::slice::sort::partition_in_blocks.width",
                                              []
                                            |),
                                            [ M.read (| l |); M.read (| r |) ]
                                          |)
                                        |);
                                        block_l
                                      ]
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let left_val := M.copy (| γ0_0 |) in
                                        let right_val := M.copy (| γ0_1 |) in
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      UnOp.Pure.not
                                                        (BinOp.Pure.eq
                                                          (M.read (| M.read (| left_val |) |))
                                                          (M.read (| M.read (| right_val |) |)))
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      let~ kind :=
                                                        M.alloc (|
                                                          Value.StructTuple
                                                            "core::panicking::AssertKind::Eq"
                                                            []
                                                        |) in
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_function (|
                                                            "core::panicking::assert_failed",
                                                            [ Ty.path "usize"; Ty.path "usize" ]
                                                          |),
                                                          [
                                                            M.read (| kind |);
                                                            M.read (| left_val |);
                                                            M.read (| right_val |);
                                                            Value.StructTuple
                                                              "core::option::Option::None"
                                                              []
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.lt (M.read (| start_l |)) (M.read (| end_l |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ :=
                                    M.write (|
                                      end_l,
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                          "sub",
                                          []
                                        |),
                                        [ M.read (| end_l |); Value.Integer 1 ]
                                      |)
                                    |) in
                                  let~ _ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_function (| "core::ptr::swap", [ T ] |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ T ],
                                              "add",
                                              []
                                            |),
                                            [
                                              M.read (| l |);
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::convert::From",
                                                  Ty.path "usize",
                                                  [ Ty.path "u8" ],
                                                  "from",
                                                  []
                                                |),
                                                [ M.read (| M.read (| end_l |) |) ]
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ T ],
                                              "sub",
                                              []
                                            |),
                                            [ M.read (| r |); Value.Integer 1 ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ :=
                                    M.write (|
                                      r,
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                          "sub",
                                          []
                                        |),
                                        [ M.read (| r |); Value.Integer 1 ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::slice::sort::partition_in_blocks.width", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "as_mut_ptr",
                              []
                            |),
                            [ M.read (| v |) ]
                          |);
                          M.read (| r |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt (M.read (| start_r |)) (M.read (| end_r |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            Value.Tuple
                                              [
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_function (|
                                                      "core::slice::sort::partition_in_blocks.width",
                                                      []
                                                    |),
                                                    [ M.read (| l |); M.read (| r |) ]
                                                  |)
                                                |);
                                                block_r
                                              ]
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val := M.copy (| γ0_0 |) in
                                                let right_val := M.copy (| γ0_1 |) in
                                                M.match_operator (|
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              UnOp.Pure.not
                                                                (BinOp.Pure.eq
                                                                  (M.read (|
                                                                    M.read (| left_val |)
                                                                  |))
                                                                  (M.read (|
                                                                    M.read (| right_val |)
                                                                  |)))
                                                            |)) in
                                                        let _ :=
                                                          M.is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              let~ kind :=
                                                                M.alloc (|
                                                                  Value.StructTuple
                                                                    "core::panicking::AssertKind::Eq"
                                                                    []
                                                                |) in
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_function (|
                                                                    "core::panicking::assert_failed",
                                                                    [
                                                                      Ty.path "usize";
                                                                      Ty.path "usize"
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.read (| kind |);
                                                                    M.read (| left_val |);
                                                                    M.read (| right_val |);
                                                                    Value.StructTuple
                                                                      "core::option::Option::None"
                                                                      []
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            let~ _ :=
                              M.loop (|
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                BinOp.Pure.lt
                                                  (M.read (| start_r |))
                                                  (M.read (| end_r |))
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ _ :=
                                            M.write (|
                                              end_r,
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                                  "sub",
                                                  []
                                                |),
                                                [ M.read (| end_r |); Value.Integer 1 ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (| "core::ptr::swap", [ T ] |),
                                                [
                                                  M.read (| l |);
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply (Ty.path "*mut") [] [ T ],
                                                      "sub",
                                                      []
                                                    |),
                                                    [
                                                      M.read (| r |);
                                                      BinOp.Wrap.add
                                                        Integer.Usize
                                                        (M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::convert::From",
                                                            Ty.path "usize",
                                                            [ Ty.path "u8" ],
                                                            "from",
                                                            []
                                                          |),
                                                          [ M.read (| M.read (| end_r |) |) ]
                                                        |))
                                                        (Value.Integer 1)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.write (|
                                              l,
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                                  "add",
                                                  []
                                                |),
                                                [ M.read (| l |); Value.Integer 1 ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                let~ _ :=
                                                  M.alloc (|
                                                    M.never_to_any (| M.read (| M.break (||) |) |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)
                                              |)
                                            |)
                                          |)))
                                    ]
                                  |)))
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "core::slice::sort::partition_in_blocks.width",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "as_mut_ptr",
                                      []
                                    |),
                                    [ M.read (| v |) ]
                                  |);
                                  M.read (| l |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "core::slice::sort::partition_in_blocks.width",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "as_mut_ptr",
                                      []
                                    |),
                                    [ M.read (| v |) ]
                                  |);
                                  M.read (| l |)
                                ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_partition_in_blocks :
      M.IsFunction "core::slice::sort::partition_in_blocks" partition_in_blocks.
    
    Module partition_in_blocks.
      Definition value_BLOCK : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 128 |))).
      
      (*
          fn width<T>(l: *mut T, r: *mut T) -> usize {
              assert!(mem::size_of::<T>() > 0);
              // FIXME: this should *likely* use `offset_from`, but more
              // investigation is needed (including running tests in miri).
              (r.addr() - l.addr()) / mem::size_of::<T>()
          }
      *)
      Definition width (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ l; r ] =>
          ltac:(M.monadic
            (let l := M.alloc (| l |) in
            let r := M.alloc (| r |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (BinOp.Pure.gt
                                  (M.call_closure (|
                                    M.get_function (| "core::mem::size_of", [ T ] |),
                                    []
                                  |))
                                  (Value.Integer 0))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic", [] |),
                              [
                                M.read (|
                                  Value.String "assertion failed: mem::size_of::<T>() > 0"
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                BinOp.Wrap.div
                  Integer.Usize
                  (BinOp.Wrap.sub
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "addr",
                        []
                      |),
                      [ M.read (| r |) ]
                    |))
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "addr",
                        []
                      |),
                      [ M.read (| l |) ]
                    |)))
                  (M.call_closure (| M.get_function (| "core::mem::size_of", [ T ] |), [] |))
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom Function_width : M.IsFunction "core::slice::sort::partition_in_blocks::width" width.
    End partition_in_blocks.
    
    (*
    pub(super) fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)
    where
        F: FnMut(&T, &T) -> bool,
    {
        let (mid, was_partitioned) = {
            // Place the pivot at the beginning of slice.
            v.swap(0, pivot);
            let (pivot, v) = v.split_at_mut(1);
            let pivot = &mut pivot[0];
    
            // Read the pivot into a stack-allocated variable for efficiency. If a following comparison
            // operation panics, the pivot will be automatically written back into the slice.
    
            // SAFETY: `pivot` is a reference to the first element of `v`, so `ptr::read` is safe.
            let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });
            let _pivot_guard = InsertionHole { src: &*tmp, dest: pivot };
            let pivot = &*tmp;
    
            // Find the first pair of out-of-order elements.
            let mut l = 0;
            let mut r = v.len();
    
            // SAFETY: The unsafety below involves indexing an array.
            // For the first one: We already do the bounds checking here with `l < r`.
            // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.
            //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.
            unsafe {
                // Find the first element greater than or equal to the pivot.
                while l < r && is_less(v.get_unchecked(l), pivot) {
                    l += 1;
                }
    
                // Find the last element smaller that the pivot.
                while l < r && !is_less(v.get_unchecked(r - 1), pivot) {
                    r -= 1;
                }
            }
    
            (l + partition_in_blocks(&mut v[l..r], pivot, is_less), l >= r)
    
            // `_pivot_guard` goes out of scope and writes the pivot (which is a stack-allocated
            // variable) back into the slice where it originally was. This step is critical in ensuring
            // safety!
        };
    
        // Place the pivot between the two partitions.
        v.swap(0, mid);
    
        (mid, was_partitioned)
    }
    *)
    Definition partition (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; pivot; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let pivot := M.alloc (| pivot |) in
          let is_less := M.alloc (| is_less |) in
          M.read (|
            M.match_operator (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "swap", [] |),
                    [ M.read (| v |); Value.Integer 0; M.read (| pivot |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "split_at_mut",
                      []
                    |),
                    [ M.read (| v |); Value.Integer 1 ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let pivot := M.copy (| γ0_0 |) in
                      let v := M.copy (| γ0_1 |) in
                      let~ pivot :=
                        M.alloc (|
                          M.SubPointer.get_array_field (|
                            M.read (| pivot |),
                            M.alloc (| Value.Integer 0 |)
                          |)
                        |) in
                      let~ tmp :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ T ],
                              "new",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_function (| "core::ptr::read", [ T ] |),
                                [ M.read (| pivot |) ]
                              |)
                            ]
                          |)
                        |) in
                      let~ _pivot_guard :=
                        M.alloc (|
                          Value.StructRecord
                            "core::slice::sort::InsertionHole"
                            [
                              ("src",
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                      []
                                      [ T ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [ tmp ]
                                |));
                              ("dest", M.read (| pivot |))
                            ]
                        |) in
                      let~ pivot :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ T ],
                              [],
                              "deref",
                              []
                            |),
                            [ tmp ]
                          |)
                        |) in
                      let~ l := M.alloc (| Value.Integer 0 |) in
                      let~ r :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "len",
                              []
                            |),
                            [ M.read (| v |) ]
                          |)
                        |) in
                      let~ _ :=
                        let~ _ :=
                          M.loop (|
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            LogicalOp.and (|
                                              BinOp.Pure.lt (M.read (| l |)) (M.read (| r |)),
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::function::FnMut",
                                                    F,
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply (Ty.path "&") [] [ T ];
                                                          Ty.apply (Ty.path "&") [] [ T ]
                                                        ]
                                                    ],
                                                    "call_mut",
                                                    []
                                                  |),
                                                  [
                                                    M.read (| is_less |);
                                                    Value.Tuple
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            "get_unchecked",
                                                            [ Ty.path "usize" ]
                                                          |),
                                                          [ M.read (| v |); M.read (| l |) ]
                                                        |);
                                                        M.read (| pivot |)
                                                      ]
                                                  ]
                                                |)))
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ :=
                                        let β := l in
                                        M.write (|
                                          β,
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| β |))
                                            (Value.Integer 1)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let~ _ :=
                                              M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |)))
                          |) in
                        M.loop (|
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          LogicalOp.and (|
                                            BinOp.Pure.lt (M.read (| l |)) (M.read (| r |)),
                                            ltac:(M.monadic
                                              (UnOp.Pure.not
                                                (M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::function::FnMut",
                                                    F,
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply (Ty.path "&") [] [ T ];
                                                          Ty.apply (Ty.path "&") [] [ T ]
                                                        ]
                                                    ],
                                                    "call_mut",
                                                    []
                                                  |),
                                                  [
                                                    M.read (| is_less |);
                                                    Value.Tuple
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            "get_unchecked",
                                                            [ Ty.path "usize" ]
                                                          |),
                                                          [
                                                            M.read (| v |);
                                                            BinOp.Wrap.sub
                                                              Integer.Usize
                                                              (M.read (| r |))
                                                              (Value.Integer 1)
                                                          ]
                                                        |);
                                                        M.read (| pivot |)
                                                      ]
                                                  ]
                                                |))))
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ _ :=
                                      let β := r in
                                      M.write (|
                                        β,
                                        BinOp.Wrap.sub
                                          Integer.Usize
                                          (M.read (| β |))
                                          (Value.Integer 1)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            BinOp.Wrap.add
                              Integer.Usize
                              (M.read (| l |))
                              (M.call_closure (|
                                M.get_function (|
                                  "core::slice::sort::partition_in_blocks",
                                  [ T; F ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::index::IndexMut",
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                      "index_mut",
                                      []
                                    |),
                                    [
                                      M.read (| v |);
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [ ("start", M.read (| l |)); ("end_", M.read (| r |)) ]
                                    ]
                                  |);
                                  M.read (| pivot |);
                                  M.read (| is_less |)
                                ]
                              |));
                            BinOp.Pure.ge (M.read (| l |)) (M.read (| r |))
                          ]
                      |)))
                ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let mid := M.copy (| γ0_0 |) in
                    let was_partitioned := M.copy (| γ0_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "swap",
                            []
                          |),
                          [ M.read (| v |); Value.Integer 0; M.read (| mid |) ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [ M.read (| mid |); M.read (| was_partitioned |) ] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_partition : M.IsFunction "core::slice::sort::partition" partition.
    
    (*
    pub(super) fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize
    where
        F: FnMut(&T, &T) -> bool,
    {
        // Place the pivot at the beginning of slice.
        v.swap(0, pivot);
        let (pivot, v) = v.split_at_mut(1);
        let pivot = &mut pivot[0];
    
        // Read the pivot into a stack-allocated variable for efficiency. If a following comparison
        // operation panics, the pivot will be automatically written back into the slice.
        // SAFETY: The pointer here is valid because it is obtained from a reference to a slice.
        let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });
        let _pivot_guard = InsertionHole { src: &*tmp, dest: pivot };
        let pivot = &*tmp;
    
        let len = v.len();
        if len == 0 {
            return 0;
        }
    
        // Now partition the slice.
        let mut l = 0;
        let mut r = len;
        loop {
            // SAFETY: The unsafety below involves indexing an array.
            // For the first one: We already do the bounds checking here with `l < r`.
            // For the second one: We initially have `l == 0` and `r == v.len()` and we checked that `l < r` at every indexing operation.
            //                     From here we know that `r` must be at least `r == l` which was shown to be valid from the first one.
            unsafe {
                // Find the first element greater than the pivot.
                while l < r && !is_less(pivot, v.get_unchecked(l)) {
                    l += 1;
                }
    
                // Find the last element equal to the pivot.
                loop {
                    r -= 1;
                    if l >= r || !is_less(pivot, v.get_unchecked(r)) {
                        break;
                    }
                }
    
                // Are we done?
                if l >= r {
                    break;
                }
    
                // Swap the found pair of out-of-order elements.
                let ptr = v.as_mut_ptr();
                ptr::swap(ptr.add(l), ptr.add(r));
                l += 1;
            }
        }
    
        // We found `l` elements equal to the pivot. Add 1 to account for the pivot itself.
        l + 1
    
        // `_pivot_guard` goes out of scope and writes the pivot (which is a stack-allocated variable)
        // back into the slice where it originally was. This step is critical in ensuring safety!
    }
    *)
    Definition partition_equal (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; pivot; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let pivot := M.alloc (| pivot |) in
          let is_less := M.alloc (| is_less |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "swap",
                        []
                      |),
                      [ M.read (| v |); Value.Integer 0; M.read (| pivot |) ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "split_at_mut",
                        []
                      |),
                      [ M.read (| v |); Value.Integer 1 ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let pivot := M.copy (| γ0_0 |) in
                        let v := M.copy (| γ0_1 |) in
                        let~ pivot :=
                          M.alloc (|
                            M.SubPointer.get_array_field (|
                              M.read (| pivot |),
                              M.alloc (| Value.Integer 0 |)
                            |)
                          |) in
                        let~ tmp :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [ T ],
                                "new",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_function (| "core::ptr::read", [ T ] |),
                                  [ M.read (| pivot |) ]
                                |)
                              ]
                            |)
                          |) in
                        let~ _pivot_guard :=
                          M.alloc (|
                            Value.StructRecord
                              "core::slice::sort::InsertionHole"
                              [
                                ("src",
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                        []
                                        [ T ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [ tmp ]
                                  |));
                                ("dest", M.read (| pivot |))
                              ]
                          |) in
                        let~ pivot :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [ T ],
                                [],
                                "deref",
                                []
                              |),
                              [ tmp ]
                            |)
                          |) in
                        let~ len :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| v |) ]
                            |)
                          |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.eq (M.read (| len |)) (Value.Integer 0)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (| M.return_ (| Value.Integer 0 |) |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        let~ l := M.alloc (| Value.Integer 0 |) in
                        let~ r := M.copy (| len |) in
                        let~ _ :=
                          M.loop (|
                            ltac:(M.monadic
                              (let~ _ :=
                                M.loop (|
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  LogicalOp.and (|
                                                    BinOp.Pure.lt (M.read (| l |)) (M.read (| r |)),
                                                    ltac:(M.monadic
                                                      (UnOp.Pure.not
                                                        (M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::function::FnMut",
                                                            F,
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply (Ty.path "&") [] [ T ];
                                                                  Ty.apply (Ty.path "&") [] [ T ]
                                                                ]
                                                            ],
                                                            "call_mut",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| is_less |);
                                                            Value.Tuple
                                                              [
                                                                M.read (| pivot |);
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ T ],
                                                                    "get_unchecked",
                                                                    [ Ty.path "usize" ]
                                                                  |),
                                                                  [ M.read (| v |); M.read (| l |) ]
                                                                |)
                                                              ]
                                                          ]
                                                        |))))
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            let~ _ :=
                                              let β := l in
                                              M.write (|
                                                β,
                                                BinOp.Wrap.add
                                                  Integer.Usize
                                                  (M.read (| β |))
                                                  (Value.Integer 1)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  let~ _ :=
                                                    M.alloc (|
                                                      M.never_to_any (| M.read (| M.break (||) |) |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |)))
                                |) in
                              let~ _ :=
                                M.loop (|
                                  ltac:(M.monadic
                                    (let~ _ :=
                                      let β := r in
                                      M.write (|
                                        β,
                                        BinOp.Wrap.sub
                                          Integer.Usize
                                          (M.read (| β |))
                                          (Value.Integer 1)
                                      |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  LogicalOp.or (|
                                                    BinOp.Pure.ge (M.read (| l |)) (M.read (| r |)),
                                                    ltac:(M.monadic
                                                      (UnOp.Pure.not
                                                        (M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::function::FnMut",
                                                            F,
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply (Ty.path "&") [] [ T ];
                                                                  Ty.apply (Ty.path "&") [] [ T ]
                                                                ]
                                                            ],
                                                            "call_mut",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| is_less |);
                                                            Value.Tuple
                                                              [
                                                                M.read (| pivot |);
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ T ],
                                                                    "get_unchecked",
                                                                    [ Ty.path "usize" ]
                                                                  |),
                                                                  [ M.read (| v |); M.read (| r |) ]
                                                                |)
                                                              ]
                                                          ]
                                                        |))))
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |)))
                                |) in
                              let~ _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.Pure.ge (M.read (| l |)) (M.read (| r |))
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ ptr :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ T ],
                                      "as_mut_ptr",
                                      []
                                    |),
                                    [ M.read (| v |) ]
                                  |)
                                |) in
                              let~ _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::ptr::swap", [ T ] |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                          "add",
                                          []
                                        |),
                                        [ M.read (| ptr |); M.read (| l |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                          "add",
                                          []
                                        |),
                                        [ M.read (| ptr |); M.read (| r |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ _ :=
                                let β := l in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add Integer.Usize (M.read (| β |)) (Value.Integer 1)
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |) in
                        M.alloc (|
                          BinOp.Wrap.add Integer.Usize (M.read (| l |)) (Value.Integer 1)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_partition_equal :
      M.IsFunction "core::slice::sort::partition_equal" partition_equal.
    
    (*
    pub(super) fn break_patterns<T>(v: &mut [T]) {
        let len = v.len();
        if len >= 8 {
            let mut seed = len;
            let mut gen_usize = || {
                // Pseudorandom number generator from the "Xorshift RNGs" paper by George Marsaglia.
                if usize::BITS <= 32 {
                    let mut r = seed as u32;
                    r ^= r << 13;
                    r ^= r >> 17;
                    r ^= r << 5;
                    seed = r as usize;
                    seed
                } else {
                    let mut r = seed as u64;
                    r ^= r << 13;
                    r ^= r >> 7;
                    r ^= r << 17;
                    seed = r as usize;
                    seed
                }
            };
    
            // Take random numbers modulo this number.
            // The number fits into `usize` because `len` is not greater than `isize::MAX`.
            let modulus = len.next_power_of_two();
    
            // Some pivot candidates will be in the nearby of this index. Let's randomize them.
            let pos = len / 4 * 2;
    
            for i in 0..3 {
                // Generate a random number modulo `len`. However, in order to avoid costly operations
                // we first take it modulo a power of two, and then decrease by `len` until it fits
                // into the range `[0, len - 1]`.
                let mut other = gen_usize() & (modulus - 1);
    
                // `other` is guaranteed to be less than `2 * len`.
                if other >= len {
                    other -= len;
                }
    
                v.swap(pos - 1 + i, other);
            }
        }
    }
    *)
    Definition break_patterns (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            let~ len :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "len", [] |),
                  [ M.read (| v |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.alloc (| BinOp.Pure.ge (M.read (| len |)) (Value.Integer 8) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ seed := M.copy (| len |) in
                    let~ gen_usize :=
                      M.alloc (|
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.read (|
                                          M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.use
                                                      (M.alloc (|
                                                        BinOp.Pure.le
                                                          (M.read (|
                                                            M.get_constant (| "core::num::BITS" |)
                                                          |))
                                                          (Value.Integer 32)
                                                      |)) in
                                                  let _ :=
                                                    M.is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  let~ r :=
                                                    M.alloc (| M.rust_cast (M.read (| seed |)) |) in
                                                  let~ _ :=
                                                    let β := r in
                                                    M.write (|
                                                      β,
                                                      BinOp.Pure.bit_xor
                                                        (M.read (| β |))
                                                        (BinOp.Wrap.shl
                                                          (M.read (| r |))
                                                          (Value.Integer 13))
                                                    |) in
                                                  let~ _ :=
                                                    let β := r in
                                                    M.write (|
                                                      β,
                                                      BinOp.Pure.bit_xor
                                                        (M.read (| β |))
                                                        (BinOp.Wrap.shr
                                                          (M.read (| r |))
                                                          (Value.Integer 17))
                                                    |) in
                                                  let~ _ :=
                                                    let β := r in
                                                    M.write (|
                                                      β,
                                                      BinOp.Pure.bit_xor
                                                        (M.read (| β |))
                                                        (BinOp.Wrap.shl
                                                          (M.read (| r |))
                                                          (Value.Integer 5))
                                                    |) in
                                                  let~ _ :=
                                                    M.write (|
                                                      seed,
                                                      M.rust_cast (M.read (| r |))
                                                    |) in
                                                  seed));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let~ r :=
                                                    M.alloc (| M.rust_cast (M.read (| seed |)) |) in
                                                  let~ _ :=
                                                    let β := r in
                                                    M.write (|
                                                      β,
                                                      BinOp.Pure.bit_xor
                                                        (M.read (| β |))
                                                        (BinOp.Wrap.shl
                                                          (M.read (| r |))
                                                          (Value.Integer 13))
                                                    |) in
                                                  let~ _ :=
                                                    let β := r in
                                                    M.write (|
                                                      β,
                                                      BinOp.Pure.bit_xor
                                                        (M.read (| β |))
                                                        (BinOp.Wrap.shr
                                                          (M.read (| r |))
                                                          (Value.Integer 7))
                                                    |) in
                                                  let~ _ :=
                                                    let β := r in
                                                    M.write (|
                                                      β,
                                                      BinOp.Pure.bit_xor
                                                        (M.read (| β |))
                                                        (BinOp.Wrap.shl
                                                          (M.read (| r |))
                                                          (Value.Integer 17))
                                                    |) in
                                                  let~ _ :=
                                                    M.write (|
                                                      seed,
                                                      M.rust_cast (M.read (| r |))
                                                    |) in
                                                  seed))
                                            ]
                                          |)
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      |) in
                    let~ modulus :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "usize", "next_power_of_two", [] |),
                          [ M.read (| len |) ]
                        |)
                      |) in
                    let~ pos :=
                      M.alloc (|
                        BinOp.Wrap.mul
                          Integer.Usize
                          (BinOp.Wrap.div Integer.Usize (M.read (| len |)) (Value.Integer 4))
                          (Value.Integer 2)
                      |) in
                    M.use
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              [],
                              "into_iter",
                              []
                            |),
                            [
                              Value.StructRecord
                                "core::ops::range::Range"
                                [ ("start", Value.Integer 0); ("end_", Value.Integer 3) ]
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                ltac:(M.monadic
                                  (let~ _ :=
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let i := M.copy (| γ0_0 |) in
                                            let~ other :=
                                              M.alloc (|
                                                BinOp.Pure.bit_and
                                                  (M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      Ty.function [ Ty.tuple [] ] (Ty.path "usize"),
                                                      [ Ty.tuple [] ],
                                                      "call_mut",
                                                      []
                                                    |),
                                                    [ gen_usize; Value.Tuple [] ]
                                                  |))
                                                  (BinOp.Wrap.sub
                                                    Integer.Usize
                                                    (M.read (| modulus |))
                                                    (Value.Integer 1))
                                              |) in
                                            let~ _ :=
                                              M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            BinOp.Pure.ge
                                                              (M.read (| other |))
                                                              (M.read (| len |))
                                                          |)) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      let~ _ :=
                                                        let β := other in
                                                        M.write (|
                                                          β,
                                                          BinOp.Wrap.sub
                                                            Integer.Usize
                                                            (M.read (| β |))
                                                            (M.read (| len |))
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |) in
                                            let~ _ :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "slice") [] [ T ],
                                                    "swap",
                                                    []
                                                  |),
                                                  [
                                                    M.read (| v |);
                                                    BinOp.Wrap.add
                                                      Integer.Usize
                                                      (BinOp.Wrap.sub
                                                        Integer.Usize
                                                        (M.read (| pos |))
                                                        (Value.Integer 1))
                                                      (M.read (| i |));
                                                    M.read (| other |)
                                                  ]
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |))));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_break_patterns : M.IsFunction "core::slice::sort::break_patterns" break_patterns.
    
    (*
    pub(super) fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)
    where
        F: FnMut(&T, &T) -> bool,
    {
        // Minimum length to choose the median-of-medians method.
        // Shorter slices use the simple median-of-three method.
        const SHORTEST_MEDIAN_OF_MEDIANS: usize = 50;
        // Maximum number of swaps that can be performed in this function.
        const MAX_SWAPS: usize = 4 * 3;
    
        let len = v.len();
    
        // Three indices near which we are going to choose a pivot.
        let mut a = len / 4 * 1;
        let mut b = len / 4 * 2;
        let mut c = len / 4 * 3;
    
        // Counts the total number of swaps we are about to perform while sorting indices.
        let mut swaps = 0;
    
        if len >= 8 {
            // Swaps indices so that `v[a] <= v[b]`.
            // SAFETY: `len >= 8` so there are at least two elements in the neighborhoods of
            // `a`, `b` and `c`. This means the three calls to `sort_adjacent` result in
            // corresponding calls to `sort3` with valid 3-item neighborhoods around each
            // pointer, which in turn means the calls to `sort2` are done with valid
            // references. Thus the `v.get_unchecked` calls are safe, as is the `ptr::swap`
            // call.
            let mut sort2 = |a: &mut usize, b: &mut usize| unsafe {
                if is_less(v.get_unchecked( *b), v.get_unchecked( *a)) {
                    ptr::swap(a, b);
                    swaps += 1;
                }
            };
    
            // Swaps indices so that `v[a] <= v[b] <= v[c]`.
            let mut sort3 = |a: &mut usize, b: &mut usize, c: &mut usize| {
                sort2(a, b);
                sort2(b, c);
                sort2(a, b);
            };
    
            if len >= SHORTEST_MEDIAN_OF_MEDIANS {
                // Finds the median of `v[a - 1], v[a], v[a + 1]` and stores the index into `a`.
                let mut sort_adjacent = |a: &mut usize| {
                    let tmp = *a;
                    sort3(&mut (tmp - 1), a, &mut (tmp + 1));
                };
    
                // Find medians in the neighborhoods of `a`, `b`, and `c`.
                sort_adjacent(&mut a);
                sort_adjacent(&mut b);
                sort_adjacent(&mut c);
            }
    
            // Find the median among `a`, `b`, and `c`.
            sort3(&mut a, &mut b, &mut c);
        }
    
        if swaps < MAX_SWAPS {
            (b, swaps == 0)
        } else {
            // The maximum number of swaps was performed. Chances are the slice is descending or mostly
            // descending, so reversing will probably help sort it faster.
            v.reverse();
            (len - 1 - b, true)
        }
    }
    *)
    Definition choose_pivot (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let is_less := M.alloc (| is_less |) in
          M.read (|
            let~ len :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "len", [] |),
                  [ M.read (| v |) ]
                |)
              |) in
            let~ a :=
              M.alloc (|
                BinOp.Wrap.mul
                  Integer.Usize
                  (BinOp.Wrap.div Integer.Usize (M.read (| len |)) (Value.Integer 4))
                  (Value.Integer 1)
              |) in
            let~ b :=
              M.alloc (|
                BinOp.Wrap.mul
                  Integer.Usize
                  (BinOp.Wrap.div Integer.Usize (M.read (| len |)) (Value.Integer 4))
                  (Value.Integer 2)
              |) in
            let~ c :=
              M.alloc (|
                BinOp.Wrap.mul
                  Integer.Usize
                  (BinOp.Wrap.div Integer.Usize (M.read (| len |)) (Value.Integer 4))
                  (Value.Integer 3)
              |) in
            let~ swaps := M.alloc (| Value.Integer 0 |) in
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.ge (M.read (| len |)) (Value.Integer 8) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ sort2 :=
                        M.alloc (|
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0; α1 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let a := M.copy (| γ |) in
                                          M.match_operator (|
                                            M.alloc (| α1 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let b := M.copy (| γ |) in
                                                  M.read (|
                                                    M.match_operator (|
                                                      M.alloc (| Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::ops::function::FnMut",
                                                                      F,
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ T ];
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ T ]
                                                                          ]
                                                                      ],
                                                                      "call_mut",
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.read (| is_less |);
                                                                      Value.Tuple
                                                                        [
                                                                          M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.apply
                                                                                (Ty.path "slice")
                                                                                []
                                                                                [ T ],
                                                                              "get_unchecked",
                                                                              [ Ty.path "usize" ]
                                                                            |),
                                                                            [
                                                                              M.read (| v |);
                                                                              M.read (|
                                                                                M.read (| b |)
                                                                              |)
                                                                            ]
                                                                          |);
                                                                          M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.apply
                                                                                (Ty.path "slice")
                                                                                []
                                                                                [ T ],
                                                                              "get_unchecked",
                                                                              [ Ty.path "usize" ]
                                                                            |),
                                                                            [
                                                                              M.read (| v |);
                                                                              M.read (|
                                                                                M.read (| a |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                    ]
                                                                  |)
                                                                |)) in
                                                            let _ :=
                                                              M.is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            let~ _ :=
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_function (|
                                                                    "core::ptr::swap",
                                                                    [ Ty.path "usize" ]
                                                                  |),
                                                                  [ M.read (| a |); M.read (| b |) ]
                                                                |)
                                                              |) in
                                                            let~ _ :=
                                                              let β := swaps in
                                                              M.write (|
                                                                β,
                                                                BinOp.Wrap.add
                                                                  Integer.Usize
                                                                  (M.read (| β |))
                                                                  (Value.Integer 1)
                                                              |) in
                                                            M.alloc (| Value.Tuple [] |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |)
                                                  |)))
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        |) in
                      let~ sort3 :=
                        M.alloc (|
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0; α1; α2 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let a := M.copy (| γ |) in
                                          M.match_operator (|
                                            M.alloc (| α1 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let b := M.copy (| γ |) in
                                                  M.match_operator (|
                                                    M.alloc (| α2 |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let c := M.copy (| γ |) in
                                                          M.read (|
                                                            let~ _ :=
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::function::FnMut",
                                                                    Ty.function
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&mut")
                                                                              []
                                                                              [ Ty.path "usize" ];
                                                                            Ty.apply
                                                                              (Ty.path "&mut")
                                                                              []
                                                                              [ Ty.path "usize" ]
                                                                          ]
                                                                      ]
                                                                      (Ty.tuple []),
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&mut")
                                                                            []
                                                                            [ Ty.path "usize" ];
                                                                          Ty.apply
                                                                            (Ty.path "&mut")
                                                                            []
                                                                            [ Ty.path "usize" ]
                                                                        ]
                                                                    ],
                                                                    "call_mut",
                                                                    []
                                                                  |),
                                                                  [
                                                                    sort2;
                                                                    Value.Tuple
                                                                      [
                                                                        M.read (| a |);
                                                                        M.read (| b |)
                                                                      ]
                                                                  ]
                                                                |)
                                                              |) in
                                                            let~ _ :=
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::function::FnMut",
                                                                    Ty.function
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&mut")
                                                                              []
                                                                              [ Ty.path "usize" ];
                                                                            Ty.apply
                                                                              (Ty.path "&mut")
                                                                              []
                                                                              [ Ty.path "usize" ]
                                                                          ]
                                                                      ]
                                                                      (Ty.tuple []),
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&mut")
                                                                            []
                                                                            [ Ty.path "usize" ];
                                                                          Ty.apply
                                                                            (Ty.path "&mut")
                                                                            []
                                                                            [ Ty.path "usize" ]
                                                                        ]
                                                                    ],
                                                                    "call_mut",
                                                                    []
                                                                  |),
                                                                  [
                                                                    sort2;
                                                                    Value.Tuple
                                                                      [
                                                                        M.read (| b |);
                                                                        M.read (| c |)
                                                                      ]
                                                                  ]
                                                                |)
                                                              |) in
                                                            let~ _ :=
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::function::FnMut",
                                                                    Ty.function
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&mut")
                                                                              []
                                                                              [ Ty.path "usize" ];
                                                                            Ty.apply
                                                                              (Ty.path "&mut")
                                                                              []
                                                                              [ Ty.path "usize" ]
                                                                          ]
                                                                      ]
                                                                      (Ty.tuple []),
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&mut")
                                                                            []
                                                                            [ Ty.path "usize" ];
                                                                          Ty.apply
                                                                            (Ty.path "&mut")
                                                                            []
                                                                            [ Ty.path "usize" ]
                                                                        ]
                                                                    ],
                                                                    "call_mut",
                                                                    []
                                                                  |),
                                                                  [
                                                                    sort2;
                                                                    Value.Tuple
                                                                      [
                                                                        M.read (| a |);
                                                                        M.read (| b |)
                                                                      ]
                                                                  ]
                                                                |)
                                                              |) in
                                                            M.alloc (| Value.Tuple [] |)
                                                          |)))
                                                    ]
                                                  |)))
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        |) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      BinOp.Pure.ge
                                        (M.read (| len |))
                                        (M.read (|
                                          M.get_constant (|
                                            "core::slice::sort::choose_pivot::SHORTEST_MEDIAN_OF_MEDIANS"
                                          |)
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ sort_adjacent :=
                                  M.alloc (|
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let a := M.copy (| γ |) in
                                                    M.read (|
                                                      let~ tmp := M.copy (| M.read (| a |) |) in
                                                      let~ _ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::function::FnMut",
                                                              Ty.function
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&mut")
                                                                        []
                                                                        [ Ty.path "usize" ];
                                                                      Ty.apply
                                                                        (Ty.path "&mut")
                                                                        []
                                                                        [ Ty.path "usize" ];
                                                                      Ty.apply
                                                                        (Ty.path "&mut")
                                                                        []
                                                                        [ Ty.path "usize" ]
                                                                    ]
                                                                ]
                                                                (Ty.tuple []),
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&mut")
                                                                      []
                                                                      [ Ty.path "usize" ];
                                                                    Ty.apply
                                                                      (Ty.path "&mut")
                                                                      []
                                                                      [ Ty.path "usize" ];
                                                                    Ty.apply
                                                                      (Ty.path "&mut")
                                                                      []
                                                                      [ Ty.path "usize" ]
                                                                  ]
                                                              ],
                                                              "call_mut",
                                                              []
                                                            |),
                                                            [
                                                              sort3;
                                                              Value.Tuple
                                                                [
                                                                  M.alloc (|
                                                                    BinOp.Wrap.sub
                                                                      Integer.Usize
                                                                      (M.read (| tmp |))
                                                                      (Value.Integer 1)
                                                                  |);
                                                                  M.read (| a |);
                                                                  M.alloc (|
                                                                    BinOp.Wrap.add
                                                                      Integer.Usize
                                                                      (M.read (| tmp |))
                                                                      (Value.Integer 1)
                                                                  |)
                                                                ]
                                                            ]
                                                          |)
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  |) in
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ] ]
                                          ]
                                          (Ty.tuple []),
                                        [
                                          Ty.tuple
                                            [ Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ] ]
                                        ],
                                        "call_mut",
                                        []
                                      |),
                                      [ sort_adjacent; Value.Tuple [ a ] ]
                                    |)
                                  |) in
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ] ]
                                          ]
                                          (Ty.tuple []),
                                        [
                                          Ty.tuple
                                            [ Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ] ]
                                        ],
                                        "call_mut",
                                        []
                                      |),
                                      [ sort_adjacent; Value.Tuple [ b ] ]
                                    |)
                                  |) in
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ] ]
                                          ]
                                          (Ty.tuple []),
                                        [
                                          Ty.tuple
                                            [ Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ] ]
                                        ],
                                        "call_mut",
                                        []
                                      |),
                                      [ sort_adjacent; Value.Tuple [ c ] ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::function::FnMut",
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ];
                                      Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ];
                                      Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ]
                                    ]
                                ]
                                (Ty.tuple []),
                              [
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ];
                                    Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ];
                                    Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ]
                                  ]
                              ],
                              "call_mut",
                              []
                            |),
                            [ sort3; Value.Tuple [ a; b; c ] ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.lt
                            (M.read (| swaps |))
                            (M.read (|
                              M.get_constant (| "core::slice::sort::choose_pivot::MAX_SWAPS" |)
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.Tuple
                        [ M.read (| b |); BinOp.Pure.eq (M.read (| swaps |)) (Value.Integer 0) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "reverse",
                            []
                          |),
                          [ M.read (| v |) ]
                        |)
                      |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          BinOp.Wrap.sub
                            Integer.Usize
                            (BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (Value.Integer 1))
                            (M.read (| b |));
                          Value.Bool true
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_choose_pivot : M.IsFunction "core::slice::sort::choose_pivot" choose_pivot.
    
    Module choose_pivot.
      Definition value_SHORTEST_MEDIAN_OF_MEDIANS : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer 50 |))).
      
      Definition value_MAX_SWAPS : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (| BinOp.Wrap.mul Integer.Usize (Value.Integer 4) (Value.Integer 3) |))).
    End choose_pivot.
    
    (*
    fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: u32)
    where
        F: FnMut(&T, &T) -> bool,
    {
        // Slices of up to this length get sorted using insertion sort.
        const MAX_INSERTION: usize = 20;
    
        // True if the last partitioning was reasonably balanced.
        let mut was_balanced = true;
        // True if the last partitioning didn't shuffle elements (the slice was already partitioned).
        let mut was_partitioned = true;
    
        loop {
            let len = v.len();
    
            // Very short slices get sorted using insertion sort.
            if len <= MAX_INSERTION {
                if len >= 2 {
                    insertion_sort_shift_left(v, 1, is_less);
                }
                return;
            }
    
            // If too many bad pivot choices were made, simply fall back to heapsort in order to
            // guarantee `O(n * log(n))` worst-case.
            if limit == 0 {
                heapsort(v, is_less);
                return;
            }
    
            // If the last partitioning was imbalanced, try breaking patterns in the slice by shuffling
            // some elements around. Hopefully we'll choose a better pivot this time.
            if !was_balanced {
                break_patterns(v);
                limit -= 1;
            }
    
            // Choose a pivot and try guessing whether the slice is already sorted.
            let (pivot, likely_sorted) = choose_pivot(v, is_less);
    
            // If the last partitioning was decently balanced and didn't shuffle elements, and if pivot
            // selection predicts the slice is likely already sorted...
            if was_balanced && was_partitioned && likely_sorted {
                // Try identifying several out-of-order elements and shifting them to correct
                // positions. If the slice ends up being completely sorted, we're done.
                if partial_insertion_sort(v, is_less) {
                    return;
                }
            }
    
            // If the chosen pivot is equal to the predecessor, then it's the smallest element in the
            // slice. Partition the slice into elements equal to and elements greater than the pivot.
            // This case is usually hit when the slice contains many duplicate elements.
            if let Some(p) = pred {
                if !is_less(p, &v[pivot]) {
                    let mid = partition_equal(v, pivot, is_less);
    
                    // Continue sorting elements greater than the pivot.
                    v = &mut v[mid..];
                    continue;
                }
            }
    
            // Partition the slice.
            let (mid, was_p) = partition(v, pivot, is_less);
            was_balanced = cmp::min(mid, len - mid) >= len / 8;
            was_partitioned = was_p;
    
            // Split the slice into `left`, `pivot`, and `right`.
            let (left, right) = v.split_at_mut(mid);
            let (pivot, right) = right.split_at_mut(1);
            let pivot = &pivot[0];
    
            // Recurse into the shorter side only in order to minimize the total number of recursive
            // calls and consume less stack space. Then just continue with the longer side (this is
            // akin to tail recursion).
            if left.len() < right.len() {
                recurse(left, is_less, pred, limit);
                v = right;
                pred = Some(pivot);
            } else {
                recurse(right, is_less, Some(pivot), limit);
                v = left;
            }
        }
    }
    *)
    Definition recurse (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; is_less; pred; limit ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let is_less := M.alloc (| is_less |) in
          let pred := M.alloc (| pred |) in
          let limit := M.alloc (| limit |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ was_balanced := M.alloc (| Value.Bool true |) in
                let~ was_partitioned := M.alloc (| Value.Bool true |) in
                M.alloc (|
                  M.never_to_any (|
                    M.read (|
                      M.loop (|
                        ltac:(M.monadic
                          (let~ len :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  []
                                |),
                                [ M.read (| v |) ]
                              |)
                            |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          BinOp.Pure.le
                                            (M.read (| len |))
                                            (M.read (|
                                              M.get_constant (|
                                                "core::slice::sort::recurse::MAX_INSERTION"
                                              |)
                                            |))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ :=
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          BinOp.Pure.ge
                                                            (M.read (| len |))
                                                            (Value.Integer 2)
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    let~ _ :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_function (|
                                                            "core::slice::sort::insertion_sort_shift_left",
                                                            [ T; F ]
                                                          |),
                                                          [
                                                            M.read (| v |);
                                                            Value.Integer 1;
                                                            M.read (| is_less |)
                                                          ]
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |) in
                                          M.return_ (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          BinOp.Pure.eq (M.read (| limit |)) (Value.Integer 0)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (|
                                                  "core::slice::sort::heapsort",
                                                  [ T; Ty.apply (Ty.path "&mut") [] [ F ] ]
                                                |),
                                                [ M.read (| v |); M.read (| is_less |) ]
                                              |)
                                            |) in
                                          M.return_ (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (| UnOp.Pure.not (M.read (| was_balanced |)) |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ _ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_function (|
                                            "core::slice::sort::break_patterns",
                                            [ T ]
                                          |),
                                          [ M.read (| v |) ]
                                        |)
                                      |) in
                                    let~ _ :=
                                      let β := limit in
                                      M.write (|
                                        β,
                                        BinOp.Wrap.sub
                                          Integer.U32
                                          (M.read (| β |))
                                          (Value.Integer 1)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::slice::sort::choose_pivot", [ T; F ] |),
                                [ M.read (| v |); M.read (| is_less |) ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let pivot := M.copy (| γ0_0 |) in
                                  let likely_sorted := M.copy (| γ0_1 |) in
                                  let~ _ :=
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  LogicalOp.and (|
                                                    LogicalOp.and (|
                                                      M.read (| was_balanced |),
                                                      ltac:(M.monadic
                                                        (M.read (| was_partitioned |)))
                                                    |),
                                                    ltac:(M.monadic (M.read (| likely_sorted |)))
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          M.call_closure (|
                                                            M.get_function (|
                                                              "core::slice::sort::partial_insertion_sort",
                                                              [ T; F ]
                                                            |),
                                                            [ M.read (| v |); M.read (| is_less |) ]
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (| M.return_ (| Value.Tuple [] |) |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  let~ _ :=
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ := pred in
                                            let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let p := M.copy (| γ0_0 |) in
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          UnOp.Pure.not
                                                            (M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::function::FnMut",
                                                                F,
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ T ];
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ T ]
                                                                    ]
                                                                ],
                                                                "call_mut",
                                                                []
                                                              |),
                                                              [
                                                                M.read (| is_less |);
                                                                Value.Tuple
                                                                  [
                                                                    M.read (| p |);
                                                                    M.SubPointer.get_array_field (|
                                                                      M.read (| v |),
                                                                      pivot
                                                                    |)
                                                                  ]
                                                              ]
                                                            |))
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          let~ mid :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_function (|
                                                                  "core::slice::sort::partition_equal",
                                                                  [ T; F ]
                                                                |),
                                                                [
                                                                  M.read (| v |);
                                                                  M.read (| pivot |);
                                                                  M.read (| is_less |)
                                                                ]
                                                              |)
                                                            |) in
                                                          let~ _ :=
                                                            M.write (|
                                                              v,
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::index::IndexMut",
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    []
                                                                    [ T ],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::ops::range::RangeFrom")
                                                                      []
                                                                      [ Ty.path "usize" ]
                                                                  ],
                                                                  "index_mut",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| v |);
                                                                  Value.StructRecord
                                                                    "core::ops::range::RangeFrom"
                                                                    [ ("start", M.read (| mid |)) ]
                                                                ]
                                                              |)
                                                            |) in
                                                          M.continue (||)
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_function (|
                                          "core::slice::sort::partition",
                                          [ T; F ]
                                        |),
                                        [ M.read (| v |); M.read (| pivot |); M.read (| is_less |) ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                          let mid := M.copy (| γ0_0 |) in
                                          let was_p := M.copy (| γ0_1 |) in
                                          let~ _ :=
                                            M.write (|
                                              was_balanced,
                                              BinOp.Pure.ge
                                                (M.call_closure (|
                                                  M.get_function (|
                                                    "core::cmp::min",
                                                    [ Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.read (| mid |);
                                                    BinOp.Wrap.sub
                                                      Integer.Usize
                                                      (M.read (| len |))
                                                      (M.read (| mid |))
                                                  ]
                                                |))
                                                (BinOp.Wrap.div
                                                  Integer.Usize
                                                  (M.read (| len |))
                                                  (Value.Integer 8))
                                            |) in
                                          let~ _ :=
                                            M.write (| was_partitioned, M.read (| was_p |) |) in
                                          M.match_operator (|
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "slice") [] [ T ],
                                                  "split_at_mut",
                                                  []
                                                |),
                                                [ M.read (| v |); M.read (| mid |) ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                  let γ0_1 :=
                                                    M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                  let left := M.copy (| γ0_0 |) in
                                                  let right := M.copy (| γ0_1 |) in
                                                  M.match_operator (|
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply (Ty.path "slice") [] [ T ],
                                                          "split_at_mut",
                                                          []
                                                        |),
                                                        [ M.read (| right |); Value.Integer 1 ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ0_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let pivot := M.copy (| γ0_0 |) in
                                                          let right := M.copy (| γ0_1 |) in
                                                          let~ pivot :=
                                                            M.alloc (|
                                                              M.SubPointer.get_array_field (|
                                                                M.read (| pivot |),
                                                                M.alloc (| Value.Integer 0 |)
                                                              |)
                                                            |) in
                                                          M.match_operator (|
                                                            M.alloc (| Value.Tuple [] |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ :=
                                                                    M.use
                                                                      (M.alloc (|
                                                                        BinOp.Pure.lt
                                                                          (M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.apply
                                                                                (Ty.path "slice")
                                                                                []
                                                                                [ T ],
                                                                              "len",
                                                                              []
                                                                            |),
                                                                            [ M.read (| left |) ]
                                                                          |))
                                                                          (M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.apply
                                                                                (Ty.path "slice")
                                                                                []
                                                                                [ T ],
                                                                              "len",
                                                                              []
                                                                            |),
                                                                            [ M.read (| right |) ]
                                                                          |))
                                                                      |)) in
                                                                  let _ :=
                                                                    M.is_constant_or_break_match (|
                                                                      M.read (| γ |),
                                                                      Value.Bool true
                                                                    |) in
                                                                  let~ _ :=
                                                                    M.alloc (|
                                                                      M.call_closure (|
                                                                        M.get_function (|
                                                                          "core::slice::sort::recurse",
                                                                          [ T; F ]
                                                                        |),
                                                                        [
                                                                          M.read (| left |);
                                                                          M.read (| is_less |);
                                                                          M.read (| pred |);
                                                                          M.read (| limit |)
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      v,
                                                                      M.read (| right |)
                                                                    |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      pred,
                                                                      Value.StructTuple
                                                                        "core::option::Option::Some"
                                                                        [ M.read (| pivot |) ]
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let~ _ :=
                                                                    M.alloc (|
                                                                      M.call_closure (|
                                                                        M.get_function (|
                                                                          "core::slice::sort::recurse",
                                                                          [ T; F ]
                                                                        |),
                                                                        [
                                                                          M.read (| right |);
                                                                          M.read (| is_less |);
                                                                          Value.StructTuple
                                                                            "core::option::Option::Some"
                                                                            [ M.read (| pivot |) ];
                                                                          M.read (| limit |)
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ _ :=
                                                                    M.write (|
                                                                      v,
                                                                      M.read (| left |)
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                            ]
                                                          |)))
                                                    ]
                                                  |)))
                                            ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      |)
                    |)
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_recurse : M.IsFunction "core::slice::sort::recurse" recurse.
    
    Module recurse.
      Definition value_MAX_INSERTION : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer 20 |))).
    End recurse.
    
    (*
    pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)
    where
        F: FnMut(&T, &T) -> bool,
    {
        // Sorting has no meaningful behavior on zero-sized types.
        if T::IS_ZST {
            return;
        }
    
        // Limit the number of imbalanced partitions to `floor(log2(len)) + 1`.
        let limit = usize::BITS - v.len().leading_zeros();
    
        recurse(v, &mut is_less, None, limit);
    }
    *)
    Definition quicksort (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let is_less := M.alloc (| is_less |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ limit :=
                  M.alloc (|
                    BinOp.Wrap.sub
                      Integer.U32
                      (M.read (| M.get_constant (| "core::num::BITS" |) |))
                      (M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "leading_zeros", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ T ],
                              "len",
                              []
                            |),
                            [ M.read (| v |) ]
                          |)
                        ]
                      |))
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::slice::sort::recurse", [ T; F ] |),
                      [
                        M.read (| v |);
                        is_less;
                        Value.StructTuple "core::option::Option::None" [];
                        M.read (| limit |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_quicksort : M.IsFunction "core::slice::sort::quicksort" quicksort.
    
    (*
    unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)
    where
        F: FnMut(&T, &T) -> bool,
    {
        let len = v.len();
        let v = v.as_mut_ptr();
    
        // SAFETY: mid and len must be in-bounds of v.
        let (v_mid, v_end) = unsafe { (v.add(mid), v.add(len)) };
    
        // The merge process first copies the shorter run into `buf`. Then it traces the newly copied
        // run and the longer run forwards (or backwards), comparing their next unconsumed elements and
        // copying the lesser (or greater) one into `v`.
        //
        // As soon as the shorter run is fully consumed, the process is done. If the longer run gets
        // consumed first, then we must copy whatever is left of the shorter run into the remaining
        // hole in `v`.
        //
        // Intermediate state of the process is always tracked by `hole`, which serves two purposes:
        // 1. Protects integrity of `v` from panics in `is_less`.
        // 2. Fills the remaining hole in `v` if the longer run gets consumed first.
        //
        // Panic safety:
        //
        // If `is_less` panics at any point during the process, `hole` will get dropped and fill the
        // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every
        // object it initially held exactly once.
        let mut hole;
    
        if mid <= len - mid {
            // The left run is shorter.
    
            // SAFETY: buf must have enough capacity for `v[..mid]`.
            unsafe {
                ptr::copy_nonoverlapping(v, buf, mid);
                hole = MergeHole { start: buf, end: buf.add(mid), dest: v };
            }
    
            // Initially, these pointers point to the beginnings of their arrays.
            let left = &mut hole.start;
            let mut right = v_mid;
            let out = &mut hole.dest;
    
            while *left < hole.end && right < v_end {
                // Consume the lesser side.
                // If equal, prefer the left run to maintain stability.
    
                // SAFETY: left and right must be valid and part of v same for out.
                unsafe {
                    let is_l = is_less(&*right, &**left);
                    let to_copy = if is_l { right } else { *left };
                    ptr::copy_nonoverlapping(to_copy, *out, 1);
                    *out = out.add(1);
                    right = right.add(is_l as usize);
                    *left = left.add(!is_l as usize);
                }
            }
        } else {
            // The right run is shorter.
    
            // SAFETY: buf must have enough capacity for `v[mid..]`.
            unsafe {
                ptr::copy_nonoverlapping(v_mid, buf, len - mid);
                hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };
            }
    
            // Initially, these pointers point past the ends of their arrays.
            let left = &mut hole.dest;
            let right = &mut hole.end;
            let mut out = v_end;
    
            while v < *left && buf < *right {
                // Consume the greater side.
                // If equal, prefer the right run to maintain stability.
    
                // SAFETY: left and right must be valid and part of v same for out.
                unsafe {
                    let is_l = is_less(&*right.sub(1), &*left.sub(1));
                    *left = left.sub(is_l as usize);
                    *right = right.sub(!is_l as usize);
                    let to_copy = if is_l { *left } else { *right };
                    out = out.sub(1);
                    ptr::copy_nonoverlapping(to_copy, out, 1);
                }
            }
        }
        // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of
        // it will now be copied into the hole in `v`.
    
        // When dropped, copies the range `start..end` into `dest..`.
        struct MergeHole<T> {
            start: *mut T,
            end: *mut T,
            dest: *mut T,
        }
    
        impl<T> Drop for MergeHole<T> {
            fn drop(&mut self) {
                // SAFETY: `T` is not a zero-sized type, and these are pointers into a slice's elements.
                unsafe {
                    let len = self.end.sub_ptr(self.start);
                    ptr::copy_nonoverlapping(self.start, self.dest, len);
                }
            }
        }
    }
    *)
    Definition merge (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; mid; buf; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let mid := M.alloc (| mid |) in
          let buf := M.alloc (| buf |) in
          let is_less := M.alloc (| is_less |) in
          M.read (|
            let~ len :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "len", [] |),
                  [ M.read (| v |) ]
                |)
              |) in
            let~ v :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ T ],
                    "as_mut_ptr",
                    []
                  |),
                  [ M.read (| v |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                Value.Tuple
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "add", [] |),
                      [ M.read (| v |); M.read (| mid |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "add", [] |),
                      [ M.read (| v |); M.read (| len |) ]
                    |)
                  ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let v_mid := M.copy (| γ0_0 |) in
                    let v_end := M.copy (| γ0_1 |) in
                    let~ hole := M.copy (| Value.DeclaredButUndefined |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.le
                                      (M.read (| mid |))
                                      (BinOp.Wrap.sub
                                        Integer.Usize
                                        (M.read (| len |))
                                        (M.read (| mid |)))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::intrinsics::copy_nonoverlapping",
                                        [ T ]
                                      |),
                                      [
                                        (* MutToConstPointer *) M.pointer_coercion (M.read (| v |));
                                        M.read (| buf |);
                                        M.read (| mid |)
                                      ]
                                    |)
                                  |) in
                                let~ _ :=
                                  M.write (|
                                    hole,
                                    Value.StructRecord
                                      "core::slice::sort::merge::MergeHole"
                                      [
                                        ("start", M.read (| buf |));
                                        ("end_",
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ T ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| buf |); M.read (| mid |) ]
                                          |));
                                        ("dest", M.read (| v |))
                                      ]
                                  |) in
                                M.alloc (| Value.Tuple [] |) in
                              let~ left :=
                                M.alloc (|
                                  M.SubPointer.get_struct_record_field (|
                                    hole,
                                    "core::slice::sort::merge::MergeHole",
                                    "start"
                                  |)
                                |) in
                              let~ right := M.copy (| v_mid |) in
                              let~ out :=
                                M.alloc (|
                                  M.SubPointer.get_struct_record_field (|
                                    hole,
                                    "core::slice::sort::merge::MergeHole",
                                    "dest"
                                  |)
                                |) in
                              M.loop (|
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                LogicalOp.and (|
                                                  BinOp.Pure.lt
                                                    (M.read (| M.read (| left |) |))
                                                    (M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        hole,
                                                        "core::slice::sort::merge::MergeHole",
                                                        "end"
                                                      |)
                                                    |)),
                                                  ltac:(M.monadic
                                                    (BinOp.Pure.lt
                                                      (M.read (| right |))
                                                      (M.read (| v_end |))))
                                                |)
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ is_l :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ T ];
                                                        Ty.apply (Ty.path "&") [] [ T ]
                                                      ]
                                                  ],
                                                  "call_mut",
                                                  []
                                                |),
                                                [
                                                  M.read (| is_less |);
                                                  Value.Tuple
                                                    [
                                                      M.read (| right |);
                                                      M.read (| M.read (| left |) |)
                                                    ]
                                                ]
                                              |)
                                            |) in
                                          let~ to_copy :=
                                            M.copy (|
                                              M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ := M.use is_l in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      right));
                                                  fun γ => ltac:(M.monadic (M.read (| left |)))
                                                ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (|
                                                  "core::intrinsics::copy_nonoverlapping",
                                                  [ T ]
                                                |),
                                                [
                                                  (* MutToConstPointer *)
                                                  M.pointer_coercion (M.read (| to_copy |));
                                                  M.read (| M.read (| out |) |);
                                                  Value.Integer 1
                                                ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.write (|
                                              M.read (| out |),
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                                  "add",
                                                  []
                                                |),
                                                [ M.read (| M.read (| out |) |); Value.Integer 1 ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.write (|
                                              right,
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                                  "add",
                                                  []
                                                |),
                                                [
                                                  M.read (| right |);
                                                  M.rust_cast (M.read (| is_l |))
                                                ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.write (|
                                              M.read (| left |),
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                                  "add",
                                                  []
                                                |),
                                                [
                                                  M.read (| M.read (| left |) |);
                                                  M.rust_cast (UnOp.Pure.not (M.read (| is_l |)))
                                                ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                let~ _ :=
                                                  M.alloc (|
                                                    M.never_to_any (| M.read (| M.break (||) |) |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)
                                              |)
                                            |)
                                          |)))
                                    ]
                                  |)))
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ _ :=
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::intrinsics::copy_nonoverlapping",
                                        [ T ]
                                      |),
                                      [
                                        (* MutToConstPointer *)
                                        M.pointer_coercion (M.read (| v_mid |));
                                        M.read (| buf |);
                                        BinOp.Wrap.sub
                                          Integer.Usize
                                          (M.read (| len |))
                                          (M.read (| mid |))
                                      ]
                                    |)
                                  |) in
                                let~ _ :=
                                  M.write (|
                                    hole,
                                    Value.StructRecord
                                      "core::slice::sort::merge::MergeHole"
                                      [
                                        ("start", M.read (| buf |));
                                        ("end_",
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ T ],
                                              "add",
                                              []
                                            |),
                                            [
                                              M.read (| buf |);
                                              BinOp.Wrap.sub
                                                Integer.Usize
                                                (M.read (| len |))
                                                (M.read (| mid |))
                                            ]
                                          |));
                                        ("dest", M.read (| v_mid |))
                                      ]
                                  |) in
                                M.alloc (| Value.Tuple [] |) in
                              let~ left :=
                                M.alloc (|
                                  M.SubPointer.get_struct_record_field (|
                                    hole,
                                    "core::slice::sort::merge::MergeHole",
                                    "dest"
                                  |)
                                |) in
                              let~ right :=
                                M.alloc (|
                                  M.SubPointer.get_struct_record_field (|
                                    hole,
                                    "core::slice::sort::merge::MergeHole",
                                    "end"
                                  |)
                                |) in
                              let~ out := M.copy (| v_end |) in
                              M.loop (|
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                LogicalOp.and (|
                                                  BinOp.Pure.lt
                                                    (M.read (| v |))
                                                    (M.read (| M.read (| left |) |)),
                                                  ltac:(M.monadic
                                                    (BinOp.Pure.lt
                                                      (M.read (| buf |))
                                                      (M.read (| M.read (| right |) |))))
                                                |)
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ is_l :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ T ];
                                                        Ty.apply (Ty.path "&") [] [ T ]
                                                      ]
                                                  ],
                                                  "call_mut",
                                                  []
                                                |),
                                                [
                                                  M.read (| is_less |);
                                                  Value.Tuple
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                                          "sub",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| M.read (| right |) |);
                                                          Value.Integer 1
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                                          "sub",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| M.read (| left |) |);
                                                          Value.Integer 1
                                                        ]
                                                      |)
                                                    ]
                                                ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.write (|
                                              M.read (| left |),
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                                  "sub",
                                                  []
                                                |),
                                                [
                                                  M.read (| M.read (| left |) |);
                                                  M.rust_cast (M.read (| is_l |))
                                                ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.write (|
                                              M.read (| right |),
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                                  "sub",
                                                  []
                                                |),
                                                [
                                                  M.read (| M.read (| right |) |);
                                                  M.rust_cast (UnOp.Pure.not (M.read (| is_l |)))
                                                ]
                                              |)
                                            |) in
                                          let~ to_copy :=
                                            M.copy (|
                                              M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ := M.use is_l in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.read (| left |)));
                                                  fun γ => ltac:(M.monadic (M.read (| right |)))
                                                ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.write (|
                                              out,
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                                  "sub",
                                                  []
                                                |),
                                                [ M.read (| out |); Value.Integer 1 ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (|
                                                  "core::intrinsics::copy_nonoverlapping",
                                                  [ T ]
                                                |),
                                                [
                                                  (* MutToConstPointer *)
                                                  M.pointer_coercion (M.read (| to_copy |));
                                                  M.read (| out |);
                                                  Value.Integer 1
                                                ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                let~ _ :=
                                                  M.alloc (|
                                                    M.never_to_any (| M.read (| M.break (||) |) |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)
                                              |)
                                            |)
                                          |)))
                                    ]
                                  |)))
                              |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_merge : M.IsFunction "core::slice::sort::merge" merge.
    
    Module merge.
      (* StructRecord
        {
          name := "MergeHole";
          const_params := [];
          ty_params := [ "T" ];
          fields :=
            [
              ("start", Ty.apply (Ty.path "*mut") [] [ T ]);
              ("end_", Ty.apply (Ty.path "*mut") [] [ T ]);
              ("dest", Ty.apply (Ty.path "*mut") [] [ T ])
            ];
        } *)
      
      Module Impl_core_ops_drop_Drop_for_core_slice_sort_merge_MergeHole_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "core::slice::sort::merge::MergeHole") [] [ T ].
        
        (*
                fn drop(&mut self) {
                    // SAFETY: `T` is not a zero-sized type, and these are pointers into a slice's elements.
                    unsafe {
                        let len = self.end.sub_ptr(self.start);
                        ptr::copy_nonoverlapping(self.start, self.dest, len);
                    }
                }
        *)
        Definition drop (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "sub_ptr",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::sort::merge::MergeHole",
                            "end"
                          |)
                        |);
                        (* MutToConstPointer *)
                        M.pointer_coercion
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::sort::merge::MergeHole",
                              "start"
                            |)
                          |))
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                      [
                        (* MutToConstPointer *)
                        M.pointer_coercion
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::slice::sort::merge::MergeHole",
                              "start"
                            |)
                          |));
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::sort::merge::MergeHole",
                            "dest"
                          |)
                        |);
                        M.read (| len |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::ops::drop::Drop"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("drop", InstanceField.Method (drop T)) ].
      End Impl_core_ops_drop_Drop_for_core_slice_sort_merge_MergeHole_T.
    End merge.
    
    (*
    pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(
        v: &mut [T],
        is_less: &mut CmpF,
        elem_alloc_fn: ElemAllocF,
        elem_dealloc_fn: ElemDeallocF,
        run_alloc_fn: RunAllocF,
        run_dealloc_fn: RunDeallocF,
    ) where
        CmpF: FnMut(&T, &T) -> bool,
        ElemAllocF: Fn(usize) -> *mut T,
        ElemDeallocF: Fn( *mut T, usize),
        RunAllocF: Fn(usize) -> *mut TimSortRun,
        RunDeallocF: Fn( *mut TimSortRun, usize),
    {
        // Slices of up to this length get sorted using insertion sort.
        const MAX_INSERTION: usize = 20;
    
        // The caller should have already checked that.
        debug_assert!(!T::IS_ZST);
    
        let len = v.len();
    
        // Short arrays get sorted in-place via insertion sort to avoid allocations.
        if len <= MAX_INSERTION {
            if len >= 2 {
                insertion_sort_shift_left(v, 1, is_less);
            }
            return;
        }
    
        // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it
        // shallow copies of the contents of `v` without risking the dtors running on copies if
        // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,
        // which will always have length at most `len / 2`.
        let buf = BufGuard::new(len / 2, elem_alloc_fn, elem_dealloc_fn);
        let buf_ptr = buf.buf_ptr.as_ptr();
    
        let mut runs = RunVec::new(run_alloc_fn, run_dealloc_fn);
    
        let mut end = 0;
        let mut start = 0;
    
        // Scan forward. Memory pre-fetching prefers forward scanning vs backwards scanning, and the
        // code-gen is usually better. For the most sensitive types such as integers, these are merged
        // bidirectionally at once. So there is no benefit in scanning backwards.
        while end < len {
            let (streak_end, was_reversed) = find_streak(&v[start..], is_less);
            end += streak_end;
            if was_reversed {
                v[start..end].reverse();
            }
    
            // Insert some more elements into the run if it's too short. Insertion sort is faster than
            // merge sort on short sequences, so this significantly improves performance.
            end = provide_sorted_batch(v, start, end, is_less);
    
            // Push this run onto the stack.
            runs.push(TimSortRun { start, len: end - start });
            start = end;
    
            // Merge some pairs of adjacent runs to satisfy the invariants.
            while let Some(r) = collapse(runs.as_slice(), len) {
                let left = runs[r];
                let right = runs[r + 1];
                let merge_slice = &mut v[left.start..right.start + right.len];
                // SAFETY: `buf_ptr` must hold enough capacity for the shorter of the two sides, and
                // neither side may be on length 0.
                unsafe {
                    merge(merge_slice, left.len, buf_ptr, is_less);
                }
                runs[r + 1] = TimSortRun { start: left.start, len: left.len + right.len };
                runs.remove(r);
            }
        }
    
        // Finally, exactly one run must remain in the stack.
        debug_assert!(runs.len() == 1 && runs[0].start == 0 && runs[0].len == len);
    
        // Examines the stack of runs and identifies the next pair of runs to merge. More specifically,
        // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the
        // algorithm should continue building a new run instead, `None` is returned.
        //
        // TimSort is infamous for its buggy implementations, as described here:
        // http://envisage-project.eu/timsort-specification-and-verification/
        //
        // The gist of the story is: we must enforce the invariants on the top four runs on the stack.
        // Enforcing them on just top three is not sufficient to ensure that the invariants will still
        // hold for *all* runs in the stack.
        //
        // This function correctly checks invariants for the top four runs. Additionally, if the top
        // run starts at index 0, it will always demand a merge operation until the stack is fully
        // collapsed, in order to complete the sort.
        #[inline]
        fn collapse(runs: &[TimSortRun], stop: usize) -> Option<usize> {
            let n = runs.len();
            if n >= 2
                && (runs[n - 1].start + runs[n - 1].len == stop
                    || runs[n - 2].len <= runs[n - 1].len
                    || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)
                    || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))
            {
                if n >= 3 && runs[n - 3].len < runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }
            } else {
                None
            }
        }
    
        // Extremely basic versions of Vec.
        // Their use is super limited and by having the code here, it allows reuse between the sort
        // implementations.
        struct BufGuard<T, ElemDeallocF>
        where
            ElemDeallocF: Fn( *mut T, usize),
        {
            buf_ptr: ptr::NonNull<T>,
            capacity: usize,
            elem_dealloc_fn: ElemDeallocF,
        }
    
        impl<T, ElemDeallocF> BufGuard<T, ElemDeallocF>
        where
            ElemDeallocF: Fn( *mut T, usize),
        {
            fn new<ElemAllocF>(
                len: usize,
                elem_alloc_fn: ElemAllocF,
                elem_dealloc_fn: ElemDeallocF,
            ) -> Self
            where
                ElemAllocF: Fn(usize) -> *mut T,
            {
                Self {
                    buf_ptr: ptr::NonNull::new(elem_alloc_fn(len)).unwrap(),
                    capacity: len,
                    elem_dealloc_fn,
                }
            }
        }
    
        impl<T, ElemDeallocF> Drop for BufGuard<T, ElemDeallocF>
        where
            ElemDeallocF: Fn( *mut T, usize),
        {
            fn drop(&mut self) {
                (self.elem_dealloc_fn)(self.buf_ptr.as_ptr(), self.capacity);
            }
        }
    
        struct RunVec<RunAllocF, RunDeallocF>
        where
            RunAllocF: Fn(usize) -> *mut TimSortRun,
            RunDeallocF: Fn( *mut TimSortRun, usize),
        {
            buf_ptr: ptr::NonNull<TimSortRun>,
            capacity: usize,
            len: usize,
            run_alloc_fn: RunAllocF,
            run_dealloc_fn: RunDeallocF,
        }
    
        impl<RunAllocF, RunDeallocF> RunVec<RunAllocF, RunDeallocF>
        where
            RunAllocF: Fn(usize) -> *mut TimSortRun,
            RunDeallocF: Fn( *mut TimSortRun, usize),
        {
            fn new(run_alloc_fn: RunAllocF, run_dealloc_fn: RunDeallocF) -> Self {
                // Most slices can be sorted with at most 16 runs in-flight.
                const START_RUN_CAPACITY: usize = 16;
    
                Self {
                    buf_ptr: ptr::NonNull::new(run_alloc_fn(START_RUN_CAPACITY)).unwrap(),
                    capacity: START_RUN_CAPACITY,
                    len: 0,
                    run_alloc_fn,
                    run_dealloc_fn,
                }
            }
    
            fn push(&mut self, val: TimSortRun) {
                if self.len == self.capacity {
                    let old_capacity = self.capacity;
                    let old_buf_ptr = self.buf_ptr.as_ptr();
    
                    self.capacity = self.capacity * 2;
                    self.buf_ptr = ptr::NonNull::new((self.run_alloc_fn)(self.capacity)).unwrap();
    
                    // SAFETY: buf_ptr new and old were correctly allocated and old_buf_ptr has
                    // old_capacity valid elements.
                    unsafe {
                        ptr::copy_nonoverlapping(old_buf_ptr, self.buf_ptr.as_ptr(), old_capacity);
                    }
    
                    (self.run_dealloc_fn)(old_buf_ptr, old_capacity);
                }
    
                // SAFETY: The invariant was just checked.
                unsafe {
                    self.buf_ptr.as_ptr().add(self.len).write(val);
                }
                self.len += 1;
            }
    
            fn remove(&mut self, index: usize) {
                if index >= self.len {
                    panic!("Index out of bounds");
                }
    
                // SAFETY: buf_ptr needs to be valid and len invariant upheld.
                unsafe {
                    // the place we are taking from.
                    let ptr = self.buf_ptr.as_ptr().add(index);
    
                    // Shift everything down to fill in that spot.
                    ptr::copy(ptr.add(1), ptr, self.len - index - 1);
                }
                self.len -= 1;
            }
    
            fn as_slice(&self) -> &[TimSortRun] {
                // SAFETY: Safe as long as buf_ptr is valid and len invariant was upheld.
                unsafe { &*ptr::slice_from_raw_parts(self.buf_ptr.as_ptr(), self.len) }
            }
    
            fn len(&self) -> usize {
                self.len
            }
        }
    
        impl<RunAllocF, RunDeallocF> core::ops::Index<usize> for RunVec<RunAllocF, RunDeallocF>
        where
            RunAllocF: Fn(usize) -> *mut TimSortRun,
            RunDeallocF: Fn( *mut TimSortRun, usize),
        {
            type Output = TimSortRun;
    
            fn index(&self, index: usize) -> &Self::Output {
                if index < self.len {
                    // SAFETY: buf_ptr and len invariant must be upheld.
                    unsafe {
                        return &*(self.buf_ptr.as_ptr().add(index));
                    }
                }
    
                panic!("Index out of bounds");
            }
        }
    
        impl<RunAllocF, RunDeallocF> core::ops::IndexMut<usize> for RunVec<RunAllocF, RunDeallocF>
        where
            RunAllocF: Fn(usize) -> *mut TimSortRun,
            RunDeallocF: Fn( *mut TimSortRun, usize),
        {
            fn index_mut(&mut self, index: usize) -> &mut Self::Output {
                if index < self.len {
                    // SAFETY: buf_ptr and len invariant must be upheld.
                    unsafe {
                        return &mut *(self.buf_ptr.as_ptr().add(index));
                    }
                }
    
                panic!("Index out of bounds");
            }
        }
    
        impl<RunAllocF, RunDeallocF> Drop for RunVec<RunAllocF, RunDeallocF>
        where
            RunAllocF: Fn(usize) -> *mut TimSortRun,
            RunDeallocF: Fn( *mut TimSortRun, usize),
        {
            fn drop(&mut self) {
                // As long as TimSortRun is Copy we don't need to drop them individually but just the
                // whole allocation.
                (self.run_dealloc_fn)(self.buf_ptr.as_ptr(), self.capacity);
            }
        }
    }
    *)
    Definition merge_sort (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [],
          [ T; CmpF; ElemAllocF; ElemDeallocF; RunAllocF; RunDeallocF ],
          [ v; is_less; elem_alloc_fn; elem_dealloc_fn; run_alloc_fn; run_dealloc_fn ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let is_less := M.alloc (| is_less |) in
          let elem_alloc_fn := M.alloc (| elem_alloc_fn |) in
          let elem_dealloc_fn := M.alloc (| elem_dealloc_fn |) in
          let run_alloc_fn := M.alloc (| run_alloc_fn |) in
          let run_dealloc_fn := M.alloc (| run_dealloc_fn |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (UnOp.Pure.not
                                              (M.read (|
                                                M.get_constant (|
                                                  "core::mem::SizedTypeProperties::IS_ZST"
                                                |)
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [ M.read (| Value.String "assertion failed: !T::IS_ZST" |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        []
                      |),
                      [ M.read (| v |) ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.le
                                  (M.read (| len |))
                                  (M.read (|
                                    M.get_constant (|
                                      "core::slice::sort::merge_sort::MAX_INSERTION"
                                    |)
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ :=
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                BinOp.Pure.ge (M.read (| len |)) (Value.Integer 2)
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (|
                                                  "core::slice::sort::insertion_sort_shift_left",
                                                  [ T; CmpF ]
                                                |),
                                                [
                                                  M.read (| v |);
                                                  Value.Integer 1;
                                                  M.read (| is_less |)
                                                ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ buf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::slice::sort::merge_sort::BufGuard")
                          []
                          [ T; ElemDeallocF ],
                        "new",
                        [ ElemAllocF ]
                      |),
                      [
                        BinOp.Wrap.div Integer.Usize (M.read (| len |)) (Value.Integer 2);
                        M.read (| elem_alloc_fn |);
                        M.read (| elem_dealloc_fn |)
                      ]
                    |)
                  |) in
                let~ buf_ptr :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                        "as_ptr",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            buf,
                            "core::slice::sort::merge_sort::BufGuard",
                            "buf_ptr"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ runs :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::slice::sort::merge_sort::RunVec")
                          []
                          [ RunAllocF; RunDeallocF ],
                        "new",
                        []
                      |),
                      [ M.read (| run_alloc_fn |); M.read (| run_dealloc_fn |) ]
                    |)
                  |) in
                let~ end_ := M.alloc (| Value.Integer 0 |) in
                let~ start := M.alloc (| Value.Integer 0 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.lt (M.read (| end_ |)) (M.read (| len |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::slice::sort::find_streak",
                                      [ T; CmpF ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::index::Index",
                                          Ty.apply (Ty.path "slice") [] [ T ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::RangeFrom")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index",
                                          []
                                        |),
                                        [
                                          M.read (| v |);
                                          Value.StructRecord
                                            "core::ops::range::RangeFrom"
                                            [ ("start", M.read (| start |)) ]
                                        ]
                                      |);
                                      M.read (| is_less |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let streak_end := M.copy (| γ0_0 |) in
                                      let was_reversed := M.copy (| γ0_1 |) in
                                      let~ _ :=
                                        let β := end_ in
                                        M.write (|
                                          β,
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| β |))
                                            (M.read (| streak_end |))
                                        |) in
                                      let~ _ :=
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ := M.use was_reversed in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                let~ _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply (Ty.path "slice") [] [ T ],
                                                        "reverse",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::index::IndexMut",
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::ops::range::Range")
                                                                []
                                                                [ Ty.path "usize" ]
                                                            ],
                                                            "index_mut",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| v |);
                                                            Value.StructRecord
                                                              "core::ops::range::Range"
                                                              [
                                                                ("start", M.read (| start |));
                                                                ("end_", M.read (| end_ |))
                                                              ]
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      let~ _ :=
                                        M.write (|
                                          end_,
                                          M.call_closure (|
                                            M.get_function (|
                                              "core::slice::sort::provide_sorted_batch",
                                              [ T; CmpF ]
                                            |),
                                            [
                                              M.read (| v |);
                                              M.read (| start |);
                                              M.read (| end_ |);
                                              M.read (| is_less |)
                                            ]
                                          |)
                                        |) in
                                      let~ _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::slice::sort::merge_sort::RunVec")
                                                []
                                                [ RunAllocF; RunDeallocF ],
                                              "push",
                                              []
                                            |),
                                            [
                                              runs;
                                              Value.StructRecord
                                                "core::slice::sort::TimSortRun"
                                                [
                                                  ("start", M.read (| start |));
                                                  ("len",
                                                    BinOp.Wrap.sub
                                                      Integer.Usize
                                                      (M.read (| end_ |))
                                                      (M.read (| start |)))
                                                ]
                                            ]
                                          |)
                                        |) in
                                      let~ _ := M.write (| start, M.read (| end_ |) |) in
                                      M.loop (|
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_function (|
                                                          "core::slice::sort::merge_sort.collapse",
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::slice::sort::merge_sort::RunVec")
                                                                []
                                                                [ RunAllocF; RunDeallocF ],
                                                              "as_slice",
                                                              []
                                                            |),
                                                            [ runs ]
                                                          |);
                                                          M.read (| len |)
                                                        ]
                                                      |)
                                                    |) in
                                                  let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::option::Option::Some",
                                                      0
                                                    |) in
                                                  let r := M.copy (| γ0_0 |) in
                                                  let~ left :=
                                                    M.copy (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::index::Index",
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::slice::sort::merge_sort::RunVec")
                                                            []
                                                            [ RunAllocF; RunDeallocF ],
                                                          [ Ty.path "usize" ],
                                                          "index",
                                                          []
                                                        |),
                                                        [ runs; M.read (| r |) ]
                                                      |)
                                                    |) in
                                                  let~ right :=
                                                    M.copy (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::index::Index",
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::slice::sort::merge_sort::RunVec")
                                                            []
                                                            [ RunAllocF; RunDeallocF ],
                                                          [ Ty.path "usize" ],
                                                          "index",
                                                          []
                                                        |),
                                                        [
                                                          runs;
                                                          BinOp.Wrap.add
                                                            Integer.Usize
                                                            (M.read (| r |))
                                                            (Value.Integer 1)
                                                        ]
                                                      |)
                                                    |) in
                                                  let~ merge_slice :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::index::IndexMut",
                                                          Ty.apply (Ty.path "slice") [] [ T ],
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::ops::range::Range")
                                                              []
                                                              [ Ty.path "usize" ]
                                                          ],
                                                          "index_mut",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| v |);
                                                          Value.StructRecord
                                                            "core::ops::range::Range"
                                                            [
                                                              ("start",
                                                                M.read (|
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    left,
                                                                    "core::slice::sort::TimSortRun",
                                                                    "start"
                                                                  |)
                                                                |));
                                                              ("end_",
                                                                BinOp.Wrap.add
                                                                  Integer.Usize
                                                                  (M.read (|
                                                                    M.SubPointer.get_struct_record_field (|
                                                                      right,
                                                                      "core::slice::sort::TimSortRun",
                                                                      "start"
                                                                    |)
                                                                  |))
                                                                  (M.read (|
                                                                    M.SubPointer.get_struct_record_field (|
                                                                      right,
                                                                      "core::slice::sort::TimSortRun",
                                                                      "len"
                                                                    |)
                                                                  |)))
                                                            ]
                                                        ]
                                                      |)
                                                    |) in
                                                  let~ _ :=
                                                    let~ _ :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_function (|
                                                            "core::slice::sort::merge",
                                                            [ T; CmpF ]
                                                          |),
                                                          [
                                                            M.read (| merge_slice |);
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                left,
                                                                "core::slice::sort::TimSortRun",
                                                                "len"
                                                              |)
                                                            |);
                                                            M.read (| buf_ptr |);
                                                            M.read (| is_less |)
                                                          ]
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |) in
                                                  let~ _ :=
                                                    M.write (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::index::IndexMut",
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::slice::sort::merge_sort::RunVec")
                                                            []
                                                            [ RunAllocF; RunDeallocF ],
                                                          [ Ty.path "usize" ],
                                                          "index_mut",
                                                          []
                                                        |),
                                                        [
                                                          runs;
                                                          BinOp.Wrap.add
                                                            Integer.Usize
                                                            (M.read (| r |))
                                                            (Value.Integer 1)
                                                        ]
                                                      |),
                                                      Value.StructRecord
                                                        "core::slice::sort::TimSortRun"
                                                        [
                                                          ("start",
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                left,
                                                                "core::slice::sort::TimSortRun",
                                                                "start"
                                                              |)
                                                            |));
                                                          ("len",
                                                            BinOp.Wrap.add
                                                              Integer.Usize
                                                              (M.read (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  left,
                                                                  "core::slice::sort::TimSortRun",
                                                                  "len"
                                                                |)
                                                              |))
                                                              (M.read (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  right,
                                                                  "core::slice::sort::TimSortRun",
                                                                  "len"
                                                                |)
                                                              |)))
                                                        ]
                                                    |) in
                                                  let~ _ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::slice::sort::merge_sort::RunVec")
                                                            []
                                                            [ RunAllocF; RunDeallocF ],
                                                          "remove",
                                                          []
                                                        |),
                                                        [ runs; M.read (| r |) ]
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (M.alloc (|
                                                    M.never_to_any (|
                                                      M.read (|
                                                        let~ _ :=
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (| M.break (||) |)
                                                            |)
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)
                                                      |)
                                                    |)
                                                  |)))
                                            ]
                                          |)))
                                      |)))
                                ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (LogicalOp.and (|
                                              LogicalOp.and (|
                                                BinOp.Pure.eq
                                                  (M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::slice::sort::merge_sort::RunVec")
                                                        []
                                                        [ RunAllocF; RunDeallocF ],
                                                      "len",
                                                      []
                                                    |),
                                                    [ runs ]
                                                  |))
                                                  (Value.Integer 1),
                                                ltac:(M.monadic
                                                  (BinOp.Pure.eq
                                                    (M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::index::Index",
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::slice::sort::merge_sort::RunVec")
                                                              []
                                                              [ RunAllocF; RunDeallocF ],
                                                            [ Ty.path "usize" ],
                                                            "index",
                                                            []
                                                          |),
                                                          [ runs; Value.Integer 0 ]
                                                        |),
                                                        "core::slice::sort::TimSortRun",
                                                        "start"
                                                      |)
                                                    |))
                                                    (Value.Integer 0)))
                                              |),
                                              ltac:(M.monadic
                                                (BinOp.Pure.eq
                                                  (M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::index::Index",
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::slice::sort::merge_sort::RunVec")
                                                            []
                                                            [ RunAllocF; RunDeallocF ],
                                                          [ Ty.path "usize" ],
                                                          "index",
                                                          []
                                                        |),
                                                        [ runs; Value.Integer 0 ]
                                                      |),
                                                      "core::slice::sort::TimSortRun",
                                                      "len"
                                                    |)
                                                  |))
                                                  (M.read (| len |))))
                                            |))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: runs.len() == 1 && runs[0].start == 0 && runs[0].len == len"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_merge_sort : M.IsFunction "core::slice::sort::merge_sort" merge_sort.
    
    Module merge_sort.
      Definition value_MAX_INSERTION : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer 20 |))).
      
      (*
          fn collapse(runs: &[TimSortRun], stop: usize) -> Option<usize> {
              let n = runs.len();
              if n >= 2
                  && (runs[n - 1].start + runs[n - 1].len == stop
                      || runs[n - 2].len <= runs[n - 1].len
                      || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)
                      || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))
              {
                  if n >= 3 && runs[n - 3].len < runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }
              } else {
                  None
              }
          }
      *)
      Definition collapse (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ runs; stop ] =>
          ltac:(M.monadic
            (let runs := M.alloc (| runs |) in
            let stop := M.alloc (| stop |) in
            M.read (|
              let~ n :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "core::slice::sort::TimSortRun" ],
                      "len",
                      []
                    |),
                    [ M.read (| runs |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              BinOp.Pure.ge (M.read (| n |)) (Value.Integer 2),
                              ltac:(M.monadic
                                (LogicalOp.or (|
                                  LogicalOp.or (|
                                    LogicalOp.or (|
                                      BinOp.Pure.eq
                                        (BinOp.Wrap.add
                                          Integer.Usize
                                          (M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_array_field (|
                                                M.read (| runs |),
                                                M.alloc (|
                                                  BinOp.Wrap.sub
                                                    Integer.Usize
                                                    (M.read (| n |))
                                                    (Value.Integer 1)
                                                |)
                                              |),
                                              "core::slice::sort::TimSortRun",
                                              "start"
                                            |)
                                          |))
                                          (M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_array_field (|
                                                M.read (| runs |),
                                                M.alloc (|
                                                  BinOp.Wrap.sub
                                                    Integer.Usize
                                                    (M.read (| n |))
                                                    (Value.Integer 1)
                                                |)
                                              |),
                                              "core::slice::sort::TimSortRun",
                                              "len"
                                            |)
                                          |)))
                                        (M.read (| stop |)),
                                      ltac:(M.monadic
                                        (BinOp.Pure.le
                                          (M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_array_field (|
                                                M.read (| runs |),
                                                M.alloc (|
                                                  BinOp.Wrap.sub
                                                    Integer.Usize
                                                    (M.read (| n |))
                                                    (Value.Integer 2)
                                                |)
                                              |),
                                              "core::slice::sort::TimSortRun",
                                              "len"
                                            |)
                                          |))
                                          (M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_array_field (|
                                                M.read (| runs |),
                                                M.alloc (|
                                                  BinOp.Wrap.sub
                                                    Integer.Usize
                                                    (M.read (| n |))
                                                    (Value.Integer 1)
                                                |)
                                              |),
                                              "core::slice::sort::TimSortRun",
                                              "len"
                                            |)
                                          |))))
                                    |),
                                    ltac:(M.monadic
                                      (LogicalOp.and (|
                                        BinOp.Pure.ge (M.read (| n |)) (Value.Integer 3),
                                        ltac:(M.monadic
                                          (BinOp.Pure.le
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.SubPointer.get_array_field (|
                                                  M.read (| runs |),
                                                  M.alloc (|
                                                    BinOp.Wrap.sub
                                                      Integer.Usize
                                                      (M.read (| n |))
                                                      (Value.Integer 3)
                                                  |)
                                                |),
                                                "core::slice::sort::TimSortRun",
                                                "len"
                                              |)
                                            |))
                                            (BinOp.Wrap.add
                                              Integer.Usize
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.SubPointer.get_array_field (|
                                                    M.read (| runs |),
                                                    M.alloc (|
                                                      BinOp.Wrap.sub
                                                        Integer.Usize
                                                        (M.read (| n |))
                                                        (Value.Integer 2)
                                                    |)
                                                  |),
                                                  "core::slice::sort::TimSortRun",
                                                  "len"
                                                |)
                                              |))
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.SubPointer.get_array_field (|
                                                    M.read (| runs |),
                                                    M.alloc (|
                                                      BinOp.Wrap.sub
                                                        Integer.Usize
                                                        (M.read (| n |))
                                                        (Value.Integer 1)
                                                    |)
                                                  |),
                                                  "core::slice::sort::TimSortRun",
                                                  "len"
                                                |)
                                              |)))))
                                      |)))
                                  |),
                                  ltac:(M.monadic
                                    (LogicalOp.and (|
                                      BinOp.Pure.ge (M.read (| n |)) (Value.Integer 4),
                                      ltac:(M.monadic
                                        (BinOp.Pure.le
                                          (M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_array_field (|
                                                M.read (| runs |),
                                                M.alloc (|
                                                  BinOp.Wrap.sub
                                                    Integer.Usize
                                                    (M.read (| n |))
                                                    (Value.Integer 4)
                                                |)
                                              |),
                                              "core::slice::sort::TimSortRun",
                                              "len"
                                            |)
                                          |))
                                          (BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.SubPointer.get_array_field (|
                                                  M.read (| runs |),
                                                  M.alloc (|
                                                    BinOp.Wrap.sub
                                                      Integer.Usize
                                                      (M.read (| n |))
                                                      (Value.Integer 3)
                                                  |)
                                                |),
                                                "core::slice::sort::TimSortRun",
                                                "len"
                                              |)
                                            |))
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.SubPointer.get_array_field (|
                                                  M.read (| runs |),
                                                  M.alloc (|
                                                    BinOp.Wrap.sub
                                                      Integer.Usize
                                                      (M.read (| n |))
                                                      (Value.Integer 2)
                                                  |)
                                                |),
                                                "core::slice::sort::TimSortRun",
                                                "len"
                                              |)
                                            |)))))
                                    |)))
                                |)))
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.and (|
                                      BinOp.Pure.ge (M.read (| n |)) (Value.Integer 3),
                                      ltac:(M.monadic
                                        (BinOp.Pure.lt
                                          (M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_array_field (|
                                                M.read (| runs |),
                                                M.alloc (|
                                                  BinOp.Wrap.sub
                                                    Integer.Usize
                                                    (M.read (| n |))
                                                    (Value.Integer 3)
                                                |)
                                              |),
                                              "core::slice::sort::TimSortRun",
                                              "len"
                                            |)
                                          |))
                                          (M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_array_field (|
                                                M.read (| runs |),
                                                M.alloc (|
                                                  BinOp.Wrap.sub
                                                    Integer.Usize
                                                    (M.read (| n |))
                                                    (Value.Integer 1)
                                                |)
                                              |),
                                              "core::slice::sort::TimSortRun",
                                              "len"
                                            |)
                                          |))))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ BinOp.Wrap.sub Integer.Usize (M.read (| n |)) (Value.Integer 3)
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ BinOp.Wrap.sub Integer.Usize (M.read (| n |)) (Value.Integer 2)
                                  ]
                              |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom Function_collapse : M.IsFunction "core::slice::sort::merge_sort::collapse" collapse.
      
      (* StructRecord
        {
          name := "BufGuard";
          const_params := [];
          ty_params := [ "T"; "ElemDeallocF" ];
          fields :=
            [
              ("buf_ptr", Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ]);
              ("capacity", Ty.path "usize");
              ("elem_dealloc_fn", ElemDeallocF)
            ];
        } *)
      
      Module Impl_core_slice_sort_merge_sort_BufGuard_T_ElemDeallocF.
        Definition Self (T ElemDeallocF : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "core::slice::sort::merge_sort::BufGuard") [] [ T; ElemDeallocF ].
        
        (*
                fn new<ElemAllocF>(
                    len: usize,
                    elem_alloc_fn: ElemAllocF,
                    elem_dealloc_fn: ElemDeallocF,
                ) -> Self
                where
                    ElemAllocF: Fn(usize) -> *mut T,
                {
                    Self {
                        buf_ptr: ptr::NonNull::new(elem_alloc_fn(len)).unwrap(),
                        capacity: len,
                        elem_dealloc_fn,
                    }
                }
        *)
        Definition new
            (T ElemDeallocF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T ElemDeallocF in
          match ε, τ, α with
          | [], [ ElemAllocF ], [ len; elem_alloc_fn; elem_dealloc_fn ] =>
            ltac:(M.monadic
              (let len := M.alloc (| len |) in
              let elem_alloc_fn := M.alloc (| elem_alloc_fn |) in
              let elem_dealloc_fn := M.alloc (| elem_dealloc_fn |) in
              Value.StructRecord
                "core::slice::sort::merge_sort::BufGuard"
                [
                  ("buf_ptr",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ] ],
                        "unwrap",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::Fn",
                                ElemAllocF,
                                [ Ty.tuple [ Ty.path "usize" ] ],
                                "call",
                                []
                              |),
                              [ elem_alloc_fn; Value.Tuple [ M.read (| len |) ] ]
                            |)
                          ]
                        |)
                      ]
                    |));
                  ("capacity", M.read (| len |));
                  ("elem_dealloc_fn", M.read (| elem_dealloc_fn |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (T ElemDeallocF : Ty.t),
          M.IsAssociatedFunction (Self T ElemDeallocF) "new" (new T ElemDeallocF).
      End Impl_core_slice_sort_merge_sort_BufGuard_T_ElemDeallocF.
      
      Module Impl_core_ops_drop_Drop_where_core_ops_function_Fn_ElemDeallocF_Tuple_pointer_mut_T_usize__for_core_slice_sort_merge_sort_BufGuard_T_ElemDeallocF.
        Definition Self (T ElemDeallocF : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "core::slice::sort::merge_sort::BufGuard") [] [ T; ElemDeallocF ].
        
        (*
                fn drop(&mut self) {
                    (self.elem_dealloc_fn)(self.buf_ptr.as_ptr(), self.capacity);
                }
        *)
        Definition drop
            (T ElemDeallocF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T ElemDeallocF in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::function::Fn",
                        ElemDeallocF,
                        [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.path "usize" ] ],
                        "call",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::sort::merge_sort::BufGuard",
                          "elem_dealloc_fn"
                        |);
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                "as_ptr",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::sort::merge_sort::BufGuard",
                                    "buf_ptr"
                                  |)
                                |)
                              ]
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::sort::merge_sort::BufGuard",
                                "capacity"
                              |)
                            |)
                          ]
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T ElemDeallocF : Ty.t),
          M.IsTraitInstance
            "core::ops::drop::Drop"
            (Self T ElemDeallocF)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("drop", InstanceField.Method (drop T ElemDeallocF)) ].
      End Impl_core_ops_drop_Drop_where_core_ops_function_Fn_ElemDeallocF_Tuple_pointer_mut_T_usize__for_core_slice_sort_merge_sort_BufGuard_T_ElemDeallocF.
      
      (* StructRecord
        {
          name := "RunVec";
          const_params := [];
          ty_params := [ "RunAllocF"; "RunDeallocF" ];
          fields :=
            [
              ("buf_ptr",
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  []
                  [ Ty.path "core::slice::sort::TimSortRun" ]);
              ("capacity", Ty.path "usize");
              ("len", Ty.path "usize");
              ("run_alloc_fn", RunAllocF);
              ("run_dealloc_fn", RunDeallocF)
            ];
        } *)
      
      Module Impl_core_slice_sort_merge_sort_RunVec_RunAllocF_RunDeallocF.
        Definition Self (RunAllocF RunDeallocF : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "core::slice::sort::merge_sort::RunVec") [] [ RunAllocF; RunDeallocF ].
        
        (*
                fn new(run_alloc_fn: RunAllocF, run_dealloc_fn: RunDeallocF) -> Self {
                    // Most slices can be sorted with at most 16 runs in-flight.
                    const START_RUN_CAPACITY: usize = 16;
        
                    Self {
                        buf_ptr: ptr::NonNull::new(run_alloc_fn(START_RUN_CAPACITY)).unwrap(),
                        capacity: START_RUN_CAPACITY,
                        len: 0,
                        run_alloc_fn,
                        run_dealloc_fn,
                    }
                }
        *)
        Definition new
            (RunAllocF RunDeallocF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self RunAllocF RunDeallocF in
          match ε, τ, α with
          | [], [], [ run_alloc_fn; run_dealloc_fn ] =>
            ltac:(M.monadic
              (let run_alloc_fn := M.alloc (| run_alloc_fn |) in
              let run_dealloc_fn := M.alloc (| run_dealloc_fn |) in
              Value.StructRecord
                "core::slice::sort::merge_sort::RunVec"
                [
                  ("buf_ptr",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.path "core::slice::sort::TimSortRun" ]
                          ],
                        "unwrap",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.path "core::slice::sort::TimSortRun" ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::Fn",
                                RunAllocF,
                                [ Ty.tuple [ Ty.path "usize" ] ],
                                "call",
                                []
                              |),
                              [
                                run_alloc_fn;
                                Value.Tuple
                                  [
                                    M.read (|
                                      M.get_constant (|
                                        "core::slice::sort::merge_sort::new::START_RUN_CAPACITY"
                                      |)
                                    |)
                                  ]
                              ]
                            |)
                          ]
                        |)
                      ]
                    |));
                  ("capacity",
                    M.read (|
                      M.get_constant (| "core::slice::sort::merge_sort::new::START_RUN_CAPACITY" |)
                    |));
                  ("len", Value.Integer 0);
                  ("run_alloc_fn", M.read (| run_alloc_fn |));
                  ("run_dealloc_fn", M.read (| run_dealloc_fn |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (RunAllocF RunDeallocF : Ty.t),
          M.IsAssociatedFunction (Self RunAllocF RunDeallocF) "new" (new RunAllocF RunDeallocF).
        
        (*
                fn push(&mut self, val: TimSortRun) {
                    if self.len == self.capacity {
                        let old_capacity = self.capacity;
                        let old_buf_ptr = self.buf_ptr.as_ptr();
        
                        self.capacity = self.capacity * 2;
                        self.buf_ptr = ptr::NonNull::new((self.run_alloc_fn)(self.capacity)).unwrap();
        
                        // SAFETY: buf_ptr new and old were correctly allocated and old_buf_ptr has
                        // old_capacity valid elements.
                        unsafe {
                            ptr::copy_nonoverlapping(old_buf_ptr, self.buf_ptr.as_ptr(), old_capacity);
                        }
        
                        (self.run_dealloc_fn)(old_buf_ptr, old_capacity);
                    }
        
                    // SAFETY: The invariant was just checked.
                    unsafe {
                        self.buf_ptr.as_ptr().add(self.len).write(val);
                    }
                    self.len += 1;
                }
        *)
        Definition push
            (RunAllocF RunDeallocF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self RunAllocF RunDeallocF in
          match ε, τ, α with
          | [], [], [ self; val ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let val := M.alloc (| val |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq
                                  (M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::sort::merge_sort::RunVec",
                                      "len"
                                    |)
                                  |))
                                  (M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::sort::merge_sort::RunVec",
                                      "capacity"
                                    |)
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ old_capacity :=
                            M.copy (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::sort::merge_sort::RunVec",
                                "capacity"
                              |)
                            |) in
                          let~ old_buf_ptr :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.path "core::slice::sort::TimSortRun" ],
                                  "as_ptr",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::sort::merge_sort::RunVec",
                                      "buf_ptr"
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::sort::merge_sort::RunVec",
                                "capacity"
                              |),
                              BinOp.Wrap.mul
                                Integer.Usize
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::sort::merge_sort::RunVec",
                                    "capacity"
                                  |)
                                |))
                                (Value.Integer 2)
                            |) in
                          let~ _ :=
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::sort::merge_sort::RunVec",
                                "buf_ptr"
                              |),
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.path "core::slice::sort::TimSortRun" ]
                                    ],
                                  "unwrap",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.path "core::slice::sort::TimSortRun" ],
                                      "new",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::function::Fn",
                                          RunAllocF,
                                          [ Ty.tuple [ Ty.path "usize" ] ],
                                          "call",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::sort::merge_sort::RunVec",
                                            "run_alloc_fn"
                                          |);
                                          Value.Tuple
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "core::slice::sort::merge_sort::RunVec",
                                                  "capacity"
                                                |)
                                              |)
                                            ]
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            let~ _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::copy_nonoverlapping",
                                    [ Ty.path "core::slice::sort::TimSortRun" ]
                                  |),
                                  [
                                    (* MutToConstPointer *)
                                    M.pointer_coercion (M.read (| old_buf_ptr |));
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.path "core::slice::sort::TimSortRun" ],
                                        "as_ptr",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::sort::merge_sort::RunVec",
                                            "buf_ptr"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| old_capacity |)
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::function::Fn",
                                  RunDeallocF,
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.path "core::slice::sort::TimSortRun" ];
                                        Ty.path "usize"
                                      ]
                                  ],
                                  "call",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::sort::merge_sort::RunVec",
                                    "run_dealloc_fn"
                                  |);
                                  Value.Tuple
                                    [ M.read (| old_buf_ptr |); M.read (| old_capacity |) ]
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ :=
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "core::slice::sort::TimSortRun" ],
                          "write",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.path "core::slice::sort::TimSortRun" ],
                              "add",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.path "core::slice::sort::TimSortRun" ],
                                  "as_ptr",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::sort::merge_sort::RunVec",
                                      "buf_ptr"
                                    |)
                                  |)
                                ]
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::sort::merge_sort::RunVec",
                                  "len"
                                |)
                              |)
                            ]
                          |);
                          M.read (| val |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                let~ _ :=
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::sort::merge_sort::RunVec",
                      "len"
                    |) in
                  M.write (|
                    β,
                    BinOp.Wrap.add Integer.Usize (M.read (| β |)) (Value.Integer 1)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_push :
          forall (RunAllocF RunDeallocF : Ty.t),
          M.IsAssociatedFunction (Self RunAllocF RunDeallocF) "push" (push RunAllocF RunDeallocF).
        
        (*
                fn remove(&mut self, index: usize) {
                    if index >= self.len {
                        panic!("Index out of bounds");
                    }
        
                    // SAFETY: buf_ptr needs to be valid and len invariant upheld.
                    unsafe {
                        // the place we are taking from.
                        let ptr = self.buf_ptr.as_ptr().add(index);
        
                        // Shift everything down to fill in that spot.
                        ptr::copy(ptr.add(1), ptr, self.len - index - 1);
                    }
                    self.len -= 1;
                }
        *)
        Definition remove
            (RunAllocF RunDeallocF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self RunAllocF RunDeallocF in
          match ε, τ, α with
          | [], [], [ self; index ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let index := M.alloc (| index |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.ge
                                  (M.read (| index |))
                                  (M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::slice::sort::merge_sort::RunVec",
                                      "len"
                                    |)
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic_fmt", [] |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_const",
                                      []
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.alloc (|
                                          Value.Array
                                            [ M.read (| Value.String "Index out of bounds" |) ]
                                        |))
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ :=
                  let~ ptr :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "core::slice::sort::TimSortRun" ],
                          "add",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.path "core::slice::sort::TimSortRun" ],
                              "as_ptr",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::sort::merge_sort::RunVec",
                                  "buf_ptr"
                                |)
                              |)
                            ]
                          |);
                          M.read (| index |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::intrinsics::copy",
                          [ Ty.path "core::slice::sort::TimSortRun" ]
                        |),
                        [
                          (* MutToConstPointer *)
                          M.pointer_coercion
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.path "core::slice::sort::TimSortRun" ],
                                "add",
                                []
                              |),
                              [ M.read (| ptr |); Value.Integer 1 ]
                            |));
                          M.read (| ptr |);
                          BinOp.Wrap.sub
                            Integer.Usize
                            (BinOp.Wrap.sub
                              Integer.Usize
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::slice::sort::merge_sort::RunVec",
                                  "len"
                                |)
                              |))
                              (M.read (| index |)))
                            (Value.Integer 1)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                let~ _ :=
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::sort::merge_sort::RunVec",
                      "len"
                    |) in
                  M.write (|
                    β,
                    BinOp.Wrap.sub Integer.Usize (M.read (| β |)) (Value.Integer 1)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_remove :
          forall (RunAllocF RunDeallocF : Ty.t),
          M.IsAssociatedFunction
            (Self RunAllocF RunDeallocF)
            "remove"
            (remove RunAllocF RunDeallocF).
        
        (*
                fn as_slice(&self) -> &[TimSortRun] {
                    // SAFETY: Safe as long as buf_ptr is valid and len invariant was upheld.
                    unsafe { &*ptr::slice_from_raw_parts(self.buf_ptr.as_ptr(), self.len) }
                }
        *)
        Definition as_slice
            (RunAllocF RunDeallocF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self RunAllocF RunDeallocF in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_function (|
                  "core::ptr::slice_from_raw_parts",
                  [ Ty.path "core::slice::sort::TimSortRun" ]
                |),
                [
                  (* MutToConstPointer *)
                  M.pointer_coercion
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.path "core::slice::sort::TimSortRun" ],
                        "as_ptr",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::slice::sort::merge_sort::RunVec",
                            "buf_ptr"
                          |)
                        |)
                      ]
                    |));
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::sort::merge_sort::RunVec",
                      "len"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_as_slice :
          forall (RunAllocF RunDeallocF : Ty.t),
          M.IsAssociatedFunction
            (Self RunAllocF RunDeallocF)
            "as_slice"
            (as_slice RunAllocF RunDeallocF).
        
        (*
                fn len(&self) -> usize {
                    self.len
                }
        *)
        Definition len
            (RunAllocF RunDeallocF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self RunAllocF RunDeallocF in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::slice::sort::merge_sort::RunVec",
                  "len"
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_len :
          forall (RunAllocF RunDeallocF : Ty.t),
          M.IsAssociatedFunction (Self RunAllocF RunDeallocF) "len" (len RunAllocF RunDeallocF).
      End Impl_core_slice_sort_merge_sort_RunVec_RunAllocF_RunDeallocF.
      
      Module Impl_core_ops_index_Index_where_core_ops_function_Fn_RunAllocF_Tuple_usize__where_core_ops_function_Fn_RunDeallocF_Tuple_pointer_mut_core_slice_sort_TimSortRun_usize__usize_for_core_slice_sort_merge_sort_RunVec_RunAllocF_RunDeallocF.
        Definition Self (RunAllocF RunDeallocF : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "core::slice::sort::merge_sort::RunVec") [] [ RunAllocF; RunDeallocF ].
        
        (*         type Output = TimSortRun; *)
        Definition _Output (RunAllocF RunDeallocF : Ty.t) : Ty.t :=
          Ty.path "core::slice::sort::TimSortRun".
        
        (*
                fn index(&self, index: usize) -> &Self::Output {
                    if index < self.len {
                        // SAFETY: buf_ptr and len invariant must be upheld.
                        unsafe {
                            return &*(self.buf_ptr.as_ptr().add(index));
                        }
                    }
        
                    panic!("Index out of bounds");
                }
        *)
        Definition index
            (RunAllocF RunDeallocF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self RunAllocF RunDeallocF in
          match ε, τ, α with
          | [], [], [ self; index ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let index := M.alloc (| index |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.never_to_any (|
                    M.read (|
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      BinOp.Pure.lt
                                        (M.read (| index |))
                                        (M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::sort::merge_sort::RunVec",
                                            "len"
                                          |)
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.path "core::slice::sort::TimSortRun" ],
                                            "add",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.path "core::slice::sort::TimSortRun" ],
                                                "as_ptr",
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "core::slice::sort::merge_sort::RunVec",
                                                    "buf_ptr"
                                                  |)
                                                |)
                                              ]
                                            |);
                                            M.read (| index |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array [ M.read (| Value.String "Index out of bounds" |) ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (RunAllocF RunDeallocF : Ty.t),
          M.IsTraitInstance
            "core::ops::index::Index"
            (Self RunAllocF RunDeallocF)
            (* Trait polymorphic types *) [ (* Idx *) Ty.path "usize" ]
            (* Instance *)
            [
              ("Output", InstanceField.Ty (_Output RunAllocF RunDeallocF));
              ("index", InstanceField.Method (index RunAllocF RunDeallocF))
            ].
      End Impl_core_ops_index_Index_where_core_ops_function_Fn_RunAllocF_Tuple_usize__where_core_ops_function_Fn_RunDeallocF_Tuple_pointer_mut_core_slice_sort_TimSortRun_usize__usize_for_core_slice_sort_merge_sort_RunVec_RunAllocF_RunDeallocF.
      
      Module Impl_core_ops_index_IndexMut_where_core_ops_function_Fn_RunAllocF_Tuple_usize__where_core_ops_function_Fn_RunDeallocF_Tuple_pointer_mut_core_slice_sort_TimSortRun_usize__usize_for_core_slice_sort_merge_sort_RunVec_RunAllocF_RunDeallocF.
        Definition Self (RunAllocF RunDeallocF : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "core::slice::sort::merge_sort::RunVec") [] [ RunAllocF; RunDeallocF ].
        
        (*
                fn index_mut(&mut self, index: usize) -> &mut Self::Output {
                    if index < self.len {
                        // SAFETY: buf_ptr and len invariant must be upheld.
                        unsafe {
                            return &mut *(self.buf_ptr.as_ptr().add(index));
                        }
                    }
        
                    panic!("Index out of bounds");
                }
        *)
        Definition index_mut
            (RunAllocF RunDeallocF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self RunAllocF RunDeallocF in
          match ε, τ, α with
          | [], [], [ self; index ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let index := M.alloc (| index |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.never_to_any (|
                    M.read (|
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      BinOp.Pure.lt
                                        (M.read (| index |))
                                        (M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::slice::sort::merge_sort::RunVec",
                                            "len"
                                          |)
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.path "core::slice::sort::TimSortRun" ],
                                            "add",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.path "core::slice::sort::TimSortRun" ],
                                                "as_ptr",
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "core::slice::sort::merge_sort::RunVec",
                                                    "buf_ptr"
                                                  |)
                                                |)
                                              ]
                                            |);
                                            M.read (| index |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array [ M.read (| Value.String "Index out of bounds" |) ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (RunAllocF RunDeallocF : Ty.t),
          M.IsTraitInstance
            "core::ops::index::IndexMut"
            (Self RunAllocF RunDeallocF)
            (* Trait polymorphic types *) [ (* Idx *) Ty.path "usize" ]
            (* Instance *)
            [ ("index_mut", InstanceField.Method (index_mut RunAllocF RunDeallocF)) ].
      End Impl_core_ops_index_IndexMut_where_core_ops_function_Fn_RunAllocF_Tuple_usize__where_core_ops_function_Fn_RunDeallocF_Tuple_pointer_mut_core_slice_sort_TimSortRun_usize__usize_for_core_slice_sort_merge_sort_RunVec_RunAllocF_RunDeallocF.
      
      Module Impl_core_ops_drop_Drop_where_core_ops_function_Fn_RunAllocF_Tuple_usize__where_core_ops_function_Fn_RunDeallocF_Tuple_pointer_mut_core_slice_sort_TimSortRun_usize__for_core_slice_sort_merge_sort_RunVec_RunAllocF_RunDeallocF.
        Definition Self (RunAllocF RunDeallocF : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "core::slice::sort::merge_sort::RunVec") [] [ RunAllocF; RunDeallocF ].
        
        (*
                fn drop(&mut self) {
                    // As long as TimSortRun is Copy we don't need to drop them individually but just the
                    // whole allocation.
                    (self.run_dealloc_fn)(self.buf_ptr.as_ptr(), self.capacity);
                }
        *)
        Definition drop
            (RunAllocF RunDeallocF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self RunAllocF RunDeallocF in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::function::Fn",
                        RunDeallocF,
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.path "core::slice::sort::TimSortRun" ];
                              Ty.path "usize"
                            ]
                        ],
                        "call",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::slice::sort::merge_sort::RunVec",
                          "run_dealloc_fn"
                        |);
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.path "core::slice::sort::TimSortRun" ],
                                "as_ptr",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::slice::sort::merge_sort::RunVec",
                                    "buf_ptr"
                                  |)
                                |)
                              ]
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::slice::sort::merge_sort::RunVec",
                                "capacity"
                              |)
                            |)
                          ]
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (RunAllocF RunDeallocF : Ty.t),
          M.IsTraitInstance
            "core::ops::drop::Drop"
            (Self RunAllocF RunDeallocF)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("drop", InstanceField.Method (drop RunAllocF RunDeallocF)) ].
      End Impl_core_ops_drop_Drop_where_core_ops_function_Fn_RunAllocF_Tuple_usize__where_core_ops_function_Fn_RunDeallocF_Tuple_pointer_mut_core_slice_sort_TimSortRun_usize__for_core_slice_sort_merge_sort_RunVec_RunAllocF_RunDeallocF.
    End merge_sort.
    
    (* StructRecord
      {
        name := "TimSortRun";
        const_params := [];
        ty_params := [];
        fields := [ ("len", Ty.path "usize"); ("start", Ty.path "usize") ];
      } *)
    
    Module Impl_core_clone_Clone_for_core_slice_sort_TimSortRun.
      Definition Self : Ty.t := Ty.path "core::slice::sort::TimSortRun".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_slice_sort_TimSortRun.
    
    Module Impl_core_marker_Copy_for_core_slice_sort_TimSortRun.
      Definition Self : Ty.t := Ty.path "core::slice::sort::TimSortRun".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_slice_sort_TimSortRun.
    
    Module Impl_core_fmt_Debug_for_core_slice_sort_TimSortRun.
      Definition Self : Ty.t := Ty.path "core::slice::sort::TimSortRun".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "TimSortRun" |);
                M.read (| Value.String "len" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::slice::sort::TimSortRun",
                    "len"
                  |));
                M.read (| Value.String "start" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::slice::sort::TimSortRun",
                      "start"
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_slice_sort_TimSortRun.
    
    (*
    fn provide_sorted_batch<T, F>(v: &mut [T], start: usize, mut end: usize, is_less: &mut F) -> usize
    where
        F: FnMut(&T, &T) -> bool,
    {
        let len = v.len();
        assert!(end >= start && end <= len);
    
        // This value is a balance between least comparisons and best performance, as
        // influenced by for example cache locality.
        const MIN_INSERTION_RUN: usize = 10;
    
        // Insert some more elements into the run if it's too short. Insertion sort is faster than
        // merge sort on short sequences, so this significantly improves performance.
        let start_end_diff = end - start;
    
        if start_end_diff < MIN_INSERTION_RUN && end < len {
            // v[start_found..end] are elements that are already sorted in the input. We want to extend
            // the sorted region to the left, so we push up MIN_INSERTION_RUN - 1 to the right. Which is
            // more efficient that trying to push those already sorted elements to the left.
            end = cmp::min(start + MIN_INSERTION_RUN, len);
            let presorted_start = cmp::max(start_end_diff, 1);
    
            insertion_sort_shift_left(&mut v[start..end], presorted_start, is_less);
        }
    
        end
    }
    *)
    Definition provide_sorted_batch (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; start; end_; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let start := M.alloc (| start |) in
          let end_ := M.alloc (| end_ |) in
          let is_less := M.alloc (| is_less |) in
          M.read (|
            let~ len :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "len", [] |),
                  [ M.read (| v |) ]
                |)
              |) in
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (LogicalOp.and (|
                                BinOp.Pure.ge (M.read (| end_ |)) (M.read (| start |)),
                                ltac:(M.monadic
                                  (BinOp.Pure.le (M.read (| end_ |)) (M.read (| len |))))
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic", [] |),
                            [
                              M.read (|
                                Value.String "assertion failed: end >= start && end <= len"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ start_end_diff :=
              M.alloc (| BinOp.Wrap.sub Integer.Usize (M.read (| end_ |)) (M.read (| start |)) |) in
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              BinOp.Pure.lt
                                (M.read (| start_end_diff |))
                                (M.read (|
                                  M.get_constant (|
                                    "core::slice::sort::provide_sorted_batch::MIN_INSERTION_RUN"
                                  |)
                                |)),
                              ltac:(M.monadic
                                (BinOp.Pure.lt (M.read (| end_ |)) (M.read (| len |))))
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.write (|
                          end_,
                          M.call_closure (|
                            M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                            [
                              BinOp.Wrap.add
                                Integer.Usize
                                (M.read (| start |))
                                (M.read (|
                                  M.get_constant (|
                                    "core::slice::sort::provide_sorted_batch::MIN_INSERTION_RUN"
                                  |)
                                |));
                              M.read (| len |)
                            ]
                          |)
                        |) in
                      let~ presorted_start :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                            [ M.read (| start_end_diff |); Value.Integer 1 ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::slice::sort::insertion_sort_shift_left",
                              [ T; F ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::index::IndexMut",
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index_mut",
                                  []
                                |),
                                [
                                  M.read (| v |);
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [ ("start", M.read (| start |)); ("end_", M.read (| end_ |)) ]
                                ]
                              |);
                              M.read (| presorted_start |);
                              M.read (| is_less |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            end_
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_provide_sorted_batch :
      M.IsFunction "core::slice::sort::provide_sorted_batch" provide_sorted_batch.
    
    Module provide_sorted_batch.
      Definition value_MIN_INSERTION_RUN : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer 10 |))).
    End provide_sorted_batch.
    
    (*
    fn find_streak<T, F>(v: &[T], is_less: &mut F) -> (usize, bool)
    where
        F: FnMut(&T, &T) -> bool,
    {
        let len = v.len();
    
        if len < 2 {
            return (len, false);
        }
    
        let mut end = 2;
    
        // SAFETY: See below specific.
        unsafe {
            // SAFETY: We checked that len >= 2, so 0 and 1 are valid indices.
            let assume_reverse = is_less(v.get_unchecked(1), v.get_unchecked(0));
    
            // SAFETY: We know end >= 2 and check end < len.
            // From that follows that accessing v at end and end - 1 is safe.
            if assume_reverse {
                while end < len && is_less(v.get_unchecked(end), v.get_unchecked(end - 1)) {
                    end += 1;
                }
    
                (end, true)
            } else {
                while end < len && !is_less(v.get_unchecked(end), v.get_unchecked(end - 1)) {
                    end += 1;
                }
                (end, false)
            }
        }
    }
    *)
    Definition find_streak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ v; is_less ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let is_less := M.alloc (| is_less |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        []
                      |),
                      [ M.read (| v |) ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.lt (M.read (| len |)) (Value.Integer 2) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ M.read (| len |); Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ end_ := M.alloc (| Value.Integer 2 |) in
                let~ assume_reverse :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::function::FnMut",
                        F,
                        [
                          Ty.tuple
                            [ Ty.apply (Ty.path "&") [] [ T ]; Ty.apply (Ty.path "&") [] [ T ] ]
                        ],
                        "call_mut",
                        []
                      |),
                      [
                        M.read (| is_less |);
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "get_unchecked",
                                [ Ty.path "usize" ]
                              |),
                              [ M.read (| v |); Value.Integer 1 ]
                            |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "get_unchecked",
                                [ Ty.path "usize" ]
                              |),
                              [ M.read (| v |); Value.Integer 0 ]
                            |)
                          ]
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use assume_reverse in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.loop (|
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            LogicalOp.and (|
                                              BinOp.Pure.lt (M.read (| end_ |)) (M.read (| len |)),
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::function::FnMut",
                                                    F,
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply (Ty.path "&") [] [ T ];
                                                          Ty.apply (Ty.path "&") [] [ T ]
                                                        ]
                                                    ],
                                                    "call_mut",
                                                    []
                                                  |),
                                                  [
                                                    M.read (| is_less |);
                                                    Value.Tuple
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            "get_unchecked",
                                                            [ Ty.path "usize" ]
                                                          |),
                                                          [ M.read (| v |); M.read (| end_ |) ]
                                                        |);
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            "get_unchecked",
                                                            [ Ty.path "usize" ]
                                                          |),
                                                          [
                                                            M.read (| v |);
                                                            BinOp.Wrap.sub
                                                              Integer.Usize
                                                              (M.read (| end_ |))
                                                              (Value.Integer 1)
                                                          ]
                                                        |)
                                                      ]
                                                  ]
                                                |)))
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ :=
                                        let β := end_ in
                                        M.write (|
                                          β,
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| β |))
                                            (Value.Integer 1)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let~ _ :=
                                              M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |)))
                          |) in
                        M.alloc (| Value.Tuple [ M.read (| end_ |); Value.Bool true ] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let~ _ :=
                          M.loop (|
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            LogicalOp.and (|
                                              BinOp.Pure.lt (M.read (| end_ |)) (M.read (| len |)),
                                              ltac:(M.monadic
                                                (UnOp.Pure.not
                                                  (M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::function::FnMut",
                                                      F,
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply (Ty.path "&") [] [ T ];
                                                            Ty.apply (Ty.path "&") [] [ T ]
                                                          ]
                                                      ],
                                                      "call_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.read (| is_less |);
                                                      Value.Tuple
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply (Ty.path "slice") [] [ T ],
                                                              "get_unchecked",
                                                              [ Ty.path "usize" ]
                                                            |),
                                                            [ M.read (| v |); M.read (| end_ |) ]
                                                          |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply (Ty.path "slice") [] [ T ],
                                                              "get_unchecked",
                                                              [ Ty.path "usize" ]
                                                            |),
                                                            [
                                                              M.read (| v |);
                                                              BinOp.Wrap.sub
                                                                Integer.Usize
                                                                (M.read (| end_ |))
                                                                (Value.Integer 1)
                                                            ]
                                                          |)
                                                        ]
                                                    ]
                                                  |))))
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ :=
                                        let β := end_ in
                                        M.write (|
                                          β,
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| β |))
                                            (Value.Integer 1)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let~ _ :=
                                              M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |)))
                          |) in
                        M.alloc (| Value.Tuple [ M.read (| end_ |); Value.Bool false ] |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Function_find_streak : M.IsFunction "core::slice::sort::find_streak" find_streak.
  End sort.
End slice.
