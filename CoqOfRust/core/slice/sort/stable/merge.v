(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module slice.
  Module sort.
    Module stable.
      Module merge.
        (*
        pub fn merge<T, F: FnMut(&T, &T) -> bool>(
            v: &mut [T],
            scratch: &mut [MaybeUninit<T>],
            mid: usize,
            is_less: &mut F,
        ) {
            let len = v.len();
        
            if mid == 0 || mid >= len || scratch.len() < cmp::min(mid, len - mid) {
                return;
            }
        
            // SAFETY: We checked that the two slices are non-empty and `mid` is in-bounds.
            // We checked that the buffer `scratch` has enough capacity to hold a copy of
            // the shorter slice. `merge_up` and `merge_down` are written in such a way that
            // they uphold the contract described in `MergeState::drop`.
            unsafe {
                // The merge process first copies the shorter run into `buf`. Then it traces
                // the newly copied run and the longer run forwards (or backwards), comparing
                // their next unconsumed elements and copying the lesser (or greater) one into `v`.
                //
                // As soon as the shorter run is fully consumed, the process is done. If the
                // longer run gets consumed first, then we must copy whatever is left of the
                // shorter run into the remaining gap in `v`.
                //
                // Intermediate state of the process is always tracked by `gap`, which serves
                // two purposes:
                //  1. Protects integrity of `v` from panics in `is_less`.
                //  2. Fills the remaining gap in `v` if the longer run gets consumed first.
        
                let buf = MaybeUninit::slice_as_mut_ptr(scratch);
        
                let v_base = v.as_mut_ptr();
                let v_mid = v_base.add(mid);
                let v_end = v_base.add(len);
        
                let left_len = mid;
                let right_len = len - mid;
        
                let left_is_shorter = left_len <= right_len;
                let save_base = if left_is_shorter { v_base } else { v_mid };
                let save_len = if left_is_shorter { left_len } else { right_len };
        
                ptr::copy_nonoverlapping(save_base, buf, save_len);
        
                let mut merge_state = MergeState { start: buf, end: buf.add(save_len), dst: save_base };
        
                if left_is_shorter {
                    merge_state.merge_up(v_mid, v_end, is_less);
                } else {
                    merge_state.merge_down(v_base, buf, v_end, is_less);
                }
                // Finally, `merge_state` gets dropped. If the shorter run was not fully
                // consumed, whatever remains of it will now be copied into the hole in `v`.
            }
        }
        *)
        Definition merge (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [ T; F ], [ v; scratch; mid; is_less ] =>
            ltac:(M.monadic
              (let v :=
                M.alloc (|
                  Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                  v
                |) in
              let scratch :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                    ],
                  scratch
                |) in
              let mid := M.alloc (| Ty.path "usize", mid |) in
              let is_less := M.alloc (| Ty.apply (Ty.path "&mut") [] [ F ], is_less |) in
              M.catch_return (Ty.tuple []) (|
                ltac:(M.monadic
                  (M.read (|
                    let~ len : Ty.path "usize" :=
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ T ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    LogicalOp.or (|
                                      LogicalOp.or (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [ M.read (| mid |); Value.Integer IntegerKind.Usize 0 ]
                                        |),
                                        ltac:(M.monadic
                                          (M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.ge,
                                            [ M.read (| mid |); M.read (| len |) ]
                                          |)))
                                      |),
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.lt,
                                          [
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ T ]
                                                  ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| scratch |) |)
                                                |)
                                              ]
                                            |);
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_function (|
                                                "core::cmp::min",
                                                [],
                                                [ Ty.path "usize" ]
                                              |),
                                              [
                                                M.read (| mid |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  BinOp.Wrap.sub,
                                                  [ M.read (| len |); M.read (| mid |) ]
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)))
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |) in
                    let~ buf : Ty.apply (Ty.path "*mut") [] [ T ] :=
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                          "slice_as_mut_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| scratch |) |) |) ]
                      |) in
                    let~ v_base : Ty.apply (Ty.path "*mut") [] [ T ] :=
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ T ],
                          "as_mut_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| v |) |) |) ]
                      |) in
                    let~ v_mid : Ty.apply (Ty.path "*mut") [] [ T ] :=
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          "add",
                          [],
                          []
                        |),
                        [ M.read (| v_base |); M.read (| mid |) ]
                      |) in
                    let~ v_end : Ty.apply (Ty.path "*mut") [] [ T ] :=
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          "add",
                          [],
                          []
                        |),
                        [ M.read (| v_base |); M.read (| len |) ]
                      |) in
                    let~ left_len : Ty.path "usize" := M.read (| mid |) in
                    let~ right_len : Ty.path "usize" :=
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ M.read (| len |); M.read (| mid |) ]
                      |) in
                    let~ left_is_shorter : Ty.path "bool" :=
                      M.call_closure (|
                        Ty.path "bool",
                        BinOp.le,
                        [ M.read (| left_len |); M.read (| right_len |) ]
                      |) in
                    let~ save_base : Ty.apply (Ty.path "*mut") [] [ T ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use left_is_shorter in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.read (| v_base |)));
                          fun γ => ltac:(M.monadic (M.read (| v_mid |)))
                        ]
                      |) in
                    let~ save_len : Ty.path "usize" :=
                      M.match_operator (|
                        Ty.path "usize",
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use left_is_shorter in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.read (| left_len |)));
                          fun γ => ltac:(M.monadic (M.read (| right_len |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
                        [
                          (* MutToConstPointer *) M.pointer_coercion (M.read (| save_base |));
                          M.read (| buf |);
                          M.read (| save_len |)
                        ]
                      |) in
                    let~ merge_state :
                        Ty.apply
                          (Ty.path "core::slice::sort::stable::merge::MergeState")
                          []
                          [ T ] :=
                      Value.mkStructRecord
                        "core::slice::sort::stable::merge::MergeState"
                        []
                        [ T ]
                        [
                          ("start", M.read (| buf |));
                          ("end_",
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                "add",
                                [],
                                []
                              |),
                              [ M.read (| buf |); M.read (| save_len |) ]
                            |));
                          ("dst", M.read (| save_base |))
                        ] in
                    M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use left_is_shorter in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.read (|
                                let~ _ : Ty.tuple [] :=
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::slice::sort::stable::merge::MergeState")
                                        []
                                        [ T ],
                                      "merge_up",
                                      [],
                                      [ F ]
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.MutRef, merge_state |);
                                      (* MutToConstPointer *)
                                      M.pointer_coercion (M.read (| v_mid |));
                                      (* MutToConstPointer *)
                                      M.pointer_coercion (M.read (| v_end |));
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| is_less |) |)
                                      |)
                                    ]
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.read (|
                                let~ _ : Ty.tuple [] :=
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::slice::sort::stable::merge::MergeState")
                                        []
                                        [ T ],
                                      "merge_down",
                                      [],
                                      [ F ]
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.MutRef, merge_state |);
                                      (* MutToConstPointer *)
                                      M.pointer_coercion (M.read (| v_base |));
                                      (* MutToConstPointer *) M.pointer_coercion (M.read (| buf |));
                                      M.read (| v_end |);
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| is_less |) |)
                                      |)
                                    ]
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                              |)))
                        ]
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_merge :
          M.IsFunction.C "core::slice::sort::stable::merge::merge" merge.
        Admitted.
        Global Typeclasses Opaque merge.
        
        (* StructRecord
          {
            name := "MergeState";
            const_params := [];
            ty_params := [ "T" ];
            fields :=
              [
                ("start", Ty.apply (Ty.path "*mut") [] [ T ]);
                ("end_", Ty.apply (Ty.path "*mut") [] [ T ]);
                ("dst", Ty.apply (Ty.path "*mut") [] [ T ])
              ];
          } *)
        
        Module Impl_core_slice_sort_stable_merge_MergeState_T.
          Definition Self (T : Ty.t) : Ty.t :=
            Ty.apply (Ty.path "core::slice::sort::stable::merge::MergeState") [] [ T ].
          
          (*
              unsafe fn merge_up<F: FnMut(&T, &T) -> bool>(
                  &mut self,
                  mut right: *const T,
                  right_end: *const T,
                  is_less: &mut F,
              ) {
                  // SAFETY: See function safety comment.
                  unsafe {
                      let left = &mut self.start;
                      let out = &mut self.dst;
          
                      while *left != self.end && right as *const T != right_end {
                          let consume_left = !is_less(&*right, &**left);
          
                          let src = if consume_left { *left } else { right };
                          ptr::copy_nonoverlapping(src, *out, 1);
          
                          *left = left.add(consume_left as usize);
                          right = right.add(!consume_left as usize);
          
                          *out = out.add(1);
                      }
                  }
              }
          *)
          Definition merge_up
              (T : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self T in
            match ε, τ, α with
            | [], [ F ], [ self; _ as right; right_end; is_less ] =>
              ltac:(M.monadic
                (let self :=
                  M.alloc (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "core::slice::sort::stable::merge::MergeState") [] [ T ]
                      ],
                    self
                  |) in
                let right := M.alloc (| Ty.apply (Ty.path "*const") [] [ T ], right |) in
                let right_end := M.alloc (| Ty.apply (Ty.path "*const") [] [ T ], right_end |) in
                let is_less := M.alloc (| Ty.apply (Ty.path "&mut") [] [ F ], is_less |) in
                M.read (|
                  let~ left : Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ] :=
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::sort::stable::merge::MergeState",
                        "start"
                      |)
                    |) in
                  let~ out : Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ] :=
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::slice::sort::stable::merge::MergeState",
                        "dst"
                      |)
                    |) in
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (M.alloc (|
                        Ty.tuple [],
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      LogicalOp.and (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.ne,
                                          [
                                            M.read (| M.deref (| M.read (| left |) |) |);
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::slice::sort::stable::merge::MergeState",
                                                "end"
                                              |)
                                            |)
                                          ]
                                        |),
                                        ltac:(M.monadic
                                          (M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.ne,
                                            [
                                              M.cast
                                                (Ty.apply (Ty.path "*const") [] [ T ])
                                                (M.read (| right |));
                                              M.read (| right_end |)
                                            ]
                                          |)))
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.read (|
                                  let~ consume_left : Ty.path "bool" :=
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::ops::function::FnMut",
                                          F,
                                          [],
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply (Ty.path "&") [] [ T ];
                                                Ty.apply (Ty.path "&") [] [ T ]
                                              ]
                                          ],
                                          "call_mut",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| is_less |) |)
                                          |);
                                          Value.Tuple
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| right |) |)
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.read (| M.deref (| M.read (| left |) |) |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            ]
                                        ]
                                      |)
                                    |) in
                                  let~ src : Ty.apply (Ty.path "*const") [] [ T ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*const") [] [ T ],
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ := M.use consume_left in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            (* MutToConstPointer *)
                                            M.pointer_coercion
                                              (M.read (| M.deref (| M.read (| left |) |) |))));
                                        fun γ => ltac:(M.monadic (M.read (| right |)))
                                      ]
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.call_closure (|
                                      Ty.tuple [],
                                      M.get_function (|
                                        "core::intrinsics::copy_nonoverlapping",
                                        [],
                                        [ T ]
                                      |),
                                      [
                                        M.read (| src |);
                                        M.read (| M.deref (| M.read (| out |) |) |);
                                        Value.Integer IntegerKind.Usize 1
                                      ]
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.write (|
                                      M.deref (| M.read (| left |) |),
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*mut") [] [ T ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                          "add",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| M.deref (| M.read (| left |) |) |);
                                          M.cast (Ty.path "usize") (M.read (| consume_left |))
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.write (|
                                      right,
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*const") [] [ T ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*const") [] [ T ],
                                          "add",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| right |);
                                          M.cast
                                            (Ty.path "usize")
                                            (UnOp.not (| M.read (| consume_left |) |))
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.write (|
                                      M.deref (| M.read (| out |) |),
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*mut") [] [ T ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                          "add",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| M.deref (| M.read (| out |) |) |);
                                          Value.Integer IntegerKind.Usize 1
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.never_to_any (|
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.never_to_any (| M.read (| M.break (||) |) |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                  |)
                                |)))
                          ]
                        |)
                      |)))
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_merge_up :
            forall (T : Ty.t),
            M.IsAssociatedFunction.C (Self T) "merge_up" (merge_up T).
          Admitted.
          Global Typeclasses Opaque merge_up.
          
          (*
              unsafe fn merge_down<F: FnMut(&T, &T) -> bool>(
                  &mut self,
                  left_end: *const T,
                  right_end: *const T,
                  mut out: *mut T,
                  is_less: &mut F,
              ) {
                  // SAFETY: See function safety comment.
                  unsafe {
                      loop {
                          let left = self.dst.sub(1);
                          let right = self.end.sub(1);
                          out = out.sub(1);
          
                          let consume_left = is_less(&*right, &*left);
          
                          let src = if consume_left { left } else { right };
                          ptr::copy_nonoverlapping(src, out, 1);
          
                          self.dst = left.add(!consume_left as usize);
                          self.end = right.add(consume_left as usize);
          
                          if self.dst as *const T == left_end || self.end as *const T == right_end {
                              break;
                          }
                      }
                  }
              }
          *)
          Definition merge_down
              (T : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self T in
            match ε, τ, α with
            | [], [ F ], [ self; left_end; right_end; out; is_less ] =>
              ltac:(M.monadic
                (let self :=
                  M.alloc (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "core::slice::sort::stable::merge::MergeState") [] [ T ]
                      ],
                    self
                  |) in
                let left_end := M.alloc (| Ty.apply (Ty.path "*const") [] [ T ], left_end |) in
                let right_end := M.alloc (| Ty.apply (Ty.path "*const") [] [ T ], right_end |) in
                let out := M.alloc (| Ty.apply (Ty.path "*mut") [] [ T ], out |) in
                let is_less := M.alloc (| Ty.apply (Ty.path "&mut") [] [ F ], is_less |) in
                M.read (|
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (let~ left : Ty.apply (Ty.path "*mut") [] [ T ] :=
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "sub",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::sort::stable::merge::MergeState",
                                "dst"
                              |)
                            |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |) in
                      let~ right : Ty.apply (Ty.path "*mut") [] [ T ] :=
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "sub",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::slice::sort::stable::merge::MergeState",
                                "end"
                              |)
                            |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          out,
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              "sub",
                              [],
                              []
                            |),
                            [ M.read (| out |); Value.Integer IntegerKind.Usize 1 ]
                          |)
                        |) in
                      let~ consume_left : Ty.path "bool" :=
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_trait_method (|
                            "core::ops::function::FnMut",
                            F,
                            [],
                            [
                              Ty.tuple
                                [ Ty.apply (Ty.path "&") [] [ T ]; Ty.apply (Ty.path "&") [] [ T ] ]
                            ],
                            "call_mut",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| is_less |) |) |);
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| right |) |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| left |) |) |)
                                  |)
                                |)
                              ]
                          ]
                        |) in
                      let~ src : Ty.apply (Ty.path "*mut") [] [ T ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.use consume_left in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.read (| left |)));
                            fun γ => ltac:(M.monadic (M.read (| right |)))
                          ]
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
                          [
                            (* MutToConstPointer *) M.pointer_coercion (M.read (| src |));
                            M.read (| out |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::sort::stable::merge::MergeState",
                            "dst"
                          |),
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.read (| left |);
                              M.cast (Ty.path "usize") (UnOp.not (| M.read (| consume_left |) |))
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::sort::stable::merge::MergeState",
                            "end"
                          |),
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.read (| right |);
                              M.cast (Ty.path "usize") (M.read (| consume_left |))
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Ty.tuple [],
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      LogicalOp.or (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.cast
                                              (Ty.apply (Ty.path "*const") [] [ T ])
                                              (* MutToConstPointer *)
                                              (M.pointer_coercion
                                                (M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::slice::sort::stable::merge::MergeState",
                                                    "dst"
                                                  |)
                                                |)));
                                            M.read (| left_end |)
                                          ]
                                        |),
                                        ltac:(M.monadic
                                          (M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.cast
                                                (Ty.apply (Ty.path "*const") [] [ T ])
                                                (* MutToConstPointer *)
                                                (M.pointer_coercion
                                                  (M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "core::slice::sort::stable::merge::MergeState",
                                                      "end"
                                                    |)
                                                  |)));
                                              M.read (| right_end |)
                                            ]
                                          |)))
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.never_to_any (| M.read (| M.break (||) |) |)));
                            fun γ => ltac:(M.monadic (Value.Tuple []))
                          ]
                        |)
                      |)))
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_merge_down :
            forall (T : Ty.t),
            M.IsAssociatedFunction.C (Self T) "merge_down" (merge_down T).
          Admitted.
          Global Typeclasses Opaque merge_down.
        End Impl_core_slice_sort_stable_merge_MergeState_T.
        
        Module Impl_core_ops_drop_Drop_for_core_slice_sort_stable_merge_MergeState_T.
          Definition Self (T : Ty.t) : Ty.t :=
            Ty.apply (Ty.path "core::slice::sort::stable::merge::MergeState") [] [ T ].
          
          (*
              fn drop(&mut self) {
                  // SAFETY: The user of MergeState MUST ensure, that at any point this drop
                  // impl MAY run, for example when the user provided `is_less` panics, that
                  // copying the contiguous region between `start` and `end` to `dst` will
                  // leave the input slice `v` with each original element and all possible
                  // modifications observed.
                  unsafe {
                      let len = self.end.sub_ptr(self.start);
                      ptr::copy_nonoverlapping(self.start, self.dst, len);
                  }
              }
          *)
          Definition drop (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self :=
                  M.alloc (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "core::slice::sort::stable::merge::MergeState") [] [ T ]
                      ],
                    self
                  |) in
                M.read (|
                  let~ len : Ty.path "usize" :=
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "sub_ptr",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::sort::stable::merge::MergeState",
                            "end"
                          |)
                        |);
                        (* MutToConstPointer *)
                        M.pointer_coercion
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::sort::stable::merge::MergeState",
                              "start"
                            |)
                          |))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
                      [
                        (* MutToConstPointer *)
                        M.pointer_coercion
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::slice::sort::stable::merge::MergeState",
                              "start"
                            |)
                          |));
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::slice::sort::stable::merge::MergeState",
                            "dst"
                          |)
                        |);
                        M.read (| len |)
                      ]
                    |) in
                  M.alloc (| Ty.tuple [], Value.Tuple [] |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (T : Ty.t),
            M.IsTraitInstance
              "core::ops::drop::Drop"
              (* Trait polymorphic consts *) []
              (* Trait polymorphic types *) []
              (Self T)
              (* Instance *) [ ("drop", InstanceField.Method (drop T)) ].
        End Impl_core_ops_drop_Drop_for_core_slice_sort_stable_merge_MergeState_T.
      End merge.
    End stable.
  End sort.
End slice.
