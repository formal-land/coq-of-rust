(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module str.
  Module converts.
    (*
    pub const fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {
        // FIXME: This should use `?` again, once it's `const`
        match run_utf8_validation(v) {
            Ok(_) => {
                // SAFETY: validation succeeded.
                Ok(unsafe { from_utf8_unchecked(v) })
            }
            Err(err) => Err(err),
        }
    }
    *)
    Definition from_utf8 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::str::validations::run_utf8_validation", [] |),
                  [ M.read (| v |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_function (| "core::str::converts::from_utf8_unchecked", [] |),
                            [ M.read (| v |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    let err := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| err |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    pub const fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {
        // This should use `?` again, once it's `const`
        match run_utf8_validation(v) {
            Ok(_) => {
                // SAFETY: validation succeeded.
                Ok(unsafe { from_utf8_unchecked_mut(v) })
            }
            Err(err) => Err(err),
        }
    }
    *)
    Definition from_utf8_mut (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::str::validations::run_utf8_validation", [] |),
                  [ M.read (| v |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_function (| "core::str::converts::from_utf8_unchecked_mut", [] |),
                            [ M.read (| v |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    let err := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| err |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {
        // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.
        // Also relies on `&str` and `&[u8]` having the same layout.
        unsafe { mem::transmute(v) }
    }
    *)
    Definition from_utf8_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_function (|
              "core::intrinsics::transmute",
              [
                Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                Ty.apply (Ty.path "&") [ Ty.path "str" ]
              ]
            |),
            [ M.read (| v |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    pub const unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {
        // SAFETY: the caller must guarantee that the bytes `v`
        // are valid UTF-8, thus the cast to `*mut str` is safe.
        // Also, the pointer dereference is safe because that pointer
        // comes from a reference which is guaranteed to be valid for writes.
        unsafe { &mut *(v as *mut [u8] as *mut str) }
    }
    *)
    Definition from_utf8_unchecked_mut (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))))
      | _, _ => M.impossible
      end.
  End converts.
End str.
