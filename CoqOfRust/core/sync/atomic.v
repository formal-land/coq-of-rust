(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module sync.
  Module atomic.
    Definition value_EMULATE_ATOMIC_BOOL : Value.t :=
      M.run_constant ltac:(M.monadic (M.alloc (| Value.Bool false |))).
    
    Axiom Constant_value_EMULATE_ATOMIC_BOOL :
      (M.get_constant "core::sync::atomic::EMULATE_ATOMIC_BOOL") = value_EMULATE_ATOMIC_BOOL.
    Global Hint Rewrite Constant_value_EMULATE_ATOMIC_BOOL : constant_rewrites.
    
    (* StructRecord
      {
        name := "AtomicBool";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicBool.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicBool".
      
      (*
          fn default() -> Self {
              Self::new(false)
          }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicBool",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicBool",
                "new",
                [],
                []
              |),
              [ Value.Bool false ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicBool.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicBool.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicBool".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicBool.
    
    (* StructRecord
      {
        name := "AtomicPtr";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("p",
              Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ])
          ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ].
      
      (*
          fn default() -> AtomicPtr<T> {
              AtomicPtr::new(crate::ptr::null_mut())
          }
      *)
      Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_function (| "core::ptr::null_mut", [], [ T ] |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicPtr_T.
    
    Module Impl_core_marker_Send_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Send_for_core_sync_atomic_AtomicPtr_T.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicPtr_T.
    
    (*
    Enum Ordering
    {
      const_params := [];
      ty_params := [];
      variants :=
        [
          {
            name := "Relaxed";
            item := StructTuple [];
          };
          {
            name := "Release";
            item := StructTuple [];
          };
          {
            name := "Acquire";
            item := StructTuple [];
          };
          {
            name := "AcqRel";
            item := StructTuple [];
          };
          {
            name := "SeqCst";
            item := StructTuple [];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_Ordering_Relaxed :
      M.IsDiscriminant "core::sync::atomic::Ordering::Relaxed" 0.
    Axiom IsDiscriminant_Ordering_Release :
      M.IsDiscriminant "core::sync::atomic::Ordering::Release" 1.
    Axiom IsDiscriminant_Ordering_Acquire :
      M.IsDiscriminant "core::sync::atomic::Ordering::Acquire" 2.
    Axiom IsDiscriminant_Ordering_AcqRel :
      M.IsDiscriminant "core::sync::atomic::Ordering::AcqRel" 3.
    Axiom IsDiscriminant_Ordering_SeqCst :
      M.IsDiscriminant "core::sync::atomic::Ordering::SeqCst" 4.
    
    Module Impl_core_marker_Copy_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_sync_atomic_Ordering.
    
    Module Impl_core_clone_Clone_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.deref (| M.read (| self |) |) |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_sync_atomic_Ordering.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.read (|
                  M.match_operator (|
                    self,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let _ :=
                            M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                          M.alloc (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.read (| Value.String "Relaxed" |) |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let _ :=
                            M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                          M.alloc (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.read (| Value.String "Release" |) |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let _ :=
                            M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                          M.alloc (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.read (| Value.String "Acquire" |) |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let _ :=
                            M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                          M.alloc (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.read (| Value.String "AcqRel" |) |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let _ :=
                            M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                          M.alloc (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.read (| Value.String "SeqCst" |) |)
                            |)
                          |)))
                    ]
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_Ordering.
    
    Module Impl_core_cmp_Eq_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_sync_atomic_Ordering.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_sync_atomic_Ordering.
    
    Module Impl_core_cmp_PartialEq_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ __self_discr : Ty.path "isize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "isize",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.path "core::sync::atomic::Ordering" ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              let~ __arg1_discr : Ty.path "isize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "isize",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.path "core::sync::atomic::Ordering" ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |) in
              M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_sync_atomic_Ordering.
    
    Module Impl_core_hash_Hash_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      (* Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ __self_discr : Ty.path "isize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "isize",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.path "core::sync::atomic::Ordering" ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_sync_atomic_Ordering.
    
    Definition value_ATOMIC_BOOL_INIT : Value.t :=
      M.run_constant
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicBool",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicBool",
                "new",
                [],
                []
              |),
              [ Value.Bool false ]
            |)
          |))).
    
    Axiom Constant_value_ATOMIC_BOOL_INIT :
      (M.get_constant "core::sync::atomic::ATOMIC_BOOL_INIT") = value_ATOMIC_BOOL_INIT.
    Global Hint Rewrite Constant_value_ATOMIC_BOOL_INIT : constant_rewrites.
    
    Module Impl_core_sync_atomic_AtomicBool.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicBool".
      
      (*
          pub const fn new(v: bool) -> AtomicBool {
              AtomicBool { v: UnsafeCell::new(v as u8) }
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicBool"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.cast (Ty.path "u8") (M.read (| v |)) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub const unsafe fn from_ptr<'a>(ptr: *mut bool) -> &'a AtomicBool {
              // SAFETY: guaranteed by the caller
              unsafe { &*ptr.cast() }
          }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicBool" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "bool" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicBool" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
          pub fn get_mut(&mut self) -> &mut bool {
              // SAFETY: the mutable reference guarantees unique ownership.
              unsafe { &mut *(self.v.get() as *mut bool) }
          }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply (Ty.path "*mut") [] [ Ty.path "bool" ])
                              (M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::sync::atomic::AtomicBool",
                                      "v"
                                    |)
                                  |)
                                ]
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
          pub fn from_mut(v: &mut bool) -> &mut Self {
              // SAFETY: the mutable reference guarantees unique ownership, and
              // alignment of both `bool` and `Self` is 1.
              unsafe { &mut *(v as *mut bool as *mut Self) }
          }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.path "core::sync::atomic::AtomicBool" ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| v |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
          pub fn get_mut_slice(this: &mut [Self]) -> &mut [bool] {
              // SAFETY: the mutable reference guarantees unique ownership.
              unsafe { &mut *(this as *mut [Self] as *mut [bool]) }
          }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "bool" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
          pub fn from_mut_slice(v: &mut [bool]) -> &mut [Self] {
              // SAFETY: the mutable reference guarantees unique ownership, and
              // alignment of both `bool` and `Self` is 1.
              unsafe { &mut *(v as *mut [bool] as *mut [Self]) }
          }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "core::sync::atomic::AtomicBool" ]
                                ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| v |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
          pub const fn into_inner(self) -> bool {
              self.v.into_inner() != 0
          }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.ne (|
              M.call_closure (|
                Ty.path "u8",
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                  "into_inner",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "core::sync::atomic::AtomicBool",
                      "v"
                    |)
                  |)
                ]
              |),
              Value.Integer IntegerKind.U8 0
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
          pub fn load(&self, order: Ordering) -> bool {
              // SAFETY: any data races are prevented by atomic intrinsics and the raw
              // pointer passed in is valid because we got it from a reference.
              unsafe { atomic_load(self.v.get(), order) != 0 }
          }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            BinOp.ne (|
              M.call_closure (|
                Ty.path "u8",
                M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "u8" ] |),
                [
                  (* MutToConstPointer *)
                  M.pointer_coercion
                    (M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicBool",
                            "v"
                          |)
                        |)
                      ]
                    |));
                  M.read (| order |)
                ]
              |),
              Value.Integer IntegerKind.U8 0
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
          pub fn store(&self, val: bool, order: Ordering) {
              // SAFETY: any data races are prevented by atomic intrinsics and the raw
              // pointer passed in is valid because we got it from a reference.
              unsafe {
                  atomic_store(self.v.get(), val as u8, order);
              }
          }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::sync::atomic::atomic_store", [], [ Ty.path "u8" ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicBool",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.cast (Ty.path "u8") (M.read (| val |));
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
          pub fn swap(&self, val: bool, order: Ordering) -> bool {
              if EMULATE_ATOMIC_BOOL {
                  if val { self.fetch_or(true, order) } else { self.fetch_and(false, order) }
              } else {
                  // SAFETY: data races are prevented by atomic intrinsics.
                  unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }
              }
          }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.get_constant "core::sync::atomic::EMULATE_ATOMIC_BOOL") in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use val in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.path "core::sync::atomic::AtomicBool",
                                    "fetch_or",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| self |) |)
                                    |);
                                    Value.Bool true;
                                    M.read (| order |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.path "core::sync::atomic::AtomicBool",
                                    "fetch_and",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| self |) |)
                                    |);
                                    Value.Bool false;
                                    M.read (| order |)
                                  ]
                                |)
                              |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        BinOp.ne (|
                          M.call_closure (|
                            Ty.path "u8",
                            M.get_function (|
                              "core::sync::atomic::atomic_swap",
                              [],
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::sync::atomic::AtomicBool",
                                      "v"
                                    |)
                                  |)
                                ]
                              |);
                              M.cast (Ty.path "u8") (M.read (| val |));
                              M.read (| order |)
                            ]
                          |),
                          Value.Integer IntegerKind.U8 0
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
          pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {
              match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {
                  Ok(x) => x,
                  Err(x) => x,
              }
          }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "bool"; Ty.path "bool" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicBool",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
          pub fn compare_exchange(
              &self,
              current: bool,
              new: bool,
              success: Ordering,
              failure: Ordering,
          ) -> Result<bool, bool> {
              if EMULATE_ATOMIC_BOOL {
                  // Pick the strongest ordering from success and failure.
                  let order = match (success, failure) {
                      (SeqCst, _) => SeqCst,
                      (_, SeqCst) => SeqCst,
                      (AcqRel, _) => AcqRel,
                      (_, AcqRel) => {
                          panic!("there is no such thing as an acquire-release failure ordering")
                      }
                      (Release, Acquire) => AcqRel,
                      (Acquire, _) => Acquire,
                      (_, Acquire) => Acquire,
                      (Release, Relaxed) => Release,
                      (_, Release) => panic!("there is no such thing as a release failure ordering"),
                      (Relaxed, Relaxed) => Relaxed,
                  };
                  let old = if current == new {
                      // This is a no-op, but we still need to perform the operation
                      // for memory ordering reasons.
                      self.fetch_or(false, order)
                  } else {
                      // This sets the value to the new one and returns the old one.
                      self.swap(new, order)
                  };
                  if old == current { Ok(old) } else { Err(old) }
              } else {
                  // SAFETY: data races are prevented by atomic intrinsics.
                  match unsafe {
                      atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)
                  } {
                      Ok(x) => Ok(x != 0),
                      Err(x) => Err(x != 0),
                  }
              }
          }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.get_constant "core::sync::atomic::EMULATE_ATOMIC_BOOL") in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ order : Ty.path "core::sync::atomic::Ordering" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              Value.Tuple [ M.read (| success |); M.read (| failure |) ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_0,
                                      "core::sync::atomic::Ordering::SeqCst"
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::SeqCst" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_1,
                                      "core::sync::atomic::Ordering::SeqCst"
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::SeqCst" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_0,
                                      "core::sync::atomic::Ordering::AcqRel"
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::AcqRel" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_1,
                                      "core::sync::atomic::Ordering::AcqRel"
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::Arguments",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_const",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.alloc (|
                                                      Value.Array
                                                        [
                                                          M.read (|
                                                            Value.String
                                                              "there is no such thing as an acquire-release failure ordering"
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_0,
                                      "core::sync::atomic::Ordering::Release"
                                    |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_1,
                                      "core::sync::atomic::Ordering::Acquire"
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::AcqRel" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_0,
                                      "core::sync::atomic::Ordering::Acquire"
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::Acquire" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_1,
                                      "core::sync::atomic::Ordering::Acquire"
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::Acquire" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_0,
                                      "core::sync::atomic::Ordering::Release"
                                    |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_1,
                                      "core::sync::atomic::Ordering::Relaxed"
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::Release" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_1,
                                      "core::sync::atomic::Ordering::Release"
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::Arguments",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_const",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.alloc (|
                                                      Value.Array
                                                        [
                                                          M.read (|
                                                            Value.String
                                                              "there is no such thing as a release failure ordering"
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_0,
                                      "core::sync::atomic::Ordering::Relaxed"
                                    |) in
                                  let _ :=
                                    M.is_struct_tuple (|
                                      γ0_1,
                                      "core::sync::atomic::Ordering::Relaxed"
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                                  |)))
                            ]
                          |)
                        |) in
                      let~ old : Ty.path "bool" :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.eq (| M.read (| current |), M.read (| new |) |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicBool",
                                        "fetch_or",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        Value.Bool false;
                                        M.read (| order |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicBool",
                                        "swap",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| new |);
                                        M.read (| order |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.eq (| M.read (| old |), M.read (| current |) |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::result::Result::Ok" [ M.read (| old |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| old |) ]
                              |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.path "u8"; Ty.path "u8" ],
                            M.get_function (|
                              "core::sync::atomic::atomic_compare_exchange",
                              [],
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::sync::atomic::AtomicBool",
                                      "v"
                                    |)
                                  |)
                                ]
                              |);
                              M.cast (Ty.path "u8") (M.read (| current |));
                              M.cast (Ty.path "u8") (M.read (| new |));
                              M.read (| success |);
                              M.read (| failure |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Ok",
                                  0
                                |) in
                              let x := M.copy (| γ0_0 |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::result::Result::Ok"
                                  [ BinOp.ne (| M.read (| x |), Value.Integer IntegerKind.U8 0 |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Err",
                                  0
                                |) in
                              let x := M.copy (| γ0_0 |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [ BinOp.ne (| M.read (| x |), Value.Integer IntegerKind.U8 0 |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
          pub fn compare_exchange_weak(
              &self,
              current: bool,
              new: bool,
              success: Ordering,
              failure: Ordering,
          ) -> Result<bool, bool> {
              if EMULATE_ATOMIC_BOOL {
                  return self.compare_exchange(current, new, success, failure);
              }
      
              // SAFETY: data races are prevented by atomic intrinsics.
              match unsafe {
                  atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)
              } {
                  Ok(x) => Ok(x != 0),
                  Err(x) => Err(x != 0),
              }
          }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use (M.get_constant "core::sync::atomic::EMULATE_ATOMIC_BOOL") in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "bool"; Ty.path "bool" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicBool",
                                        "compare_exchange",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| current |);
                                        M.read (| new |);
                                        M.read (| success |);
                                        M.read (| failure |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u8"; Ty.path "u8" ],
                        M.get_function (|
                          "core::sync::atomic::atomic_compare_exchange_weak",
                          [],
                          [ Ty.path "u8" ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                              "get",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::sync::atomic::AtomicBool",
                                  "v"
                                |)
                              |)
                            ]
                          |);
                          M.cast (Ty.path "u8") (M.read (| current |));
                          M.cast (Ty.path "u8") (M.read (| new |));
                          M.read (| success |);
                          M.read (| failure |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let x := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Ok"
                              [ BinOp.ne (| M.read (| x |), Value.Integer IntegerKind.U8 0 |) ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let x := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Err"
                              [ BinOp.ne (| M.read (| x |), Value.Integer IntegerKind.U8 0 |) ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
          pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }
          }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            BinOp.ne (|
              M.call_closure (|
                Ty.path "u8",
                M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "u8" ] |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicBool",
                          "v"
                        |)
                      |)
                    ]
                  |);
                  M.cast (Ty.path "u8") (M.read (| val |));
                  M.read (| order |)
                ]
              |),
              Value.Integer IntegerKind.U8 0
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
          pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {
              // We can't use atomic_nand here because it can result in a bool with
              // an invalid value. This happens because the atomic operation is done
              // with an 8-bit integer internally, which would set the upper 7 bits.
              // So we just use fetch_xor or swap instead.
              if val {
                  // !(x & true) == !x
                  // We must invert the bool.
                  self.fetch_xor(true, order)
              } else {
                  // !(x & false) == true
                  // We must set the bool to true.
                  self.swap(true, order)
              }
          }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use val in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicBool",
                            "fetch_xor",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.Bool true;
                            M.read (| order |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicBool",
                            "swap",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.Bool true;
                            M.read (| order |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
          pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }
          }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            BinOp.ne (|
              M.call_closure (|
                Ty.path "u8",
                M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "u8" ] |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicBool",
                          "v"
                        |)
                      |)
                    ]
                  |);
                  M.cast (Ty.path "u8") (M.read (| val |));
                  M.read (| order |)
                ]
              |),
              Value.Integer IntegerKind.U8 0
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
          pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }
          }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            BinOp.ne (|
              M.call_closure (|
                Ty.path "u8",
                M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "u8" ] |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicBool",
                          "v"
                        |)
                      |)
                    ]
                  |);
                  M.cast (Ty.path "u8") (M.read (| val |));
                  M.read (| order |)
                ]
              |),
              Value.Integer IntegerKind.U8 0
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
          pub fn fetch_not(&self, order: Ordering) -> bool {
              self.fetch_xor(true, order)
          }
      *)
      Definition fetch_not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicBool",
                "fetch_xor",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                Value.Bool true;
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_not : M.IsAssociatedFunction Self "fetch_not" fetch_not.
      Smpl Add apply AssociatedFunction_fetch_not : is_associated.
      
      (*
          pub const fn as_ptr(&self) -> *mut bool {
              self.v.get().cast()
          }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "bool" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "cast",
                [],
                [ Ty.path "bool" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicBool",
                        "v"
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
      
      (*
          pub fn fetch_update<F>(
              &self,
              set_order: Ordering,
              fetch_order: Ordering,
              mut f: F,
          ) -> Result<bool, bool>
          where
              F: FnMut(bool) -> Option<bool>,
          {
              let mut prev = self.load(fetch_order);
              while let Some(next) = f(prev) {
                  match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                      x @ Ok(_) => return x,
                      Err(next_prev) => prev = next_prev,
                  }
              }
              Err(prev)
          }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "bool" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicBool",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "bool" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "bool" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "bool"; Ty.path "bool" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicBool",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
    End Impl_core_sync_atomic_AtomicBool.
    
    Module Impl_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ].
      
      (*
          pub const fn new(p: *mut T) -> AtomicPtr<T> {
              AtomicPtr { p: UnsafeCell::new(p) }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ p ] =>
          ltac:(M.monadic
            (let p := M.alloc (| p |) in
            Value.StructRecord
              "core::sync::atomic::AtomicPtr"
              [
                ("p",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::cell::UnsafeCell")
                      []
                      [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::cell::UnsafeCell")
                        []
                        [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| p |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
          pub const unsafe fn from_ptr<'a>(ptr: *mut *mut T) -> &'a AtomicPtr<T> {
              // SAFETY: guaranteed by the caller
              unsafe { &*ptr.cast() }
          }
      *)
      Definition from_ptr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                        "cast",
                        [],
                        [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ] ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "from_ptr" (from_ptr T).
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
          pub fn get_mut(&mut self) -> &mut *mut T {
              self.p.get_mut()
          }
      *)
      Definition get_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicPtr",
                            "p"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "get_mut" (get_mut T).
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
          pub fn from_mut(v: &mut *mut T) -> &mut Self {
              let [] = [(); align_of::<AtomicPtr<()>>() - align_of::<*mut ()>()];
              // SAFETY:
              //  - the mutable reference guarantees unique ownership.
              //  - the alignment of `*mut T` and `Self` is the same on all platforms
              //    supported by rust, as verified above.
              unsafe { &mut *(v as *mut *mut T as *mut Self) }
          }
      *)
      Definition from_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::sync::atomic::AtomicPtr")
                                                []
                                                [ T ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "from_mut" (from_mut T).
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
          pub fn get_mut_slice(this: &mut [Self]) -> &mut [*mut T] {
              // SAFETY: the mutable reference guarantees unique ownership.
              unsafe { &mut *(this as *mut [Self] as *mut [*mut T]) }
          }
      *)
      Definition get_mut_slice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                                ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "get_mut_slice" (get_mut_slice T).
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
          pub fn from_mut_slice(v: &mut [*mut T]) -> &mut [Self] {
              // SAFETY:
              //  - the mutable reference guarantees unique ownership.
              //  - the alignment of `*mut T` and `Self` is the same on all platforms
              //    supported by rust, as verified above.
              unsafe { &mut *(v as *mut [*mut T] as *mut [Self]) }
          }
      *)
      Definition from_mut_slice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ] ]
                                ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| v |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "from_mut_slice" (from_mut_slice T).
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
          pub const fn into_inner(self) -> *mut T {
              self.p.into_inner()
          }
      *)
      Definition into_inner (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::cell::UnsafeCell")
                  []
                  [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicPtr",
                    "p"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "into_inner" (into_inner T).
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
          pub fn load(&self, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_load(self.p.get(), order) }
          }
      *)
      Definition load (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_function (|
                "core::sync::atomic::atomic_load",
                [],
                [ Ty.apply (Ty.path "*mut") [] [ T ] ]
              |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::cell::UnsafeCell")
                        []
                        [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicPtr",
                          "p"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "load" (load T).
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
          pub fn store(&self, ptr: *mut T, order: Ordering) {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe {
                  atomic_store(self.p.get(), ptr, order);
              }
          }
      *)
      Definition store (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; ptr; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let ptr := M.alloc (| ptr |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (|
                      "core::sync::atomic::atomic_store",
                      [],
                      [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::cell::UnsafeCell")
                            []
                            [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicPtr",
                              "p"
                            |)
                          |)
                        ]
                      |);
                      M.read (| ptr |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "store" (store T).
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
          pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_swap(self.p.get(), ptr, order) }
          }
      *)
      Definition swap (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; ptr; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let ptr := M.alloc (| ptr |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_function (|
                "core::sync::atomic::atomic_swap",
                [],
                [ Ty.apply (Ty.path "*mut") [] [ T ] ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::cell::UnsafeCell")
                      []
                      [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicPtr",
                        "p"
                      |)
                    |)
                  ]
                |);
                M.read (| ptr |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "swap" (swap T).
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
          pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {
              match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {
                  Ok(x) => x,
                  Err(x) => x,
              }
          }
      *)
      Definition compare_and_swap
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.apply (Ty.path "*mut") [] [ T ] ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "compare_and_swap" (compare_and_swap T).
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
          pub fn compare_exchange(
              &self,
              current: *mut T,
              new: *mut T,
              success: Ordering,
              failure: Ordering,
          ) -> Result<*mut T, *mut T> {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_compare_exchange(self.p.get(), current, new, success, failure) }
          }
      *)
      Definition compare_exchange
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.apply (Ty.path "*mut") [] [ T ] ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.apply (Ty.path "*mut") [] [ T ] ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::cell::UnsafeCell")
                      []
                      [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicPtr",
                        "p"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "compare_exchange" (compare_exchange T).
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
          pub fn compare_exchange_weak(
              &self,
              current: *mut T,
              new: *mut T,
              success: Ordering,
              failure: Ordering,
          ) -> Result<*mut T, *mut T> {
              // SAFETY: This intrinsic is unsafe because it operates on a raw pointer
              // but we know for sure that the pointer is valid (we just got it from
              // an `UnsafeCell` that we have by reference) and the atomic operation
              // itself allows us to safely mutate the `UnsafeCell` contents.
              unsafe { atomic_compare_exchange_weak(self.p.get(), current, new, success, failure) }
          }
      *)
      Definition compare_exchange_weak
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.apply (Ty.path "*mut") [] [ T ] ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.apply (Ty.path "*mut") [] [ T ] ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::cell::UnsafeCell")
                      []
                      [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicPtr",
                        "p"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "compare_exchange_weak" (compare_exchange_weak T).
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
          pub fn fetch_update<F>(
              &self,
              set_order: Ordering,
              fetch_order: Ordering,
              mut f: F,
          ) -> Result<*mut T, *mut T>
          where
              F: FnMut( *mut T) -> Option<*mut T>,
          {
              let mut prev = self.load(fetch_order);
              while let Some(next) = f(prev) {
                  match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                      x @ Ok(_) => return x,
                      Err(next_prev) => prev = next_prev,
                  }
              }
              Err(prev)
          }
      *)
      Definition fetch_update
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.apply (Ty.path "*mut") [] [ T ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ T ] ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply (Ty.path "*mut") [] [ T ];
                                          Ty.apply (Ty.path "*mut") [] [ T ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_update" (fetch_update T).
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
          pub fn fetch_ptr_add(&self, val: usize, order: Ordering) -> *mut T {
              self.fetch_byte_add(val.wrapping_mul(core::mem::size_of::<T>()), order)
          }
      *)
      Definition fetch_ptr_add
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
                "fetch_byte_add",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "wrapping_mul", [], [] |),
                  [
                    M.read (| val |);
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_function (| "core::mem::size_of", [], [ T ] |),
                      []
                    |)
                  ]
                |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_ptr_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_ptr_add" (fetch_ptr_add T).
      Smpl Add apply AssociatedFunction_fetch_ptr_add : is_associated.
      
      (*
          pub fn fetch_ptr_sub(&self, val: usize, order: Ordering) -> *mut T {
              self.fetch_byte_sub(val.wrapping_mul(core::mem::size_of::<T>()), order)
          }
      *)
      Definition fetch_ptr_sub
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
                "fetch_byte_sub",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "wrapping_mul", [], [] |),
                  [
                    M.read (| val |);
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_function (| "core::mem::size_of", [], [ T ] |),
                      []
                    |)
                  ]
                |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_ptr_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_ptr_sub" (fetch_ptr_sub T).
      Smpl Add apply AssociatedFunction_fetch_ptr_sub : is_associated.
      
      (*
          pub fn fetch_byte_add(&self, val: usize, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_add(self.p.get(), core::ptr::without_provenance_mut(val), order).cast() }
          }
      *)
      Definition fetch_byte_add
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "cast", [], [ T ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_function (|
                    "core::sync::atomic::atomic_add",
                    [],
                    [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                        "get",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicPtr",
                            "p"
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ T ],
                      M.get_function (| "core::ptr::without_provenance_mut", [], [ T ] |),
                      [ M.read (| val |) ]
                    |);
                    M.read (| order |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_byte_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_byte_add" (fetch_byte_add T).
      Smpl Add apply AssociatedFunction_fetch_byte_add : is_associated.
      
      (*
          pub fn fetch_byte_sub(&self, val: usize, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_sub(self.p.get(), core::ptr::without_provenance_mut(val), order).cast() }
          }
      *)
      Definition fetch_byte_sub
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "cast", [], [ T ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_function (|
                    "core::sync::atomic::atomic_sub",
                    [],
                    [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                        "get",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicPtr",
                            "p"
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ T ],
                      M.get_function (| "core::ptr::without_provenance_mut", [], [ T ] |),
                      [ M.read (| val |) ]
                    |);
                    M.read (| order |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_byte_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_byte_sub" (fetch_byte_sub T).
      Smpl Add apply AssociatedFunction_fetch_byte_sub : is_associated.
      
      (*
          pub fn fetch_or(&self, val: usize, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_or(self.p.get(), core::ptr::without_provenance_mut(val), order).cast() }
          }
      *)
      Definition fetch_or (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "cast", [], [ T ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_function (|
                    "core::sync::atomic::atomic_or",
                    [],
                    [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                        "get",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicPtr",
                            "p"
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ T ],
                      M.get_function (| "core::ptr::without_provenance_mut", [], [ T ] |),
                      [ M.read (| val |) ]
                    |);
                    M.read (| order |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_or" (fetch_or T).
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
          pub fn fetch_and(&self, val: usize, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_and(self.p.get(), core::ptr::without_provenance_mut(val), order).cast() }
          }
      *)
      Definition fetch_and (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "cast", [], [ T ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_function (|
                    "core::sync::atomic::atomic_and",
                    [],
                    [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                        "get",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicPtr",
                            "p"
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ T ],
                      M.get_function (| "core::ptr::without_provenance_mut", [], [ T ] |),
                      [ M.read (| val |) ]
                    |);
                    M.read (| order |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_and" (fetch_and T).
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
          pub fn fetch_xor(&self, val: usize, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_xor(self.p.get(), core::ptr::without_provenance_mut(val), order).cast() }
          }
      *)
      Definition fetch_xor (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "cast", [], [ T ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ T ],
                  M.get_function (|
                    "core::sync::atomic::atomic_xor",
                    [],
                    [ Ty.apply (Ty.path "*mut") [] [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                        "get",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicPtr",
                            "p"
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ T ],
                      M.get_function (| "core::ptr::without_provenance_mut", [], [ T ] |),
                      [ M.read (| val |) ]
                    |);
                    M.read (| order |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_xor" (fetch_xor T).
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
          pub const fn as_ptr(&self) -> *mut *mut T {
              self.p.get()
          }
      *)
      Definition as_ptr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::cell::UnsafeCell")
                  []
                  [ Ty.apply (Ty.path "*mut") [] [ T ] ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicPtr",
                    "p"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_ptr" (as_ptr T).
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicPtr_T.
    
    Module Impl_core_convert_From_bool_for_core_sync_atomic_AtomicBool.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicBool".
      
      (*
          fn from(b: bool) -> Self {
              Self::new(b)
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ b ] =>
          ltac:(M.monadic
            (let b := M.alloc (| b |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicBool",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicBool",
                "new",
                [],
                []
              |),
              [ M.read (| b |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "bool" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_core_sync_atomic_AtomicBool.
    
    Module Impl_core_convert_From_pointer_mut_T_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ].
      
      (*
          fn from(p: *mut T) -> Self {
              Self::new(p)
          }
      *)
      Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ p ] =>
          ltac:(M.monadic
            (let p := M.alloc (| p |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
                "new",
                [],
                []
              |),
              [ M.read (| p |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "*mut") [] [ T ] ]
          (* Instance *) [ ("from", InstanceField.Method (from T)) ].
    End Impl_core_convert_From_pointer_mut_T_for_core_sync_atomic_AtomicPtr_T.
    
    (* StructRecord
      {
        name := "AtomicI8";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicI8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI8".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicI8",
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicI8", "new", [], [] |),
              [
                M.call_closure (|
                  Ty.path "i8",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "i8",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicI8.
    
    Module Impl_core_convert_From_i8_for_core_sync_atomic_AtomicI8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI8".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicI8",
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicI8", "new", [], [] |),
              [ M.read (| v |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "i8" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i8_for_core_sync_atomic_AtomicI8.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i8", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "i8",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicI8",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI8.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicI8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicI8.
    
    Module Impl_core_sync_atomic_AtomicI8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI8".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicI8"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicI8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicI8" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicI8",
                            "v"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.path "core::sync::atomic::AtomicI8" ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "i8" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::sync::atomic::AtomicI8" ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicI8",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "i8" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicI8",
                          "v"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::sync::atomic::atomic_store", [], [ Ty.path "i8" ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicI8",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (| "core::sync::atomic::atomic_swap", [], [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i8"; Ty.path "i8" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI8",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i8"; Ty.path "i8" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.path "i8" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i8"; Ty.path "i8" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.path "i8" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (| "core::sync::atomic::atomic_add", [], [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      Smpl Add apply AssociatedFunction_fetch_add : is_associated.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (| "core::sync::atomic::atomic_sub", [], [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      Smpl Add apply AssociatedFunction_fetch_sub : is_associated.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (| "core::sync::atomic::atomic_nand", [], [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "i8" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "i8",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicI8",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "i8" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "i8"; Ty.path "i8" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicI8",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (| "core::sync::atomic::atomic_max", [], [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      Smpl Add apply AssociatedFunction_fetch_max : is_associated.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (| "core::sync::atomic::atomic_min", [], [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      Smpl Add apply AssociatedFunction_fetch_min : is_associated.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "i8" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i8" ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicI8",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicI8.
    
    (* StructRecord
      {
        name := "AtomicU8";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicU8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU8".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicU8",
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicU8", "new", [], [] |),
              [
                M.call_closure (|
                  Ty.path "u8",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u8",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicU8.
    
    Module Impl_core_convert_From_u8_for_core_sync_atomic_AtomicU8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU8".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicU8",
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicU8", "new", [], [] |),
              [ M.read (| v |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "u8" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_core_sync_atomic_AtomicU8.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u8", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "u8",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicU8",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU8.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicU8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicU8.
    
    Module Impl_core_sync_atomic_AtomicU8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU8".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicU8"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicU8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicU8" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicU8",
                            "v"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.path "core::sync::atomic::AtomicU8" ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::sync::atomic::AtomicU8" ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicU8",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "u8" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicU8",
                          "v"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::sync::atomic::atomic_store", [], [ Ty.path "u8" ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicU8",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (| "core::sync::atomic::atomic_swap", [], [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u8"; Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU8",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u8"; Ty.path "u8" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.path "u8" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u8"; Ty.path "u8" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.path "u8" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (| "core::sync::atomic::atomic_add", [], [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      Smpl Add apply AssociatedFunction_fetch_add : is_associated.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (| "core::sync::atomic::atomic_sub", [], [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      Smpl Add apply AssociatedFunction_fetch_sub : is_associated.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (| "core::sync::atomic::atomic_nand", [], [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "u8" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u8",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicU8",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "u8" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "u8"; Ty.path "u8" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicU8",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (| "core::sync::atomic::atomic_umax", [], [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      Smpl Add apply AssociatedFunction_fetch_max : is_associated.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (| "core::sync::atomic::atomic_umin", [], [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      Smpl Add apply AssociatedFunction_fetch_min : is_associated.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u8" ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicU8",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicU8.
    
    (* StructRecord
      {
        name := "AtomicI16";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicI16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI16".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicI16",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicI16",
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "i16",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicI16.
    
    Module Impl_core_convert_From_i16_for_core_sync_atomic_AtomicI16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI16".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicI16",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicI16",
                "new",
                [],
                []
              |),
              [ M.read (| v |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "i16" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i16_for_core_sync_atomic_AtomicI16.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i16", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "i16",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicI16",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI16.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicI16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicI16.
    
    Module Impl_core_sync_atomic_AtomicI16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI16".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicI16"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicI16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicI16" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicI16",
                            "v"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.path "core::sync::atomic::AtomicI16" ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "i16" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::sync::atomic::AtomicI16" ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicI16",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "i16" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicI16",
                          "v"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::sync::atomic::atomic_store", [], [ Ty.path "i16" ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicI16",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (| "core::sync::atomic::atomic_swap", [], [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i16"; Ty.path "i16" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI16",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i16"; Ty.path "i16" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.path "i16" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i16"; Ty.path "i16" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.path "i16" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (| "core::sync::atomic::atomic_add", [], [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      Smpl Add apply AssociatedFunction_fetch_add : is_associated.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (| "core::sync::atomic::atomic_sub", [], [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      Smpl Add apply AssociatedFunction_fetch_sub : is_associated.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (| "core::sync::atomic::atomic_nand", [], [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "i16" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "i16",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicI16",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "i16" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "i16" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "i16"; Ty.path "i16" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicI16",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (| "core::sync::atomic::atomic_max", [], [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      Smpl Add apply AssociatedFunction_fetch_max : is_associated.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (| "core::sync::atomic::atomic_min", [], [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      Smpl Add apply AssociatedFunction_fetch_min : is_associated.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "i16" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i16" ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicI16",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicI16.
    
    (* StructRecord
      {
        name := "AtomicU16";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicU16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU16".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicU16",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicU16",
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u16",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicU16.
    
    Module Impl_core_convert_From_u16_for_core_sync_atomic_AtomicU16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU16".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicU16",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicU16",
                "new",
                [],
                []
              |),
              [ M.read (| v |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "u16" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_core_sync_atomic_AtomicU16.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u16", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "u16",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicU16",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU16.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicU16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicU16.
    
    Module Impl_core_sync_atomic_AtomicU16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU16".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicU16"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicU16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicU16" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicU16",
                            "v"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.path "core::sync::atomic::AtomicU16" ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u16" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::sync::atomic::AtomicU16" ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicU16",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "u16" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicU16",
                          "v"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::sync::atomic::atomic_store", [], [ Ty.path "u16" ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicU16",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (| "core::sync::atomic::atomic_swap", [], [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u16"; Ty.path "u16" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU16",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u16"; Ty.path "u16" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.path "u16" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u16"; Ty.path "u16" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.path "u16" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (| "core::sync::atomic::atomic_add", [], [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      Smpl Add apply AssociatedFunction_fetch_add : is_associated.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (| "core::sync::atomic::atomic_sub", [], [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      Smpl Add apply AssociatedFunction_fetch_sub : is_associated.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (| "core::sync::atomic::atomic_nand", [], [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "u16" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u16",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicU16",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "u16" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "u16" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "u16"; Ty.path "u16" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicU16",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (| "core::sync::atomic::atomic_umax", [], [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      Smpl Add apply AssociatedFunction_fetch_max : is_associated.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (| "core::sync::atomic::atomic_umin", [], [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      Smpl Add apply AssociatedFunction_fetch_min : is_associated.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u16" ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicU16",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicU16.
    
    (* StructRecord
      {
        name := "AtomicI32";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicI32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI32".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicI32",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicI32",
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "i32",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicI32.
    
    Module Impl_core_convert_From_i32_for_core_sync_atomic_AtomicI32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI32".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicI32",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicI32",
                "new",
                [],
                []
              |),
              [ M.read (| v |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "i32" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i32_for_core_sync_atomic_AtomicI32.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i32", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "i32",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicI32",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI32.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicI32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicI32.
    
    Module Impl_core_sync_atomic_AtomicI32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI32".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicI32"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicI32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicI32" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "i32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicI32",
                            "v"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.path "core::sync::atomic::AtomicI32" ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "i32" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::sync::atomic::AtomicI32" ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicI32",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "i32" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicI32",
                          "v"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::sync::atomic::atomic_store", [], [ Ty.path "i32" ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicI32",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (| "core::sync::atomic::atomic_swap", [], [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i32"; Ty.path "i32" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI32",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i32"; Ty.path "i32" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.path "i32" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i32"; Ty.path "i32" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.path "i32" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (| "core::sync::atomic::atomic_add", [], [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      Smpl Add apply AssociatedFunction_fetch_add : is_associated.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (| "core::sync::atomic::atomic_sub", [], [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      Smpl Add apply AssociatedFunction_fetch_sub : is_associated.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (| "core::sync::atomic::atomic_nand", [], [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "i32" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "i32",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicI32",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "i32" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "i32" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "i32"; Ty.path "i32" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicI32",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (| "core::sync::atomic::atomic_max", [], [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      Smpl Add apply AssociatedFunction_fetch_max : is_associated.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (| "core::sync::atomic::atomic_min", [], [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      Smpl Add apply AssociatedFunction_fetch_min : is_associated.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "i32" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i32" ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicI32",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicI32.
    
    (* StructRecord
      {
        name := "AtomicU32";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicU32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU32".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicU32",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicU32",
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u32",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicU32.
    
    Module Impl_core_convert_From_u32_for_core_sync_atomic_AtomicU32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU32".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicU32",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicU32",
                "new",
                [],
                []
              |),
              [ M.read (| v |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "u32" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u32_for_core_sync_atomic_AtomicU32.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u32", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "u32",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicU32",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU32.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicU32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicU32.
    
    Module Impl_core_sync_atomic_AtomicU32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU32".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicU32"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicU32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicU32" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicU32",
                            "v"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.path "core::sync::atomic::AtomicU32" ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u32" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::sync::atomic::AtomicU32" ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicU32",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "u32" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicU32",
                          "v"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::sync::atomic::atomic_store", [], [ Ty.path "u32" ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicU32",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (| "core::sync::atomic::atomic_swap", [], [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u32"; Ty.path "u32" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU32",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u32"; Ty.path "u32" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.path "u32" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u32"; Ty.path "u32" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.path "u32" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (| "core::sync::atomic::atomic_add", [], [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      Smpl Add apply AssociatedFunction_fetch_add : is_associated.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (| "core::sync::atomic::atomic_sub", [], [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      Smpl Add apply AssociatedFunction_fetch_sub : is_associated.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (| "core::sync::atomic::atomic_nand", [], [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "u32" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u32",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicU32",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "u32" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "u32" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "u32"; Ty.path "u32" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicU32",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (| "core::sync::atomic::atomic_umax", [], [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      Smpl Add apply AssociatedFunction_fetch_max : is_associated.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (| "core::sync::atomic::atomic_umin", [], [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      Smpl Add apply AssociatedFunction_fetch_min : is_associated.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "u32" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u32" ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicU32",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicU32.
    
    (* StructRecord
      {
        name := "AtomicI64";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicI64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI64".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicI64",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicI64",
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "i64",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicI64.
    
    Module Impl_core_convert_From_i64_for_core_sync_atomic_AtomicI64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI64".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicI64",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicI64",
                "new",
                [],
                []
              |),
              [ M.read (| v |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "i64" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i64_for_core_sync_atomic_AtomicI64.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i64", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "i64",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicI64",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI64.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicI64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicI64.
    
    Module Impl_core_sync_atomic_AtomicI64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI64".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicI64"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicI64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicI64" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "i64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicI64",
                            "v"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.path "core::sync::atomic::AtomicI64" ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "i64" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::sync::atomic::AtomicI64" ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicI64",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "i64" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicI64",
                          "v"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::sync::atomic::atomic_store", [], [ Ty.path "i64" ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicI64",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (| "core::sync::atomic::atomic_swap", [], [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i64"; Ty.path "i64" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI64",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i64"; Ty.path "i64" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.path "i64" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "i64"; Ty.path "i64" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.path "i64" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (| "core::sync::atomic::atomic_add", [], [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      Smpl Add apply AssociatedFunction_fetch_add : is_associated.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (| "core::sync::atomic::atomic_sub", [], [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      Smpl Add apply AssociatedFunction_fetch_sub : is_associated.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (| "core::sync::atomic::atomic_nand", [], [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "i64" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "i64",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicI64",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "i64" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "i64" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "i64"; Ty.path "i64" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicI64",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (| "core::sync::atomic::atomic_max", [], [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      Smpl Add apply AssociatedFunction_fetch_max : is_associated.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (| "core::sync::atomic::atomic_min", [], [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      Smpl Add apply AssociatedFunction_fetch_min : is_associated.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "i64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "i64" ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicI64",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicI64.
    
    (* StructRecord
      {
        name := "AtomicU64";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicU64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU64".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicU64",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicU64",
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u64",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicU64.
    
    Module Impl_core_convert_From_u64_for_core_sync_atomic_AtomicU64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU64".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicU64",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicU64",
                "new",
                [],
                []
              |),
              [ M.read (| v |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "u64" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u64_for_core_sync_atomic_AtomicU64.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u64", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "u64",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicU64",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU64.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicU64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicU64.
    
    Module Impl_core_sync_atomic_AtomicU64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU64".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicU64"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicU64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicU64" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicU64",
                            "v"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.path "core::sync::atomic::AtomicU64" ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::sync::atomic::AtomicU64" ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicU64",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "u64" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicU64",
                          "v"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::sync::atomic::atomic_store", [], [ Ty.path "u64" ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicU64",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (| "core::sync::atomic::atomic_swap", [], [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u64"; Ty.path "u64" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU64",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u64"; Ty.path "u64" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.path "u64" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "u64"; Ty.path "u64" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.path "u64" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (| "core::sync::atomic::atomic_add", [], [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      Smpl Add apply AssociatedFunction_fetch_add : is_associated.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (| "core::sync::atomic::atomic_sub", [], [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      Smpl Add apply AssociatedFunction_fetch_sub : is_associated.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (| "core::sync::atomic::atomic_nand", [], [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "u64" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u64",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicU64",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "u64" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "u64" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "u64"; Ty.path "u64" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicU64",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (| "core::sync::atomic::atomic_umax", [], [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      Smpl Add apply AssociatedFunction_fetch_max : is_associated.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (| "core::sync::atomic::atomic_umin", [], [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      Smpl Add apply AssociatedFunction_fetch_min : is_associated.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "u64" ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicU64",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicU64.
    
    (* StructRecord
      {
        name := "AtomicIsize";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicIsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicIsize".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicIsize",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicIsize",
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "isize",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicIsize.
    
    Module Impl_core_convert_From_isize_for_core_sync_atomic_AtomicIsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicIsize".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicIsize",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicIsize",
                "new",
                [],
                []
              |),
              [ M.read (| v |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "isize" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_isize_for_core_sync_atomic_AtomicIsize.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicIsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicIsize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "isize", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "isize",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicIsize",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicIsize.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicIsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicIsize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicIsize.
    
    Module Impl_core_sync_atomic_AtomicIsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicIsize".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicIsize"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicIsize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicIsize" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "isize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicIsize",
                            "v"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.path "core::sync::atomic::AtomicIsize" ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "isize" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::sync::atomic::AtomicIsize" ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicIsize",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "isize" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicIsize",
                          "v"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (|
                      "core::sync::atomic::atomic_store",
                      [],
                      [ Ty.path "isize" ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicIsize",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (| "core::sync::atomic::atomic_swap", [], [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "isize"; Ty.path "isize" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicIsize",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "isize"; Ty.path "isize" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.path "isize" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "isize"; Ty.path "isize" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.path "isize" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (| "core::sync::atomic::atomic_add", [], [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      Smpl Add apply AssociatedFunction_fetch_add : is_associated.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (| "core::sync::atomic::atomic_sub", [], [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      Smpl Add apply AssociatedFunction_fetch_sub : is_associated.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (| "core::sync::atomic::atomic_nand", [], [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "isize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "isize",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicIsize",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "isize" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "isize" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "isize"; Ty.path "isize" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicIsize",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (| "core::sync::atomic::atomic_max", [], [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      Smpl Add apply AssociatedFunction_fetch_max : is_associated.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (| "core::sync::atomic::atomic_min", [], [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      Smpl Add apply AssociatedFunction_fetch_min : is_associated.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "isize" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "isize" ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicIsize",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicIsize.
    
    (* StructRecord
      {
        name := "AtomicUsize";
        const_params := [];
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicUsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicUsize".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "core::sync::atomic::AtomicUsize",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicUsize",
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "usize",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicUsize.
    
    Module Impl_core_convert_From_usize_for_core_sync_atomic_AtomicUsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicUsize".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicUsize",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicUsize",
                "new",
                [],
                []
              |),
              [ M.read (| v |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "usize" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_usize_for_core_sync_atomic_AtomicUsize.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicUsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicUsize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "usize", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicUsize.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicUsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicUsize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicUsize.
    
    Module Impl_core_sync_atomic_AtomicUsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicUsize".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicUsize"
              [
                ("v",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      Smpl Add apply AssociatedFunction_new : is_associated.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicUsize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                        "cast",
                        [],
                        [ Ty.path "core::sync::atomic::AtomicUsize" ]
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      Smpl Add apply AssociatedFunction_from_ptr : is_associated.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                        "get_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::sync::atomic::AtomicUsize",
                            "v"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      Smpl Add apply AssociatedFunction_get_mut : is_associated.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.path "core::sync::atomic::AtomicUsize" ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      Smpl Add apply AssociatedFunction_from_mut : is_associated.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "usize" ] ])
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutPointer,
                                      M.deref (| M.read (| this |) |)
                                    |)
                                  |))
                              |))
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      Smpl Add apply AssociatedFunction_get_mut_slice : is_associated.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  M.match_operator (|
                    M.alloc (| repeat (| Value.Tuple [], Value.Integer IntegerKind.Usize 0 |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.cast
                                          (Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [ Ty.path "core::sync::atomic::AtomicUsize" ]
                                            ])
                                          (M.read (|
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.MutPointer,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              |))
                                          |))
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      Smpl Add apply AssociatedFunction_from_mut_slice : is_associated.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                "into_inner",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicUsize",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      Smpl Add apply AssociatedFunction_into_inner : is_associated.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::sync::atomic::atomic_load", [], [ Ty.path "usize" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::sync::atomic::AtomicUsize",
                          "v"
                        |)
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      Smpl Add apply AssociatedFunction_load : is_associated.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (|
                      "core::sync::atomic::atomic_store",
                      [],
                      [ Ty.path "usize" ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::sync::atomic::AtomicUsize",
                              "v"
                            |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      Smpl Add apply AssociatedFunction_store : is_associated.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::sync::atomic::atomic_swap", [], [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      Smpl Add apply AssociatedFunction_swap : is_associated.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "usize"; Ty.path "usize" ],
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicUsize",
                      "compare_exchange",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::Ordering",
                        M.get_function (|
                          "core::sync::atomic::strongest_failure_ordering",
                          [],
                          []
                        |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      Smpl Add apply AssociatedFunction_compare_and_swap : is_associated.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "usize"; Ty.path "usize" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [],
                [ Ty.path "usize" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      Smpl Add apply AssociatedFunction_compare_exchange : is_associated.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.path "usize"; Ty.path "usize" ],
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [],
                [ Ty.path "usize" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      Smpl Add apply AssociatedFunction_compare_exchange_weak : is_associated.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::sync::atomic::atomic_add", [], [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      Smpl Add apply AssociatedFunction_fetch_add : is_associated.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::sync::atomic::atomic_sub", [], [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      Smpl Add apply AssociatedFunction_fetch_sub : is_associated.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::sync::atomic::atomic_and", [], [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      Smpl Add apply AssociatedFunction_fetch_and : is_associated.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::sync::atomic::atomic_nand", [], [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      Smpl Add apply AssociatedFunction_fetch_nand : is_associated.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::sync::atomic::atomic_or", [], [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      Smpl Add apply AssociatedFunction_fetch_or : is_associated.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::sync::atomic::atomic_xor", [], [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      Smpl Add apply AssociatedFunction_fetch_xor : is_associated.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ prev : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| fetch_order |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ],
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [],
                                        [ Ty.tuple [ Ty.path "usize" ] ],
                                        "call_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.MutRef, f |);
                                        Value.Tuple [ M.read (| prev |) ]
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.path "usize"; Ty.path "usize" ],
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        "compare_exchange_weak",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.alloc (| M.write (| prev, M.read (| next_prev |) |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      Smpl Add apply AssociatedFunction_fetch_update : is_associated.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::sync::atomic::atomic_umax", [], [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      Smpl Add apply AssociatedFunction_fetch_max : is_associated.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::sync::atomic::atomic_umin", [], [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                    "get",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      Smpl Add apply AssociatedFunction_fetch_min : is_associated.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "usize" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [] [ Ty.path "usize" ],
                "get",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::sync::atomic::AtomicUsize",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      Smpl Add apply AssociatedFunction_as_ptr : is_associated.
    End Impl_core_sync_atomic_AtomicUsize.
    
    Definition value_ATOMIC_ISIZE_INIT : Value.t :=
      M.run_constant
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicIsize",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicIsize",
                "new",
                [],
                []
              |),
              [ Value.Integer IntegerKind.Isize 0 ]
            |)
          |))).
    
    Axiom Constant_value_ATOMIC_ISIZE_INIT :
      (M.get_constant "core::sync::atomic::ATOMIC_ISIZE_INIT") = value_ATOMIC_ISIZE_INIT.
    Global Hint Rewrite Constant_value_ATOMIC_ISIZE_INIT : constant_rewrites.
    
    Definition value_ATOMIC_USIZE_INIT : Value.t :=
      M.run_constant
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              Ty.path "core::sync::atomic::AtomicUsize",
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicUsize",
                "new",
                [],
                []
              |),
              [ Value.Integer IntegerKind.Usize 0 ]
            |)
          |))).
    
    Axiom Constant_value_ATOMIC_USIZE_INIT :
      (M.get_constant "core::sync::atomic::ATOMIC_USIZE_INIT") = value_ATOMIC_USIZE_INIT.
    Global Hint Rewrite Constant_value_ATOMIC_USIZE_INIT : constant_rewrites.
    
    (*
    fn strongest_failure_ordering(order: Ordering) -> Ordering {
        match order {
            Release => Relaxed,
            Relaxed => Relaxed,
            SeqCst => SeqCst,
            Acquire => Acquire,
            AcqRel => Acquire,
        }
    }
    *)
    Definition strongest_failure_ordering
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ order ] =>
        ltac:(M.monadic
          (let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (| Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (| Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (| Value.StructTuple "core::sync::atomic::Ordering::SeqCst" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (| Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (| Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_strongest_failure_ordering :
      M.IsFunction "core::sync::atomic::strongest_failure_ordering" strongest_failure_ordering.
    Smpl Add apply Function_strongest_failure_ordering : is_function.
    
    (*
    unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {
        // SAFETY: the caller must uphold the safety contract for `atomic_store`.
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_store_relaxed(dst, val),
                Release => intrinsics::atomic_store_release(dst, val),
                SeqCst => intrinsics::atomic_store_seqcst(dst, val),
                Acquire => panic!("there is no such thing as an acquire store"),
                AcqRel => panic!("there is no such thing as an acquire-release store"),
            }
        }
    }
    *)
    Definition atomic_store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::atomic_store_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::atomic_store_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::atomic_store_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.read (|
                                              Value.String
                                                "there is no such thing as an acquire store"
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.read (|
                                              Value.String
                                                "there is no such thing as an acquire-release store"
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_store : M.IsFunction "core::sync::atomic::atomic_store" atomic_store.
    Smpl Add apply Function_atomic_store : is_function.
    
    (*
    unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_load`.
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_load_relaxed(dst),
                Acquire => intrinsics::atomic_load_acquire(dst),
                SeqCst => intrinsics::atomic_load_seqcst(dst),
                Release => panic!("there is no such thing as a release load"),
                AcqRel => panic!("there is no such thing as an acquire-release load"),
            }
        }
    }
    *)
    Definition atomic_load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_load_relaxed", [], [ T ] |),
                        [ M.read (| dst |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_load_acquire", [], [ T ] |),
                        [ M.read (| dst |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_load_seqcst", [], [ T ] |),
                        [ M.read (| dst |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.read (|
                                              Value.String
                                                "there is no such thing as a release load"
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.read (|
                                              Value.String
                                                "there is no such thing as an acquire-release load"
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_load : M.IsFunction "core::sync::atomic::atomic_load" atomic_load.
    Smpl Add apply Function_atomic_load : is_function.
    
    (*
    unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_swap`.
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),
                Acquire => intrinsics::atomic_xchg_acquire(dst, val),
                Release => intrinsics::atomic_xchg_release(dst, val),
                AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),
                SeqCst => intrinsics::atomic_xchg_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xchg_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xchg_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xchg_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xchg_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xchg_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_swap : M.IsFunction "core::sync::atomic::atomic_swap" atomic_swap.
    Smpl Add apply Function_atomic_swap : is_function.
    
    (*
    unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_add`.
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),
                Acquire => intrinsics::atomic_xadd_acquire(dst, val),
                Release => intrinsics::atomic_xadd_release(dst, val),
                AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),
                SeqCst => intrinsics::atomic_xadd_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xadd_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xadd_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xadd_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xadd_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xadd_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_add : M.IsFunction "core::sync::atomic::atomic_add" atomic_add.
    Smpl Add apply Function_atomic_add : is_function.
    
    (*
    unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_sub`.
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),
                Acquire => intrinsics::atomic_xsub_acquire(dst, val),
                Release => intrinsics::atomic_xsub_release(dst, val),
                AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),
                SeqCst => intrinsics::atomic_xsub_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xsub_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xsub_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xsub_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xsub_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xsub_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_sub : M.IsFunction "core::sync::atomic::atomic_sub" atomic_sub.
    Smpl Add apply Function_atomic_sub : is_function.
    
    (*
    unsafe fn atomic_compare_exchange<T: Copy>(
        dst: *mut T,
        old: T,
        new: T,
        success: Ordering,
        failure: Ordering,
    ) -> Result<T, T> {
        // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange`.
        let (val, ok) = unsafe {
            match (success, failure) {
                (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed_relaxed(dst, old, new),
                (Relaxed, Acquire) => intrinsics::atomic_cxchg_relaxed_acquire(dst, old, new),
                (Relaxed, SeqCst) => intrinsics::atomic_cxchg_relaxed_seqcst(dst, old, new),
                (Acquire, Relaxed) => intrinsics::atomic_cxchg_acquire_relaxed(dst, old, new),
                (Acquire, Acquire) => intrinsics::atomic_cxchg_acquire_acquire(dst, old, new),
                (Acquire, SeqCst) => intrinsics::atomic_cxchg_acquire_seqcst(dst, old, new),
                (Release, Relaxed) => intrinsics::atomic_cxchg_release_relaxed(dst, old, new),
                (Release, Acquire) => intrinsics::atomic_cxchg_release_acquire(dst, old, new),
                (Release, SeqCst) => intrinsics::atomic_cxchg_release_seqcst(dst, old, new),
                (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_relaxed(dst, old, new),
                (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel_acquire(dst, old, new),
                (AcqRel, SeqCst) => intrinsics::atomic_cxchg_acqrel_seqcst(dst, old, new),
                (SeqCst, Relaxed) => intrinsics::atomic_cxchg_seqcst_relaxed(dst, old, new),
                (SeqCst, Acquire) => intrinsics::atomic_cxchg_seqcst_acquire(dst, old, new),
                (SeqCst, SeqCst) => intrinsics::atomic_cxchg_seqcst_seqcst(dst, old, new),
                (_, AcqRel) => panic!("there is no such thing as an acquire-release failure ordering"),
                (_, Release) => panic!("there is no such thing as a release failure ordering"),
            }
        };
        if ok { Ok(val) } else { Err(val) }
    }
    *)
    Definition atomic_compare_exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; old; new; success; failure ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let old := M.alloc (| old |) in
          let new := M.alloc (| new |) in
          let success := M.alloc (| success |) in
          let failure := M.alloc (| failure |) in
          M.read (|
            M.match_operator (|
              M.match_operator (|
                M.alloc (| Value.Tuple [ M.read (| success |); M.read (| failure |) ] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Relaxed" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Relaxed" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_relaxed_relaxed",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Relaxed" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Acquire" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_relaxed_acquire",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Relaxed" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::SeqCst" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_relaxed_seqcst",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Acquire" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Relaxed" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acquire_relaxed",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Acquire" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Acquire" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acquire_acquire",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Acquire" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::SeqCst" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acquire_seqcst",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Release" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Relaxed" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_release_relaxed",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Release" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Acquire" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_release_acquire",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Release" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::SeqCst" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_release_seqcst",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::AcqRel" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Relaxed" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acqrel_relaxed",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::AcqRel" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Acquire" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acqrel_acquire",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::AcqRel" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::SeqCst" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acqrel_seqcst",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::SeqCst" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Relaxed" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_seqcst_relaxed",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::SeqCst" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Acquire" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_seqcst_acquire",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::SeqCst" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::SeqCst" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_seqcst_seqcst",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::AcqRel" |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.read (|
                                                Value.String
                                                  "there is no such thing as an acquire-release failure ordering"
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Release" |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.read (|
                                                Value.String
                                                  "there is no such thing as a release failure ordering"
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let val := M.copy (| γ0_0 |) in
                    let ok := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use ok in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              Value.StructTuple "core::result::Result::Ok" [ M.read (| val |) ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::result::Result::Err" [ M.read (| val |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_compare_exchange :
      M.IsFunction "core::sync::atomic::atomic_compare_exchange" atomic_compare_exchange.
    Smpl Add apply Function_atomic_compare_exchange : is_function.
    
    (*
    unsafe fn atomic_compare_exchange_weak<T: Copy>(
        dst: *mut T,
        old: T,
        new: T,
        success: Ordering,
        failure: Ordering,
    ) -> Result<T, T> {
        // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange_weak`.
        let (val, ok) = unsafe {
            match (success, failure) {
                (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed_relaxed(dst, old, new),
                (Relaxed, Acquire) => intrinsics::atomic_cxchgweak_relaxed_acquire(dst, old, new),
                (Relaxed, SeqCst) => intrinsics::atomic_cxchgweak_relaxed_seqcst(dst, old, new),
                (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acquire_relaxed(dst, old, new),
                (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acquire_acquire(dst, old, new),
                (Acquire, SeqCst) => intrinsics::atomic_cxchgweak_acquire_seqcst(dst, old, new),
                (Release, Relaxed) => intrinsics::atomic_cxchgweak_release_relaxed(dst, old, new),
                (Release, Acquire) => intrinsics::atomic_cxchgweak_release_acquire(dst, old, new),
                (Release, SeqCst) => intrinsics::atomic_cxchgweak_release_seqcst(dst, old, new),
                (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_relaxed(dst, old, new),
                (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel_acquire(dst, old, new),
                (AcqRel, SeqCst) => intrinsics::atomic_cxchgweak_acqrel_seqcst(dst, old, new),
                (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_seqcst_relaxed(dst, old, new),
                (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_seqcst_acquire(dst, old, new),
                (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak_seqcst_seqcst(dst, old, new),
                (_, AcqRel) => panic!("there is no such thing as an acquire-release failure ordering"),
                (_, Release) => panic!("there is no such thing as a release failure ordering"),
            }
        };
        if ok { Ok(val) } else { Err(val) }
    }
    *)
    Definition atomic_compare_exchange_weak
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; old; new; success; failure ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let old := M.alloc (| old |) in
          let new := M.alloc (| new |) in
          let success := M.alloc (| success |) in
          let failure := M.alloc (| failure |) in
          M.read (|
            M.match_operator (|
              M.match_operator (|
                M.alloc (| Value.Tuple [ M.read (| success |); M.read (| failure |) ] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Relaxed" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Relaxed" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_relaxed_relaxed",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Relaxed" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Acquire" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_relaxed_acquire",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Relaxed" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::SeqCst" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_relaxed_seqcst",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Acquire" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Relaxed" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acquire_relaxed",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Acquire" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Acquire" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acquire_acquire",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Acquire" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::SeqCst" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acquire_seqcst",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Release" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Relaxed" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_release_relaxed",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Release" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Acquire" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_release_acquire",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::Release" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::SeqCst" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_release_seqcst",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::AcqRel" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Relaxed" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acqrel_relaxed",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::AcqRel" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Acquire" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acqrel_acquire",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::AcqRel" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::SeqCst" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acqrel_seqcst",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::SeqCst" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Relaxed" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_seqcst_relaxed",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::SeqCst" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Acquire" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_seqcst_acquire",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_0, "core::sync::atomic::Ordering::SeqCst" |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::SeqCst" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ T; Ty.path "bool" ],
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_seqcst_seqcst",
                            [],
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::AcqRel" |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.read (|
                                                Value.String
                                                  "there is no such thing as an acquire-release failure ordering"
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let _ :=
                        M.is_struct_tuple (| γ0_1, "core::sync::atomic::Ordering::Release" |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.read (|
                                                Value.String
                                                  "there is no such thing as a release failure ordering"
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let val := M.copy (| γ0_0 |) in
                    let ok := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use ok in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              Value.StructTuple "core::result::Result::Ok" [ M.read (| val |) ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::result::Result::Err" [ M.read (| val |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_compare_exchange_weak :
      M.IsFunction "core::sync::atomic::atomic_compare_exchange_weak" atomic_compare_exchange_weak.
    Smpl Add apply Function_atomic_compare_exchange_weak : is_function.
    
    (*
    unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_and`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_and_relaxed(dst, val),
                Acquire => intrinsics::atomic_and_acquire(dst, val),
                Release => intrinsics::atomic_and_release(dst, val),
                AcqRel => intrinsics::atomic_and_acqrel(dst, val),
                SeqCst => intrinsics::atomic_and_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_and_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_and_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_and_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_and_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_and_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_and : M.IsFunction "core::sync::atomic::atomic_and" atomic_and.
    Smpl Add apply Function_atomic_and : is_function.
    
    (*
    unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_nand`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_nand_relaxed(dst, val),
                Acquire => intrinsics::atomic_nand_acquire(dst, val),
                Release => intrinsics::atomic_nand_release(dst, val),
                AcqRel => intrinsics::atomic_nand_acqrel(dst, val),
                SeqCst => intrinsics::atomic_nand_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_nand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_nand_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_nand_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_nand_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_nand_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_nand_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_nand : M.IsFunction "core::sync::atomic::atomic_nand" atomic_nand.
    Smpl Add apply Function_atomic_nand : is_function.
    
    (*
    unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_or`
        unsafe {
            match order {
                SeqCst => intrinsics::atomic_or_seqcst(dst, val),
                Acquire => intrinsics::atomic_or_acquire(dst, val),
                Release => intrinsics::atomic_or_release(dst, val),
                AcqRel => intrinsics::atomic_or_acqrel(dst, val),
                Relaxed => intrinsics::atomic_or_relaxed(dst, val),
            }
        }
    }
    *)
    Definition atomic_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_or_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_or_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_or_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_or_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_or_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_or : M.IsFunction "core::sync::atomic::atomic_or" atomic_or.
    Smpl Add apply Function_atomic_or : is_function.
    
    (*
    unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_xor`
        unsafe {
            match order {
                SeqCst => intrinsics::atomic_xor_seqcst(dst, val),
                Acquire => intrinsics::atomic_xor_acquire(dst, val),
                Release => intrinsics::atomic_xor_release(dst, val),
                AcqRel => intrinsics::atomic_xor_acqrel(dst, val),
                Relaxed => intrinsics::atomic_xor_relaxed(dst, val),
            }
        }
    }
    *)
    Definition atomic_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xor_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xor_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xor_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xor_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_xor_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_xor : M.IsFunction "core::sync::atomic::atomic_xor" atomic_xor.
    Smpl Add apply Function_atomic_xor : is_function.
    
    (*
    unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_max`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_max_relaxed(dst, val),
                Acquire => intrinsics::atomic_max_acquire(dst, val),
                Release => intrinsics::atomic_max_release(dst, val),
                AcqRel => intrinsics::atomic_max_acqrel(dst, val),
                SeqCst => intrinsics::atomic_max_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_max_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_max_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_max_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_max_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_max_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_max : M.IsFunction "core::sync::atomic::atomic_max" atomic_max.
    Smpl Add apply Function_atomic_max : is_function.
    
    (*
    unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_min`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_min_relaxed(dst, val),
                Acquire => intrinsics::atomic_min_acquire(dst, val),
                Release => intrinsics::atomic_min_release(dst, val),
                AcqRel => intrinsics::atomic_min_acqrel(dst, val),
                SeqCst => intrinsics::atomic_min_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_min_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_min_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_min_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_min_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_min_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_min : M.IsFunction "core::sync::atomic::atomic_min" atomic_min.
    Smpl Add apply Function_atomic_min : is_function.
    
    (*
    unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_umax`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_umax_relaxed(dst, val),
                Acquire => intrinsics::atomic_umax_acquire(dst, val),
                Release => intrinsics::atomic_umax_release(dst, val),
                AcqRel => intrinsics::atomic_umax_acqrel(dst, val),
                SeqCst => intrinsics::atomic_umax_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_umax (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_umax_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_umax_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_umax_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_umax_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_umax_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_umax : M.IsFunction "core::sync::atomic::atomic_umax" atomic_umax.
    Smpl Add apply Function_atomic_umax : is_function.
    
    (*
    unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_umin`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_umin_relaxed(dst, val),
                Acquire => intrinsics::atomic_umin_acquire(dst, val),
                Release => intrinsics::atomic_umin_release(dst, val),
                AcqRel => intrinsics::atomic_umin_acqrel(dst, val),
                SeqCst => intrinsics::atomic_umin_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_umin (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_umin_relaxed", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_umin_acquire", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_umin_release", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_umin_acqrel", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        T,
                        M.get_function (| "core::intrinsics::atomic_umin_seqcst", [], [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_atomic_umin : M.IsFunction "core::sync::atomic::atomic_umin" atomic_umin.
    Smpl Add apply Function_atomic_umin : is_function.
    
    (*
    pub fn fence(order: Ordering) {
        // SAFETY: using an atomic fence is safe.
        unsafe {
            match order {
                Acquire => intrinsics::atomic_fence_acquire(),
                Release => intrinsics::atomic_fence_release(),
                AcqRel => intrinsics::atomic_fence_acqrel(),
                SeqCst => intrinsics::atomic_fence_seqcst(),
                Relaxed => panic!("there is no such thing as a relaxed fence"),
            }
        }
    }
    *)
    Definition fence (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ order ] =>
        ltac:(M.monadic
          (let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::atomic_fence_acquire", [], [] |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::atomic_fence_release", [], [] |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::atomic_fence_acqrel", [], [] |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::atomic_fence_seqcst", [], [] |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.read (|
                                              Value.String
                                                "there is no such thing as a relaxed fence"
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_fence : M.IsFunction "core::sync::atomic::fence" fence.
    Smpl Add apply Function_fence : is_function.
    
    (*
    pub fn compiler_fence(order: Ordering) {
        // SAFETY: using an atomic fence is safe.
        unsafe {
            match order {
                Acquire => intrinsics::atomic_singlethreadfence_acquire(),
                Release => intrinsics::atomic_singlethreadfence_release(),
                AcqRel => intrinsics::atomic_singlethreadfence_acqrel(),
                SeqCst => intrinsics::atomic_singlethreadfence_seqcst(),
                Relaxed => panic!("there is no such thing as a relaxed compiler fence"),
            }
        }
    }
    *)
    Definition compiler_fence (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ order ] =>
        ltac:(M.monadic
          (let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Acquire" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (|
                          "core::intrinsics::atomic_singlethreadfence_acquire",
                          [],
                          []
                        |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Release" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (|
                          "core::intrinsics::atomic_singlethreadfence_release",
                          [],
                          []
                        |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::AcqRel" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (|
                          "core::intrinsics::atomic_singlethreadfence_acqrel",
                          [],
                          []
                        |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::SeqCst" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (|
                          "core::intrinsics::atomic_singlethreadfence_seqcst",
                          [],
                          []
                        |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::sync::atomic::Ordering::Relaxed" |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.read (|
                                              Value.String
                                                "there is no such thing as a relaxed compiler fence"
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_compiler_fence :
      M.IsFunction "core::sync::atomic::compiler_fence" compiler_fence.
    Smpl Add apply Function_compiler_fence : is_function.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicBool.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicBool".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "bool", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicBool",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicBool.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (|
                "core::fmt::Debug",
                Ty.apply (Ty.path "*mut") [] [ T ],
                [],
                [],
                "fmt",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicPtr_T.
    
    Module Impl_core_fmt_Pointer_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              fmt::Pointer::fmt(&self.load(Ordering::Relaxed), f)
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (|
                "core::fmt::Pointer",
                Ty.apply (Ty.path "*mut") [] [ T ],
                [],
                [],
                "fmt",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ T ],
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Pointer"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Pointer_for_core_sync_atomic_AtomicPtr_T.
    
    (*
    pub fn spin_loop_hint() {
        spin_loop()
    }
    *)
    Definition spin_loop_hint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.tuple [],
            M.get_function (| "core::hint::spin_loop", [], [] |),
            []
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_spin_loop_hint :
      M.IsFunction "core::sync::atomic::spin_loop_hint" spin_loop_hint.
    Smpl Add apply Function_spin_loop_hint : is_function.
  End atomic.
End sync.
