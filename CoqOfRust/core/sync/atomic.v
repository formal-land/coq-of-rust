(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module sync.
  Module atomic.
    Definition value_EMULATE_ATOMIC_BOOL : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
    
    (* StructRecord
      {
        name := "AtomicBool";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicBool.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicBool".
      
      (*
          fn default() -> Self {
              Self::new(false)
          }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicBool", "new", [] |),
              [ Value.Bool false ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicBool.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicBool.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicBool".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicBool.
    
    (* StructRecord
      {
        name := "AtomicPtr";
        ty_params := [ "T" ];
        fields :=
          [ ("p", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.apply (Ty.path "*mut") [ T ] ])
          ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ].
      
      (*
          fn default() -> AtomicPtr<T> {
              AtomicPtr::new(crate::ptr::null_mut())
          }
      *)
      Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ],
                "new",
                []
              |),
              [ M.call_closure (| M.get_function (| "core::ptr::null_mut", [ T ] |), [] |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicPtr_T.
    
    Module Impl_core_marker_Send_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Send_for_core_sync_atomic_AtomicPtr_T.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicPtr_T.
    
    (*
    Enum Ordering
    {
      ty_params := [];
      variants :=
        [
          {
            name := "Relaxed";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Release";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Acquire";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "AcqRel";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "SeqCst";
            item := StructTuple [];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_marker_Copy_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_sync_atomic_Ordering.
    
    Module Impl_core_clone_Clone_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.read (| self |) |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_sync_atomic_Ordering.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
              [
                M.read (| f |);
                M.read (|
                  M.match_operator (|
                    self,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          M.alloc (| M.read (| Value.String "Relaxed" |) |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          M.alloc (| M.read (| Value.String "Release" |) |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          M.alloc (| M.read (| Value.String "Acquire" |) |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          M.alloc (| M.read (| Value.String "AcqRel" |) |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          M.alloc (| M.read (| Value.String "SeqCst" |) |)))
                    ]
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_Ordering.
    
    Module Impl_core_marker_StructuralEq_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_sync_atomic_Ordering.
    
    Module Impl_core_cmp_Eq_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_sync_atomic_Ordering.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_sync_atomic_Ordering.
    
    Module Impl_core_cmp_PartialEq_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let __self_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "core::sync::atomic::Ordering" ]
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let __arg1_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "core::sync::atomic::Ordering" ]
                    |),
                    [ M.read (| other |) ]
                  |)
                |) in
              M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_sync_atomic_Ordering.
    
    Module Impl_core_hash_Hash_for_core_sync_atomic_Ordering.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::Ordering".
      
      (* Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let __self_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "core::sync::atomic::Ordering" ]
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_sync_atomic_Ordering.
    
    Definition value_ATOMIC_BOOL_INIT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicBool", "new", [] |),
              [ Value.Bool false ]
            |)
          |))).
    
    Module Impl_core_sync_atomic_AtomicBool.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicBool".
      
      (*
          pub const fn new(v: bool) -> AtomicBool {
              AtomicBool { v: UnsafeCell::new(v as u8) }
          }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicBool"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                      "new",
                      []
                    |),
                    [ M.rust_cast (M.read (| v |)) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
          pub const unsafe fn from_ptr<'a>(ptr: *mut bool) -> &'a AtomicBool {
              // SAFETY: guaranteed by the caller
              unsafe { &*ptr.cast() }
          }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "bool" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicBool" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
          pub fn get_mut(&mut self) -> &mut bool {
              // SAFETY: the mutable reference guarantees unique ownership.
              unsafe { &mut *(self.v.get() as *mut bool) }
          }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                  "get",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::sync::atomic::AtomicBool",
                    "v"
                  |)
                ]
              |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
          pub fn from_mut(v: &mut bool) -> &mut Self {
              // SAFETY: the mutable reference guarantees unique ownership, and
              // alignment of both `bool` and `Self` is 1.
              unsafe { &mut *(v as *mut bool as *mut Self) }
          }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
          pub fn get_mut_slice(this: &mut [Self]) -> &mut [bool] {
              // SAFETY: the mutable reference guarantees unique ownership.
              unsafe { &mut *(this as *mut [Self] as *mut [bool]) }
          }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
          pub fn from_mut_slice(v: &mut [bool]) -> &mut [Self] {
              // SAFETY: the mutable reference guarantees unique ownership, and
              // alignment of both `bool` and `Self` is 1.
              unsafe { &mut *(v as *mut [bool] as *mut [Self]) }
          }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
          pub const fn into_inner(self) -> bool {
              self.v.into_inner() != 0
          }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Pure.ne
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                  "into_inner",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "core::sync::atomic::AtomicBool",
                      "v"
                    |)
                  |)
                ]
              |))
              (Value.Integer 0)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
          pub fn load(&self, order: Ordering) -> bool {
              // SAFETY: any data races are prevented by atomic intrinsics and the raw
              // pointer passed in is valid because we got it from a reference.
              unsafe { atomic_load(self.v.get(), order) != 0 }
          }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            BinOp.Pure.ne
              (M.call_closure (|
                M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "u8" ] |),
                [
                  (* MutToConstPointer *)
                  M.pointer_coercion
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                        "get",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::sync::atomic::AtomicBool",
                          "v"
                        |)
                      ]
                    |));
                  M.read (| order |)
                ]
              |))
              (Value.Integer 0)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
          pub fn store(&self, val: bool, order: Ordering) {
              // SAFETY: any data races are prevented by atomic intrinsics and the raw
              // pointer passed in is valid because we got it from a reference.
              unsafe {
                  atomic_store(self.v.get(), val as u8, order);
              }
          }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "u8" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicBool",
                            "v"
                          |)
                        ]
                      |);
                      M.rust_cast (M.read (| val |));
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
          pub fn swap(&self, val: bool, order: Ordering) -> bool {
              if EMULATE_ATOMIC_BOOL {
                  if val { self.fetch_or(true, order) } else { self.fetch_and(false, order) }
              } else {
                  // SAFETY: data races are prevented by atomic intrinsics.
                  unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }
              }
          }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.get_constant (| "core::sync::atomic::EMULATE_ATOMIC_BOOL" |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use val in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::sync::atomic::AtomicBool",
                                    "fetch_or",
                                    []
                                  |),
                                  [ M.read (| self |); Value.Bool true; M.read (| order |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::sync::atomic::AtomicBool",
                                    "fetch_and",
                                    []
                                  |),
                                  [ M.read (| self |); Value.Bool false; M.read (| order |) ]
                                |)
                              |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        BinOp.Pure.ne
                          (M.call_closure (|
                            M.get_function (|
                              "core::sync::atomic::atomic_swap",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                                  "get",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::sync::atomic::AtomicBool",
                                    "v"
                                  |)
                                ]
                              |);
                              M.rust_cast (M.read (| val |));
                              M.read (| order |)
                            ]
                          |))
                          (Value.Integer 0)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
          pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {
              match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {
                  Ok(x) => x,
                  Err(x) => x,
              }
          }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicBool",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
          pub fn compare_exchange(
              &self,
              current: bool,
              new: bool,
              success: Ordering,
              failure: Ordering,
          ) -> Result<bool, bool> {
              if EMULATE_ATOMIC_BOOL {
                  // Pick the strongest ordering from success and failure.
                  let order = match (success, failure) {
                      (SeqCst, _) => SeqCst,
                      (_, SeqCst) => SeqCst,
                      (AcqRel, _) => AcqRel,
                      (_, AcqRel) => {
                          panic!("there is no such thing as an acquire-release failure ordering")
                      }
                      (Release, Acquire) => AcqRel,
                      (Acquire, _) => Acquire,
                      (_, Acquire) => Acquire,
                      (Release, Relaxed) => Release,
                      (_, Release) => panic!("there is no such thing as a release failure ordering"),
                      (Relaxed, Relaxed) => Relaxed,
                  };
                  let old = if current == new {
                      // This is a no-op, but we still need to perform the operation
                      // for memory ordering reasons.
                      self.fetch_or(false, order)
                  } else {
                      // This sets the value to the new one and returns the old one.
                      self.swap(new, order)
                  };
                  if old == current { Ok(old) } else { Err(old) }
              } else {
                  // SAFETY: data races are prevented by atomic intrinsics.
                  match unsafe {
                      atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)
                  } {
                      Ok(x) => Ok(x != 0),
                      Err(x) => Err(x != 0),
                  }
              }
          }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.get_constant (| "core::sync::atomic::EMULATE_ATOMIC_BOOL" |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let order :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              Value.Tuple [ M.read (| success |); M.read (| failure |) ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::SeqCst" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::SeqCst" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::AcqRel" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic_fmt", [] |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_const",
                                              []
                                            |),
                                            [
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.read (|
                                                        Value.String
                                                          "there is no such thing as an acquire-release failure ordering"
                                                      |)
                                                    ]
                                                |))
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::AcqRel" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::Acquire" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::Acquire" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::Release" []
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic_fmt", [] |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_const",
                                              []
                                            |),
                                            [
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.read (|
                                                        Value.String
                                                          "there is no such thing as a release failure ordering"
                                                      |)
                                                    ]
                                                |))
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  M.alloc (|
                                    Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                                  |)))
                            ]
                          |)
                        |) in
                      let old :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.eq (M.read (| current |)) (M.read (| new |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicBool",
                                        "fetch_or",
                                        []
                                      |),
                                      [ M.read (| self |); Value.Bool false; M.read (| order |) ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicBool",
                                        "swap",
                                        []
                                      |),
                                      [ M.read (| self |); M.read (| new |); M.read (| order |) ]
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq (M.read (| old |)) (M.read (| current |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple "core::result::Result::Ok" [ M.read (| old |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| old |) ]
                              |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::sync::atomic::atomic_compare_exchange",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                                  "get",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::sync::atomic::AtomicBool",
                                    "v"
                                  |)
                                ]
                              |);
                              M.rust_cast (M.read (| current |));
                              M.rust_cast (M.read (| new |));
                              M.read (| success |);
                              M.read (| failure |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Ok",
                                  0
                                |) in
                              let x := M.copy (| γ0_0 |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::result::Result::Ok"
                                  [ BinOp.Pure.ne (M.read (| x |)) (Value.Integer 0) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Err",
                                  0
                                |) in
                              let x := M.copy (| γ0_0 |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [ BinOp.Pure.ne (M.read (| x |)) (Value.Integer 0) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
          pub fn compare_exchange_weak(
              &self,
              current: bool,
              new: bool,
              success: Ordering,
              failure: Ordering,
          ) -> Result<bool, bool> {
              if EMULATE_ATOMIC_BOOL {
                  return self.compare_exchange(current, new, success, failure);
              }
      
              // SAFETY: data races are prevented by atomic intrinsics.
              match unsafe {
                  atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)
              } {
                  Ok(x) => Ok(x != 0),
                  Err(x) => Err(x != 0),
              }
          }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.get_constant (| "core::sync::atomic::EMULATE_ATOMIC_BOOL" |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicBool",
                                        "compare_exchange",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| current |);
                                        M.read (| new |);
                                        M.read (| success |);
                                        M.read (| failure |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::sync::atomic::atomic_compare_exchange_weak",
                          [ Ty.path "u8" ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                              "get",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::sync::atomic::AtomicBool",
                                "v"
                              |)
                            ]
                          |);
                          M.rust_cast (M.read (| current |));
                          M.rust_cast (M.read (| new |));
                          M.read (| success |);
                          M.read (| failure |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let x := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Ok"
                              [ BinOp.Pure.ne (M.read (| x |)) (Value.Integer 0) ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let x := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Err"
                              [ BinOp.Pure.ne (M.read (| x |)) (Value.Integer 0) ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
          pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }
          }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            BinOp.Pure.ne
              (M.call_closure (|
                M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "u8" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicBool",
                        "v"
                      |)
                    ]
                  |);
                  M.rust_cast (M.read (| val |));
                  M.read (| order |)
                ]
              |))
              (Value.Integer 0)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
          pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {
              // We can't use atomic_nand here because it can result in a bool with
              // an invalid value. This happens because the atomic operation is done
              // with an 8-bit integer internally, which would set the upper 7 bits.
              // So we just use fetch_xor or swap instead.
              if val {
                  // !(x & true) == !x
                  // We must invert the bool.
                  self.fetch_xor(true, order)
              } else {
                  // !(x & false) == true
                  // We must set the bool to true.
                  self.swap(true, order)
              }
          }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use val in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicBool",
                            "fetch_xor",
                            []
                          |),
                          [ M.read (| self |); Value.Bool true; M.read (| order |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicBool",
                            "swap",
                            []
                          |),
                          [ M.read (| self |); Value.Bool true; M.read (| order |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
          pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }
          }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            BinOp.Pure.ne
              (M.call_closure (|
                M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "u8" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicBool",
                        "v"
                      |)
                    ]
                  |);
                  M.rust_cast (M.read (| val |));
                  M.read (| order |)
                ]
              |))
              (Value.Integer 0)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
          pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }
          }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            BinOp.Pure.ne
              (M.call_closure (|
                M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "u8" ] |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicBool",
                        "v"
                      |)
                    ]
                  |);
                  M.rust_cast (M.read (| val |));
                  M.read (| order |)
                ]
              |))
              (Value.Integer 0)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
          pub fn fetch_not(&self, order: Ordering) -> bool {
              self.fetch_xor(true, order)
          }
      *)
      Definition fetch_not (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::sync::atomic::AtomicBool",
                "fetch_xor",
                []
              |),
              [ M.read (| self |); Value.Bool true; M.read (| order |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_not : M.IsAssociatedFunction Self "fetch_not" fetch_not.
      
      (*
          pub const fn as_ptr(&self) -> *mut bool {
              self.v.get().cast()
          }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                "cast",
                [ Ty.path "bool" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicBool",
                      "v"
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
      
      (*
          pub fn fetch_update<F>(
              &self,
              set_order: Ordering,
              fetch_order: Ordering,
              mut f: F,
          ) -> Result<bool, bool>
          where
              F: FnMut(bool) -> Option<bool>,
          {
              let mut prev = self.load(fetch_order);
              while let Some(next) = f(prev) {
                  match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                      x @ Ok(_) => return x,
                      Err(next_prev) => prev = next_prev,
                  }
              }
              Err(prev)
          }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicBool",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "bool" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicBool",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
    End Impl_core_sync_atomic_AtomicBool.
    
    Module Impl_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ].
      
      (*
          pub const fn new(p: *mut T) -> AtomicPtr<T> {
              AtomicPtr { p: UnsafeCell::new(p) }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ p ] =>
          ltac:(M.monadic
            (let p := M.alloc (| p |) in
            Value.StructRecord
              "core::sync::atomic::AtomicPtr"
              [
                ("p",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::cell::UnsafeCell")
                        [ Ty.apply (Ty.path "*mut") [ T ] ],
                      "new",
                      []
                    |),
                    [ M.read (| p |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub const unsafe fn from_ptr<'a>(ptr: *mut *mut T) -> &'a AtomicPtr<T> {
              // SAFETY: guaranteed by the caller
              unsafe { &*ptr.cast() }
          }
      *)
      Definition from_ptr (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "*mut") [ T ] ],
                "cast",
                [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ] ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "from_ptr" (from_ptr T).
      
      (*
          pub fn get_mut(&mut self) -> &mut *mut T {
              self.p.get_mut()
          }
      *)
      Definition get_mut (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.apply (Ty.path "*mut") [ T ] ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicPtr",
                  "p"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "get_mut" (get_mut T).
      
      (*
          pub fn from_mut(v: &mut *mut T) -> &mut Self {
              use crate::mem::align_of;
              let [] = [(); align_of::<AtomicPtr<()>>() - align_of::<*mut ()>()];
              // SAFETY:
              //  - the mutable reference guarantees unique ownership.
              //  - the alignment of `*mut T` and `Self` is the same on all platforms
              //    supported by rust, as verified above.
              unsafe { &mut *(v as *mut *mut T as *mut Self) }
          }
      *)
      Definition from_mut (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "from_mut" (from_mut T).
      
      (*
          pub fn get_mut_slice(this: &mut [Self]) -> &mut [*mut T] {
              // SAFETY: the mutable reference guarantees unique ownership.
              unsafe { &mut *(this as *mut [Self] as *mut [*mut T]) }
          }
      *)
      Definition get_mut_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "get_mut_slice" (get_mut_slice T).
      
      (*
          pub fn from_mut_slice(v: &mut [*mut T]) -> &mut [Self] {
              // SAFETY:
              //  - the mutable reference guarantees unique ownership.
              //  - the alignment of `*mut T` and `Self` is the same on all platforms
              //    supported by rust, as verified above.
              unsafe { &mut *(v as *mut [*mut T] as *mut [Self]) }
          }
      *)
      Definition from_mut_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "from_mut_slice" (from_mut_slice T).
      
      (*
          pub const fn into_inner(self) -> *mut T {
              self.p.into_inner()
          }
      *)
      Definition into_inner (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.apply (Ty.path "*mut") [ T ] ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicPtr",
                    "p"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "into_inner" (into_inner T).
      
      (*
          pub fn load(&self, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_load(self.p.get(), order) }
          }
      *)
      Definition load (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_load",
                [ Ty.apply (Ty.path "*mut") [ T ] ]
              |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::cell::UnsafeCell")
                        [ Ty.apply (Ty.path "*mut") [ T ] ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicPtr",
                        "p"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "load" (load T).
      
      (*
          pub fn store(&self, ptr: *mut T, order: Ordering) {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe {
                  atomic_store(self.p.get(), ptr, order);
              }
          }
      *)
      Definition store (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; ptr; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let ptr := M.alloc (| ptr |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::sync::atomic::atomic_store",
                      [ Ty.apply (Ty.path "*mut") [ T ] ]
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::cell::UnsafeCell")
                            [ Ty.apply (Ty.path "*mut") [ T ] ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicPtr",
                            "p"
                          |)
                        ]
                      |);
                      M.read (| ptr |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "store" (store T).
      
      (*
          pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_swap(self.p.get(), ptr, order) }
          }
      *)
      Definition swap (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; ptr; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let ptr := M.alloc (| ptr |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_swap",
                [ Ty.apply (Ty.path "*mut") [ T ] ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.apply (Ty.path "*mut") [ T ] ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicPtr",
                      "p"
                    |)
                  ]
                |);
                M.read (| ptr |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "swap" (swap T).
      
      (*
          pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {
              match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {
                  Ok(x) => x,
                  Err(x) => x,
              }
          }
      *)
      Definition compare_and_swap (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ],
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "compare_and_swap" (compare_and_swap T).
      
      (*
          pub fn compare_exchange(
              &self,
              current: *mut T,
              new: *mut T,
              success: Ordering,
              failure: Ordering,
          ) -> Result<*mut T, *mut T> {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_compare_exchange(self.p.get(), current, new, success, failure) }
          }
      *)
      Definition compare_exchange (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [ Ty.apply (Ty.path "*mut") [ T ] ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.apply (Ty.path "*mut") [ T ] ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicPtr",
                      "p"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "compare_exchange" (compare_exchange T).
      
      (*
          pub fn compare_exchange_weak(
              &self,
              current: *mut T,
              new: *mut T,
              success: Ordering,
              failure: Ordering,
          ) -> Result<*mut T, *mut T> {
              // SAFETY: This intrinsic is unsafe because it operates on a raw pointer
              // but we know for sure that the pointer is valid (we just got it from
              // an `UnsafeCell` that we have by reference) and the atomic operation
              // itself allows us to safely mutate the `UnsafeCell` contents.
              unsafe { atomic_compare_exchange_weak(self.p.get(), current, new, success, failure) }
          }
      *)
      Definition compare_exchange_weak (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.apply (Ty.path "*mut") [ T ] ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.apply (Ty.path "*mut") [ T ] ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicPtr",
                      "p"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "compare_exchange_weak" (compare_exchange_weak T).
      
      (*
          pub fn fetch_update<F>(
              &self,
              set_order: Ordering,
              fetch_order: Ordering,
              mut f: F,
          ) -> Result<*mut T, *mut T>
          where
              F: FnMut( *mut T) -> Option<*mut T>,
          {
              let mut prev = self.load(fetch_order);
              while let Some(next) = f(prev) {
                  match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                      x @ Ok(_) => return x,
                      Err(next_prev) => prev = next_prev,
                  }
              }
              Err(prev)
          }
      *)
      Definition fetch_update (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ],
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ T ] ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ],
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_update" (fetch_update T).
      
      (*
          pub fn fetch_ptr_add(&self, val: usize, order: Ordering) -> *mut T {
              self.fetch_byte_add(val.wrapping_mul(core::mem::size_of::<T>()), order)
          }
      *)
      Definition fetch_ptr_add (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ],
                "fetch_byte_add",
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_mul", [] |),
                  [
                    M.read (| val |);
                    M.call_closure (| M.get_function (| "core::mem::size_of", [ T ] |), [] |)
                  ]
                |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_ptr_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_ptr_add" (fetch_ptr_add T).
      
      (*
          pub fn fetch_ptr_sub(&self, val: usize, order: Ordering) -> *mut T {
              self.fetch_byte_sub(val.wrapping_mul(core::mem::size_of::<T>()), order)
          }
      *)
      Definition fetch_ptr_sub (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ],
                "fetch_byte_sub",
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_mul", [] |),
                  [
                    M.read (| val |);
                    M.call_closure (| M.get_function (| "core::mem::size_of", [ T ] |), [] |)
                  ]
                |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_ptr_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_ptr_sub" (fetch_ptr_sub T).
      
      (*
          pub fn fetch_byte_add(&self, val: usize, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_add(self.p.get(), core::ptr::invalid_mut(val), order).cast() }
          }
      *)
      Definition fetch_byte_add (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "cast", [ T ] |),
              [
                M.call_closure (|
                  M.get_function (|
                    "core::sync::atomic::atomic_add",
                    [ Ty.apply (Ty.path "*mut") [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          [ Ty.apply (Ty.path "*mut") [ T ] ],
                        "get",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::sync::atomic::AtomicPtr",
                          "p"
                        |)
                      ]
                    |);
                    M.call_closure (|
                      M.get_function (| "core::ptr::invalid_mut", [ T ] |),
                      [ M.read (| val |) ]
                    |);
                    M.read (| order |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_byte_add :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_byte_add" (fetch_byte_add T).
      
      (*
          pub fn fetch_byte_sub(&self, val: usize, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_sub(self.p.get(), core::ptr::invalid_mut(val), order).cast() }
          }
      *)
      Definition fetch_byte_sub (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "cast", [ T ] |),
              [
                M.call_closure (|
                  M.get_function (|
                    "core::sync::atomic::atomic_sub",
                    [ Ty.apply (Ty.path "*mut") [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          [ Ty.apply (Ty.path "*mut") [ T ] ],
                        "get",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::sync::atomic::AtomicPtr",
                          "p"
                        |)
                      ]
                    |);
                    M.call_closure (|
                      M.get_function (| "core::ptr::invalid_mut", [ T ] |),
                      [ M.read (| val |) ]
                    |);
                    M.read (| order |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_byte_sub :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_byte_sub" (fetch_byte_sub T).
      
      (*
          pub fn fetch_or(&self, val: usize, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_or(self.p.get(), core::ptr::invalid_mut(val), order).cast() }
          }
      *)
      Definition fetch_or (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "cast", [ T ] |),
              [
                M.call_closure (|
                  M.get_function (|
                    "core::sync::atomic::atomic_or",
                    [ Ty.apply (Ty.path "*mut") [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          [ Ty.apply (Ty.path "*mut") [ T ] ],
                        "get",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::sync::atomic::AtomicPtr",
                          "p"
                        |)
                      ]
                    |);
                    M.call_closure (|
                      M.get_function (| "core::ptr::invalid_mut", [ T ] |),
                      [ M.read (| val |) ]
                    |);
                    M.read (| order |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_or" (fetch_or T).
      
      (*
          pub fn fetch_and(&self, val: usize, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_and(self.p.get(), core::ptr::invalid_mut(val), order).cast() }
          }
      *)
      Definition fetch_and (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "cast", [ T ] |),
              [
                M.call_closure (|
                  M.get_function (|
                    "core::sync::atomic::atomic_and",
                    [ Ty.apply (Ty.path "*mut") [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          [ Ty.apply (Ty.path "*mut") [ T ] ],
                        "get",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::sync::atomic::AtomicPtr",
                          "p"
                        |)
                      ]
                    |);
                    M.call_closure (|
                      M.get_function (| "core::ptr::invalid_mut", [ T ] |),
                      [ M.read (| val |) ]
                    |);
                    M.read (| order |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_and" (fetch_and T).
      
      (*
          pub fn fetch_xor(&self, val: usize, order: Ordering) -> *mut T {
              // SAFETY: data races are prevented by atomic intrinsics.
              unsafe { atomic_xor(self.p.get(), core::ptr::invalid_mut(val), order).cast() }
          }
      *)
      Definition fetch_xor (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "cast", [ T ] |),
              [
                M.call_closure (|
                  M.get_function (|
                    "core::sync::atomic::atomic_xor",
                    [ Ty.apply (Ty.path "*mut") [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::cell::UnsafeCell")
                          [ Ty.apply (Ty.path "*mut") [ T ] ],
                        "get",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::sync::atomic::AtomicPtr",
                          "p"
                        |)
                      ]
                    |);
                    M.call_closure (|
                      M.get_function (| "core::ptr::invalid_mut", [ T ] |),
                      [ M.read (| val |) ]
                    |);
                    M.read (| order |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "fetch_xor" (fetch_xor T).
      
      (*
          pub const fn as_ptr(&self) -> *mut *mut T {
              self.p.get()
          }
      *)
      Definition as_ptr (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.apply (Ty.path "*mut") [ T ] ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicPtr",
                  "p"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "as_ptr" (as_ptr T).
    End Impl_core_sync_atomic_AtomicPtr_T.
    
    Module Impl_core_convert_From_bool_for_core_sync_atomic_AtomicBool.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicBool".
      
      (*
          fn from(b: bool) -> Self {
              Self::new(b)
          }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ b ] =>
          ltac:(M.monadic
            (let b := M.alloc (| b |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicBool", "new", [] |),
              [ M.read (| b |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "bool" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_core_sync_atomic_AtomicBool.
    
    Module Impl_core_convert_From_pointer_mut_T_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ].
      
      (*
          fn from(p: *mut T) -> Self {
              Self::new(p)
          }
      *)
      Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ p ] =>
          ltac:(M.monadic
            (let p := M.alloc (| p |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ],
                "new",
                []
              |),
              [ M.read (| p |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "*mut") [ T ] ]
          (* Instance *) [ ("from", InstanceField.Method (from T)) ].
    End Impl_core_convert_From_pointer_mut_T_for_core_sync_atomic_AtomicPtr_T.
    
    (* StructRecord
      {
        name := "AtomicI8";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicI8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI8".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicI8", "new", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "i8",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicI8.
    
    Module Impl_core_convert_From_i8_for_core_sync_atomic_AtomicI8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI8".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicI8", "new", [] |),
              [ M.read (| v |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "i8" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i8_for_core_sync_atomic_AtomicI8.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI8",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI8.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicI8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicI8.
    
    Module Impl_core_sync_atomic_AtomicI8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI8".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicI8"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "i8" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicI8" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicI8",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicI8",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "i8" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicI8",
                        "v"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "i8" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicI8",
                            "v"
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_swap", [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI8",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_compare_exchange", [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.path "i8" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_add", [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_sub", [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_nand", [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicI8",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "i8" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicI8",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_max", [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_min", [ Ty.path "i8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i8" ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicI8",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
    End Impl_core_sync_atomic_AtomicI8.
    
    (* StructRecord
      {
        name := "AtomicU8";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicU8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU8".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicU8", "new", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u8",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicU8.
    
    Module Impl_core_convert_From_u8_for_core_sync_atomic_AtomicU8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU8".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicU8", "new", [] |),
              [ M.read (| v |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "u8" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_core_sync_atomic_AtomicU8.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u8", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU8",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU8.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicU8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicU8.
    
    Module Impl_core_sync_atomic_AtomicU8.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU8".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicU8"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicU8" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicU8",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicU8",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "u8" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicU8",
                        "v"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "u8" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicU8",
                            "v"
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_swap", [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU8",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_compare_exchange", [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.path "u8" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_add", [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_sub", [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_nand", [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicU8",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "u8" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicU8",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_umax", [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_umin", [ Ty.path "u8" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU8",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u8" ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicU8",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
    End Impl_core_sync_atomic_AtomicU8.
    
    (* StructRecord
      {
        name := "AtomicI16";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicI16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI16".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicI16", "new", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "i16",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicI16.
    
    Module Impl_core_convert_From_i16_for_core_sync_atomic_AtomicI16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI16".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicI16", "new", [] |),
              [ M.read (| v |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "i16" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i16_for_core_sync_atomic_AtomicI16.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI16",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI16.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicI16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicI16.
    
    Module Impl_core_sync_atomic_AtomicI16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI16".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicI16"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "i16" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicI16" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicI16",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicI16",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "i16" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicI16",
                        "v"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "i16" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicI16",
                            "v"
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_swap", [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI16",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_compare_exchange", [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.path "i16" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_add", [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_sub", [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_nand", [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicI16",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "i16" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicI16",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_max", [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_min", [ Ty.path "i16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i16" ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicI16",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
    End Impl_core_sync_atomic_AtomicI16.
    
    (* StructRecord
      {
        name := "AtomicU16";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicU16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU16".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicU16", "new", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u16",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicU16.
    
    Module Impl_core_convert_From_u16_for_core_sync_atomic_AtomicU16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU16".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicU16", "new", [] |),
              [ M.read (| v |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "u16" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_core_sync_atomic_AtomicU16.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u16", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU16",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU16.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicU16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicU16.
    
    Module Impl_core_sync_atomic_AtomicU16.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU16".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicU16"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "u16" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicU16" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicU16",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicU16",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "u16" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicU16",
                        "v"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "u16" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicU16",
                            "v"
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_swap", [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU16",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_compare_exchange", [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.path "u16" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_add", [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_sub", [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_nand", [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicU16",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "u16" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicU16",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_umax", [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_umin", [ Ty.path "u16" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU16",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u16" ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicU16",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
    End Impl_core_sync_atomic_AtomicU16.
    
    (* StructRecord
      {
        name := "AtomicI32";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicI32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI32".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicI32", "new", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "i32",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicI32.
    
    Module Impl_core_convert_From_i32_for_core_sync_atomic_AtomicI32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI32".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicI32", "new", [] |),
              [ M.read (| v |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "i32" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i32_for_core_sync_atomic_AtomicI32.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI32",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI32.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicI32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicI32.
    
    Module Impl_core_sync_atomic_AtomicI32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI32".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicI32"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "i32" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicI32" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicI32",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicI32",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "i32" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicI32",
                        "v"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "i32" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicI32",
                            "v"
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_swap", [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI32",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_compare_exchange", [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.path "i32" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_add", [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_sub", [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_nand", [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicI32",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "i32" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicI32",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_max", [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_min", [ Ty.path "i32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i32" ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicI32",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
    End Impl_core_sync_atomic_AtomicI32.
    
    (* StructRecord
      {
        name := "AtomicU32";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicU32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU32".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicU32", "new", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u32",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicU32.
    
    Module Impl_core_convert_From_u32_for_core_sync_atomic_AtomicU32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU32".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicU32", "new", [] |),
              [ M.read (| v |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "u32" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u32_for_core_sync_atomic_AtomicU32.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u32", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU32",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU32.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicU32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicU32.
    
    Module Impl_core_sync_atomic_AtomicU32.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU32".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicU32"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "u32" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicU32" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicU32",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicU32",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "u32" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicU32",
                        "v"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "u32" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicU32",
                            "v"
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_swap", [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU32",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_compare_exchange", [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.path "u32" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_add", [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_sub", [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_nand", [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicU32",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "u32" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicU32",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_umax", [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_umin", [ Ty.path "u32" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU32",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u32" ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicU32",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
    End Impl_core_sync_atomic_AtomicU32.
    
    (* StructRecord
      {
        name := "AtomicI64";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicI64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI64".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicI64", "new", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "i64",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicI64.
    
    Module Impl_core_convert_From_i64_for_core_sync_atomic_AtomicI64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI64".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicI64", "new", [] |),
              [ M.read (| v |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "i64" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i64_for_core_sync_atomic_AtomicI64.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "i64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI64",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicI64.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicI64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicI64.
    
    Module Impl_core_sync_atomic_AtomicI64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicI64".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicI64"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "i64" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicI64" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicI64",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicI64",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "i64" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicI64",
                        "v"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "i64" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicI64",
                            "v"
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_swap", [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicI64",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_compare_exchange", [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.path "i64" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_add", [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_sub", [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_nand", [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicI64",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "i64" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicI64",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_max", [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_min", [ Ty.path "i64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicI64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "i64" ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicI64",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
    End Impl_core_sync_atomic_AtomicI64.
    
    (* StructRecord
      {
        name := "AtomicU64";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicU64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU64".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicU64", "new", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u64",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicU64.
    
    Module Impl_core_convert_From_u64_for_core_sync_atomic_AtomicU64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU64".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicU64", "new", [] |),
              [ M.read (| v |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "u64" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u64_for_core_sync_atomic_AtomicU64.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "u64", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU64",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicU64.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicU64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicU64.
    
    Module Impl_core_sync_atomic_AtomicU64.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicU64".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicU64"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "u64" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicU64" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicU64",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicU64",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "u64" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicU64",
                        "v"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "u64" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicU64",
                            "v"
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_swap", [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicU64",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_compare_exchange", [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.path "u64" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_add", [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_sub", [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_nand", [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicU64",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "u64" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicU64",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_umax", [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_umin", [ Ty.path "u64" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicU64",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "u64" ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicU64",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
    End Impl_core_sync_atomic_AtomicU64.
    
    (* StructRecord
      {
        name := "AtomicIsize";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicIsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicIsize".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicIsize", "new", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "isize",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicIsize.
    
    Module Impl_core_convert_From_isize_for_core_sync_atomic_AtomicIsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicIsize".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicIsize", "new", [] |),
              [ M.read (| v |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "isize" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_isize_for_core_sync_atomic_AtomicIsize.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicIsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicIsize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "isize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicIsize",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicIsize.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicIsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicIsize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicIsize.
    
    Module Impl_core_sync_atomic_AtomicIsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicIsize".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicIsize"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "isize" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicIsize" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicIsize",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicIsize",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "isize" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicIsize",
                        "v"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "isize" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicIsize",
                            "v"
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_swap", [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicIsize",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [ Ty.path "isize" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.path "isize" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_add", [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_sub", [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_nand", [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicIsize",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "isize" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicIsize",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_max", [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_min", [ Ty.path "isize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicIsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "isize" ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicIsize",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
    End Impl_core_sync_atomic_AtomicIsize.
    
    (* StructRecord
      {
        name := "AtomicUsize";
        ty_params := [];
        fields := [ ("v", Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ]) ];
      } *)
    
    Module Impl_core_default_Default_for_core_sync_atomic_AtomicUsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicUsize".
      
      (*
                  fn default() -> Self {
                      Self::new(Default::default())
                  }
      *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicUsize", "new", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "usize",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_core_sync_atomic_AtomicUsize.
    
    Module Impl_core_convert_From_usize_for_core_sync_atomic_AtomicUsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicUsize".
      
      (*             fn from(v: $int_type) -> Self { Self::new(v) } *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicUsize", "new", [] |),
              [ M.read (| v |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "usize" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_usize_for_core_sync_atomic_AtomicUsize.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicUsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicUsize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "usize", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicUsize",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicUsize.
    
    Module Impl_core_marker_Sync_for_core_sync_atomic_AtomicUsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicUsize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Sync"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Sync_for_core_sync_atomic_AtomicUsize.
    
    Module Impl_core_sync_atomic_AtomicUsize.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicUsize".
      
      (*
                  pub const fn new(v: $int_type) -> Self {
                      Self {v: UnsafeCell::new(v)}
                  }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            Value.StructRecord
              "core::sync::atomic::AtomicUsize"
              [
                ("v",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
                  pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {
                      // SAFETY: guaranteed by the caller
                      unsafe { &*ptr.cast() }
                  }
      *)
      Definition from_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ ptr ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [ Ty.path "usize" ],
                "cast",
                [ Ty.path "core::sync::atomic::AtomicUsize" ]
              |),
              [ M.read (| ptr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_ptr : M.IsAssociatedFunction Self "from_ptr" from_ptr.
      
      (*
                  pub fn get_mut(&mut self) -> &mut $int_type {
                      self.v.get_mut()
                  }
      *)
      Definition get_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                "get_mut",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicUsize",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
      
      (*
                  pub fn from_mut(v: &mut $int_type) -> &mut Self {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut $int_type as *mut Self) }
                  }
      *)
      Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut : M.IsAssociatedFunction Self "from_mut" from_mut.
      
      (*
                  pub fn get_mut_slice(this: &mut [Self]) -> &mut [$int_type] {
                      // SAFETY: the mutable reference guarantees unique ownership.
                      unsafe { &mut *(this as *mut [Self] as *mut [$int_type]) }
                  }
      *)
      Definition get_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.rust_cast (M.read (| M.use (M.alloc (| M.read (| this |) |)) |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut_slice :
        M.IsAssociatedFunction Self "get_mut_slice" get_mut_slice.
      
      (*
                  pub fn from_mut_slice(v: &mut [$int_type]) -> &mut [Self] {
                      use crate::mem::align_of;
                      let [] = [(); align_of::<Self>() - align_of::<$int_type>()];
                      // SAFETY:
                      //  - the mutable reference guarantees unique ownership.
                      //  - the alignment of `$int_type` and `Self` is the
                      //    same, as promised by $cfg_align and verified above.
                      unsafe { &mut *(v as *mut [$int_type] as *mut [Self]) }
                  }
      *)
      Definition from_mut_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                M.alloc (| repeat (Value.Tuple []) 0 |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.rust_cast (M.read (| M.use (M.alloc (| M.read (| v |) |)) |))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_mut_slice :
        M.IsAssociatedFunction Self "from_mut_slice" from_mut_slice.
      
      (*
                  pub const fn into_inner(self) -> $int_type {
                      self.v.into_inner()
                  }
      *)
      Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                "into_inner",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "core::sync::atomic::AtomicUsize",
                    "v"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
      
      (*
                  pub fn load(&self, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_load(self.v.get(), order) }
                  }
      *)
      Definition load (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_load", [ Ty.path "usize" ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                      "get",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::sync::atomic::AtomicUsize",
                        "v"
                      |)
                    ]
                  |));
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_load : M.IsAssociatedFunction Self "load" load.
      
      (*
                  pub fn store(&self, val: $int_type, order: Ordering) {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_store(self.v.get(), val, order); }
                  }
      *)
      Definition store (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::sync::atomic::atomic_store", [ Ty.path "usize" ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                          "get",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::sync::atomic::AtomicUsize",
                            "v"
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| order |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_store : M.IsAssociatedFunction Self "store" store.
      
      (*
                  pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_swap(self.v.get(), val, order) }
                  }
      *)
      Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_swap", [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap : M.IsAssociatedFunction Self "swap" swap.
      
      (*
                  pub fn compare_and_swap(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          order: Ordering) -> $int_type {
                      match self.compare_exchange(current,
                                                  new,
                                                  order,
                                                  strongest_failure_ordering(order)) {
                          Ok(x) => x,
                          Err(x) => x,
                      }
                  }
      *)
      Definition compare_and_swap (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let order := M.alloc (| order |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicUsize",
                      "compare_exchange",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| current |);
                      M.read (| new |);
                      M.read (| order |);
                      M.call_closure (|
                        M.get_function (| "core::sync::atomic::strongest_failure_ordering", [] |),
                        [ M.read (| order |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_and_swap :
        M.IsAssociatedFunction Self "compare_and_swap" compare_and_swap.
      
      (*
                  pub fn compare_exchange(&self,
                                          current: $int_type,
                                          new: $int_type,
                                          success: Ordering,
                                          failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
                  }
      *)
      Definition compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange",
                [ Ty.path "usize" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange :
        M.IsAssociatedFunction Self "compare_exchange" compare_exchange.
      
      (*
                  pub fn compare_exchange_weak(&self,
                                               current: $int_type,
                                               new: $int_type,
                                               success: Ordering,
                                               failure: Ordering) -> Result<$int_type, $int_type> {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe {
                          atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)
                      }
                  }
      *)
      Definition compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; current; new; success; failure ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let current := M.alloc (| current |) in
            let new := M.alloc (| new |) in
            let success := M.alloc (| success |) in
            let failure := M.alloc (| failure |) in
            M.call_closure (|
              M.get_function (|
                "core::sync::atomic::atomic_compare_exchange_weak",
                [ Ty.path "usize" ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| current |);
                M.read (| new |);
                M.read (| success |);
                M.read (| failure |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compare_exchange_weak :
        M.IsAssociatedFunction Self "compare_exchange_weak" compare_exchange_weak.
      
      (*
                  pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_add(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_add", [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_add : M.IsAssociatedFunction Self "fetch_add" fetch_add.
      
      (*
                  pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_sub(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_sub (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_sub", [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_sub : M.IsAssociatedFunction Self "fetch_sub" fetch_sub.
      
      (*
                  pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_and(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_and (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_and", [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_and : M.IsAssociatedFunction Self "fetch_and" fetch_and.
      
      (*
                  pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_nand(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_nand (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_nand", [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_nand : M.IsAssociatedFunction Self "fetch_nand" fetch_nand.
      
      (*
                  pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_or(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_or (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_or", [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_or : M.IsAssociatedFunction Self "fetch_or" fetch_or.
      
      (*
                  pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { atomic_xor(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_xor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_xor", [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_xor : M.IsAssociatedFunction Self "fetch_xor" fetch_xor.
      
      (*
                  pub fn fetch_update<F>(&self,
                                         set_order: Ordering,
                                         fetch_order: Ordering,
                                         mut f: F) -> Result<$int_type, $int_type>
                  where F: FnMut($int_type) -> Option<$int_type> {
                      let mut prev = self.load(fetch_order);
                      while let Some(next) = f(prev) {
                          match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
                              x @ Ok(_) => return x,
                              Err(next_prev) => prev = next_prev
                          }
                      }
                      Err(prev)
                  }
      *)
      Definition fetch_update (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; set_order; fetch_order; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let set_order := M.alloc (| set_order |) in
            let fetch_order := M.alloc (| fetch_order |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let prev :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "load",
                          []
                        |),
                        [ M.read (| self |); M.read (| fetch_order |) ]
                      |)
                    |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::FnMut",
                                        F,
                                        [ Ty.tuple [ Ty.path "usize" ] ],
                                        "call_mut",
                                        []
                                      |),
                                      [ f; Value.Tuple [ M.read (| prev |) ] ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let next := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        "compare_exchange_weak",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (| prev |);
                                        M.read (| next |);
                                        M.read (| set_order |);
                                        M.read (| fetch_order |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| x |) |) |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        let next_prev := M.copy (| γ0_0 |) in
                                        M.write (| prev, M.read (| next_prev |) |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Err" [ M.read (| prev |) ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_update :
        M.IsAssociatedFunction Self "fetch_update" fetch_update.
      
      (*
                  pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $max_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_umax", [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_max : M.IsAssociatedFunction Self "fetch_max" fetch_max.
      
      (*
                  pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {
                      // SAFETY: data races are prevented by atomic intrinsics.
                      unsafe { $min_fn(self.v.get(), val, order) }
                  }
      *)
      Definition fetch_min (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; val; order ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let order := M.alloc (| order |) in
            M.call_closure (|
              M.get_function (| "core::sync::atomic::atomic_umin", [ Ty.path "usize" ] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                    "get",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::sync::atomic::AtomicUsize",
                      "v"
                    |)
                  ]
                |);
                M.read (| val |);
                M.read (| order |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fetch_min : M.IsAssociatedFunction Self "fetch_min" fetch_min.
      
      (*
                  pub const fn as_ptr(&self) -> *mut $int_type {
                      self.v.get()
                  }
      *)
      Definition as_ptr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::UnsafeCell") [ Ty.path "usize" ],
                "get",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::sync::atomic::AtomicUsize",
                  "v"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_ptr : M.IsAssociatedFunction Self "as_ptr" as_ptr.
    End Impl_core_sync_atomic_AtomicUsize.
    
    Definition value_ATOMIC_ISIZE_INIT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicIsize", "new", [] |),
              [ Value.Integer 0 ]
            |)
          |))).
    
    Definition value_ATOMIC_USIZE_INIT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::sync::atomic::AtomicUsize", "new", [] |),
              [ Value.Integer 0 ]
            |)
          |))).
    
    (*
    fn strongest_failure_ordering(order: Ordering) -> Ordering {
        match order {
            Release => Relaxed,
            Relaxed => Relaxed,
            SeqCst => SeqCst,
            Acquire => Acquire,
            AcqRel => Acquire,
        }
    }
    *)
    Definition strongest_failure_ordering (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ order ] =>
        ltac:(M.monadic
          (let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (| Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (| Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (| Value.StructTuple "core::sync::atomic::Ordering::SeqCst" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (| Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (| Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {
        // SAFETY: the caller must uphold the safety contract for `atomic_store`.
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_store_relaxed(dst, val),
                Release => intrinsics::atomic_store_release(dst, val),
                SeqCst => intrinsics::atomic_store_seqcst(dst, val),
                Acquire => panic!("there is no such thing as an acquire store"),
                AcqRel => panic!("there is no such thing as an acquire-release store"),
            }
        }
    }
    *)
    Definition atomic_store (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_store_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_store_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_store_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String "there is no such thing as an acquire store"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "there is no such thing as an acquire-release store"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_load`.
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_load_relaxed(dst),
                Acquire => intrinsics::atomic_load_acquire(dst),
                SeqCst => intrinsics::atomic_load_seqcst(dst),
                Release => panic!("there is no such thing as a release load"),
                AcqRel => panic!("there is no such thing as an acquire-release load"),
            }
        }
    }
    *)
    Definition atomic_load (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_load_relaxed", [ T ] |),
                        [ M.read (| dst |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_load_acquire", [ T ] |),
                        [ M.read (| dst |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_load_seqcst", [ T ] |),
                        [ M.read (| dst |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String "there is no such thing as a release load"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "there is no such thing as an acquire-release load"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_swap`.
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),
                Acquire => intrinsics::atomic_xchg_acquire(dst, val),
                Release => intrinsics::atomic_xchg_release(dst, val),
                AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),
                SeqCst => intrinsics::atomic_xchg_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_swap (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xchg_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xchg_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xchg_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xchg_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xchg_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_add`.
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),
                Acquire => intrinsics::atomic_xadd_acquire(dst, val),
                Release => intrinsics::atomic_xadd_release(dst, val),
                AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),
                SeqCst => intrinsics::atomic_xadd_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xadd_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xadd_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xadd_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xadd_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xadd_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_sub`.
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),
                Acquire => intrinsics::atomic_xsub_acquire(dst, val),
                Release => intrinsics::atomic_xsub_release(dst, val),
                AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),
                SeqCst => intrinsics::atomic_xsub_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xsub_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xsub_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xsub_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xsub_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xsub_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_compare_exchange<T: Copy>(
        dst: *mut T,
        old: T,
        new: T,
        success: Ordering,
        failure: Ordering,
    ) -> Result<T, T> {
        // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange`.
        let (val, ok) = unsafe {
            match (success, failure) {
                (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed_relaxed(dst, old, new),
                (Relaxed, Acquire) => intrinsics::atomic_cxchg_relaxed_acquire(dst, old, new),
                (Relaxed, SeqCst) => intrinsics::atomic_cxchg_relaxed_seqcst(dst, old, new),
                (Acquire, Relaxed) => intrinsics::atomic_cxchg_acquire_relaxed(dst, old, new),
                (Acquire, Acquire) => intrinsics::atomic_cxchg_acquire_acquire(dst, old, new),
                (Acquire, SeqCst) => intrinsics::atomic_cxchg_acquire_seqcst(dst, old, new),
                (Release, Relaxed) => intrinsics::atomic_cxchg_release_relaxed(dst, old, new),
                (Release, Acquire) => intrinsics::atomic_cxchg_release_acquire(dst, old, new),
                (Release, SeqCst) => intrinsics::atomic_cxchg_release_seqcst(dst, old, new),
                (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_relaxed(dst, old, new),
                (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel_acquire(dst, old, new),
                (AcqRel, SeqCst) => intrinsics::atomic_cxchg_acqrel_seqcst(dst, old, new),
                (SeqCst, Relaxed) => intrinsics::atomic_cxchg_seqcst_relaxed(dst, old, new),
                (SeqCst, Acquire) => intrinsics::atomic_cxchg_seqcst_acquire(dst, old, new),
                (SeqCst, SeqCst) => intrinsics::atomic_cxchg_seqcst_seqcst(dst, old, new),
                (_, AcqRel) => panic!("there is no such thing as an acquire-release failure ordering"),
                (_, Release) => panic!("there is no such thing as a release failure ordering"),
            }
        };
        if ok { Ok(val) } else { Err(val) }
    }
    *)
    Definition atomic_compare_exchange (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; old; new; success; failure ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let old := M.alloc (| old |) in
          let new := M.alloc (| new |) in
          let success := M.alloc (| success |) in
          let failure := M.alloc (| failure |) in
          M.read (|
            M.match_operator (|
              M.match_operator (|
                M.alloc (| Value.Tuple [ M.read (| success |); M.read (| failure |) ] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_relaxed_relaxed",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_relaxed_acquire",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_relaxed_seqcst",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acquire_relaxed",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acquire_acquire",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acquire_seqcst",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_release_relaxed",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_release_acquire",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_release_seqcst",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acqrel_relaxed",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acqrel_acquire",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_acqrel_seqcst",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_seqcst_relaxed",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_seqcst_acquire",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchg_seqcst_seqcst",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "there is no such thing as an acquire-release failure ordering"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "there is no such thing as a release failure ordering"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let val := M.copy (| γ0_0 |) in
                    let ok := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use ok in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              Value.StructTuple "core::result::Result::Ok" [ M.read (| val |) ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::result::Result::Err" [ M.read (| val |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_compare_exchange_weak<T: Copy>(
        dst: *mut T,
        old: T,
        new: T,
        success: Ordering,
        failure: Ordering,
    ) -> Result<T, T> {
        // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange_weak`.
        let (val, ok) = unsafe {
            match (success, failure) {
                (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed_relaxed(dst, old, new),
                (Relaxed, Acquire) => intrinsics::atomic_cxchgweak_relaxed_acquire(dst, old, new),
                (Relaxed, SeqCst) => intrinsics::atomic_cxchgweak_relaxed_seqcst(dst, old, new),
                (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acquire_relaxed(dst, old, new),
                (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acquire_acquire(dst, old, new),
                (Acquire, SeqCst) => intrinsics::atomic_cxchgweak_acquire_seqcst(dst, old, new),
                (Release, Relaxed) => intrinsics::atomic_cxchgweak_release_relaxed(dst, old, new),
                (Release, Acquire) => intrinsics::atomic_cxchgweak_release_acquire(dst, old, new),
                (Release, SeqCst) => intrinsics::atomic_cxchgweak_release_seqcst(dst, old, new),
                (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_relaxed(dst, old, new),
                (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel_acquire(dst, old, new),
                (AcqRel, SeqCst) => intrinsics::atomic_cxchgweak_acqrel_seqcst(dst, old, new),
                (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_seqcst_relaxed(dst, old, new),
                (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_seqcst_acquire(dst, old, new),
                (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak_seqcst_seqcst(dst, old, new),
                (_, AcqRel) => panic!("there is no such thing as an acquire-release failure ordering"),
                (_, Release) => panic!("there is no such thing as a release failure ordering"),
            }
        };
        if ok { Ok(val) } else { Err(val) }
    }
    *)
    Definition atomic_compare_exchange_weak (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; old; new; success; failure ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let old := M.alloc (| old |) in
          let new := M.alloc (| new |) in
          let success := M.alloc (| success |) in
          let failure := M.alloc (| failure |) in
          M.read (|
            M.match_operator (|
              M.match_operator (|
                M.alloc (| Value.Tuple [ M.read (| success |); M.read (| failure |) ] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_relaxed_relaxed",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_relaxed_acquire",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_relaxed_seqcst",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acquire_relaxed",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acquire_acquire",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acquire_seqcst",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_release_relaxed",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_release_acquire",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_release_seqcst",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acqrel_relaxed",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acqrel_acquire",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_acqrel_seqcst",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_seqcst_relaxed",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_seqcst_acquire",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::atomic_cxchgweak_seqcst_seqcst",
                            [ T ]
                          |),
                          [ M.read (| dst |); M.read (| old |); M.read (| new |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "there is no such thing as an acquire-release failure ordering"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String
                                              "there is no such thing as a release failure ordering"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let val := M.copy (| γ0_0 |) in
                    let ok := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use ok in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              Value.StructTuple "core::result::Result::Ok" [ M.read (| val |) ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::result::Result::Err" [ M.read (| val |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_and`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_and_relaxed(dst, val),
                Acquire => intrinsics::atomic_and_acquire(dst, val),
                Release => intrinsics::atomic_and_release(dst, val),
                AcqRel => intrinsics::atomic_and_acqrel(dst, val),
                SeqCst => intrinsics::atomic_and_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_and (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_and_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_and_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_and_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_and_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_and_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_nand`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_nand_relaxed(dst, val),
                Acquire => intrinsics::atomic_nand_acquire(dst, val),
                Release => intrinsics::atomic_nand_release(dst, val),
                AcqRel => intrinsics::atomic_nand_acqrel(dst, val),
                SeqCst => intrinsics::atomic_nand_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_nand (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_nand_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_nand_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_nand_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_nand_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_nand_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_or`
        unsafe {
            match order {
                SeqCst => intrinsics::atomic_or_seqcst(dst, val),
                Acquire => intrinsics::atomic_or_acquire(dst, val),
                Release => intrinsics::atomic_or_release(dst, val),
                AcqRel => intrinsics::atomic_or_acqrel(dst, val),
                Relaxed => intrinsics::atomic_or_relaxed(dst, val),
            }
        }
    }
    *)
    Definition atomic_or (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_or_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_or_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_or_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_or_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_or_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_xor`
        unsafe {
            match order {
                SeqCst => intrinsics::atomic_xor_seqcst(dst, val),
                Acquire => intrinsics::atomic_xor_acquire(dst, val),
                Release => intrinsics::atomic_xor_release(dst, val),
                AcqRel => intrinsics::atomic_xor_acqrel(dst, val),
                Relaxed => intrinsics::atomic_xor_relaxed(dst, val),
            }
        }
    }
    *)
    Definition atomic_xor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xor_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xor_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xor_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xor_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_xor_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_max`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_max_relaxed(dst, val),
                Acquire => intrinsics::atomic_max_acquire(dst, val),
                Release => intrinsics::atomic_max_release(dst, val),
                AcqRel => intrinsics::atomic_max_acqrel(dst, val),
                SeqCst => intrinsics::atomic_max_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_max (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_max_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_max_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_max_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_max_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_max_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_min`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_min_relaxed(dst, val),
                Acquire => intrinsics::atomic_min_acquire(dst, val),
                Release => intrinsics::atomic_min_release(dst, val),
                AcqRel => intrinsics::atomic_min_acqrel(dst, val),
                SeqCst => intrinsics::atomic_min_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_min (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_min_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_min_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_min_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_min_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_min_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_umax`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_umax_relaxed(dst, val),
                Acquire => intrinsics::atomic_umax_acquire(dst, val),
                Release => intrinsics::atomic_umax_release(dst, val),
                AcqRel => intrinsics::atomic_umax_acqrel(dst, val),
                SeqCst => intrinsics::atomic_umax_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_umax (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_umax_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_umax_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_umax_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_umax_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_umax_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        // SAFETY: the caller must uphold the safety contract for `atomic_umin`
        unsafe {
            match order {
                Relaxed => intrinsics::atomic_umin_relaxed(dst, val),
                Acquire => intrinsics::atomic_umin_acquire(dst, val),
                Release => intrinsics::atomic_umin_release(dst, val),
                AcqRel => intrinsics::atomic_umin_acqrel(dst, val),
                SeqCst => intrinsics::atomic_umin_seqcst(dst, val),
            }
        }
    }
    *)
    Definition atomic_umin (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst; val; order ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          let val := M.alloc (| val |) in
          let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_umin_relaxed", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_umin_acquire", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_umin_release", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_umin_acqrel", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_umin_seqcst", [ T ] |),
                        [ M.read (| dst |); M.read (| val |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    pub fn fence(order: Ordering) {
        // SAFETY: using an atomic fence is safe.
        unsafe {
            match order {
                Acquire => intrinsics::atomic_fence_acquire(),
                Release => intrinsics::atomic_fence_release(),
                AcqRel => intrinsics::atomic_fence_acqrel(),
                SeqCst => intrinsics::atomic_fence_seqcst(),
                Relaxed => panic!("there is no such thing as a relaxed fence"),
            }
        }
    }
    *)
    Definition fence (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ order ] =>
        ltac:(M.monadic
          (let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_fence_acquire", [] |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_fence_release", [] |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_fence_acqrel", [] |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::atomic_fence_seqcst", [] |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String "there is no such thing as a relaxed fence"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    pub fn compiler_fence(order: Ordering) {
        // SAFETY: using an atomic fence is safe.
        unsafe {
            match order {
                Acquire => intrinsics::atomic_singlethreadfence_acquire(),
                Release => intrinsics::atomic_singlethreadfence_release(),
                AcqRel => intrinsics::atomic_singlethreadfence_acqrel(),
                SeqCst => intrinsics::atomic_singlethreadfence_seqcst(),
                Relaxed => panic!("there is no such thing as a relaxed compiler fence"),
            }
        }
    }
    *)
    Definition compiler_fence (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ order ] =>
        ltac:(M.monadic
          (let order := M.alloc (| order |) in
          M.read (|
            M.match_operator (|
              order,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::intrinsics::atomic_singlethreadfence_acquire",
                          []
                        |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::intrinsics::atomic_singlethreadfence_release",
                          []
                        |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::intrinsics::atomic_singlethreadfence_acqrel",
                          []
                        |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::intrinsics::atomic_singlethreadfence_seqcst",
                          []
                        |),
                        []
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "there is no such thing as a relaxed compiler fence"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicBool.
      Definition Self : Ty.t := Ty.path "core::sync::atomic::AtomicBool".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
          }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (| "core::fmt::Debug", Ty.path "bool", [], "fmt", [] |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicBool",
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicBool.
    
    Module Impl_core_fmt_Debug_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              fmt::Debug::fmt(&self.load(Ordering::Relaxed), f)
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::Debug",
                Ty.apply (Ty.path "*mut") [ T ],
                [],
                "fmt",
                []
              |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ],
                      "load",
                      []
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_for_core_sync_atomic_AtomicPtr_T.
    
    Module Impl_core_fmt_Pointer_for_core_sync_atomic_AtomicPtr_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              fmt::Pointer::fmt(&self.load(Ordering::SeqCst), f)
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::Pointer",
                Ty.apply (Ty.path "*mut") [ T ],
                [],
                "fmt",
                []
              |),
              [
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [ T ],
                      "load",
                      []
                    |),
                    [ M.read (| self |); Value.StructTuple "core::sync::atomic::Ordering::SeqCst" []
                    ]
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Pointer"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Pointer_for_core_sync_atomic_AtomicPtr_T.
    
    (*
    pub fn spin_loop_hint() {
        spin_loop()
    }
    *)
    Definition spin_loop_hint (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic (M.call_closure (| M.get_function (| "core::hint::spin_loop", [] |), [] |)))
      | _, _ => M.impossible
      end.
  End atomic.
End sync.
