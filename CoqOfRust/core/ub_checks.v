(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module hint.
  Module unreachable_unchecked.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.use (M.alloc (| Ty.path "bool", UnOp.not (| Value.Bool false |) |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: hint::unreachable_unchecked must never be reached"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::hint::unreachable_unchecked::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End unreachable_unchecked.
  
  Module assert_unchecked.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ cond ] =>
        ltac:(M.monadic
          (let cond := M.alloc (| Ty.path "bool", cond |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use (M.alloc (| Ty.path "bool", UnOp.not (| M.read (| cond |) |) |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: hint::assert_unchecked must never be called when the condition is false"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::hint::assert_unchecked::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End assert_unchecked.
End hint.

Module intrinsics.
  Module copy_nonoverlapping.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ src; dst; size; align; count ] =>
        ltac:(M.monadic
          (let src := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ], src |) in
          let dst := M.alloc (| Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ], dst |) in
          let size := M.alloc (| Ty.path "usize", size |) in
          let align := M.alloc (| Ty.path "usize", align |) in
          let count := M.alloc (| Ty.path "usize", count |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        UnOp.not (|
                          M.read (|
                            let~ zero_size : Ty.path "bool" :=
                              LogicalOp.or (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| count |); Value.Integer IntegerKind.Usize 0 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ M.read (| size |); Value.Integer IntegerKind.Usize 0 ]
                                  |)))
                              |) in
                            M.alloc (|
                              Ty.path "bool",
                              LogicalOp.and (|
                                LogicalOp.and (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_function (|
                                      "core::ub_checks::maybe_is_aligned_and_not_null",
                                      [],
                                      []
                                    |),
                                    [ M.read (| src |); M.read (| align |); M.read (| zero_size |) ]
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_function (|
                                        "core::ub_checks::maybe_is_aligned_and_not_null",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                          M.pointer_coercion
                                            M.PointerCoercion.MutToConstPointer
                                            (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                            (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                          [ M.read (| dst |) ]
                                        |);
                                        M.read (| align |);
                                        M.read (| zero_size |)
                                      ]
                                    |)))
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_function (|
                                      "core::ub_checks::maybe_is_nonoverlapping",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (| src |);
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                        M.pointer_coercion
                                          M.PointerCoercion.MutToConstPointer
                                          (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                          (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                        [ M.read (| dst |) ]
                                      |);
                                      M.read (| size |);
                                      M.read (| count |)
                                    ]
                                  |)))
                              |)
                            |)
                          |)
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::intrinsics::copy_nonoverlapping::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End copy_nonoverlapping.
  
  Module copy.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ src; dst; align; zero_size ] =>
        ltac:(M.monadic
          (let src := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ], src |) in
          let dst := M.alloc (| Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ], dst |) in
          let align := M.alloc (| Ty.path "usize", align |) in
          let zero_size := M.alloc (| Ty.path "bool", zero_size |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        UnOp.not (|
                          LogicalOp.and (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::ub_checks::maybe_is_aligned_and_not_null",
                                [],
                                []
                              |),
                              [ M.read (| src |); M.read (| align |); M.read (| zero_size |) ]
                            |),
                            ltac:(M.monadic
                              (M.call_closure (|
                                Ty.path "bool",
                                M.get_function (|
                                  "core::ub_checks::maybe_is_aligned_and_not_null",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                    M.pointer_coercion
                                      M.PointerCoercion.MutToConstPointer
                                      (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                      (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                    [ M.read (| dst |) ]
                                  |);
                                  M.read (| align |);
                                  M.read (| zero_size |)
                                ]
                              |)))
                          |)
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: ptr::copy requires that both pointer arguments are aligned and non-null"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::intrinsics::copy::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End copy.
  
  Module write_bytes.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; zero_size ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ], addr |) in
          let align := M.alloc (| Ty.path "usize", align |) in
          let zero_size := M.alloc (| Ty.path "bool", zero_size |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        UnOp.not (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (|
                              "core::ub_checks::maybe_is_aligned_and_not_null",
                              [],
                              []
                            |),
                            [ M.read (| addr |); M.read (| align |); M.read (| zero_size |) ]
                          |)
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: ptr::write_bytes requires that the destination pointer is aligned and non-null"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::intrinsics::write_bytes::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End write_bytes.
End intrinsics.

Module ptr.
  Module swap_nonoverlapping.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x; y; size; align; count ] =>
        ltac:(M.monadic
          (let x := M.alloc (| Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ], x |) in
          let y := M.alloc (| Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ], y |) in
          let size := M.alloc (| Ty.path "usize", size |) in
          let align := M.alloc (| Ty.path "usize", align |) in
          let count := M.alloc (| Ty.path "usize", count |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        UnOp.not (|
                          M.read (|
                            let~ zero_size : Ty.path "bool" :=
                              LogicalOp.or (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| size |); Value.Integer IntegerKind.Usize 0 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ M.read (| count |); Value.Integer IntegerKind.Usize 0 ]
                                  |)))
                              |) in
                            M.alloc (|
                              Ty.path "bool",
                              LogicalOp.and (|
                                LogicalOp.and (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_function (|
                                      "core::ub_checks::maybe_is_aligned_and_not_null",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                        M.pointer_coercion
                                          M.PointerCoercion.MutToConstPointer
                                          (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                          (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                        [ M.read (| x |) ]
                                      |);
                                      M.read (| align |);
                                      M.read (| zero_size |)
                                    ]
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_function (|
                                        "core::ub_checks::maybe_is_aligned_and_not_null",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                          M.pointer_coercion
                                            M.PointerCoercion.MutToConstPointer
                                            (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                            (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                          [ M.read (| y |) ]
                                        |);
                                        M.read (| align |);
                                        M.read (| zero_size |)
                                      ]
                                    |)))
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_function (|
                                      "core::ub_checks::maybe_is_nonoverlapping",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                        M.pointer_coercion
                                          M.PointerCoercion.MutToConstPointer
                                          (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                          (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                        [ M.read (| x |) ]
                                      |);
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                        M.pointer_coercion
                                          M.PointerCoercion.MutToConstPointer
                                          (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                          (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                        [ M.read (| y |) ]
                                      |);
                                      M.read (| size |);
                                      M.read (| count |)
                                    ]
                                  |)))
                              |)
                            |)
                          |)
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: ptr::swap_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::swap_nonoverlapping::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End swap_nonoverlapping.
  
  Module replace.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; is_zst ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ], addr |) in
          let align := M.alloc (| Ty.path "usize", align |) in
          let is_zst := M.alloc (| Ty.path "bool", is_zst |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        UnOp.not (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (|
                              "core::ub_checks::maybe_is_aligned_and_not_null",
                              [],
                              []
                            |),
                            [ M.read (| addr |); M.read (| align |); M.read (| is_zst |) ]
                          |)
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: ptr::replace requires that the pointer argument is aligned and non-null"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::replace::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End replace.
  
  Module read.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; is_zst ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ], addr |) in
          let align := M.alloc (| Ty.path "usize", align |) in
          let is_zst := M.alloc (| Ty.path "bool", is_zst |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        UnOp.not (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (|
                              "core::ub_checks::maybe_is_aligned_and_not_null",
                              [],
                              []
                            |),
                            [ M.read (| addr |); M.read (| align |); M.read (| is_zst |) ]
                          |)
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: ptr::read requires that the pointer argument is aligned and non-null"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::read::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End read.
  
  Module write.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; is_zst ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ], addr |) in
          let align := M.alloc (| Ty.path "usize", align |) in
          let is_zst := M.alloc (| Ty.path "bool", is_zst |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        UnOp.not (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (|
                              "core::ub_checks::maybe_is_aligned_and_not_null",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                M.pointer_coercion
                                  M.PointerCoercion.MutToConstPointer
                                  (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                  (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                [ M.read (| addr |) ]
                              |);
                              M.read (| align |);
                              M.read (| is_zst |)
                            ]
                          |)
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: ptr::write requires that the pointer argument is aligned and non-null"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::write::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End write.
  
  Module read_volatile.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; is_zst ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ], addr |) in
          let align := M.alloc (| Ty.path "usize", align |) in
          let is_zst := M.alloc (| Ty.path "bool", is_zst |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        UnOp.not (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (|
                              "core::ub_checks::maybe_is_aligned_and_not_null",
                              [],
                              []
                            |),
                            [ M.read (| addr |); M.read (| align |); M.read (| is_zst |) ]
                          |)
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: ptr::read_volatile requires that the pointer argument is aligned and non-null"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::read_volatile::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End read_volatile.
  
  Module write_volatile.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; is_zst ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ], addr |) in
          let align := M.alloc (| Ty.path "usize", align |) in
          let is_zst := M.alloc (| Ty.path "bool", is_zst |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        UnOp.not (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (|
                              "core::ub_checks::maybe_is_aligned_and_not_null",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                M.pointer_coercion
                                  M.PointerCoercion.MutToConstPointer
                                  (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                  (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                [ M.read (| addr |) ]
                              |);
                              M.read (| align |);
                              M.read (| is_zst |)
                            ]
                          |)
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                      [
                        mk_str (|
                          "unsafe precondition(s) violated: ptr::write_volatile requires that the pointer argument is aligned and non-null"
                        |)
                      ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (Value.Tuple []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::write_volatile::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End write_volatile.
End ptr.

Module ub_checks.
  (*
  pub(crate) const fn check_language_ub() -> bool {
      // Only used for UB checks so we may const_eval_select.
      intrinsics::ub_checks()
          && const_eval_select!(
              @capture { } -> bool:
              if const {
                  // Always disable UB checks.
                  false
              } else {
                  // Disable UB checks in Miri.
                  !cfg!(miri)
              }
          )
  }
  *)
  Definition check_language_ub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (LogicalOp.and (|
          M.call_closure (|
            Ty.path "bool",
            M.get_function (| "core::intrinsics::ub_checks", [], [] |),
            []
          |),
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "bool",
              M.get_function (|
                "core::intrinsics::const_eval_select",
                [],
                [
                  Ty.tuple [];
                  Ty.function [] (Ty.path "bool");
                  Ty.function [] (Ty.path "bool");
                  Ty.path "bool"
                ]
              |),
              [
                Value.Tuple [];
                M.get_function (| "core::ub_checks::check_language_ub.compiletime", [], [] |);
                M.get_function (| "core::ub_checks::check_language_ub.runtime", [], [] |)
              ]
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_check_language_ub :
    M.IsFunction.C "core::ub_checks::check_language_ub" check_language_ub.
  Admitted.
  Global Typeclasses Opaque check_language_ub.
  
  (*
  pub(crate) const fn maybe_is_aligned_and_not_null(
      ptr: *const (),
      align: usize,
      is_zst: bool,
  ) -> bool {
      // This is just for safety checks so we can const_eval_select.
      const_eval_select!(
          @capture { ptr: *const (), align: usize, is_zst: bool } -> bool:
          if const {
              is_zst || !ptr.is_null()
          } else {
              ptr.is_aligned_to(align) && (is_zst || !ptr.is_null())
          }
      )
  }
  *)
  Definition maybe_is_aligned_and_not_null
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [ ptr; align; is_zst ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ], ptr |) in
        let align := M.alloc (| Ty.path "usize", align |) in
        let is_zst := M.alloc (| Ty.path "bool", is_zst |) in
        M.call_closure (|
          Ty.path "bool",
          M.get_function (|
            "core::intrinsics::const_eval_select",
            [],
            [
              Ty.tuple
                [ Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]; Ty.path "usize"; Ty.path "bool" ];
              Ty.function
                [ Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]; Ty.path "usize"; Ty.path "bool" ]
                (Ty.path "bool");
              Ty.function
                [ Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]; Ty.path "usize"; Ty.path "bool" ]
                (Ty.path "bool");
              Ty.path "bool"
            ]
          |),
          [
            Value.Tuple [ M.read (| ptr |); M.read (| align |); M.read (| is_zst |) ];
            M.get_function (|
              "core::ub_checks::maybe_is_aligned_and_not_null.compiletime",
              [],
              []
            |);
            M.get_function (| "core::ub_checks::maybe_is_aligned_and_not_null.runtime", [], [] |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_maybe_is_aligned_and_not_null :
    M.IsFunction.C "core::ub_checks::maybe_is_aligned_and_not_null" maybe_is_aligned_and_not_null.
  Admitted.
  Global Typeclasses Opaque maybe_is_aligned_and_not_null.
  
  (*
  pub(crate) const fn is_valid_allocation_size(size: usize, len: usize) -> bool {
      let max_len = if size == 0 { usize::MAX } else { isize::MAX as usize / size };
      len <= max_len
  }
  *)
  Definition is_valid_allocation_size (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ size; len ] =>
      ltac:(M.monadic
        (let size := M.alloc (| Ty.path "usize", size |) in
        let len := M.alloc (| Ty.path "usize", len |) in
        M.read (|
          let~ max_len : Ty.path "usize" :=
            M.match_operator (|
              Ty.path "usize",
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [ M.read (| size |); Value.Integer IntegerKind.Usize 0 ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.read (|
                      get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.div,
                      [
                        M.cast
                          (Ty.path "usize")
                          (M.read (|
                            get_associated_constant (| Ty.path "isize", "MAX", Ty.path "isize" |)
                          |));
                        M.read (| size |)
                      ]
                    |)))
              ]
            |) in
          M.alloc (|
            Ty.path "bool",
            M.call_closure (|
              Ty.path "bool",
              BinOp.le,
              [ M.read (| len |); M.read (| max_len |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_is_valid_allocation_size :
    M.IsFunction.C "core::ub_checks::is_valid_allocation_size" is_valid_allocation_size.
  Admitted.
  Global Typeclasses Opaque is_valid_allocation_size.
  
  (*
  pub(crate) const fn maybe_is_nonoverlapping(
      src: *const (),
      dst: *const (),
      size: usize,
      count: usize,
  ) -> bool {
      // This is just for safety checks so we can const_eval_select.
      const_eval_select!(
          @capture { src: *const (), dst: *const (), size: usize, count: usize } -> bool:
          if const {
              true
          } else {
              let src_usize = src.addr();
              let dst_usize = dst.addr();
              let Some(size) = size.checked_mul(count) else {
                  crate::panicking::panic_nounwind(
                      "is_nonoverlapping: `size_of::<T>() * count` overflows a usize",
                  )
              };
              let diff = src_usize.abs_diff(dst_usize);
              // If the absolute distance between the ptrs is at least as big as the size of the buffer,
              // they do not overlap.
              diff >= size
          }
      )
  }
  *)
  Definition maybe_is_nonoverlapping (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ src; dst; size; count ] =>
      ltac:(M.monadic
        (let src := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ], src |) in
        let dst := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ], dst |) in
        let size := M.alloc (| Ty.path "usize", size |) in
        let count := M.alloc (| Ty.path "usize", count |) in
        M.call_closure (|
          Ty.path "bool",
          M.get_function (|
            "core::intrinsics::const_eval_select",
            [],
            [
              Ty.tuple
                [
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.path "usize";
                  Ty.path "usize"
                ];
              Ty.function
                [
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.path "usize";
                  Ty.path "usize"
                ]
                (Ty.path "bool");
              Ty.function
                [
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.path "usize";
                  Ty.path "usize"
                ]
                (Ty.path "bool");
              Ty.path "bool"
            ]
          |),
          [
            Value.Tuple
              [ M.read (| src |); M.read (| dst |); M.read (| size |); M.read (| count |) ];
            M.get_function (| "core::ub_checks::maybe_is_nonoverlapping.compiletime", [], [] |);
            M.get_function (| "core::ub_checks::maybe_is_nonoverlapping.runtime", [], [] |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_maybe_is_nonoverlapping :
    M.IsFunction.C "core::ub_checks::maybe_is_nonoverlapping" maybe_is_nonoverlapping.
  Admitted.
  Global Typeclasses Opaque maybe_is_nonoverlapping.
End ub_checks.

Module char.
  Module convert.
    Module from_u32_unchecked.
      (*
                  const fn precondition_check($($name:$ty),* ) {
                      if !$e {
                          ::core::panicking::panic_nounwind(
                              concat!("unsafe precondition(s) violated: ", $message)
                          );
                      }
                  }
      *)
      Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ i ] =>
          ltac:(M.monadic
            (let i := M.alloc (| Ty.path "u32", i |) in
            M.match_operator (|
              Ty.tuple [],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [ Ty.path "char"; Ty.path "core::char::convert::CharTryFromError"
                                  ],
                                "is_ok",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "char";
                                        Ty.path "core::char::convert::CharTryFromError"
                                      ],
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "char";
                                          Ty.path "core::char::convert::CharTryFromError"
                                        ],
                                      M.get_function (|
                                        "core::char::convert::char_try_from_u32",
                                        [],
                                        []
                                      |),
                                      [ M.read (| i |) ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                        [ mk_str (| "unsafe precondition(s) violated: invalid value for `char`" |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (Value.Tuple []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_precondition_check :
        M.IsFunction.C
          "core::char::convert::from_u32_unchecked::precondition_check"
          precondition_check.
      Admitted.
      Global Typeclasses Opaque precondition_check.
    End from_u32_unchecked.
  End convert.
End char.

Module slice.
  Module raw.
    Module from_raw_parts.
      (*
                  const fn precondition_check($($name:$ty),* ) {
                      if !$e {
                          ::core::panicking::panic_nounwind(
                              concat!("unsafe precondition(s) violated: ", $message)
                          );
                      }
                  }
      *)
      Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ data; size; align; len ] =>
          ltac:(M.monadic
            (let data := M.alloc (| Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ], data |) in
            let size := M.alloc (| Ty.path "usize", size |) in
            let align := M.alloc (| Ty.path "usize", align |) in
            let len := M.alloc (| Ty.path "usize", len |) in
            M.match_operator (|
              Ty.tuple [],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          UnOp.not (|
                            LogicalOp.and (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_function (|
                                  "core::ub_checks::maybe_is_aligned_and_not_null",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                    M.pointer_coercion
                                      M.PointerCoercion.MutToConstPointer
                                      (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                      (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                    [ M.read (| data |) ]
                                  |);
                                  M.read (| align |);
                                  Value.Bool false
                                ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  M.get_function (|
                                    "core::ub_checks::is_valid_allocation_size",
                                    [],
                                    []
                                  |),
                                  [ M.read (| size |); M.read (| len |) ]
                                |)))
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                        [
                          mk_str (|
                            "unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`"
                          |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (Value.Tuple []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_precondition_check :
        M.IsFunction.C "core::slice::raw::from_raw_parts::precondition_check" precondition_check.
      Admitted.
      Global Typeclasses Opaque precondition_check.
    End from_raw_parts.
    
    Module from_raw_parts_mut.
      (*
                  const fn precondition_check($($name:$ty),* ) {
                      if !$e {
                          ::core::panicking::panic_nounwind(
                              concat!("unsafe precondition(s) violated: ", $message)
                          );
                      }
                  }
      *)
      Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ data; size; align; len ] =>
          ltac:(M.monadic
            (let data := M.alloc (| Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ], data |) in
            let size := M.alloc (| Ty.path "usize", size |) in
            let align := M.alloc (| Ty.path "usize", align |) in
            let len := M.alloc (| Ty.path "usize", len |) in
            M.match_operator (|
              Ty.tuple [],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          UnOp.not (|
                            LogicalOp.and (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_function (|
                                  "core::ub_checks::maybe_is_aligned_and_not_null",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                    M.pointer_coercion
                                      M.PointerCoercion.MutToConstPointer
                                      (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                      (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]),
                                    [ M.read (| data |) ]
                                  |);
                                  M.read (| align |);
                                  Value.Bool false
                                ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  M.get_function (|
                                    "core::ub_checks::is_valid_allocation_size",
                                    [],
                                    []
                                  |),
                                  [ M.read (| size |); M.read (| len |) ]
                                |)))
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                        [
                          mk_str (|
                            "unsafe precondition(s) violated: slice::from_raw_parts_mut requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`"
                          |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (Value.Tuple []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_precondition_check :
        M.IsFunction.C
          "core::slice::raw::from_raw_parts_mut::precondition_check"
          precondition_check.
      Admitted.
      Global Typeclasses Opaque precondition_check.
    End from_raw_parts_mut.
  End raw.
End slice.
