(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module hint.
  Module unreachable_unchecked.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| UnOp.not (| Value.Bool false |) |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: hint::unreachable_unchecked must never be reached"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::hint::unreachable_unchecked::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End unreachable_unchecked.
  
  Module assert_unchecked.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ cond ] =>
        ltac:(M.monadic
          (let cond := M.alloc (| cond |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| UnOp.not (| M.read (| cond |) |) |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: hint::assert_unchecked must never be called when the condition is false"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::hint::assert_unchecked::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End assert_unchecked.
End hint.

Module intrinsics.
  Module copy_nonoverlapping.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ src; dst; size; align; count ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let dst := M.alloc (| dst |) in
          let size := M.alloc (| size |) in
          let align := M.alloc (| align |) in
          let count := M.alloc (| count |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.read (|
                              let~ zero_size : Ty.apply (Ty.path "*") [] [ Ty.path "bool" ] :=
                                M.alloc (|
                                  LogicalOp.or (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [ M.read (| count |); Value.Integer IntegerKind.Usize 0 ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [ M.read (| size |); Value.Integer IntegerKind.Usize 0 ]
                                      |)))
                                  |)
                                |) in
                              M.alloc (|
                                LogicalOp.and (|
                                  LogicalOp.and (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_function (|
                                        "core::ub_checks::maybe_is_aligned_and_not_null",
                                        [],
                                        []
                                      |),
                                      [ M.read (| src |); M.read (| align |); M.read (| zero_size |)
                                      ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        M.get_function (|
                                          "core::ub_checks::maybe_is_aligned_and_not_null",
                                          [],
                                          []
                                        |),
                                        [
                                          (* MutToConstPointer *)
                                          M.pointer_coercion (M.read (| dst |));
                                          M.read (| align |);
                                          M.read (| zero_size |)
                                        ]
                                      |)))
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_function (|
                                        "core::ub_checks::maybe_is_nonoverlapping",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (| src |);
                                        (* MutToConstPointer *)
                                        M.pointer_coercion (M.read (| dst |));
                                        M.read (| size |);
                                        M.read (| count |)
                                      ]
                                    |)))
                                |)
                              |)
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::intrinsics::copy_nonoverlapping::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End copy_nonoverlapping.
  
  Module copy.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ src; dst; align; zero_size ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let dst := M.alloc (| dst |) in
          let align := M.alloc (| align |) in
          let zero_size := M.alloc (| zero_size |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            LogicalOp.and (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_function (|
                                  "core::ub_checks::maybe_is_aligned_and_not_null",
                                  [],
                                  []
                                |),
                                [ M.read (| src |); M.read (| align |); M.read (| zero_size |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  M.get_function (|
                                    "core::ub_checks::maybe_is_aligned_and_not_null",
                                    [],
                                    []
                                  |),
                                  [
                                    (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |));
                                    M.read (| align |);
                                    M.read (| zero_size |)
                                  ]
                                |)))
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: ptr::copy requires that both pointer arguments are aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::intrinsics::copy::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End copy.
  
  Module write_bytes.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; zero_size ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          let align := M.alloc (| align |) in
          let zero_size := M.alloc (| zero_size |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::ub_checks::maybe_is_aligned_and_not_null",
                                [],
                                []
                              |),
                              [ M.read (| addr |); M.read (| align |); M.read (| zero_size |) ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: ptr::write_bytes requires that the destination pointer is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::intrinsics::write_bytes::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End write_bytes.
End intrinsics.

Module ptr.
  Module swap_nonoverlapping.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ x; y; size; align; count ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let y := M.alloc (| y |) in
          let size := M.alloc (| size |) in
          let align := M.alloc (| align |) in
          let count := M.alloc (| count |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.read (|
                              let~ zero_size : Ty.apply (Ty.path "*") [] [ Ty.path "bool" ] :=
                                M.alloc (|
                                  LogicalOp.or (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [ M.read (| size |); Value.Integer IntegerKind.Usize 0 ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [ M.read (| count |); Value.Integer IntegerKind.Usize 0 ]
                                      |)))
                                  |)
                                |) in
                              M.alloc (|
                                LogicalOp.and (|
                                  LogicalOp.and (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_function (|
                                        "core::ub_checks::maybe_is_aligned_and_not_null",
                                        [],
                                        []
                                      |),
                                      [
                                        (* MutToConstPointer *) M.pointer_coercion (M.read (| x |));
                                        M.read (| align |);
                                        M.read (| zero_size |)
                                      ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        M.get_function (|
                                          "core::ub_checks::maybe_is_aligned_and_not_null",
                                          [],
                                          []
                                        |),
                                        [
                                          (* MutToConstPointer *)
                                          M.pointer_coercion (M.read (| y |));
                                          M.read (| align |);
                                          M.read (| zero_size |)
                                        ]
                                      |)))
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_function (|
                                        "core::ub_checks::maybe_is_nonoverlapping",
                                        [],
                                        []
                                      |),
                                      [
                                        (* MutToConstPointer *) M.pointer_coercion (M.read (| x |));
                                        (* MutToConstPointer *) M.pointer_coercion (M.read (| y |));
                                        M.read (| size |);
                                        M.read (| count |)
                                      ]
                                    |)))
                                |)
                              |)
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: ptr::swap_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::swap_nonoverlapping::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End swap_nonoverlapping.
  
  Module replace.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; is_zst ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          let align := M.alloc (| align |) in
          let is_zst := M.alloc (| is_zst |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::ub_checks::maybe_is_aligned_and_not_null",
                                [],
                                []
                              |),
                              [ M.read (| addr |); M.read (| align |); M.read (| is_zst |) ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: ptr::replace requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::replace::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End replace.
  
  Module read.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; is_zst ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          let align := M.alloc (| align |) in
          let is_zst := M.alloc (| is_zst |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::ub_checks::maybe_is_aligned_and_not_null",
                                [],
                                []
                              |),
                              [ M.read (| addr |); M.read (| align |); M.read (| is_zst |) ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: ptr::read requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::read::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End read.
  
  Module write.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; is_zst ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          let align := M.alloc (| align |) in
          let is_zst := M.alloc (| is_zst |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::ub_checks::maybe_is_aligned_and_not_null",
                                [],
                                []
                              |),
                              [
                                (* MutToConstPointer *) M.pointer_coercion (M.read (| addr |));
                                M.read (| align |);
                                M.read (| is_zst |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: ptr::write requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::write::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End write.
  
  Module read_volatile.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; is_zst ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          let align := M.alloc (| align |) in
          let is_zst := M.alloc (| is_zst |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::ub_checks::maybe_is_aligned_and_not_null",
                                [],
                                []
                              |),
                              [ M.read (| addr |); M.read (| align |); M.read (| is_zst |) ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: ptr::read_volatile requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::read_volatile::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End read_volatile.
  
  Module write_volatile.
    (*
                const fn precondition_check($($name:$ty),* ) {
                    if !$e {
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $message)
                        );
                    }
                }
    *)
    Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ addr; align; is_zst ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          let align := M.alloc (| align |) in
          let is_zst := M.alloc (| is_zst |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::ub_checks::maybe_is_aligned_and_not_null",
                                [],
                                []
                              |),
                              [
                                (* MutToConstPointer *) M.pointer_coercion (M.read (| addr |));
                                M.read (| align |);
                                M.read (| is_zst |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                          [
                            mk_str (|
                              "unsafe precondition(s) violated: ptr::write_volatile requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_precondition_check :
      M.IsFunction.C "core::ptr::write_volatile::precondition_check" precondition_check.
    Admitted.
    Global Typeclasses Opaque precondition_check.
  End write_volatile.
End ptr.

Module ub_checks.
  (*
  pub(crate) const fn check_language_ub() -> bool {
      // Only used for UB checks so we may const_eval_select.
      intrinsics::ub_checks()
          && const_eval_select!(
              @capture { } -> bool:
              if const {
                  // Always disable UB checks.
                  false
              } else {
                  // Disable UB checks in Miri.
                  !cfg!(miri)
              }
          )
  }
  *)
  Definition check_language_ub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (LogicalOp.and (|
          M.call_closure (|
            Ty.path "bool",
            M.get_function (| "core::intrinsics::ub_checks", [], [] |),
            []
          |),
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "bool",
              M.get_function (|
                "core::intrinsics::const_eval_select",
                [],
                [
                  Ty.tuple [];
                  Ty.function [] (Ty.path "bool");
                  Ty.function [] (Ty.path "bool");
                  Ty.path "bool"
                ]
              |),
              [
                Value.Tuple [];
                M.get_function (| "core::ub_checks::check_language_ub.compiletime", [], [] |);
                M.get_function (| "core::ub_checks::check_language_ub.runtime", [], [] |)
              ]
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_check_language_ub :
    M.IsFunction.C "core::ub_checks::check_language_ub" check_language_ub.
  Admitted.
  Global Typeclasses Opaque check_language_ub.
  
  (*
  pub(crate) const fn maybe_is_aligned_and_not_null(
      ptr: *const (),
      align: usize,
      is_zst: bool,
  ) -> bool {
      // This is just for safety checks so we can const_eval_select.
      const_eval_select!(
          @capture { ptr: *const (), align: usize, is_zst: bool } -> bool:
          if const {
              is_zst || !ptr.is_null()
          } else {
              ptr.is_aligned_to(align) && (is_zst || !ptr.is_null())
          }
      )
  }
  *)
  Definition maybe_is_aligned_and_not_null
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [ ptr; align; is_zst ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        let align := M.alloc (| align |) in
        let is_zst := M.alloc (| is_zst |) in
        M.call_closure (|
          Ty.path "bool",
          M.get_function (|
            "core::intrinsics::const_eval_select",
            [],
            [
              Ty.tuple
                [ Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]; Ty.path "usize"; Ty.path "bool" ];
              Ty.function
                [ Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]; Ty.path "usize"; Ty.path "bool" ]
                (Ty.path "bool");
              Ty.function
                [ Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ]; Ty.path "usize"; Ty.path "bool" ]
                (Ty.path "bool");
              Ty.path "bool"
            ]
          |),
          [
            Value.Tuple [ M.read (| ptr |); M.read (| align |); M.read (| is_zst |) ];
            M.get_function (|
              "core::ub_checks::maybe_is_aligned_and_not_null.compiletime",
              [],
              []
            |);
            M.get_function (| "core::ub_checks::maybe_is_aligned_and_not_null.runtime", [], [] |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_maybe_is_aligned_and_not_null :
    M.IsFunction.C "core::ub_checks::maybe_is_aligned_and_not_null" maybe_is_aligned_and_not_null.
  Admitted.
  Global Typeclasses Opaque maybe_is_aligned_and_not_null.
  
  (*
  pub(crate) const fn is_valid_allocation_size(size: usize, len: usize) -> bool {
      let max_len = if size == 0 { usize::MAX } else { isize::MAX as usize / size };
      len <= max_len
  }
  *)
  Definition is_valid_allocation_size (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ size; len ] =>
      ltac:(M.monadic
        (let size := M.alloc (| size |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ max_len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.copy (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [ M.read (| size |); Value.Integer IntegerKind.Usize 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.div,
                          [
                            M.cast
                              (Ty.path "usize")
                              (M.read (|
                                get_associated_constant (|
                                  Ty.path "isize",
                                  "MAX",
                                  Ty.path "isize"
                                |)
                              |));
                            M.read (| size |)
                          ]
                        |)
                      |)))
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "bool",
              BinOp.le,
              [ M.read (| len |); M.read (| max_len |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_is_valid_allocation_size :
    M.IsFunction.C "core::ub_checks::is_valid_allocation_size" is_valid_allocation_size.
  Admitted.
  Global Typeclasses Opaque is_valid_allocation_size.
  
  (*
  pub(crate) const fn maybe_is_nonoverlapping(
      src: *const (),
      dst: *const (),
      size: usize,
      count: usize,
  ) -> bool {
      // This is just for safety checks so we can const_eval_select.
      const_eval_select!(
          @capture { src: *const (), dst: *const (), size: usize, count: usize } -> bool:
          if const {
              true
          } else {
              let src_usize = src.addr();
              let dst_usize = dst.addr();
              let Some(size) = size.checked_mul(count) else {
                  crate::panicking::panic_nounwind(
                      "is_nonoverlapping: `size_of::<T>() * count` overflows a usize",
                  )
              };
              let diff = src_usize.abs_diff(dst_usize);
              // If the absolute distance between the ptrs is at least as big as the size of the buffer,
              // they do not overlap.
              diff >= size
          }
      )
  }
  *)
  Definition maybe_is_nonoverlapping (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ src; dst; size; count ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        let dst := M.alloc (| dst |) in
        let size := M.alloc (| size |) in
        let count := M.alloc (| count |) in
        M.call_closure (|
          Ty.path "bool",
          M.get_function (|
            "core::intrinsics::const_eval_select",
            [],
            [
              Ty.tuple
                [
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.path "usize";
                  Ty.path "usize"
                ];
              Ty.function
                [
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.path "usize";
                  Ty.path "usize"
                ]
                (Ty.path "bool");
              Ty.function
                [
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                  Ty.path "usize";
                  Ty.path "usize"
                ]
                (Ty.path "bool");
              Ty.path "bool"
            ]
          |),
          [
            Value.Tuple
              [ M.read (| src |); M.read (| dst |); M.read (| size |); M.read (| count |) ];
            M.get_function (| "core::ub_checks::maybe_is_nonoverlapping.compiletime", [], [] |);
            M.get_function (| "core::ub_checks::maybe_is_nonoverlapping.runtime", [], [] |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_maybe_is_nonoverlapping :
    M.IsFunction.C "core::ub_checks::maybe_is_nonoverlapping" maybe_is_nonoverlapping.
  Admitted.
  Global Typeclasses Opaque maybe_is_nonoverlapping.
End ub_checks.

Module char.
  Module convert.
    Module from_u32_unchecked.
      (*
                  const fn precondition_check($($name:$ty),* ) {
                      if !$e {
                          ::core::panicking::panic_nounwind(
                              concat!("unsafe precondition(s) violated: ", $message)
                          );
                      }
                  }
      *)
      Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ i ] =>
          ltac:(M.monadic
            (let i := M.alloc (| i |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "char";
                                      Ty.path "core::char::convert::CharTryFromError"
                                    ],
                                  "is_ok",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "char";
                                            Ty.path "core::char::convert::CharTryFromError"
                                          ],
                                        M.get_function (|
                                          "core::char::convert::char_try_from_u32",
                                          [],
                                          []
                                        |),
                                        [ M.read (| i |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                            [
                              mk_str (|
                                "unsafe precondition(s) violated: invalid value for `char`"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_precondition_check :
        M.IsFunction.C
          "core::char::convert::from_u32_unchecked::precondition_check"
          precondition_check.
      Admitted.
      Global Typeclasses Opaque precondition_check.
    End from_u32_unchecked.
  End convert.
End char.

Module slice.
  Module raw.
    Module from_raw_parts.
      (*
                  const fn precondition_check($($name:$ty),* ) {
                      if !$e {
                          ::core::panicking::panic_nounwind(
                              concat!("unsafe precondition(s) violated: ", $message)
                          );
                      }
                  }
      *)
      Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ data; size; align; len ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let size := M.alloc (| size |) in
            let align := M.alloc (| align |) in
            let len := M.alloc (| len |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_function (|
                                    "core::ub_checks::maybe_is_aligned_and_not_null",
                                    [],
                                    []
                                  |),
                                  [
                                    (* MutToConstPointer *) M.pointer_coercion (M.read (| data |));
                                    M.read (| align |);
                                    Value.Bool false
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_function (|
                                      "core::ub_checks::is_valid_allocation_size",
                                      [],
                                      []
                                    |),
                                    [ M.read (| size |); M.read (| len |) ]
                                  |)))
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                            [
                              mk_str (|
                                "unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_precondition_check :
        M.IsFunction.C "core::slice::raw::from_raw_parts::precondition_check" precondition_check.
      Admitted.
      Global Typeclasses Opaque precondition_check.
    End from_raw_parts.
    
    Module from_raw_parts_mut.
      (*
                  const fn precondition_check($($name:$ty),* ) {
                      if !$e {
                          ::core::panicking::panic_nounwind(
                              concat!("unsafe precondition(s) violated: ", $message)
                          );
                      }
                  }
      *)
      Definition precondition_check (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ data; size; align; len ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let size := M.alloc (| size |) in
            let align := M.alloc (| align |) in
            let len := M.alloc (| len |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_function (|
                                    "core::ub_checks::maybe_is_aligned_and_not_null",
                                    [],
                                    []
                                  |),
                                  [
                                    (* MutToConstPointer *) M.pointer_coercion (M.read (| data |));
                                    M.read (| align |);
                                    Value.Bool false
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_function (|
                                      "core::ub_checks::is_valid_allocation_size",
                                      [],
                                      []
                                    |),
                                    [ M.read (| size |); M.read (| len |) ]
                                  |)))
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_nounwind", [], [] |),
                            [
                              mk_str (|
                                "unsafe precondition(s) violated: slice::from_raw_parts_mut requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_precondition_check :
        M.IsFunction.C
          "core::slice::raw::from_raw_parts_mut::precondition_check"
          precondition_check.
      Admitted.
      Global Typeclasses Opaque precondition_check.
    End from_raw_parts_mut.
  End raw.
End slice.
