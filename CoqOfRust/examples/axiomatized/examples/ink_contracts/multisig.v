(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Definition Get__key :=
    Ref.map (fun α => Some α.(_key)) (fun β α => Some (α <| _key := β |>)).
  Definition Get__value :=
    Ref.map (fun α => Some α.(_value)) (fun β α => Some (α <| _value := β |>)).
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_multisig_Mapping_t_K_V.
Section Impl_core_default_Default_for_multisig_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := multisig.Mapping.t K V.
  
  (*
  Default
  *)
  Parameter default : M (multisig.Mapping.t K V).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Mapping_t_K_V.
End Impl_core_default_Default_for_multisig_Mapping_t_K_V.

Module  Impl_multisig_Mapping_t_K_V.
Section Impl_multisig_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := multisig.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Parameter contains : (ref Self) -> (ref K) -> M bool.t.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Parameter get : (ref Self) -> (ref K) -> M (core.option.Option.t V).
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Parameter insert : (mut_ref Self) -> K -> V -> M (core.option.Option.t u32.t).
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Parameter remove : (ref Self) -> K -> M unit.
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Parameter size : (ref Self) -> K -> M (core.option.Option.t u32.t).
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon Self "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Parameter take : (ref Self) -> K -> M (core.option.Option.t V).
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_multisig_Mapping_t_K_V.
End Impl_multisig_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_multisig_AccountId_t.
Section Impl_core_default_Default_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Default
  *)
  Parameter default : M multisig.AccountId.t.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_AccountId_t.
End Impl_core_default_Default_for_multisig_AccountId_t.

Module  Impl_core_fmt_Debug_for_multisig_AccountId_t.
Section Impl_core_fmt_Debug_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Debug
  *)
  Parameter fmt :
      (ref Self) -> (mut_ref core.fmt.Formatter.t) -> M ltac:(core.fmt.Result).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_multisig_AccountId_t.
End Impl_core_fmt_Debug_for_multisig_AccountId_t.

Module  Impl_core_clone_Clone_for_multisig_AccountId_t.
Section Impl_core_clone_Clone_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Clone
  *)
  Parameter clone : (ref Self) -> M multisig.AccountId.t.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_AccountId_t.
End Impl_core_clone_Clone_for_multisig_AccountId_t.

Module  Impl_core_marker_Copy_for_multisig_AccountId_t.
Section Impl_core_marker_Copy_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_AccountId_t.
End Impl_core_marker_Copy_for_multisig_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
Section Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  PartialEq
  *)
  Parameter eq : (ref Self) -> (ref multisig.AccountId.t) -> M bool.t.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
End Impl_core_cmp_PartialEq_for_multisig_AccountId_t.

Module  Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
Section Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
End Impl_core_marker_StructuralEq_for_multisig_AccountId_t.

Module  Impl_core_cmp_Eq_for_multisig_AccountId_t.
Section Impl_core_cmp_Eq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Eq
  *)
  Parameter assert_receiver_is_total_eq : (ref Self) -> M unit.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_multisig_AccountId_t.
End Impl_core_cmp_Eq_for_multisig_AccountId_t.

Module  Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
Section Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  PartialOrd
  *)
  Parameter partial_cmp :
      (ref Self) ->
        (ref multisig.AccountId.t) ->
        M (core.option.Option.t core.cmp.Ordering.t).
  
  Global Instance AssociatedFunction_partial_cmp :
    Notations.DoubleColon Self "partial_cmp" := {
    Notations.double_colon := partial_cmp;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialOrd.Required.Trait Self
      (Rhs := core.cmp.PartialOrd.Default.Rhs Self) := {
    core.cmp.PartialOrd.partial_cmp := partial_cmp;
    core.cmp.PartialOrd.lt := Datatypes.None;
    core.cmp.PartialOrd.le := Datatypes.None;
    core.cmp.PartialOrd.gt := Datatypes.None;
    core.cmp.PartialOrd.ge := Datatypes.None;
  }.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.

Module  Impl_core_cmp_Ord_for_multisig_AccountId_t.
Section Impl_core_cmp_Ord_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Ord
  *)
  Parameter cmp :
      (ref Self) -> (ref multisig.AccountId.t) -> M core.cmp.Ordering.t.
  
  Global Instance AssociatedFunction_cmp : Notations.DoubleColon Self "cmp" := {
    Notations.double_colon := cmp;
  }.
  
  Global Instance ℐ : core.cmp.Ord.Required.Trait Self := {
    core.cmp.Ord.cmp := cmp;
    core.cmp.Ord.max := Datatypes.None;
    core.cmp.Ord.min := Datatypes.None;
    core.cmp.Ord.clamp := Datatypes.None;
  }.
End Impl_core_cmp_Ord_for_multisig_AccountId_t.
End Impl_core_cmp_Ord_for_multisig_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : multisig.AccountId.t;
  }.
  
  Definition Get_caller :=
    Ref.map (fun α => Some α.(caller)) (fun β α => Some (α <| caller := β |>)).
End Env.
End Env.

Parameter MAX_OWNERS : M.Val u32.t.

Ltac TransactionId := exact u32.t.

Parameter WRONG_TRANSACTION_ID : M.Val (ref str.t).

Module  CallInput.
Section CallInput.
  Record t : Set := {
    x0 : ref (slice u8.t);
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End CallInput.
End CallInput.

Module ConfirmationStatus.
  Inductive t : Set :=
  | Confirmed
  | ConfirmationsNeeded (_ : u32.t).
  
  Definition Get_ConfirmationsNeeded_0 :=
    Ref.map
      (fun α =>
        match α with | ConfirmationsNeeded α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | ConfirmationsNeeded _ => Some (ConfirmationsNeeded β)
        | _ => None
        end).
End ConfirmationStatus.

Module  Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
Section Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
  Definition Self : Set := multisig.ConfirmationStatus.t.
  
  (*
  Clone
  *)
  Parameter clone : (ref Self) -> M multisig.ConfirmationStatus.t.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.

Module  Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
Section Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
  Definition Self : Set := multisig.ConfirmationStatus.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.

Module  Transaction.
Section Transaction.
  Record t : Set := {
    callee : multisig.AccountId.t;
    selector : array u8.t;
    input : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A;
    transferred_value : ltac:(multisig.Balance);
    gas_limit : u64.t;
    allow_reentry : bool.t;
  }.
  
  Definition Get_callee :=
    Ref.map (fun α => Some α.(callee)) (fun β α => Some (α <| callee := β |>)).
  Definition Get_selector :=
    Ref.map
      (fun α => Some α.(selector))
      (fun β α => Some (α <| selector := β |>)).
  Definition Get_input :=
    Ref.map (fun α => Some α.(input)) (fun β α => Some (α <| input := β |>)).
  Definition Get_transferred_value :=
    Ref.map
      (fun α => Some α.(transferred_value))
      (fun β α => Some (α <| transferred_value := β |>)).
  Definition Get_gas_limit :=
    Ref.map
      (fun α => Some α.(gas_limit))
      (fun β α => Some (α <| gas_limit := β |>)).
  Definition Get_allow_reentry :=
    Ref.map
      (fun α => Some α.(allow_reentry))
      (fun β α => Some (α <| allow_reentry := β |>)).
End Transaction.
End Transaction.

Module  Impl_core_default_Default_for_multisig_Transaction_t.
Section Impl_core_default_Default_for_multisig_Transaction_t.
  Definition Self : Set := multisig.Transaction.t.
  
  (*
  Default
  *)
  Parameter default : M multisig.Transaction.t.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Transaction_t.
End Impl_core_default_Default_for_multisig_Transaction_t.

Module Error.
  Inductive t : Set :=
  | TransactionFailed.
End Error.

Module  Impl_core_clone_Clone_for_multisig_Error_t.
Section Impl_core_clone_Clone_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  Clone
  *)
  Parameter clone : (ref Self) -> M multisig.Error.t.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_Error_t.
End Impl_core_clone_Clone_for_multisig_Error_t.

Module  Impl_core_marker_Copy_for_multisig_Error_t.
Section Impl_core_marker_Copy_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_Error_t.
End Impl_core_marker_Copy_for_multisig_Error_t.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
Section Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.

Module  Impl_core_cmp_PartialEq_for_multisig_Error_t.
Section Impl_core_cmp_PartialEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  PartialEq
  *)
  Parameter eq : (ref Self) -> (ref multisig.Error.t) -> M bool.t.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_multisig_Error_t.
End Impl_core_cmp_PartialEq_for_multisig_Error_t.

Module  Impl_core_marker_StructuralEq_for_multisig_Error_t.
Section Impl_core_marker_StructuralEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_multisig_Error_t.
End Impl_core_marker_StructuralEq_for_multisig_Error_t.

Module  Impl_core_cmp_Eq_for_multisig_Error_t.
Section Impl_core_cmp_Eq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  Eq
  *)
  Parameter assert_receiver_is_total_eq : (ref Self) -> M unit.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_multisig_Error_t.
End Impl_core_cmp_Eq_for_multisig_Error_t.

Module  Transactions.
Section Transactions.
  Record t : Set := {
    transactions :
      alloc.vec.Vec.t ltac:(multisig.TransactionId) alloc.vec.Vec.Default.A;
    next_id : ltac:(multisig.TransactionId);
  }.
  
  Definition Get_transactions :=
    Ref.map
      (fun α => Some α.(transactions))
      (fun β α => Some (α <| transactions := β |>)).
  Definition Get_next_id :=
    Ref.map
      (fun α => Some α.(next_id))
      (fun β α => Some (α <| next_id := β |>)).
End Transactions.
End Transactions.

Module  Impl_core_default_Default_for_multisig_Transactions_t.
Section Impl_core_default_Default_for_multisig_Transactions_t.
  Definition Self : Set := multisig.Transactions.t.
  
  (*
  Default
  *)
  Parameter default : M multisig.Transactions.t.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Transactions_t.
End Impl_core_default_Default_for_multisig_Transactions_t.

Module  Confirmation.
Section Confirmation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    from : multisig.AccountId.t;
    status : multisig.ConfirmationStatus.t;
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
  Definition Get_status :=
    Ref.map (fun α => Some α.(status)) (fun β α => Some (α <| status := β |>)).
End Confirmation.
End Confirmation.

Module  Revocation.
Section Revocation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    from : multisig.AccountId.t;
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
End Revocation.
End Revocation.

Module  Submission.
Section Submission.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
End Submission.
End Submission.

Module  Cancellation.
Section Cancellation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
End Cancellation.
End Cancellation.

Module  Execution.
Section Execution.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    result :
      core.result.Result.t
        (core.option.Option.t (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        multisig.Error.t;
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
  Definition Get_result :=
    Ref.map (fun α => Some α.(result)) (fun β α => Some (α <| result := β |>)).
End Execution.
End Execution.

Module  OwnerAddition.
Section OwnerAddition.
  Record t : Set := {
    owner : multisig.AccountId.t;
  }.
  
  Definition Get_owner :=
    Ref.map (fun α => Some α.(owner)) (fun β α => Some (α <| owner := β |>)).
End OwnerAddition.
End OwnerAddition.

Module  OwnerRemoval.
Section OwnerRemoval.
  Record t : Set := {
    owner : multisig.AccountId.t;
  }.
  
  Definition Get_owner :=
    Ref.map (fun α => Some α.(owner)) (fun β α => Some (α <| owner := β |>)).
End OwnerRemoval.
End OwnerRemoval.

Module  RequirementChange.
Section RequirementChange.
  Record t : Set := {
    new_requirement : u32.t;
  }.
  
  Definition Get_new_requirement :=
    Ref.map
      (fun α => Some α.(new_requirement))
      (fun β α => Some (α <| new_requirement := β |>)).
End RequirementChange.
End RequirementChange.

Module Event.
  Inductive t : Set :=
  | Confirmation (_ : multisig.Confirmation.t)
  | Revocation (_ : multisig.Revocation.t)
  | Submission (_ : multisig.Submission.t)
  | Cancellation (_ : multisig.Cancellation.t)
  | Execution (_ : multisig.Execution.t)
  | OwnerAddition (_ : multisig.OwnerAddition.t)
  | OwnerRemoval (_ : multisig.OwnerRemoval.t)
  | RequirementChange (_ : multisig.RequirementChange.t).
  
  Definition Get_Confirmation_0 :=
    Ref.map
      (fun α => match α with | Confirmation α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Confirmation _ => Some (Confirmation β) | _ => None end).
  
  Definition Get_Revocation_0 :=
    Ref.map
      (fun α => match α with | Revocation α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Revocation _ => Some (Revocation β) | _ => None end).
  
  Definition Get_Submission_0 :=
    Ref.map
      (fun α => match α with | Submission α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Submission _ => Some (Submission β) | _ => None end).
  
  Definition Get_Cancellation_0 :=
    Ref.map
      (fun α => match α with | Cancellation α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Cancellation _ => Some (Cancellation β) | _ => None end).
  
  Definition Get_Execution_0 :=
    Ref.map
      (fun α => match α with | Execution α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Execution _ => Some (Execution β) | _ => None end).
  
  Definition Get_OwnerAddition_0 :=
    Ref.map
      (fun α => match α with | OwnerAddition α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | OwnerAddition _ => Some (OwnerAddition β)
        | _ => None
        end).
  
  Definition Get_OwnerRemoval_0 :=
    Ref.map
      (fun α => match α with | OwnerRemoval α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | OwnerRemoval _ => Some (OwnerRemoval β) | _ => None end).
  
  Definition Get_RequirementChange_0 :=
    Ref.map
      (fun α => match α with | RequirementChange α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | RequirementChange _ => Some (RequirementChange β)
        | _ => None
        end).
End Event.

Module  Impl_multisig_Env_t.
Section Impl_multisig_Env_t.
  Definition Self : Set := multisig.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Parameter caller : (ref Self) -> M multisig.AccountId.t.
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Parameter emit_event : (ref Self) -> multisig.Event.t -> M unit.
  
  Global Instance AssociatedFunction_emit_event :
    Notations.DoubleColon Self "emit_event" := {
    Notations.double_colon := emit_event;
  }.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Parameter transferred_value : (ref Self) -> M ltac:(multisig.Balance).
  
  Global Instance AssociatedFunction_transferred_value :
    Notations.DoubleColon Self "transferred_value" := {
    Notations.double_colon := transferred_value;
  }.
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Parameter account_id : (ref Self) -> M multisig.AccountId.t.
  
  Global Instance AssociatedFunction_account_id :
    Notations.DoubleColon Self "account_id" := {
    Notations.double_colon := account_id;
  }.
End Impl_multisig_Env_t.
End Impl_multisig_Env_t.

Module  Multisig.
Section Multisig.
  Record t : Set := {
    confirmations :
      multisig.Mapping.t
        (ltac:(multisig.TransactionId) * multisig.AccountId.t)
        unit;
    confirmation_count : multisig.Mapping.t ltac:(multisig.TransactionId) u32.t;
    transactions :
      multisig.Mapping.t ltac:(multisig.TransactionId) multisig.Transaction.t;
    transaction_list : multisig.Transactions.t;
    owners : alloc.vec.Vec.t multisig.AccountId.t alloc.vec.Vec.Default.A;
    is_owner : multisig.Mapping.t multisig.AccountId.t unit;
    requirement : u32.t;
  }.
  
  Definition Get_confirmations :=
    Ref.map
      (fun α => Some α.(confirmations))
      (fun β α => Some (α <| confirmations := β |>)).
  Definition Get_confirmation_count :=
    Ref.map
      (fun α => Some α.(confirmation_count))
      (fun β α => Some (α <| confirmation_count := β |>)).
  Definition Get_transactions :=
    Ref.map
      (fun α => Some α.(transactions))
      (fun β α => Some (α <| transactions := β |>)).
  Definition Get_transaction_list :=
    Ref.map
      (fun α => Some α.(transaction_list))
      (fun β α => Some (α <| transaction_list := β |>)).
  Definition Get_owners :=
    Ref.map (fun α => Some α.(owners)) (fun β α => Some (α <| owners := β |>)).
  Definition Get_is_owner :=
    Ref.map
      (fun α => Some α.(is_owner))
      (fun β α => Some (α <| is_owner := β |>)).
  Definition Get_requirement :=
    Ref.map
      (fun α => Some α.(requirement))
      (fun β α => Some (α <| requirement := β |>)).
End Multisig.
End Multisig.

Module  Impl_core_default_Default_for_multisig_Multisig_t.
Section Impl_core_default_Default_for_multisig_Multisig_t.
  Definition Self : Set := multisig.Multisig.t.
  
  (*
  Default
  *)
  Parameter default : M multisig.Multisig.t.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Multisig_t.
End Impl_core_default_Default_for_multisig_Multisig_t.

(*
fn ensure_requirement_is_valid(owners: u32, requirement: u32) {
    assert!(0 < requirement && requirement <= owners && owners <= MAX_OWNERS);
}
*)
Parameter ensure_requirement_is_valid : u32.t -> u32.t -> M unit.

Module  Impl_multisig_Multisig_t.
Section Impl_multisig_Multisig_t.
  Definition Self : Set := multisig.Multisig.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Parameter init_env : M multisig.Env.t.
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Parameter env : (ref Self) -> M multisig.Env.t.
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new(requirement: u32, mut owners: Vec<AccountId>) -> Self {
          let mut contract = Multisig::default();
          owners.sort_unstable();
          owners.dedup();
          ensure_requirement_is_valid(owners.len() as u32, requirement);
  
          for owner in &owners {
              contract.is_owner.insert( *owner, ());
          }
  
          contract.owners = owners;
          contract.transaction_list = Default::default();
          contract.requirement = requirement;
          contract
      }
  *)
  Parameter new :
      u32.t ->
        (alloc.vec.Vec.t multisig.AccountId.t alloc.vec.Vec.Default.A) ->
        M Self.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn ensure_confirmed(&self, trans_id: TransactionId) {
          assert!(
              self.confirmation_count
                  .get(&trans_id)
                  .expect(WRONG_TRANSACTION_ID)
                  >= self.requirement
          );
      }
  *)
  Parameter ensure_confirmed :
      (ref Self) -> ltac:(multisig.TransactionId) -> M unit.
  
  Global Instance AssociatedFunction_ensure_confirmed :
    Notations.DoubleColon Self "ensure_confirmed" := {
    Notations.double_colon := ensure_confirmed;
  }.
  
  (*
      fn ensure_transaction_exists(&self, trans_id: TransactionId) {
          self.transactions
              .get(&trans_id)
              .expect(WRONG_TRANSACTION_ID);
      }
  *)
  Parameter ensure_transaction_exists :
      (ref Self) -> ltac:(multisig.TransactionId) -> M unit.
  
  Global Instance AssociatedFunction_ensure_transaction_exists :
    Notations.DoubleColon Self "ensure_transaction_exists" := {
    Notations.double_colon := ensure_transaction_exists;
  }.
  
  (*
      fn ensure_owner(&self, owner: &AccountId) {
          assert!(self.is_owner.contains(owner));
      }
  *)
  Parameter ensure_owner : (ref Self) -> (ref multisig.AccountId.t) -> M unit.
  
  Global Instance AssociatedFunction_ensure_owner :
    Notations.DoubleColon Self "ensure_owner" := {
    Notations.double_colon := ensure_owner;
  }.
  
  (*
      fn ensure_caller_is_owner(&self) {
          self.ensure_owner(&self.env().caller());
      }
  *)
  Parameter ensure_caller_is_owner : (ref Self) -> M unit.
  
  Global Instance AssociatedFunction_ensure_caller_is_owner :
    Notations.DoubleColon Self "ensure_caller_is_owner" := {
    Notations.double_colon := ensure_caller_is_owner;
  }.
  
  (*
      fn ensure_from_wallet(&self) {
          assert_eq!(self.env().caller(), self.env().account_id());
      }
  *)
  Parameter ensure_from_wallet : (ref Self) -> M unit.
  
  Global Instance AssociatedFunction_ensure_from_wallet :
    Notations.DoubleColon Self "ensure_from_wallet" := {
    Notations.double_colon := ensure_from_wallet;
  }.
  
  (*
      fn ensure_no_owner(&self, owner: &AccountId) {
          assert!(!self.is_owner.contains(owner));
      }
  *)
  Parameter ensure_no_owner :
      (ref Self) -> (ref multisig.AccountId.t) -> M unit.
  
  Global Instance AssociatedFunction_ensure_no_owner :
    Notations.DoubleColon Self "ensure_no_owner" := {
    Notations.double_colon := ensure_no_owner;
  }.
  
  (*
      pub fn add_owner(&mut self, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_no_owner(&new_owner);
          ensure_requirement_is_valid(self.owners.len() as u32 + 1, self.requirement);
          self.is_owner.insert(new_owner, ());
          self.owners.push(new_owner);
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Parameter add_owner : (mut_ref Self) -> multisig.AccountId.t -> M unit.
  
  Global Instance AssociatedFunction_add_owner :
    Notations.DoubleColon Self "add_owner" := {
    Notations.double_colon := add_owner;
  }.
  
  (*
      fn owner_index(&self, owner: &AccountId) -> u32 {
          self.owners.iter().position(|x| *x == *owner).expect(
              "This is only called after it was already verified that the id is
                 actually an owner.",
          ) as u32
      }
  *)
  Parameter owner_index : (ref Self) -> (ref multisig.AccountId.t) -> M u32.t.
  
  Global Instance AssociatedFunction_owner_index :
    Notations.DoubleColon Self "owner_index" := {
    Notations.double_colon := owner_index;
  }.
  
  (*
      fn clean_owner_confirmations(&mut self, owner: &AccountId) {
          for trans_id in &self.transaction_list.transactions {
              let key = ( *trans_id, *owner);
              if self.confirmations.contains(&key) {
                  self.confirmations.remove(key);
                  let mut count = self.confirmation_count.get(trans_id).unwrap_or(0 as u32);
                  count -= 1;
                  self.confirmation_count.insert( *trans_id, count);
              }
          }
      }
  *)
  Parameter clean_owner_confirmations :
      (mut_ref Self) -> (ref multisig.AccountId.t) -> M unit.
  
  Global Instance AssociatedFunction_clean_owner_confirmations :
    Notations.DoubleColon Self "clean_owner_confirmations" := {
    Notations.double_colon := clean_owner_confirmations;
  }.
  
  (*
      pub fn remove_owner(&mut self, owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&owner);
          let len = self.owners.len() as u32 - 1;
          let requirement = u32::min(len, self.requirement);
          ensure_requirement_is_valid(len, requirement);
          let owner_index = self.owner_index(&owner) as usize;
          self.owners.swap_remove(owner_index);
          self.is_owner.remove(owner);
          self.requirement = requirement;
          self.clean_owner_confirmations(&owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner }));
      }
  *)
  Parameter remove_owner : (mut_ref Self) -> multisig.AccountId.t -> M unit.
  
  Global Instance AssociatedFunction_remove_owner :
    Notations.DoubleColon Self "remove_owner" := {
    Notations.double_colon := remove_owner;
  }.
  
  (*
      pub fn replace_owner(&mut self, old_owner: AccountId, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&old_owner);
          self.ensure_no_owner(&new_owner);
          let owner_index = self.owner_index(&old_owner);
          self.owners[owner_index as usize] = new_owner;
          self.is_owner.remove(old_owner);
          self.is_owner.insert(new_owner, ());
          self.clean_owner_confirmations(&old_owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner: old_owner }));
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Parameter replace_owner :
      (mut_ref Self) -> multisig.AccountId.t -> multisig.AccountId.t -> M unit.
  
  Global Instance AssociatedFunction_replace_owner :
    Notations.DoubleColon Self "replace_owner" := {
    Notations.double_colon := replace_owner;
  }.
  
  (*
      pub fn change_requirement(&mut self, new_requirement: u32) {
          self.ensure_from_wallet();
          ensure_requirement_is_valid(self.owners.len() as u32, new_requirement);
          self.requirement = new_requirement;
          self.env()
              .emit_event(Event::RequirementChange(RequirementChange {
                  new_requirement,
              }));
      }
  *)
  Parameter change_requirement : (mut_ref Self) -> u32.t -> M unit.
  
  Global Instance AssociatedFunction_change_requirement :
    Notations.DoubleColon Self "change_requirement" := {
    Notations.double_colon := change_requirement;
  }.
  
  (*
      fn confirm_by_caller(
          &mut self,
          confirmer: AccountId,
          transaction: TransactionId,
      ) -> ConfirmationStatus {
          let mut count = self
              .confirmation_count
              .get(&transaction)
              .unwrap_or(0 as u32);
          let key = (transaction, confirmer);
          let new_confirmation = !self.confirmations.contains(&key);
          if new_confirmation {
              count += 1;
              self.confirmations.insert(key, ());
              self.confirmation_count.insert(transaction, count);
          }
          let status = {
              if count >= self.requirement {
                  ConfirmationStatus::Confirmed
              } else {
                  ConfirmationStatus::ConfirmationsNeeded(self.requirement - count)
              }
          };
          if new_confirmation {
              self.env().emit_event(Event::Confirmation(Confirmation {
                  transaction,
                  from: confirmer,
                  status,
              }));
          }
          status
      }
  *)
  Parameter confirm_by_caller :
      (mut_ref Self) ->
        multisig.AccountId.t ->
        ltac:(multisig.TransactionId) ->
        M multisig.ConfirmationStatus.t.
  
  Global Instance AssociatedFunction_confirm_by_caller :
    Notations.DoubleColon Self "confirm_by_caller" := {
    Notations.double_colon := confirm_by_caller;
  }.
  
  (*
      pub fn submit_transaction(
          &mut self,
          transaction: Transaction,
      ) -> (TransactionId, ConfirmationStatus) {
          self.ensure_caller_is_owner();
          let trans_id = self.transaction_list.next_id;
          self.transaction_list.next_id = trans_id
              .checked_add(1 as u32)
              .expect("Transaction ids exhausted.");
          self.transactions.insert(trans_id, transaction);
          self.transaction_list.transactions.push(trans_id);
          self.env().emit_event(Event::Submission(Submission {
              transaction: trans_id,
          }));
          (
              trans_id,
              self.confirm_by_caller(self.env().caller(), trans_id),
          )
      }
  *)
  Parameter submit_transaction :
      (mut_ref Self) ->
        multisig.Transaction.t ->
        M (ltac:(multisig.TransactionId) * multisig.ConfirmationStatus.t).
  
  Global Instance AssociatedFunction_submit_transaction :
    Notations.DoubleColon Self "submit_transaction" := {
    Notations.double_colon := submit_transaction;
  }.
  
  (*
      fn take_transaction(&mut self, trans_id: TransactionId) -> Option<Transaction> {
          let transaction = self.transactions.get(&trans_id);
          if transaction.is_some() {
              self.transactions.remove(trans_id);
              let pos = self
                  .transaction_list
                  .transactions
                  .iter()
                  .position(|t| t == &trans_id)
                  .expect("The transaction exists hence it must also be in the list.");
              self.transaction_list.transactions.swap_remove(pos);
              for owner in self.owners.iter() {
                  self.confirmations.remove((trans_id, *owner));
              }
              self.confirmation_count.remove(trans_id);
          }
          transaction
      }
  *)
  Parameter take_transaction :
      (mut_ref Self) ->
        ltac:(multisig.TransactionId) ->
        M (core.option.Option.t multisig.Transaction.t).
  
  Global Instance AssociatedFunction_take_transaction :
    Notations.DoubleColon Self "take_transaction" := {
    Notations.double_colon := take_transaction;
  }.
  
  (*
      pub fn cancel_transaction(&mut self, trans_id: TransactionId) {
          self.ensure_from_wallet();
          if self.take_transaction(trans_id).is_some() {
              self.env().emit_event(Event::Cancellation(Cancellation {
                  transaction: trans_id,
              }));
          }
      }
  *)
  Parameter cancel_transaction :
      (mut_ref Self) -> ltac:(multisig.TransactionId) -> M unit.
  
  Global Instance AssociatedFunction_cancel_transaction :
    Notations.DoubleColon Self "cancel_transaction" := {
    Notations.double_colon := cancel_transaction;
  }.
  
  (*
      pub fn confirm_transaction(&mut self, trans_id: TransactionId) -> ConfirmationStatus {
          self.ensure_caller_is_owner();
          self.ensure_transaction_exists(trans_id);
          self.confirm_by_caller(self.env().caller(), trans_id)
      }
  *)
  Parameter confirm_transaction :
      (mut_ref Self) ->
        ltac:(multisig.TransactionId) ->
        M multisig.ConfirmationStatus.t.
  
  Global Instance AssociatedFunction_confirm_transaction :
    Notations.DoubleColon Self "confirm_transaction" := {
    Notations.double_colon := confirm_transaction;
  }.
  
  (*
      pub fn revoke_confirmation(&mut self, trans_id: TransactionId) {
          self.ensure_caller_is_owner();
          let caller = self.env().caller();
          if self.confirmations.contains(&(trans_id, caller)) {
              self.confirmations.remove((trans_id, caller));
              let mut confirmation_count = self
                  .confirmation_count
                  .get(&trans_id)
                  .expect("There is a entry in `self.confirmations`. Hence a count must exit.");
              // Will not underflow as there is at least one confirmation
              confirmation_count -= 1;
              self.confirmation_count.insert(trans_id, confirmation_count);
              self.env().emit_event(Event::Revocation(Revocation {
                  transaction: trans_id,
                  from: caller,
              }));
          }
      }
  *)
  Parameter revoke_confirmation :
      (mut_ref Self) -> ltac:(multisig.TransactionId) -> M unit.
  
  Global Instance AssociatedFunction_revoke_confirmation :
    Notations.DoubleColon Self "revoke_confirmation" := {
    Notations.double_colon := revoke_confirmation;
  }.
  
  (*
      pub fn invoke_transaction(&mut self, trans_id: TransactionId) -> Result<(), Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          assert!(self.env().transferred_value() == t.transferred_value);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<()>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(_)) => Ok(()),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.map(|_| None),
          }));
          result
      }
  *)
  Parameter invoke_transaction :
      (mut_ref Self) ->
        ltac:(multisig.TransactionId) ->
        M (core.result.Result.t unit multisig.Error.t).
  
  Global Instance AssociatedFunction_invoke_transaction :
    Notations.DoubleColon Self "invoke_transaction" := {
    Notations.double_colon := invoke_transaction;
  }.
  
  (*
      pub fn eval_transaction(&mut self, trans_id: TransactionId) -> Result<Vec<u8>, Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<Vec<u8>>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(v)) => Ok(v),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.clone().map(Some),
          }));
          result
      }
  *)
  Parameter eval_transaction :
      (mut_ref Self) ->
        ltac:(multisig.TransactionId) ->
        M
          (core.result.Result.t
            (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
            multisig.Error.t).
  
  Global Instance AssociatedFunction_eval_transaction :
    Notations.DoubleColon Self "eval_transaction" := {
    Notations.double_colon := eval_transaction;
  }.
End Impl_multisig_Multisig_t.
End Impl_multisig_Multisig_t.
