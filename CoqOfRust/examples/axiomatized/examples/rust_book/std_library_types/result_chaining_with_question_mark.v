(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module checked.
  (*
  Enum MathError
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "DivisionByZero";
          item := StructTuple [];
        };
        {
          name := "NonPositiveLogarithm";
          item := StructTuple [];
        };
        {
          name := "NegativeSquareRoot";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_MathError_DivisionByZero :
    M.IsDiscriminant "result_chaining_with_question_mark::checked::MathError::DivisionByZero" 0.
  Axiom IsDiscriminant_MathError_NonPositiveLogarithm :
    M.IsDiscriminant
      "result_chaining_with_question_mark::checked::MathError::NonPositiveLogarithm"
      1.
  Axiom IsDiscriminant_MathError_NegativeSquareRoot :
    M.IsDiscriminant "result_chaining_with_question_mark::checked::MathError::NegativeSquareRoot" 2.
  
  Module Impl_core_fmt_Debug_for_result_chaining_with_question_mark_checked_MathError.
    Definition Self : Ty.t := Ty.path "result_chaining_with_question_mark::checked::MathError".
    
    Parameter fmt : (list Value.t) -> (list Ty.t) -> (list Value.t) -> M.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_result_chaining_with_question_mark_checked_MathError.
  
  Axiom MathResult :
    (Ty.path "result_chaining_with_question_mark::checked::MathResult") =
      (Ty.apply
        (Ty.path "core::result::Result")
        []
        [ Ty.path "f64"; Ty.path "result_chaining_with_question_mark::checked::MathError" ]).
  
  Parameter div : (list Value.t) -> (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_div : M.IsFunction "result_chaining_with_question_mark::checked::div" div.
  Smpl Add apply Function_div : is_function.
  
  Parameter sqrt : (list Value.t) -> (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_sqrt : M.IsFunction "result_chaining_with_question_mark::checked::sqrt" sqrt.
  Smpl Add apply Function_sqrt : is_function.
  
  Parameter ln : (list Value.t) -> (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_ln : M.IsFunction "result_chaining_with_question_mark::checked::ln" ln.
  Smpl Add apply Function_ln : is_function.
  
  Parameter op_ : (list Value.t) -> (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_op_ : M.IsFunction "result_chaining_with_question_mark::checked::op_" op_.
  Smpl Add apply Function_op_ : is_function.
  
  Parameter op : (list Value.t) -> (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_op : M.IsFunction "result_chaining_with_question_mark::checked::op" op.
  Smpl Add apply Function_op : is_function.
End checked.

Parameter main : (list Value.t) -> (list Ty.t) -> (list Value.t) -> M.

Axiom Function_main : M.IsFunction "result_chaining_with_question_mark::main" main.
Smpl Add apply Function_main : is_function.
