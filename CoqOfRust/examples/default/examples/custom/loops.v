(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
pub fn sum_checked(xs: &[u32]) -> Option<u32> {
    let mut acc: u32 = 0;
    let mut i: usize = 0;
    // Invariant idea (Coq):
    //  - 0 <= i <= xs.len()
    //  - acc = sum(xs[0..i]) and never overflowed
    while i < xs.len() {
        match acc.checked_add(xs[i]) {
            Some(v) => acc = v,
            None => return None,
        }
        i += 1;
    }
    Some(acc)
}
*)
Definition sum_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ xs ] =>
    ltac:(M.monadic
      (let xs :=
        M.alloc (|
          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u32" ] ],
          xs
        |) in
      M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ]) (|
        ltac:(M.monadic
          (M.read (|
            let~ acc : Ty.path "u32" := Value.Integer IntegerKind.U32 0 in
            let~ i : Ty.path "usize" := Value.Integer IntegerKind.Usize 0 in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.loop (|
                  Ty.tuple [],
                  ltac:(M.monadic
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.lt,
                                      [
                                        M.read (| i |);
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u32" ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| xs |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.read (|
                                let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "u32" ],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u32" ],
                                        M.get_associated_function (|
                                          Ty.path "u32",
                                          "checked_add",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| acc |);
                                          M.read (|
                                            M.SubPointer.get_array_field (|
                                              M.deref (| M.read (| xs |) |),
                                              M.read (| i |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let v := M.copy (| Ty.path "u32", γ0_0 |) in
                                          M.write (| acc, M.read (| v |) |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::option::Option::None"
                                                  []
                                                  [ Ty.path "u32" ]
                                                  []
                                              |)
                                            |)
                                          |)))
                                    ]
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  let β := i in
                                  M.write (|
                                    β,
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.add,
                                      [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                    |)
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.tuple [] :=
                                    M.never_to_any (| M.read (| M.break (||) |) |) in
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                |)
                              |)))
                        ]
                      |)
                    |)))
                |)
              |) in
            M.alloc (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
              Value.StructTuple
                "core::option::Option::Some"
                []
                [ Ty.path "u32" ]
                [ M.read (| acc |) ]
            |)
          |)))
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_sum_checked : M.IsFunction.C "loops::sum_checked" sum_checked.
Admitted.
Global Typeclasses Opaque sum_checked.

(*
pub fn reverse_in_place(xs: &mut [i32]) {
  if xs.len() == 0 { return; }
  let mut l: usize = 0;
  let mut r: usize = xs.len() - 1;
  // Invariant idea:
  //  - xs[0..l] and xs[r+1..] are already reversed wrt original
  //  - l <= r + 1
  while l < r {
      let tmp = xs[l];
      xs[l] = xs[r];
      xs[r] = tmp;
      l += 1;
      r -= 1;
  }
}
*)
Definition reverse_in_place (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ xs ] =>
    ltac:(M.monadic
      (let xs :=
        M.alloc (|
          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "i32" ] ],
          xs
        |) in
      M.catch_return (Ty.tuple []) (|
        ltac:(M.monadic
          (M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "i32" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| xs |) |) |) ]
                                |);
                                Value.Integer IntegerKind.Usize 0
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |) in
            let~ l : Ty.path "usize" := Value.Integer IntegerKind.Usize 0 in
            let~ r : Ty.path "usize" :=
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.sub,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "i32" ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| xs |) |) |) ]
                  |);
                  Value.Integer IntegerKind.Usize 1
                ]
              |) in
            M.loop (|
              Ty.tuple [],
              ltac:(M.monadic
                (M.alloc (|
                  Ty.tuple [],
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| l |); M.read (| r |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.read (|
                            let~ tmp : Ty.path "i32" :=
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| xs |) |),
                                  M.read (| l |)
                                |)
                              |) in
                            let~ _ : Ty.tuple [] :=
                              M.write (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| xs |) |),
                                  M.read (| l |)
                                |),
                                M.read (|
                                  M.SubPointer.get_array_field (|
                                    M.deref (| M.read (| xs |) |),
                                    M.read (| r |)
                                  |)
                                |)
                              |) in
                            let~ _ : Ty.tuple [] :=
                              M.write (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| xs |) |),
                                  M.read (| r |)
                                |),
                                M.read (| tmp |)
                              |) in
                            let~ _ : Ty.tuple [] :=
                              let β := l in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.add,
                                  [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                |)
                              |) in
                            let~ _ : Ty.tuple [] :=
                              let β := r in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.sub,
                                  [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                |)
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.never_to_any (|
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.never_to_any (| M.read (| M.break (||) |) |) in
                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                            |)
                          |)))
                    ]
                  |)
                |)))
            |)
          |)))
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_reverse_in_place :
  M.IsFunction.C "loops::reverse_in_place" reverse_in_place.
Admitted.
Global Typeclasses Opaque reverse_in_place.

(*
pub fn is_sorted(xs: &[i32]) -> bool {
  let mut i: usize = 1;
  // Invariant idea:
  //  - prefix xs[0..i] is sorted (pairwise non-decreasing)
  while i < xs.len() {
      if xs[i - 1] > xs[i] { return false; }
      i += 1;
  }
  true
}
*)
Definition is_sorted (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ xs ] =>
    ltac:(M.monadic
      (let xs :=
        M.alloc (|
          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "i32" ] ],
          xs
        |) in
      M.catch_return (Ty.path "bool") (|
        ltac:(M.monadic
          (M.read (|
            let~ i : Ty.path "usize" := Value.Integer IntegerKind.Usize 1 in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.loop (|
                  Ty.tuple [],
                  ltac:(M.monadic
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.lt,
                                      [
                                        M.read (| i |);
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "i32" ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| xs |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.read (|
                                let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                Ty.path "bool",
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.gt,
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_array_field (|
                                                        M.deref (| M.read (| xs |) |),
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          BinOp.Wrap.sub,
                                                          [
                                                            M.read (| i |);
                                                            Value.Integer IntegerKind.Usize 1
                                                          ]
                                                        |)
                                                      |)
                                                    |);
                                                    M.read (|
                                                      M.SubPointer.get_array_field (|
                                                        M.deref (| M.read (| xs |) |),
                                                        M.read (| i |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.never_to_any (|
                                            M.read (| M.return_ (| Value.Bool false |) |)
                                          |)));
                                      fun γ => ltac:(M.monadic (Value.Tuple []))
                                    ]
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  let β := i in
                                  M.write (|
                                    β,
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.add,
                                      [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                    |)
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.tuple [] :=
                                    M.never_to_any (| M.read (| M.break (||) |) |) in
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                |)
                              |)))
                        ]
                      |)
                    |)))
                |)
              |) in
            M.alloc (| Ty.path "bool", Value.Bool true |)
          |)))
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_is_sorted : M.IsFunction.C "loops::is_sorted" is_sorted.
Admitted.
Global Typeclasses Opaque is_sorted.

(*
pub fn max_array<const N: usize>(a: &[i32; N]) -> i32 {
  let mut m = a[0];
  let mut i: usize = 1;
  // Invariant idea:
  //  - m = max(a[0..i])
  while i < N {
      if a[i] > m { m = a[i]; }
      i += 1;
  }
  m
}
*)
Definition max_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [ N ], [], [ a ] =>
    ltac:(M.monadic
      (let a :=
        M.alloc (|
          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "i32" ] ],
          a
        |) in
      M.read (|
        let~ m : Ty.path "i32" :=
          M.read (|
            M.SubPointer.get_array_field (|
              M.deref (| M.read (| a |) |),
              Value.Integer IntegerKind.Usize 0
            |)
          |) in
        let~ i : Ty.path "usize" := Value.Integer IntegerKind.Usize 1 in
        let~ _ : Ty.tuple [] :=
          M.read (|
            M.loop (|
              Ty.tuple [],
              ltac:(M.monadic
                (M.alloc (|
                  Ty.tuple [],
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (| Ty.path "bool", BinOp.lt, [ M.read (| i |); N ] |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.read (|
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            Ty.path "bool",
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.gt,
                                              [
                                                M.read (|
                                                  M.SubPointer.get_array_field (|
                                                    M.deref (| M.read (| a |) |),
                                                    M.read (| i |)
                                                  |)
                                                |);
                                                M.read (| m |)
                                              ]
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.read (|
                                        let~ _ : Ty.tuple [] :=
                                          M.write (|
                                            m,
                                            M.read (|
                                              M.SubPointer.get_array_field (|
                                                M.deref (| M.read (| a |) |),
                                                M.read (| i |)
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                      |)));
                                  fun γ => ltac:(M.monadic (Value.Tuple []))
                                ]
                              |) in
                            let~ _ : Ty.tuple [] :=
                              let β := i in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.add,
                                  [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                |)
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.never_to_any (|
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.never_to_any (| M.read (| M.break (||) |) |) in
                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                            |)
                          |)))
                    ]
                  |)
                |)))
            |)
          |) in
        m
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_max_array : M.IsFunction.C "loops::max_array" max_array.
Admitted.
Global Typeclasses Opaque max_array.
