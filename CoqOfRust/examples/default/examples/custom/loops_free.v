(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
pub fn max2(a: u32, b: u32) -> u32 {
    if a < b { b } else { a }
}
*)
Definition max2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ a; b ] =>
    ltac:(M.monadic
      (let a := M.alloc (| Ty.path "u32", a |) in
      let b := M.alloc (| Ty.path "u32", b |) in
      M.match_operator (|
        Ty.path "u32",
        M.alloc (| Ty.tuple [], Value.Tuple [] |),
        [
          fun γ =>
            ltac:(M.monadic
              (let γ :=
                M.use
                  (M.alloc (|
                    Ty.path "bool",
                    M.call_closure (|
                      Ty.path "bool",
                      BinOp.lt,
                      [ M.read (| a |); M.read (| b |) ]
                    |)
                  |)) in
              let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
              M.read (| b |)));
          fun γ => ltac:(M.monadic (M.read (| a |)))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_max2 : M.IsFunction.C "loops_free::max2" max2.
Admitted.
Global Typeclasses Opaque max2.

(*
pub fn abs_i32(x: i32) -> i32 {
  if x < 0 { -x } else { x }
}
*)
Definition abs_i32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ x ] =>
    ltac:(M.monadic
      (let x := M.alloc (| Ty.path "i32", x |) in
      M.match_operator (|
        Ty.path "i32",
        M.alloc (| Ty.tuple [], Value.Tuple [] |),
        [
          fun γ =>
            ltac:(M.monadic
              (let γ :=
                M.use
                  (M.alloc (|
                    Ty.path "bool",
                    M.call_closure (|
                      Ty.path "bool",
                      BinOp.lt,
                      [ M.read (| x |); Value.Integer IntegerKind.I32 0 ]
                    |)
                  |)) in
              let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
              UnOp.neg (| M.read (| x |) |)));
          fun γ => ltac:(M.monadic (M.read (| x |)))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_abs_i32 : M.IsFunction.C "loops_free::abs_i32" abs_i32.
Admitted.
Global Typeclasses Opaque abs_i32.

(*
pub fn bool_and(a: bool, b: bool) -> bool {
  if a {
      if b { true } else { false }
  } else {
      false
  }
}
*)
Definition bool_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ a; b ] =>
    ltac:(M.monadic
      (let a := M.alloc (| Ty.path "bool", a |) in
      let b := M.alloc (| Ty.path "bool", b |) in
      M.match_operator (|
        Ty.path "bool",
        M.alloc (| Ty.tuple [], Value.Tuple [] |),
        [
          fun γ =>
            ltac:(M.monadic
              (let γ := M.use a in
              let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
              M.match_operator (|
                Ty.path "bool",
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use b in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      Value.Bool true));
                  fun γ => ltac:(M.monadic (Value.Bool false))
                ]
              |)));
          fun γ => ltac:(M.monadic (Value.Bool false))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_bool_and : M.IsFunction.C "loops_free::bool_and" bool_and.
Admitted.
Global Typeclasses Opaque bool_and.

(*
pub fn get_or_zero(xs: &[u32; 4], i: usize) -> u32 {
  if i < 4 { xs[i] } else { 0 }
}
*)
Definition get_or_zero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ xs; i ] =>
    ltac:(M.monadic
      (let xs :=
        M.alloc (|
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ Ty.path "u32" ] ],
          xs
        |) in
      let i := M.alloc (| Ty.path "usize", i |) in
      M.match_operator (|
        Ty.path "u32",
        M.alloc (| Ty.tuple [], Value.Tuple [] |),
        [
          fun γ =>
            ltac:(M.monadic
              (let γ :=
                M.use
                  (M.alloc (|
                    Ty.path "bool",
                    M.call_closure (|
                      Ty.path "bool",
                      BinOp.lt,
                      [ M.read (| i |); Value.Integer IntegerKind.Usize 4 ]
                    |)
                  |)) in
              let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
              M.read (|
                M.SubPointer.get_array_field (| M.deref (| M.read (| xs |) |), M.read (| i |) |)
              |)));
          fun γ => ltac:(M.monadic (Value.Integer IntegerKind.U32 0))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_get_or_zero :
  M.IsFunction.C "loops_free::get_or_zero" get_or_zero.
Admitted.
Global Typeclasses Opaque get_or_zero.

(*
pub fn eq2(a: &[u32; 2], b: &[u32; 2]) -> bool {
  if a[0] == b[0] && a[1] == b[1] {
      true
  } else {
      false
  }
}
*)
Definition eq2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ a; b ] =>
    ltac:(M.monadic
      (let a :=
        M.alloc (|
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ Ty.path "u32" ] ],
          a
        |) in
      let b :=
        M.alloc (|
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ Ty.path "u32" ] ],
          b
        |) in
      M.match_operator (|
        Ty.path "bool",
        M.alloc (| Ty.tuple [], Value.Tuple [] |),
        [
          fun γ =>
            ltac:(M.monadic
              (let γ :=
                M.use
                  (M.alloc (|
                    Ty.path "bool",
                    LogicalOp.and (|
                      M.call_closure (|
                        Ty.path "bool",
                        BinOp.eq,
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              M.deref (| M.read (| a |) |),
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              M.deref (| M.read (| b |) |),
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |)
                        ]
                      |),
                      ltac:(M.monadic
                        (M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (|
                              M.SubPointer.get_array_field (|
                                M.deref (| M.read (| a |) |),
                                Value.Integer IntegerKind.Usize 1
                              |)
                            |);
                            M.read (|
                              M.SubPointer.get_array_field (|
                                M.deref (| M.read (| b |) |),
                                Value.Integer IntegerKind.Usize 1
                              |)
                            |)
                          ]
                        |)))
                    |)
                  |)) in
              let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
              Value.Bool true));
          fun γ => ltac:(M.monadic (Value.Bool false))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_eq2 : M.IsFunction.C "loops_free::eq2" eq2.
Admitted.
Global Typeclasses Opaque eq2.

(*
pub fn eq_pair(x: (u32, u32), y: (u32, u32)) -> bool {
  if x.0 == y.0 && x.1 == y.1 { true } else { false }
}
*)
Definition eq_pair (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ x; y ] =>
    ltac:(M.monadic
      (let x := M.alloc (| Ty.tuple [ Ty.path "u32"; Ty.path "u32" ], x |) in
      let y := M.alloc (| Ty.tuple [ Ty.path "u32"; Ty.path "u32" ], y |) in
      M.match_operator (|
        Ty.path "bool",
        M.alloc (| Ty.tuple [], Value.Tuple [] |),
        [
          fun γ =>
            ltac:(M.monadic
              (let γ :=
                M.use
                  (M.alloc (|
                    Ty.path "bool",
                    LogicalOp.and (|
                      M.call_closure (|
                        Ty.path "bool",
                        BinOp.eq,
                        [
                          M.read (| M.SubPointer.get_tuple_field (| x, 0 |) |);
                          M.read (| M.SubPointer.get_tuple_field (| y, 0 |) |)
                        ]
                      |),
                      ltac:(M.monadic
                        (M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (| M.SubPointer.get_tuple_field (| x, 1 |) |);
                            M.read (| M.SubPointer.get_tuple_field (| y, 1 |) |)
                          ]
                        |)))
                    |)
                  |)) in
              let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
              Value.Bool true));
          fun γ => ltac:(M.monadic (Value.Bool false))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_eq_pair : M.IsFunction.C "loops_free::eq_pair" eq_pair.
Admitted.
Global Typeclasses Opaque eq_pair.

(*
pub fn min3(a: u32, b: u32, c: u32) -> u32 {
  let m = if a < b { a } else { b };
  if m < c { m } else { c }
}
*)
Definition min3 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ a; b; c ] =>
    ltac:(M.monadic
      (let a := M.alloc (| Ty.path "u32", a |) in
      let b := M.alloc (| Ty.path "u32", b |) in
      let c := M.alloc (| Ty.path "u32", c |) in
      M.read (|
        let~ m : Ty.path "u32" :=
          M.match_operator (|
            Ty.path "u32",
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.lt,
                          [ M.read (| a |); M.read (| b |) ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.read (| a |)));
              fun γ => ltac:(M.monadic (M.read (| b |)))
            ]
          |) in
        M.alloc (|
          Ty.path "u32",
          M.match_operator (|
            Ty.path "u32",
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.lt,
                          [ M.read (| m |); M.read (| c |) ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.read (| m |)));
              fun γ => ltac:(M.monadic (M.read (| c |)))
            ]
          |)
        |)
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_min3 : M.IsFunction.C "loops_free::min3" min3.
Admitted.
Global Typeclasses Opaque min3.
