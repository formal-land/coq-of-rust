(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn get_at_index(vector: Vec<i32>, index: usize) -> Option<i32> {
    if index < vector.len() {
        return Some(vector[index]);
    }

    None
}
*)
Definition get_at_index (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [], [ vector; index ] =>
    let* vector := M.alloc vector in
    let* index := M.alloc index in
    let* _ :=
      let* Î±0 := M.read index in
      let* Î±1 :=
        M.get_associated_function
          (Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ])
          "len"
          [] in
      let* Î±2 := M.call_closure Î±1 [ vector ] in
      let* Î±3 := M.alloc (BinOp.Pure.lt Î±0 Î±2) in
      let* Î±4 := M.read (M.use Î±3) in
      if Value.is_true Î±4 then
        let* Î±0 :=
          M.get_trait_method
            "core::ops::index::Index"
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ])
            [ Ty.path "usize" ]
            "index"
            [] in
        let* Î±1 := M.read index in
        let* Î±2 := M.call_closure Î±0 [ vector; Î±1 ] in
        let* Î±3 := M.read Î±2 in
        let* Î±4 :=
          M.return_ (Value.StructTuple "core::option::Option::Some" [ Î±3 ]) in
        let* Î±5 := M.read Î±4 in
        let* Î±6 := M.never_to_any Î±5 in
        M.alloc Î±6
      else
        M.alloc (Value.Tuple []) in
    let* Î±0 := M.alloc (Value.StructTuple "core::option::Option::None" []) in
    M.read Î±0
  | _, _ => M.impossible
  end.

(* StructRecord
  {
    name := "Bank";
    ty_params := [];
    fields :=
      [
        ("accounts",
          Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
      ];
  } *)

Module Impl_micro_bank_Bank.
  Definition Self : Ty.t := Ty.path "micro_bank::Bank".
  
  (*
      fn transfer(&mut self, from: usize, to: usize, amount: u32) {
          if from >= self.accounts.len() || to >= self.accounts.len() {
              return;
          }
  
          if self.accounts[from] < amount {
              return;
          }
  
          self.accounts[from] -= amount;
          self.accounts[to] += amount;
      }
  *)
  Definition transfer (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self; from; to; amount ] =>
      let* self := M.alloc self in
      let* from := M.alloc from in
      let* to := M.alloc to in
      let* amount := M.alloc amount in
      let* _ :=
        let* Î±0 := M.read from in
        let* Î±1 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
            "len"
            [] in
        let* Î±2 := M.read self in
        let* Î±3 :=
          M.call_closure
            Î±1
            [ M.get_struct_record_field Î±2 "micro_bank::Bank" "accounts" ] in
        let* Î±4 :=
          LogicalOp.or
            (BinOp.Pure.ge Î±0 Î±3)
            (let* Î±0 := M.read to in
            let* Î±1 :=
              M.get_associated_function
                (Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
                "len"
                [] in
            let* Î±2 := M.read self in
            let* Î±3 :=
              M.call_closure
                Î±1
                [ M.get_struct_record_field Î±2 "micro_bank::Bank" "accounts"
                ] in
            M.pure (BinOp.Pure.ge Î±0 Î±3)) in
        let* Î±5 := M.alloc Î±4 in
        let* Î±6 := M.read (M.use Î±5) in
        if Value.is_true Î±6 then
          let* Î±0 := M.return_ (Value.Tuple []) in
          let* Î±1 := M.read Î±0 in
          let* Î±2 := M.never_to_any Î±1 in
          M.alloc Î±2
        else
          M.alloc (Value.Tuple []) in
      let* _ :=
        let* Î±0 :=
          M.get_trait_method
            "core::ops::index::Index"
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
            [ Ty.path "usize" ]
            "index"
            [] in
        let* Î±1 := M.read self in
        let* Î±2 := M.read from in
        let* Î±3 :=
          M.call_closure
            Î±0
            [ M.get_struct_record_field Î±1 "micro_bank::Bank" "accounts"; Î±2
            ] in
        let* Î±4 := M.read Î±3 in
        let* Î±5 := M.read amount in
        let* Î±6 := M.alloc (BinOp.Pure.lt Î±4 Î±5) in
        let* Î±7 := M.read (M.use Î±6) in
        if Value.is_true Î±7 then
          let* Î±0 := M.return_ (Value.Tuple []) in
          let* Î±1 := M.read Î±0 in
          let* Î±2 := M.never_to_any Î±1 in
          M.alloc Î±2
        else
          M.alloc (Value.Tuple []) in
      let* _ :=
        let* Î² :=
          let* Î±0 :=
            M.get_trait_method
              "core::ops::index::IndexMut"
              (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
              [ Ty.path "usize" ]
              "index_mut"
              [] in
          let* Î±1 := M.read self in
          let* Î±2 := M.read from in
          M.call_closure
            Î±0
            [ M.get_struct_record_field Î±1 "micro_bank::Bank" "accounts"; Î±2
            ] in
        let* Î±0 := M.read Î² in
        let* Î±1 := M.read amount in
        let* Î±2 := BinOp.Panic.sub Î±0 Î±1 in
        M.assign Î² Î±2 in
      let* _ :=
        let* Î² :=
          let* Î±0 :=
            M.get_trait_method
              "core::ops::index::IndexMut"
              (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
              [ Ty.path "usize" ]
              "index_mut"
              [] in
          let* Î±1 := M.read self in
          let* Î±2 := M.read to in
          M.call_closure
            Î±0
            [ M.get_struct_record_field Î±1 "micro_bank::Bank" "accounts"; Î±2
            ] in
        let* Î±0 := M.read Î² in
        let* Î±1 := M.read amount in
        let* Î±2 := BinOp.Panic.add Î±0 Î±1 in
        M.assign Î² Î±2 in
      let* Î±0 := M.alloc (Value.Tuple []) in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_transfer :
    M.IsAssociatedFunction Self "transfer" transfer.
End Impl_micro_bank_Bank.
