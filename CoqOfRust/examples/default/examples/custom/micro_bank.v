(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn get_at_index(vector: Vec<i32>, index: usize) -> Option<i32> {
    if index < vector.len() {
        return Some(vector[index]);
    }

    None
}
*)
Definition get_at_index (𝜏 : list Ty.t) (α : list Value.t) : M :=
  match 𝜏, α with
  | [], [ vector; index ] =>
    let* vector := M.alloc vector in
    let* index := M.alloc index in
    let* _ :=
      let* α0 := M.read index in
      let* α1 :=
        M.get_associated_function
          (Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ])
          "len"
          [] in
      let* α2 := M.call_closure α1 [ vector ] in
      let* α3 := M.alloc (BinOp.Pure.lt α0 α2) in
      let* α4 := M.read (M.use α3) in
      if Value.is_true α4 then
        let* α0 :=
          M.get_trait_method
            "core::ops::index::Index"
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ])
            [ Ty.path "usize" ]
            "index"
            [] in
        let* α1 := M.read index in
        let* α2 := M.call_closure α0 [ vector; α1 ] in
        let* α3 := M.read α2 in
        let* α4 :=
          M.return_ (Value.StructTuple "core::option::Option::Some" [ α3 ]) in
        let* α5 := M.read α4 in
        let* α6 := M.never_to_any α5 in
        M.alloc α6
      else
        M.alloc (Value.Tuple []) in
    let* α0 := M.alloc (Value.StructTuple "core::option::Option::None" []) in
    M.read α0
  | _, _ => M.impossible
  end.

(* StructRecord
  {
    name := "Bank";
    ty_params := [];
    fields :=
      [
        ("accounts",
          Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
      ];
  } *)

Module Impl_micro_bank_Bank.
  Definition Self : Ty.t := Ty.path "micro_bank::Bank".
  
  (*
      fn transfer(&mut self, from: usize, to: usize, amount: u32) {
          if from >= self.accounts.len() || to >= self.accounts.len() {
              return;
          }
  
          if self.accounts[from] < amount {
              return;
          }
  
          self.accounts[from] -= amount;
          self.accounts[to] += amount;
      }
  *)
  Definition transfer (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [ self; from; to; amount ] =>
      let* self := M.alloc self in
      let* from := M.alloc from in
      let* to := M.alloc to in
      let* amount := M.alloc amount in
      let* _ :=
        let* α0 := M.read from in
        let* α1 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
            "len"
            [] in
        let* α2 := M.read self in
        let* α3 :=
          M.call_closure
            α1
            [ M.get_struct_record_field α2 "micro_bank::Bank" "accounts" ] in
        let* α4 :=
          LogicalOp.or
            (BinOp.Pure.ge α0 α3)
            (let* α0 := M.read to in
            let* α1 :=
              M.get_associated_function
                (Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
                "len"
                [] in
            let* α2 := M.read self in
            let* α3 :=
              M.call_closure
                α1
                [ M.get_struct_record_field α2 "micro_bank::Bank" "accounts"
                ] in
            M.pure (BinOp.Pure.ge α0 α3)) in
        let* α5 := M.alloc α4 in
        let* α6 := M.read (M.use α5) in
        if Value.is_true α6 then
          let* α0 := M.return_ (Value.Tuple []) in
          let* α1 := M.read α0 in
          let* α2 := M.never_to_any α1 in
          M.alloc α2
        else
          M.alloc (Value.Tuple []) in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "core::ops::index::Index"
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
            [ Ty.path "usize" ]
            "index"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read from in
        let* α3 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "micro_bank::Bank" "accounts"; α2
            ] in
        let* α4 := M.read α3 in
        let* α5 := M.read amount in
        let* α6 := M.alloc (BinOp.Pure.lt α4 α5) in
        let* α7 := M.read (M.use α6) in
        if Value.is_true α7 then
          let* α0 := M.return_ (Value.Tuple []) in
          let* α1 := M.read α0 in
          let* α2 := M.never_to_any α1 in
          M.alloc α2
        else
          M.alloc (Value.Tuple []) in
      let* _ :=
        let* β :=
          let* α0 :=
            M.get_trait_method
              "core::ops::index::IndexMut"
              (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
              [ Ty.path "usize" ]
              "index_mut"
              [] in
          let* α1 := M.read self in
          let* α2 := M.read from in
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "micro_bank::Bank" "accounts"; α2
            ] in
        let* α0 := M.read β in
        let* α1 := M.read amount in
        let* α2 := BinOp.Panic.sub α0 α1 in
        M.assign β α2 in
      let* _ :=
        let* β :=
          let* α0 :=
            M.get_trait_method
              "core::ops::index::IndexMut"
              (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])
              [ Ty.path "usize" ]
              "index_mut"
              [] in
          let* α1 := M.read self in
          let* α2 := M.read to in
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "micro_bank::Bank" "accounts"; α2
            ] in
        let* α0 := M.read β in
        let* α1 := M.read amount in
        let* α2 := BinOp.Panic.add α0 α1 in
        M.assign β α2 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_transfer :
    M.IsAssociatedFunction Self "transfer" transfer.
End Impl_micro_bank_Bank.
