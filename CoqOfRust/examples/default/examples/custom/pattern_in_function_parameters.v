(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn sum((x, y): (i32, i32)) -> i32 {
    x + y
}
*)
Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
  match τ, α with
  | [], [ β0 ] =>
    let* β0 := M.alloc β0 in
    M.match_operator
      β0
      [
        fun γ =>
          let γ0_0 := M.get_tuple_field γ 0 in
          let γ0_1 := M.get_tuple_field γ 1 in
          let* x := M.copy γ0_0 in
          let* y := M.copy γ0_1 in
          let* α0 := M.read x in
          let* α1 := M.read y in
          BinOp.Panic.add α0 α1
      ]
  | _, _ => M.impossible
  end.

(*
fn steps_between(&start: &char, &end: &char) -> Option<usize> {
    let start = start as u32;
    let end = end as u32;
    if start <= end {
        let count = end - start;
        if start < 0xD800 && 0xE000 <= end {
            usize::try_from(count - 0x800).ok()
        } else {
            usize::try_from(count).ok()
        }
    } else {
        None
    }
}
*)
Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
  match τ, α with
  | [], [ β0; β1 ] =>
    let* β0 := M.alloc β0 in
    let* β1 := M.alloc β1 in
    M.match_operator
      β0
      [
        fun γ =>
          let* γ := M.read γ in
          let* start := M.copy γ in
          M.match_operator
            β1
            [
              fun γ =>
                let* γ := M.read γ in
                let* end_ := M.copy γ in
                let* start :=
                  let* α0 := M.read start in
                  M.alloc (M.rust_cast α0) in
                let* end_ :=
                  let* α0 := M.read end_ in
                  M.alloc (M.rust_cast α0) in
                let* α0 := M.alloc (Value.Tuple []) in
                let* α0 :=
                  M.match_operator
                    α0
                    [
                      fun γ =>
                        let* γ :=
                          let* α0 := M.read start in
                          let* α1 := M.read end_ in
                          let* α2 := M.alloc (BinOp.Pure.le α0 α1) in
                          M.pure (M.use α2) in
                        let* _ :=
                          let* α0 := M.read γ in
                          M.is_constant_or_break_match α0 (Value.Bool true) in
                        let* count :=
                          let* α0 := M.read end_ in
                          let* α1 := M.read start in
                          let* α2 := BinOp.Panic.sub α0 α1 in
                          M.alloc α2 in
                        let* α0 := M.alloc (Value.Tuple []) in
                        M.match_operator
                          α0
                          [
                            fun γ =>
                              let* γ :=
                                let* α0 := M.read start in
                                let* α1 :=
                                  LogicalOp.and
                                    (BinOp.Pure.lt α0 (Value.Integer Integer.U32 55296))
                                    (let* α0 := M.read end_ in
                                    M.pure (BinOp.Pure.le (Value.Integer Integer.U32 57344) α0)) in
                                let* α2 := M.alloc α1 in
                                M.pure (M.use α2) in
                              let* _ :=
                                let* α0 := M.read γ in
                                M.is_constant_or_break_match α0 (Value.Bool true) in
                              let* α0 :=
                                M.get_associated_function
                                  (Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ]
                                    [])
                                  "ok"
                                  []
                                  [] in
                              let* α1 :=
                                M.get_trait_method
                                  "core::convert::TryFrom"
                                  (Ty.path "usize")
                                  [ Ty.path "u32" ]
                                  []
                                  "try_from"
                                  []
                                  [] in
                              let* α2 := M.read count in
                              let* α3 := BinOp.Panic.sub α2 (Value.Integer Integer.U32 2048) in
                              let* α4 := M.call_closure α1 [ α3 ] in
                              let* α5 := M.call_closure α0 [ α4 ] in
                              M.alloc α5;
                            fun γ =>
                              let* α0 :=
                                M.get_associated_function
                                  (Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ]
                                    [])
                                  "ok"
                                  []
                                  [] in
                              let* α1 :=
                                M.get_trait_method
                                  "core::convert::TryFrom"
                                  (Ty.path "usize")
                                  [ Ty.path "u32" ]
                                  []
                                  "try_from"
                                  []
                                  [] in
                              let* α2 := M.read count in
                              let* α3 := M.call_closure α1 [ α2 ] in
                              let* α4 := M.call_closure α0 [ α3 ] in
                              M.alloc α4
                          ];
                      fun γ => M.alloc (Value.StructTuple "core::option::Option::None" [])
                    ] in
                M.read α0
            ]
      ]
  | _, _ => M.impossible
  end.
