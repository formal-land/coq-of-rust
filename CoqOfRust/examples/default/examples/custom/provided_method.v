(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  ProvidedAndRequired.
Section ProvidedAndRequired.
  Class Trait (Self : Set) : Type := {
    required : (ref Self) -> M i32.t;
  }.
  
End ProvidedAndRequired.
End ProvidedAndRequired.

Module  Impl_provided_method_ProvidedAndRequired_for_i32_t.
Section Impl_provided_method_ProvidedAndRequired_for_i32_t.
  Definition Self : Set := i32.t.
  
  (*
      fn required(&self) -> i32 {
          *self
      }
  *)
  Definition required (self : ref Self) : M i32.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      M.read (| deref (M.read (| self |)) |)
    )).
  
  Global Instance AssociatedFunction_required :
    Notations.DoubleColon Self "required" := {
    Notations.double_colon := required;
  }.
  
  Global Instance ℐ :
    provided_method.ProvidedAndRequired.Required.Trait Self := {
    provided_method.ProvidedAndRequired.required := required;
    provided_method.ProvidedAndRequired.provided := Datatypes.None;
  }.
End Impl_provided_method_ProvidedAndRequired_for_i32_t.
End Impl_provided_method_ProvidedAndRequired_for_i32_t.

Module  Impl_provided_method_ProvidedAndRequired_for_u32_t.
Section Impl_provided_method_ProvidedAndRequired_for_u32_t.
  Definition Self : Set := u32.t.
  
  (*
      fn required(&self) -> i32 {
          *self as i32
      }
  *)
  Definition required (self : ref Self) : M i32.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      rust_cast (M.read (| deref (M.read (| self |)) |))
    )).
  
  Global Instance AssociatedFunction_required :
    Notations.DoubleColon Self "required" := {
    Notations.double_colon := required;
  }.
  
  (*
      fn provided(&self) -> i32 {
          0
      }
  *)
  Definition provided (self : ref Self) : M i32.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      (Integer.of_Z 0) : i32.t
    )).
  
  Global Instance AssociatedFunction_provided :
    Notations.DoubleColon Self "provided" := {
    Notations.double_colon := provided;
  }.
  
  Global Instance ℐ :
    provided_method.ProvidedAndRequired.Required.Trait Self := {
    provided_method.ProvidedAndRequired.required := required;
    provided_method.ProvidedAndRequired.provided := Datatypes.Some provided;
  }.
End Impl_provided_method_ProvidedAndRequired_for_u32_t.
End Impl_provided_method_ProvidedAndRequired_for_u32_t.

(*
fn main() {
    let x = 5;
    assert_eq!(x.provided(), 47);
    let y = 5u32;
    assert_eq!(y.provided(), 0);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic (
    M.read (|
      let x : M.Val i32.t := M.alloc (| (Integer.of_Z 5) : i32.t |) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        provided_method.ProvidedAndRequired.provided
                          (Self := i32.t)
                          (Trait := ℐ)))
                      (borrow x))
                    |)
                  |)),
                borrow (M.alloc (| (Integer.of_Z 47) : i32.t |)))
            |))
            [
              fun (γ : M.Val ((ref i32.t) * (ref i32.t))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (BinOp.Pure.eq
                              (M.read (| deref (M.read (| left_val |)) |))
                              (M.read (| deref (M.read (| right_val |)) |)))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      let y : M.Val u32.t := M.alloc (| (Integer.of_Z 5) : u32.t |) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        provided_method.ProvidedAndRequired.provided
                          (Self := u32.t)
                          (Trait := ℐ)))
                      (borrow y))
                    |)
                  |)),
                borrow (M.alloc (| (Integer.of_Z 0) : i32.t |)))
            |))
            [
              fun (γ : M.Val ((ref i32.t) * (ref i32.t))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (BinOp.Pure.eq
                              (M.read (| deref (M.read (| left_val |)) |))
                              (M.read (| deref (M.read (| right_val |)) |)))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      M.alloc (| tt |)
    |)
  )).
