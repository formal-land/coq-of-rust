(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* StructRecord
  {
    name := "Account";
    ty_params := [];
    fields := [ ("id", Ty.path "i32"); ("balance", Ty.path "u32") ];
  } *)

(* StructRecord
  {
    name := "Bank";
    ty_params := [];
    fields :=
      [
        ("accounts",
          Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "small_bank::Account"; Ty.path "alloc::alloc::Global" ])
      ];
  } *)

Module Impl_small_bank_Bank.
  Definition Self : Ty.t := Ty.path "small_bank::Bank".
  
  (*
      fn transfer(&mut self, from: i32, to: i32, amount: u32) {
          let from_index = self.accounts.iter().position(|&x| x.id == from);
          let to_index = self.accounts.iter().position(|&x| x.id == to);
          if from_index.is_none() || to_index.is_none() {
              return;
          }
          let from_index = from_index.unwrap();
          let to_index = to_index.unwrap();
          if self.accounts[from_index].balance < amount {
              return;
          }
          self.accounts[from_index].balance -= amount;
          self.accounts[to_index].balance += amount;
      }
  *)
  Definition transfer (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [ self; from; to; amount ] =>
      let* self := M.alloc self in
      let* from := M.alloc from in
      let* to := M.alloc to in
      let* amount := M.alloc amount in
      let* from_index :=
        let* α0 :=
          M.get_trait_method
            "core::iter::traits::iterator::Iterator"
            (Ty.apply
              (Ty.path "core::slice::iter::Iter")
              [ Ty.path "small_bank::Account" ])
            []
            "position"
            [
              Ty.function
                [
                  Ty.tuple
                    [ Ty.apply (Ty.path "&") [ Ty.path "small_bank::Account" ] ]
                ]
                (Ty.path "bool")
            ] in
        let* α1 :=
          M.get_associated_function
            (Ty.apply (Ty.path "slice") [ Ty.path "small_bank::Account" ])
            "iter"
            [] in
        let* α2 :=
          M.get_trait_method
            "core::ops::deref::Deref"
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "small_bank::Account"; Ty.path "alloc::alloc::Global" ])
            []
            "deref"
            [] in
        let* α3 := M.read self in
        let* α4 :=
          M.call_closure
            α2
            [ M.get_struct_record_field α3 "small_bank::Bank" "accounts" ] in
        let* α5 := M.call_closure α1 [ α4 ] in
        let* α6 := M.alloc α5 in
        let* α7 :=
          M.call_closure
            α0
            [
              α6;
              M.closure
                (fun γ =>
                  match γ with
                  | [ α0 ] =>
                    let* α0 := M.alloc α0 in
                    match_operator
                      α0
                      [
                        fun γ =>
                          let* γ := M.read γ in
                          let* x := M.copy γ in
                          let* α0 :=
                            M.read
                              (M.get_struct_record_field
                                x
                                "small_bank::Account"
                                "id") in
                          let* α1 := M.read from in
                          M.pure (BinOp.Pure.eq α0 α1)
                      ]
                  | _ => M.impossible
                  end)
            ] in
        M.alloc α7 in
      let* to_index :=
        let* α0 :=
          M.get_trait_method
            "core::iter::traits::iterator::Iterator"
            (Ty.apply
              (Ty.path "core::slice::iter::Iter")
              [ Ty.path "small_bank::Account" ])
            []
            "position"
            [
              Ty.function
                [
                  Ty.tuple
                    [ Ty.apply (Ty.path "&") [ Ty.path "small_bank::Account" ] ]
                ]
                (Ty.path "bool")
            ] in
        let* α1 :=
          M.get_associated_function
            (Ty.apply (Ty.path "slice") [ Ty.path "small_bank::Account" ])
            "iter"
            [] in
        let* α2 :=
          M.get_trait_method
            "core::ops::deref::Deref"
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "small_bank::Account"; Ty.path "alloc::alloc::Global" ])
            []
            "deref"
            [] in
        let* α3 := M.read self in
        let* α4 :=
          M.call_closure
            α2
            [ M.get_struct_record_field α3 "small_bank::Bank" "accounts" ] in
        let* α5 := M.call_closure α1 [ α4 ] in
        let* α6 := M.alloc α5 in
        let* α7 :=
          M.call_closure
            α0
            [
              α6;
              M.closure
                (fun γ =>
                  match γ with
                  | [ α0 ] =>
                    let* α0 := M.alloc α0 in
                    match_operator
                      α0
                      [
                        fun γ =>
                          let* γ := M.read γ in
                          let* x := M.copy γ in
                          let* α0 :=
                            M.read
                              (M.get_struct_record_field
                                x
                                "small_bank::Account"
                                "id") in
                          let* α1 := M.read to in
                          M.pure (BinOp.Pure.eq α0 α1)
                      ]
                  | _ => M.impossible
                  end)
            ] in
        M.alloc α7 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ])
            "is_none"
            [] in
        let* α1 := M.call_closure α0 [ from_index ] in
        let* α2 :=
          LogicalOp.or
            α1
            (let* α0 :=
              M.get_associated_function
                (Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ])
                "is_none"
                [] in
            M.call_closure α0 [ to_index ]) in
        let* α3 := M.alloc α2 in
        let* α4 := M.read (M.use α3) in
        if Value.is_true α4 then
          let* α0 := M.return_ (Value.Tuple []) in
          let* α1 := M.read α0 in
          let* α2 := M.never_to_any α1 in
          M.alloc α2
        else
          M.alloc (Value.Tuple []) in
      let* from_index :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ])
            "unwrap"
            [] in
        let* α1 := M.read from_index in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* to_index :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ])
            "unwrap"
            [] in
        let* α1 := M.read to_index in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "core::ops::index::Index"
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "small_bank::Account"; Ty.path "alloc::alloc::Global" ])
            [ Ty.path "usize" ]
            "index"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read from_index in
        let* α3 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "small_bank::Bank" "accounts"; α2
            ] in
        let* α4 :=
          M.read
            (M.get_struct_record_field α3 "small_bank::Account" "balance") in
        let* α5 := M.read amount in
        let* α6 := M.alloc (BinOp.Pure.lt α4 α5) in
        let* α7 := M.read (M.use α6) in
        if Value.is_true α7 then
          let* α0 := M.return_ (Value.Tuple []) in
          let* α1 := M.read α0 in
          let* α2 := M.never_to_any α1 in
          M.alloc α2
        else
          M.alloc (Value.Tuple []) in
      let* _ :=
        let* β :=
          let* α0 :=
            M.get_trait_method
              "core::ops::index::IndexMut"
              (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "small_bank::Account"; Ty.path "alloc::alloc::Global"
                ])
              [ Ty.path "usize" ]
              "index_mut"
              [] in
          let* α1 := M.read self in
          let* α2 := M.read from_index in
          let* α3 :=
            M.call_closure
              α0
              [ M.get_struct_record_field α1 "small_bank::Bank" "accounts"; α2
              ] in
          M.pure
            (M.get_struct_record_field α3 "small_bank::Account" "balance") in
        let* α0 := M.read β in
        let* α1 := M.read amount in
        let* α2 := BinOp.Panic.sub α0 α1 in
        M.assign β α2 in
      let* _ :=
        let* β :=
          let* α0 :=
            M.get_trait_method
              "core::ops::index::IndexMut"
              (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "small_bank::Account"; Ty.path "alloc::alloc::Global"
                ])
              [ Ty.path "usize" ]
              "index_mut"
              [] in
          let* α1 := M.read self in
          let* α2 := M.read to_index in
          let* α3 :=
            M.call_closure
              α0
              [ M.get_struct_record_field α1 "small_bank::Bank" "accounts"; α2
              ] in
          M.pure
            (M.get_struct_record_field α3 "small_bank::Account" "balance") in
        let* α0 := M.read β in
        let* α1 := M.read amount in
        let* α2 := BinOp.Panic.add α0 α1 in
        M.assign β α2 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_transfer :
    M.IsAssociatedFunction Self "transfer" transfer.
End Impl_small_bank_Bank.
