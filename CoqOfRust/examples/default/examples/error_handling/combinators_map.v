(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module Food.
  Inductive t : Set :=
  | Apple
  | Carrot
  | Potato.
End Food.

Module  Impl_core_fmt_Debug_for_combinators_map_Food_t.
Section Impl_core_fmt_Debug_for_combinators_map_Food_t.
  Definition Self : Set := combinators_map.Food.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
    let* α1 : M.Val (ref str.t) :=
      match_operator
        self
        [
          fun γ =>
            (let* γ :=
              let* α0 := M.read γ in
              M.pure (deref α0) in
            let* α0 := M.read γ in
            match α0 with
            | combinators_map.Food.Apple =>
              let* α0 : ref str.t := M.read (mk_str "Apple") in
              M.alloc α0
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* γ :=
              let* α0 := M.read γ in
              M.pure (deref α0) in
            let* α0 := M.read γ in
            match α0 with
            | combinators_map.Food.Carrot =>
              let* α0 : ref str.t := M.read (mk_str "Carrot") in
              M.alloc α0
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* γ :=
              let* α0 := M.read γ in
              M.pure (deref α0) in
            let* α0 := M.read γ in
            match α0 with
            | combinators_map.Food.Potato =>
              let* α0 : ref str.t := M.read (mk_str "Potato") in
              M.alloc α0
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t))
        ] in
    let* α2 : ref str.t := M.read α1 in
    M.call (core.fmt.Formatter.t::["write_str"] α0 α2).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_combinators_map_Food_t.
End Impl_core_fmt_Debug_for_combinators_map_Food_t.

Module  Peeled.
Section Peeled.
  Record t : Set := {
    x0 : combinators_map.Food.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>));
  }.
End Peeled.
End Peeled.

Module  Impl_core_fmt_Debug_for_combinators_map_Peeled_t.
Section Impl_core_fmt_Debug_for_combinators_map_Peeled_t.
  Definition Self : Set := combinators_map.Peeled.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
    let* α1 : ref str.t := M.read (mk_str "Peeled") in
    let* α2 : ref combinators_map.Peeled.t := M.read self in
    let* α3 : M.Val (ref combinators_map.Food.t) :=
      M.alloc (borrow (deref α2).["0"]) in
    let* α4 : M.Val (ref (ref combinators_map.Food.t)) := M.alloc (borrow α3) in
    let* α5 : ref dynamic := M.read (pointer_coercion "Unsize" α4) in
    M.call (core.fmt.Formatter.t::["debug_tuple_field1_finish"] α0 α1 α5).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_combinators_map_Peeled_t.
End Impl_core_fmt_Debug_for_combinators_map_Peeled_t.

Module  Chopped.
Section Chopped.
  Record t : Set := {
    x0 : combinators_map.Food.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>));
  }.
End Chopped.
End Chopped.

Module  Impl_core_fmt_Debug_for_combinators_map_Chopped_t.
Section Impl_core_fmt_Debug_for_combinators_map_Chopped_t.
  Definition Self : Set := combinators_map.Chopped.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
    let* α1 : ref str.t := M.read (mk_str "Chopped") in
    let* α2 : ref combinators_map.Chopped.t := M.read self in
    let* α3 : M.Val (ref combinators_map.Food.t) :=
      M.alloc (borrow (deref α2).["0"]) in
    let* α4 : M.Val (ref (ref combinators_map.Food.t)) := M.alloc (borrow α3) in
    let* α5 : ref dynamic := M.read (pointer_coercion "Unsize" α4) in
    M.call (core.fmt.Formatter.t::["debug_tuple_field1_finish"] α0 α1 α5).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_combinators_map_Chopped_t.
End Impl_core_fmt_Debug_for_combinators_map_Chopped_t.

Module  Cooked.
Section Cooked.
  Record t : Set := {
    x0 : combinators_map.Food.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>));
  }.
End Cooked.
End Cooked.

Module  Impl_core_fmt_Debug_for_combinators_map_Cooked_t.
Section Impl_core_fmt_Debug_for_combinators_map_Cooked_t.
  Definition Self : Set := combinators_map.Cooked.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
    let* α1 : ref str.t := M.read (mk_str "Cooked") in
    let* α2 : ref combinators_map.Cooked.t := M.read self in
    let* α3 : M.Val (ref combinators_map.Food.t) :=
      M.alloc (borrow (deref α2).["0"]) in
    let* α4 : M.Val (ref (ref combinators_map.Food.t)) := M.alloc (borrow α3) in
    let* α5 : ref dynamic := M.read (pointer_coercion "Unsize" α4) in
    M.call (core.fmt.Formatter.t::["debug_tuple_field1_finish"] α0 α1 α5).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_combinators_map_Cooked_t.
End Impl_core_fmt_Debug_for_combinators_map_Cooked_t.

(*
fn peel(food: Option<Food>) -> Option<Peeled> {
    match food {
        Some(food) => Some(Peeled(food)),
        None => None,
    }
}
*)
Definition peel
    (food : core.option.Option.t combinators_map.Food.t)
    : M (core.option.Option.t combinators_map.Peeled.t) :=
  let* food := M.alloc food in
  let* α0 : M.Val (core.option.Option.t combinators_map.Peeled.t) :=
    match_operator
      food
      [
        fun γ =>
          (let* α0 := M.read γ in
          match α0 with
          | core.option.Option.Some _ =>
            let γ0 := γ.["Some.0"] in
            let* food := M.copy γ0 in
            let* α0 : combinators_map.Food.t := M.read food in
            M.alloc
              (core.option.Option.Some (combinators_map.Peeled.Build_t α0))
          | _ => M.break_match
          end) :
          M (M.Val (core.option.Option.t combinators_map.Peeled.t));
        fun γ =>
          (let* α0 := M.read γ in
          match α0 with
          | core.option.Option.None => M.alloc core.option.Option.None
          | _ => M.break_match
          end) :
          M (M.Val (core.option.Option.t combinators_map.Peeled.t))
      ] in
  M.read α0.

(*
fn chop(peeled: Option<Peeled>) -> Option<Chopped> {
    match peeled {
        Some(Peeled(food)) => Some(Chopped(food)),
        None => None,
    }
}
*)
Definition chop
    (peeled : core.option.Option.t combinators_map.Peeled.t)
    : M (core.option.Option.t combinators_map.Chopped.t) :=
  let* peeled := M.alloc peeled in
  let* α0 : M.Val (core.option.Option.t combinators_map.Chopped.t) :=
    match_operator
      peeled
      [
        fun γ =>
          (let* α0 := M.read γ in
          match α0 with
          | core.option.Option.Some _ =>
            let γ0 := γ.["Some.0"] in
            let* α0 := M.read γ0 in
            match α0 with
            | combinators_map.Peeled.Build_t _ =>
              let γ0 := γ0.["Peeled.0"] in
              let* food := M.copy γ0 in
              let* α0 : combinators_map.Food.t := M.read food in
              M.alloc
                (core.option.Option.Some (combinators_map.Chopped.Build_t α0))
            end
          | _ => M.break_match
          end) :
          M (M.Val (core.option.Option.t combinators_map.Chopped.t));
        fun γ =>
          (let* α0 := M.read γ in
          match α0 with
          | core.option.Option.None => M.alloc core.option.Option.None
          | _ => M.break_match
          end) :
          M (M.Val (core.option.Option.t combinators_map.Chopped.t))
      ] in
  M.read α0.

(*
fn cook(chopped: Option<Chopped>) -> Option<Cooked> {
    chopped.map(|Chopped(food)| Cooked(food))
}
*)
Definition cook
    (chopped : core.option.Option.t combinators_map.Chopped.t)
    : M (core.option.Option.t combinators_map.Cooked.t) :=
  let* chopped := M.alloc chopped in
  let* α0 : core.option.Option.t combinators_map.Chopped.t := M.read chopped in
  M.call
    ((core.option.Option.t combinators_map.Chopped.t)::["map"]
      α0
      (fun (α0 : combinators_map.Chopped.t) =>
        (let* α0 := M.alloc α0 in
        match_operator
          α0
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | combinators_map.Chopped.Build_t _ =>
                let γ0 := γ.["Chopped.0"] in
                let* food := M.copy γ0 in
                let* α0 : combinators_map.Food.t := M.read food in
                M.pure (combinators_map.Cooked.Build_t α0)
              end) :
              M combinators_map.Cooked.t
          ]) :
        M combinators_map.Cooked.t)).

(*
fn process(food: Option<Food>) -> Option<Cooked> {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}
*)
Definition process
    (food : core.option.Option.t combinators_map.Food.t)
    : M (core.option.Option.t combinators_map.Cooked.t) :=
  let* food := M.alloc food in
  let* α0 : core.option.Option.t combinators_map.Food.t := M.read food in
  let* α1 : core.option.Option.t combinators_map.Peeled.t :=
    M.call
      ((core.option.Option.t combinators_map.Food.t)::["map"]
        α0
        (fun (α0 : combinators_map.Food.t) =>
          (let* α0 := M.alloc α0 in
          match_operator
            α0
            [
              fun γ =>
                (let* f := M.copy γ in
                let* α0 : combinators_map.Food.t := M.read f in
                M.pure (combinators_map.Peeled.Build_t α0)) :
                M combinators_map.Peeled.t
            ]) :
          M combinators_map.Peeled.t)) in
  let* α2 : core.option.Option.t combinators_map.Chopped.t :=
    M.call
      ((core.option.Option.t combinators_map.Peeled.t)::["map"]
        α1
        (fun (α0 : combinators_map.Peeled.t) =>
          (let* α0 := M.alloc α0 in
          match_operator
            α0
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | combinators_map.Peeled.Build_t _ =>
                  let γ0 := γ.["Peeled.0"] in
                  let* f := M.copy γ0 in
                  let* α0 : combinators_map.Food.t := M.read f in
                  M.pure (combinators_map.Chopped.Build_t α0)
                end) :
                M combinators_map.Chopped.t
            ]) :
          M combinators_map.Chopped.t)) in
  M.call
    ((core.option.Option.t combinators_map.Chopped.t)::["map"]
      α2
      (fun (α0 : combinators_map.Chopped.t) =>
        (let* α0 := M.alloc α0 in
        match_operator
          α0
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | combinators_map.Chopped.Build_t _ =>
                let γ0 := γ.["Chopped.0"] in
                let* f := M.copy γ0 in
                let* α0 : combinators_map.Food.t := M.read f in
                M.pure (combinators_map.Cooked.Build_t α0)
              end) :
              M combinators_map.Cooked.t
          ]) :
        M combinators_map.Cooked.t)).

(*
fn eat(food: Option<Cooked>) {
    match food {
        Some(food) => println!("Mmm. I love {:?}", food),
        None => println!("Oh no! It wasn't edible."),
    }
}
*)
Definition eat
    (food : core.option.Option.t combinators_map.Cooked.t)
    : M unit :=
  let* food := M.alloc food in
  let* α0 : M.Val unit :=
    match_operator
      food
      [
        fun γ =>
          (let* α0 := M.read γ in
          match α0 with
          | core.option.Option.Some _ =>
            let γ0 := γ.["Some.0"] in
            let* food := M.copy γ0 in
            let* _ : M.Val unit :=
              let* α0 : ref str.t := M.read (mk_str "Mmm. I love ") in
              let* α1 : ref str.t := M.read (mk_str "
") in
              let* α2 : M.Val (array (ref str.t)) := M.alloc [ α0; α1 ] in
              let* α3 : M.Val (ref (array (ref str.t))) :=
                M.alloc (borrow α2) in
              let* α4 : ref (slice (ref str.t)) :=
                M.read (pointer_coercion "Unsize" α3) in
              let* α5 : core.fmt.rt.Argument.t :=
                M.call (core.fmt.rt.Argument.t::["new_debug"] (borrow food)) in
              let* α6 : M.Val (array core.fmt.rt.Argument.t) :=
                M.alloc [ α5 ] in
              let* α7 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
                M.alloc (borrow α6) in
              let* α8 : ref (slice core.fmt.rt.Argument.t) :=
                M.read (pointer_coercion "Unsize" α7) in
              let* α9 : core.fmt.Arguments.t :=
                M.call (core.fmt.Arguments.t::["new_v1"] α4 α8) in
              let* α10 : unit := M.call (std.io.stdio._print α9) in
              M.alloc α10 in
            M.alloc tt
          | _ => M.break_match
          end) :
          M (M.Val unit);
        fun γ =>
          (let* α0 := M.read γ in
          match α0 with
          | core.option.Option.None =>
            let* _ : M.Val unit :=
              let* α0 : ref str.t :=
                M.read (mk_str "Oh no! It wasn't edible.
") in
              let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
              let* α2 : M.Val (ref (array (ref str.t))) :=
                M.alloc (borrow α1) in
              let* α3 : ref (slice (ref str.t)) :=
                M.read (pointer_coercion "Unsize" α2) in
              let* α4 : core.fmt.Arguments.t :=
                M.call (core.fmt.Arguments.t::["new_const"] α3) in
              let* α5 : unit := M.call (std.io.stdio._print α4) in
              M.alloc α5 in
            M.alloc tt
          | _ => M.break_match
          end) :
          M (M.Val unit)
      ] in
  M.read α0.

(*
fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // Let's try the simpler looking `process()` now.
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  let* apple : M.Val (core.option.Option.t combinators_map.Food.t) :=
    M.alloc (core.option.Option.Some combinators_map.Food.Apple) in
  let* carrot : M.Val (core.option.Option.t combinators_map.Food.t) :=
    M.alloc (core.option.Option.Some combinators_map.Food.Carrot) in
  let* potato : M.Val (core.option.Option.t combinators_map.Food.t) :=
    M.alloc core.option.Option.None in
  let* cooked_apple : M.Val (core.option.Option.t combinators_map.Cooked.t) :=
    let* α0 : core.option.Option.t combinators_map.Food.t := M.read apple in
    let* α1 : core.option.Option.t combinators_map.Peeled.t :=
      M.call (combinators_map.peel α0) in
    let* α2 : core.option.Option.t combinators_map.Chopped.t :=
      M.call (combinators_map.chop α1) in
    let* α3 : core.option.Option.t combinators_map.Cooked.t :=
      M.call (combinators_map.cook α2) in
    M.alloc α3 in
  let* cooked_carrot : M.Val (core.option.Option.t combinators_map.Cooked.t) :=
    let* α0 : core.option.Option.t combinators_map.Food.t := M.read carrot in
    let* α1 : core.option.Option.t combinators_map.Peeled.t :=
      M.call (combinators_map.peel α0) in
    let* α2 : core.option.Option.t combinators_map.Chopped.t :=
      M.call (combinators_map.chop α1) in
    let* α3 : core.option.Option.t combinators_map.Cooked.t :=
      M.call (combinators_map.cook α2) in
    M.alloc α3 in
  let* cooked_potato : M.Val (core.option.Option.t combinators_map.Cooked.t) :=
    let* α0 : core.option.Option.t combinators_map.Food.t := M.read potato in
    let* α1 : core.option.Option.t combinators_map.Cooked.t :=
      M.call (combinators_map.process α0) in
    M.alloc α1 in
  let* _ : M.Val unit :=
    let* α0 : core.option.Option.t combinators_map.Cooked.t :=
      M.read cooked_apple in
    let* α1 : unit := M.call (combinators_map.eat α0) in
    M.alloc α1 in
  let* _ : M.Val unit :=
    let* α0 : core.option.Option.t combinators_map.Cooked.t :=
      M.read cooked_carrot in
    let* α1 : unit := M.call (combinators_map.eat α0) in
    M.alloc α1 in
  let* _ : M.Val unit :=
    let* α0 : core.option.Option.t combinators_map.Cooked.t :=
      M.read cooked_potato in
    let* α1 : unit := M.call (combinators_map.eat α0) in
    M.alloc α1 in
  let* α0 : M.Val unit := M.alloc tt in
  M.read α0.
