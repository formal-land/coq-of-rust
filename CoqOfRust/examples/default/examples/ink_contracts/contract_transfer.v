(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_contract_transfer_AccountId_t.
Section Impl_core_default_Default_for_contract_transfer_AccountId_t.
  Definition Self : Set := contract_transfer.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M contract_transfer.AccountId.t :=
    let* α0 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := u128.t) (Trait := ℐ))) in
    let* α1 : u128.t := M.call α0 in
    M.pure (contract_transfer.AccountId.Build_t α1).
  
  Axiom default_is_impl : impl Self "default" = default.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_contract_transfer_AccountId_t.
End Impl_core_default_Default_for_contract_transfer_AccountId_t.

Module  Impl_core_clone_Clone_for_contract_transfer_AccountId_t.
Section Impl_core_clone_Clone_for_contract_transfer_AccountId_t.
  Definition Self : Set := contract_transfer.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M contract_transfer.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : M.Val contract_transfer.AccountId.t :=
      match_operator
        (DeclaredButUndefinedVariable
          (A := core.clone.AssertParamIsClone.t u128.t))
        [
          fun γ =>
            (let* α0 : ref contract_transfer.AccountId.t := M.read self in
            M.pure (deref α0)) :
            M (M.Val contract_transfer.AccountId.t)
        ] in
    M.read α0.
  
  Axiom clone_is_impl : impl Self "clone" = clone.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_contract_transfer_AccountId_t.
End Impl_core_clone_Clone_for_contract_transfer_AccountId_t.

Module  Impl_core_marker_Copy_for_contract_transfer_AccountId_t.
Section Impl_core_marker_Copy_for_contract_transfer_AccountId_t.
  Definition Self : Set := contract_transfer.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_contract_transfer_AccountId_t.
End Impl_core_marker_Copy_for_contract_transfer_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : contract_transfer.AccountId.t;
  }.
  
  Definition Get_caller :=
    Ref.map (fun α => Some α.(caller)) (fun β α => Some (α <| caller := β |>)).
End Env.
End Env.

Module  Impl_contract_transfer_Env_t.
Section Impl_contract_transfer_Env_t.
  Definition Self : Set := contract_transfer.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (self : ref Self) : M contract_transfer.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref contract_transfer.Env.t := M.read self in
    M.read (contract_transfer.Env.Get_caller (deref α0)).
  
  Axiom caller_is_impl : impl Self "caller" = caller.
  
  (*
      fn balance(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition balance (self : ref Self) : M ltac:(contract_transfer.Balance) :=
    let* self := M.alloc self in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom balance_is_impl : impl Self "balance" = balance.
  
  (*
      fn transfer(&mut self, _to: AccountId, _value: Balance) -> Result<(), ()> {
          unimplemented!()
      }
  *)
  Definition transfer
      (self : mut_ref Self)
      (_to : contract_transfer.AccountId.t)
      (_value : ltac:(contract_transfer.Balance))
      : M (core.result.Result.t unit unit) :=
    let* self := M.alloc self in
    let* _to := M.alloc _to in
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom transfer_is_impl : impl Self "transfer" = transfer.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition transferred_value
      (self : ref Self)
      : M ltac:(contract_transfer.Balance) :=
    let* self := M.alloc self in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom transferred_value_is_impl :
      impl Self "transferred_value" = transferred_value.
End Impl_contract_transfer_Env_t.
End Impl_contract_transfer_Env_t.

Module  GiveMe.
Section GiveMe.
  Inductive t : Set := Build.
End GiveMe.
End GiveMe.

Module  Impl_contract_transfer_GiveMe_t.
Section Impl_contract_transfer_GiveMe_t.
  Definition Self : Set := contract_transfer.GiveMe.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M contract_transfer.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom init_env_is_impl : impl Self "init_env" = init_env.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (self : ref Self) : M contract_transfer.Env.t :=
    let* self := M.alloc self in
    M.call (impl contract_transfer.GiveMe.t "init_env").
  
  Axiom env_is_impl : impl Self "env" = env.
  
  (*
      pub fn new() -> Self {
          Self {}
      }
  *)
  Definition new : M Self := M.pure contract_transfer.GiveMe.Build.
  
  Axiom new_is_impl : impl Self "new" = new.
  
  (*
      pub fn give_me(&mut self, value: Balance) {
          println!("requested value: {}", value);
          println!("contract balance: {}", self.env().balance());
  
          assert!(value <= self.env().balance(), "insufficient funds!");
  
          if self.env().transfer(self.env().caller(), value).is_err() {
              panic!(
                  "requested transfer failed. this can be the case if the contract does not\
                   have sufficient free funds or if the transfer would have brought the\
                   contract's balance below minimum balance."
              )
          }
      }
  *)
  Definition give_me
      (self : mut_ref Self)
      (value : ltac:(contract_transfer.Balance))
      : M unit :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    let* _ : M.Val unit :=
      let* _ : M.Val unit :=
        let* α0 : ref str.t := M.read (mk_str "requested value: ") in
        let* α1 : ref str.t := M.read (mk_str "
") in
        let* α2 : M.Val (array (ref str.t)) := M.alloc [ α0; α1 ] in
        let* α3 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α2) in
        let* α4 : ref (slice (ref str.t)) :=
          M.read (pointer_coercion "Unsize" α3) in
        let* α5 : core.fmt.rt.Argument.t :=
          M.call (impl core.fmt.rt.Argument.t "new_display" (borrow value)) in
        let* α6 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α5 ] in
        let* α7 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
          M.alloc (borrow α6) in
        let* α8 : ref (slice core.fmt.rt.Argument.t) :=
          M.read (pointer_coercion "Unsize" α7) in
        let* α9 : core.fmt.Arguments.t :=
          M.call (impl core.fmt.Arguments.t "new_v1" α4 α8) in
        let* α10 : unit := M.call (std.io.stdio._print α9) in
        M.alloc α10 in
      M.alloc tt in
    let* _ : M.Val unit :=
      let* _ : M.Val unit :=
        let* α0 : ref str.t := M.read (mk_str "contract balance: ") in
        let* α1 : ref str.t := M.read (mk_str "
") in
        let* α2 : M.Val (array (ref str.t)) := M.alloc [ α0; α1 ] in
        let* α3 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α2) in
        let* α4 : ref (slice (ref str.t)) :=
          M.read (pointer_coercion "Unsize" α3) in
        let* α5 : mut_ref contract_transfer.GiveMe.t := M.read self in
        let* α6 : contract_transfer.Env.t :=
          M.call (impl contract_transfer.GiveMe.t "env" (borrow (deref α5))) in
        let* α7 : M.Val contract_transfer.Env.t := M.alloc α6 in
        let* α8 : u128.t :=
          M.call (impl contract_transfer.Env.t "balance" (borrow α7)) in
        let* α9 : M.Val u128.t := M.alloc α8 in
        let* α10 : core.fmt.rt.Argument.t :=
          M.call (impl core.fmt.rt.Argument.t "new_display" (borrow α9)) in
        let* α11 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α10 ] in
        let* α12 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
          M.alloc (borrow α11) in
        let* α13 : ref (slice core.fmt.rt.Argument.t) :=
          M.read (pointer_coercion "Unsize" α12) in
        let* α14 : core.fmt.Arguments.t :=
          M.call (impl core.fmt.Arguments.t "new_v1" α4 α13) in
        let* α15 : unit := M.call (std.io.stdio._print α14) in
        M.alloc α15 in
      M.alloc tt in
    let* _ : M.Val unit :=
      let* α0 : u128.t := M.read value in
      let* α1 : mut_ref contract_transfer.GiveMe.t := M.read self in
      let* α2 : contract_transfer.Env.t :=
        M.call (impl contract_transfer.GiveMe.t "env" (borrow (deref α1))) in
      let* α3 : M.Val contract_transfer.Env.t := M.alloc α2 in
      let* α4 : u128.t :=
        M.call (impl contract_transfer.Env.t "balance" (borrow α3)) in
      let* α5 : M.Val bool.t := M.alloc (UnOp.not (BinOp.Pure.le α0 α4)) in
      let* α6 : bool.t := M.read (use α5) in
      if α6 then
        let* α0 : ref str.t := M.read (mk_str "insufficient funds!") in
        let* α1 : never.t := M.call (std.panicking.begin_panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* α0 : mut_ref contract_transfer.GiveMe.t := M.read self in
    let* α1 : contract_transfer.Env.t :=
      M.call (impl contract_transfer.GiveMe.t "env" (borrow (deref α0))) in
    let* α2 : M.Val contract_transfer.Env.t := M.alloc α1 in
    let* α3 : mut_ref contract_transfer.GiveMe.t := M.read self in
    let* α4 : contract_transfer.Env.t :=
      M.call (impl contract_transfer.GiveMe.t "env" (borrow (deref α3))) in
    let* α5 : M.Val contract_transfer.Env.t := M.alloc α4 in
    let* α6 : contract_transfer.AccountId.t :=
      M.call (impl contract_transfer.Env.t "caller" (borrow α5)) in
    let* α7 : u128.t := M.read value in
    let* α8 : core.result.Result.t unit unit :=
      M.call (impl contract_transfer.Env.t "transfer" (borrow_mut α2) α6 α7) in
    let* α9 : M.Val (core.result.Result.t unit unit) := M.alloc α8 in
    let* α10 : bool.t :=
      M.call (impl (core.result.Result.t unit unit) "is_err" (borrow α9)) in
    let* α11 : M.Val bool.t := M.alloc α10 in
    let* α12 : bool.t := M.read (use α11) in
    let* α0 : M.Val unit :=
      if α12 then
        let* α0 : ref str.t :=
          M.read
            (mk_str
              "requested transfer failed. this can be the case if the contract does nothave sufficient free funds or if the transfer would have brought thecontract's balance below minimum balance.") in
        let* α1 : never.t := M.call (std.panicking.begin_panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    M.read α0.
  
  Axiom give_me_is_impl : impl Self "give_me" = give_me.
  
  (*
      pub fn was_it_ten(&self) {
          println!("received payment: {}", self.env().transferred_value());
          assert!(self.env().transferred_value() == 10, "payment was not ten");
      }
  *)
  Definition was_it_ten (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let* _ : M.Val unit :=
      let* _ : M.Val unit :=
        let* α0 : ref str.t := M.read (mk_str "received payment: ") in
        let* α1 : ref str.t := M.read (mk_str "
") in
        let* α2 : M.Val (array (ref str.t)) := M.alloc [ α0; α1 ] in
        let* α3 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α2) in
        let* α4 : ref (slice (ref str.t)) :=
          M.read (pointer_coercion "Unsize" α3) in
        let* α5 : ref contract_transfer.GiveMe.t := M.read self in
        let* α6 : contract_transfer.Env.t :=
          M.call (impl contract_transfer.GiveMe.t "env" α5) in
        let* α7 : M.Val contract_transfer.Env.t := M.alloc α6 in
        let* α8 : u128.t :=
          M.call
            (impl contract_transfer.Env.t "transferred_value" (borrow α7)) in
        let* α9 : M.Val u128.t := M.alloc α8 in
        let* α10 : core.fmt.rt.Argument.t :=
          M.call (impl core.fmt.rt.Argument.t "new_display" (borrow α9)) in
        let* α11 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α10 ] in
        let* α12 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
          M.alloc (borrow α11) in
        let* α13 : ref (slice core.fmt.rt.Argument.t) :=
          M.read (pointer_coercion "Unsize" α12) in
        let* α14 : core.fmt.Arguments.t :=
          M.call (impl core.fmt.Arguments.t "new_v1" α4 α13) in
        let* α15 : unit := M.call (std.io.stdio._print α14) in
        M.alloc α15 in
      M.alloc tt in
    let* _ : M.Val unit :=
      let* α0 : ref contract_transfer.GiveMe.t := M.read self in
      let* α1 : contract_transfer.Env.t :=
        M.call (impl contract_transfer.GiveMe.t "env" α0) in
      let* α2 : M.Val contract_transfer.Env.t := M.alloc α1 in
      let* α3 : u128.t :=
        M.call (impl contract_transfer.Env.t "transferred_value" (borrow α2)) in
      let* α4 : M.Val bool.t :=
        M.alloc (UnOp.not (BinOp.Pure.eq α3 ((Integer.of_Z 10) : u128.t))) in
      let* α5 : bool.t := M.read (use α4) in
      if α5 then
        let* α0 : ref str.t := M.read (mk_str "payment was not ten") in
        let* α1 : never.t := M.call (std.panicking.begin_panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Axiom was_it_ten_is_impl : impl Self "was_it_ten" = was_it_ten.
End Impl_contract_transfer_GiveMe_t.
End Impl_contract_transfer_GiveMe_t.
