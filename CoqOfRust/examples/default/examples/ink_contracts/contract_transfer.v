(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Struct AccountId *)

Module Impl_core_default_Default_for_contract_transfer_AccountId.
  (*
  Default
  *)
  Definition default (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [] =>
      let* Î±0 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "u128" ] in
      let* Î±1 := M.call Î±0 [] in
      M.pure (contract_transfer.AccountId.Build_t Î±1)
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    let Self := Ty.path "contract_transfer::AccountId" in
    M.IsTraitInstance
      "core::default::Default"
      Self
      []
      [ ("default", InstanceField.Method default [ Self ]) ].
End Impl_core_default_Default_for_contract_transfer_AccountId.

Module Impl_core_clone_Clone_for_contract_transfer_AccountId.
  (*
  Clone
  *)
  Definition clone (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [ Ty.path "u128" ]))
          [
            fun Î³ =>
              (let* Î±0 := M.read self in
              M.pure (deref Î±0)) :
              Ty.path "contract_transfer::AccountId"
          ] in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    let Self := Ty.path "contract_transfer::AccountId" in
    M.IsTraitInstance
      "core::clone::Clone"
      Self
      []
      [ ("clone", InstanceField.Method clone [ Self ]) ].
End Impl_core_clone_Clone_for_contract_transfer_AccountId.

Module Impl_core_marker_Copy_for_contract_transfer_AccountId.
  Axiom Implements :
    let Self := Ty.path "contract_transfer::AccountId" in
    M.IsTraitInstance "core::marker::Copy" Self [] [].
End Impl_core_marker_Copy_for_contract_transfer_AccountId.

Axiom Balance : (Ty.path "contract_transfer::Balance") = (Ty.path "u128").

(* Enum Env *)

Module Impl_contract_transfer_Env.
  Definition Self : Ty.t := Ty.path "contract_transfer::Env".
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "contract_transfer::Env::Get_caller" in
      let* Î±1 := M.read self in
      M.read (Î±0 (deref Î±1))
    | _, _ => M.impossible
    end.
  
  (*
      fn balance(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition balance (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  (*
      fn transfer(&mut self, _to: AccountId, _value: Balance) -> Result<(), ()> {
          unimplemented!()
      }
  *)
  Definition transfer (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self; _to; _value ] =>
      let* self := M.alloc self in
      let* _to := M.alloc _to in
      let* _value := M.alloc _value in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition transferred_value (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
End Impl_contract_transfer_Env.

(* Struct GiveMe *)

Module Impl_contract_transfer_GiveMe.
  Definition Self : Ty.t := Ty.path "contract_transfer::GiveMe".
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [] =>
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self ] =>
      let* self := M.alloc self in
      M.call (Ty.path "contract_transfer::GiveMe")::["init_env"] []
    | _, _ => M.impossible
    end.
  
  (*
      pub fn new() -> Self {
          Self {}
      }
  *)
  Definition new (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [] => M.pure contract_transfer.GiveMe.Build
    | _, _ => M.impossible
    end.
  
  (*
      pub fn give_me(&mut self, value: Balance) {
          println!("requested value: {}", value);
          println!("contract balance: {}", self.env().balance());
  
          assert!(value <= self.env().balance(), "insufficient funds!");
  
          if self.env().transfer(self.env().caller(), value).is_err() {
              panic!(
                  "requested transfer failed. this can be the case if the contract does not\
                   have sufficient free funds or if the transfer would have brought the\
                   contract's balance below minimum balance."
              )
          }
      }
  *)
  Definition give_me (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self; value ] =>
      let* self := M.alloc self in
      let* value := M.alloc value in
      let* _ :=
        let* _ :=
          let* Î±0 := M.var "std::io::stdio::_print" in
          let* Î±1 := M.read (mk_str "requested value: ") in
          let* Î±2 := M.read (mk_str "
") in
          let* Î±3 := M.alloc [ Î±1; Î±2 ] in
          let* Î±4 :=
            M.call
              (Ty.path "core::fmt::rt::Argument")::["new_display"]
              [ borrow value ] in
          let* Î±5 := M.alloc [ Î±4 ] in
          let* Î±6 :=
            M.call
              (Ty.path "core::fmt::Arguments")::["new_v1"]
              [
                pointer_coercion "Unsize" (borrow Î±3);
                pointer_coercion "Unsize" (borrow Î±5)
              ] in
          let* Î±7 := M.call Î±0 [ Î±6 ] in
          M.alloc Î±7 in
        M.alloc tt in
      let* _ :=
        let* _ :=
          let* Î±0 := M.var "std::io::stdio::_print" in
          let* Î±1 := M.read (mk_str "contract balance: ") in
          let* Î±2 := M.read (mk_str "
") in
          let* Î±3 := M.alloc [ Î±1; Î±2 ] in
          let* Î±4 := M.read self in
          let* Î±5 :=
            M.call
              (Ty.path "contract_transfer::GiveMe")::["env"]
              [ borrow (deref Î±4) ] in
          let* Î±6 := M.alloc Î±5 in
          let* Î±7 :=
            M.call
              (Ty.path "contract_transfer::Env")::["balance"]
              [ borrow Î±6 ] in
          let* Î±8 := M.alloc Î±7 in
          let* Î±9 :=
            M.call
              (Ty.path "core::fmt::rt::Argument")::["new_display"]
              [ borrow Î±8 ] in
          let* Î±10 := M.alloc [ Î±9 ] in
          let* Î±11 :=
            M.call
              (Ty.path "core::fmt::Arguments")::["new_v1"]
              [
                pointer_coercion "Unsize" (borrow Î±3);
                pointer_coercion "Unsize" (borrow Î±10)
              ] in
          let* Î±12 := M.call Î±0 [ Î±11 ] in
          M.alloc Î±12 in
        M.alloc tt in
      let* _ :=
        let* Î±0 := M.var "UnOp::not" in
        let* Î±1 := M.var "BinOp::Pure::le" in
        let* Î±2 := M.read value in
        let* Î±3 := M.read self in
        let* Î±4 :=
          M.call
            (Ty.path "contract_transfer::GiveMe")::["env"]
            [ borrow (deref Î±3) ] in
        let* Î±5 := M.alloc Î±4 in
        let* Î±6 :=
          M.call
            (Ty.path "contract_transfer::Env")::["balance"]
            [ borrow Î±5 ] in
        let* Î±7 := M.alloc (Î±0 (Î±1 Î±2 Î±6)) in
        let* Î±8 := M.read (use Î±7) in
        if Î±8 then
          let* Î±0 := M.var "std::panicking::begin_panic" in
          let* Î±1 := M.read (mk_str "insufficient funds!") in
          let* Î±2 := M.call Î±0 [ Î±1 ] in
          let* Î±3 := never_to_any Î±2 in
          M.alloc Î±3
        else
          M.alloc tt in
      let* Î±0 := M.read self in
      let* Î±1 :=
        M.call
          (Ty.path "contract_transfer::GiveMe")::["env"]
          [ borrow (deref Î±0) ] in
      let* Î±2 := M.alloc Î±1 in
      let* Î±3 := M.read self in
      let* Î±4 :=
        M.call
          (Ty.path "contract_transfer::GiveMe")::["env"]
          [ borrow (deref Î±3) ] in
      let* Î±5 := M.alloc Î±4 in
      let* Î±6 :=
        M.call (Ty.path "contract_transfer::Env")::["caller"] [ borrow Î±5 ] in
      let* Î±7 := M.read value in
      let* Î±8 :=
        M.call
          (Ty.path "contract_transfer::Env")::["transfer"]
          [ borrow_mut Î±2; Î±6; Î±7 ] in
      let* Î±9 := M.alloc Î±8 in
      let* Î±10 :=
        M.call
          (Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.tuple [] ])::["is_err"]
          [ borrow Î±9 ] in
      let* Î±11 := M.alloc Î±10 in
      let* Î±12 := M.read (use Î±11) in
      let* Î±0 :=
        if Î±12 then
          let* Î±0 := M.var "std::panicking::begin_panic" in
          let* Î±1 :=
            M.read
              (mk_str
                "requested transfer failed. this can be the case if the contract does nothave sufficient free funds or if the transfer would have brought thecontract's balance below minimum balance.") in
          let* Î±2 := M.call Î±0 [ Î±1 ] in
          let* Î±3 := never_to_any Î±2 in
          M.alloc Î±3
        else
          M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
      pub fn was_it_ten(&self) {
          println!("received payment: {}", self.env().transferred_value());
          assert!(self.env().transferred_value() == 10, "payment was not ten");
      }
  *)
  Definition was_it_ten (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* _ :=
        let* _ :=
          let* Î±0 := M.var "std::io::stdio::_print" in
          let* Î±1 := M.read (mk_str "received payment: ") in
          let* Î±2 := M.read (mk_str "
") in
          let* Î±3 := M.alloc [ Î±1; Î±2 ] in
          let* Î±4 := M.read self in
          let* Î±5 :=
            M.call (Ty.path "contract_transfer::GiveMe")::["env"] [ Î±4 ] in
          let* Î±6 := M.alloc Î±5 in
          let* Î±7 :=
            M.call
              (Ty.path "contract_transfer::Env")::["transferred_value"]
              [ borrow Î±6 ] in
          let* Î±8 := M.alloc Î±7 in
          let* Î±9 :=
            M.call
              (Ty.path "core::fmt::rt::Argument")::["new_display"]
              [ borrow Î±8 ] in
          let* Î±10 := M.alloc [ Î±9 ] in
          let* Î±11 :=
            M.call
              (Ty.path "core::fmt::Arguments")::["new_v1"]
              [
                pointer_coercion "Unsize" (borrow Î±3);
                pointer_coercion "Unsize" (borrow Î±10)
              ] in
          let* Î±12 := M.call Î±0 [ Î±11 ] in
          M.alloc Î±12 in
        M.alloc tt in
      let* _ :=
        let* Î±0 := M.var "UnOp::not" in
        let* Î±1 := M.var "BinOp::Pure::eq" in
        let* Î±2 := M.read self in
        let* Î±3 :=
          M.call (Ty.path "contract_transfer::GiveMe")::["env"] [ Î±2 ] in
        let* Î±4 := M.alloc Î±3 in
        let* Î±5 :=
          M.call
            (Ty.path "contract_transfer::Env")::["transferred_value"]
            [ borrow Î±4 ] in
        let* Î±6 := M.alloc (Î±0 (Î±1 Î±5 ((Integer.of_Z 10) : Ty.path "u128"))) in
        let* Î±7 := M.read (use Î±6) in
        if Î±7 then
          let* Î±0 := M.var "std::panicking::begin_panic" in
          let* Î±1 := M.read (mk_str "payment was not ten") in
          let* Î±2 := M.call Î±0 [ Î±1 ] in
          let* Î±3 := never_to_any Î±2 in
          M.alloc Î±3
        else
          M.alloc tt in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
End Impl_contract_transfer_GiveMe.
