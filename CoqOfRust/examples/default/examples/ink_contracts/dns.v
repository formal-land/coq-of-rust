(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Enum Mapping *)

Module Impl_core_default_Default_for_dns_Mapping_K_V.
  Definition Self (K V : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "dns::Mapping") [K; V].
  
  (*
  Default
  *)
  Definition default (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [] =>
      let* Î±0 :=
        ltac:(M.get_method (fun â„ =>
          core.default.Default.default
            (Self := Ty.apply (Ty.path "core::marker::PhantomData") [K])
            (Trait := â„))) in
      let* Î±1 := M.call Î±0 in
      let* Î±2 :=
        ltac:(M.get_method (fun â„ =>
          core.default.Default.default
            (Self := Ty.apply (Ty.path "core::marker::PhantomData") [V])
            (Trait := â„))) in
      let* Î±3 := M.call Î±2 in
      M.pure {| dns.Mapping._key := Î±1; dns.Mapping._value := Î±3; |}
    | _, _ => M.impossible
    end.
  
  Definition â„ (K V : Ty.t) : Instance.t :=
    [("default", InstanceField.Method (default K V))].
End Impl_core_default_Default_for_dns_Mapping_K_V.

Module Impl_dns_Mapping_K_V.
  Definition Self (K V : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "dns::Mapping") [K; V].
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Î±0 := M.read (mk_str "not implemented") in
      let* Î±1 := M.call ((M.var "core::panicking::panic") Î±0) in
      never_to_any Î±1
    | _, _ => M.impossible
    end.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Î±0 := M.read (mk_str "not implemented") in
      let* Î±1 := M.call ((M.var "core::panicking::panic") Î±0) in
      never_to_any Î±1
    | _, _ => M.impossible
    end.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; _key; _value] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* _value := M.alloc _value in
      let* Î±0 := M.read (mk_str "not implemented") in
      let* Î±1 := M.call ((M.var "core::panicking::panic") Î±0) in
      never_to_any Î±1
    | _, _ => M.impossible
    end.
  
  (*
      fn new() -> Mapping<K, V> {
          unimplemented!()
      }
  *)
  Definition new (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [] =>
      let* Î±0 := M.read (mk_str "not implemented") in
      let* Î±1 := M.call ((M.var "core::panicking::panic") Î±0) in
      never_to_any Î±1
    | _, _ => M.impossible
    end.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Î±0 := M.read (mk_str "not implemented") in
      let* Î±1 := M.call ((M.var "core::panicking::panic") Î±0) in
      never_to_any Î±1
    | _, _ => M.impossible
    end.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Î±0 := M.read (mk_str "not implemented") in
      let* Î±1 := M.call ((M.var "core::panicking::panic") Î±0) in
      never_to_any Î±1
    | _, _ => M.impossible
    end.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Î±0 := M.read (mk_str "not implemented") in
      let* Î±1 := M.call ((M.var "core::panicking::panic") Î±0) in
      never_to_any Î±1
    | _, _ => M.impossible
    end.
End Impl_dns_Mapping_K_V.

(* Struct AccountId *)

Module Impl_core_default_Default_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
  Default
  *)
  Definition default (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [] =>
      let* Î±0 :=
        ltac:(M.get_method (fun â„ =>
          core.default.Default.default
            (Self := Ty.path "u128")
            (Trait := â„))) in
      let* Î±1 := M.call Î±0 in
      M.pure (dns.AccountId.Build_t Î±1)
    | _, _ => M.impossible
    end.
  
  Definition â„ : Instance.t := [("default", InstanceField.Method default)].
End Impl_core_default_Default_for_dns_AccountId.

Module Impl_core_clone_Clone_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
  Clone
  *)
  Definition clone (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Î±0 :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [Ty.path "u128"]))
          [
            fun Î³ =>
              (let* Î±0 := M.read self in
              M.pure (deref Î±0)) :
              Ty.path "dns::AccountId"
          ] in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Definition â„ : Instance.t := [("clone", InstanceField.Method clone)].
End Impl_core_clone_Clone_for_dns_AccountId.

Module Impl_core_marker_Copy_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  Definition â„ : Instance.t := [].
End Impl_core_marker_Copy_for_dns_AccountId.

Module Impl_core_marker_StructuralPartialEq_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  Definition â„ : Instance.t := [].
End Impl_core_marker_StructuralPartialEq_for_dns_AccountId.

Module Impl_core_cmp_PartialEq_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
  PartialEq
  *)
  Definition eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Î±0 := M.read self in
      let* Î±1 := M.read ((M.var "dns::AccountId::Get_0") (deref Î±0)) in
      let* Î±2 := M.read other in
      let* Î±3 := M.read ((M.var "dns::AccountId::Get_0") (deref Î±2)) in
      M.pure ((M.var "BinOp::Pure::eq") Î±1 Î±3)
    | _, _ => M.impossible
    end.
  
  Definition â„ : Instance.t := [("eq", InstanceField.Method eq)].
End Impl_core_cmp_PartialEq_for_dns_AccountId.

Module Impl_core_convert_From_array_u8_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
      fn from(_value: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Definition from (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [_value] =>
      let* _value := M.alloc _value in
      let* Î±0 := M.read (mk_str "not implemented") in
      let* Î±1 := M.call ((M.var "core::panicking::panic") Î±0) in
      never_to_any Î±1
    | _, _ => M.impossible
    end.
  
  Definition â„ : Instance.t := [("from", InstanceField.Method from)].
End Impl_core_convert_From_array_u8_for_dns_AccountId.

Axiom Balance : (Ty.path "dns::Balance") = (Ty.path "u128").

Axiom Hash :
  (Ty.path "dns::Hash") = (Ty.apply (Ty.path "array") [Ty.path "u8"]).

(* Enum Env *)

(* Enum Register *)

(* Enum SetAddress *)

(* Enum Transfer *)

(* Enum Event *)

Module Impl_dns_Env.
  Definition Self : Ty.t := Ty.path "dns::Env".
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Î±0 := M.read self in
      M.read ((M.var "dns::Env::Get_caller") (deref Î±0))
    | _, _ => M.impossible
    end.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; _event] =>
      let* self := M.alloc self in
      let* _event := M.alloc _event in
      let* Î±0 := M.read (mk_str "not implemented") in
      let* Î±1 := M.call ((M.var "core::panicking::panic") Î±0) in
      never_to_any Î±1
    | _, _ => M.impossible
    end.
End Impl_dns_Env.

(* Enum DomainNameService *)

(*
fn zero_address() -> AccountId {
    [0u8; 32].into()
}
*)
Definition zero_address (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [], [] =>
    let* Î±0 :=
      ltac:(M.get_method (fun â„ =>
        core.convert.Into.into
          (Self := Ty.apply (Ty.path "array") [Ty.path "u8"])
          (T := Ty.path "dns::AccountId")
          (Trait := â„))) in
    M.call (Î±0 (repeat ((Integer.of_Z 0) : Ty.path "u8") 32))
  | _, _ => M.impossible
  end.

Module Impl_core_default_Default_for_dns_DomainNameService.
  Definition Self : Ty.t := Ty.path "dns::DomainNameService".
  
  (*
      fn default() -> Self {
          let mut name_to_address = Mapping::new();
          name_to_address.insert(Hash::default(), zero_address());
          let mut name_to_owner = Mapping::new();
          name_to_owner.insert(Hash::default(), zero_address());
  
          Self {
              name_to_address,
              name_to_owner,
              default_address: zero_address(),
          }
      }
  *)
  Definition default (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [] =>
      let* name_to_address :=
        let* Î±0 :=
          M.call
            (Ty.apply
                (Ty.path "dns::Mapping")
                [Ty.apply (Ty.path "array") [Ty.path "u8"];
                  Ty.path "dns::AccountId"])::["new"] in
        M.alloc Î±0 in
      let* _ :=
        let* Î±0 :=
          ltac:(M.get_method (fun â„ =>
            core.default.Default.default
              (Self := Ty.apply (Ty.path "array") [Ty.path "u8"])
              (Trait := â„))) in
        let* Î±1 := M.call Î±0 in
        let* Î±2 := M.call (M.var "dns::zero_address") in
        let* Î±3 :=
          M.call
            ((Ty.apply
                  (Ty.path "dns::Mapping")
                  [Ty.apply (Ty.path "array") [Ty.path "u8"];
                    Ty.path "dns::AccountId"])::["insert"]
              (borrow_mut name_to_address)
              Î±1
              Î±2) in
        M.alloc Î±3 in
      let* name_to_owner :=
        let* Î±0 :=
          M.call
            (Ty.apply
                (Ty.path "dns::Mapping")
                [Ty.apply (Ty.path "array") [Ty.path "u8"];
                  Ty.path "dns::AccountId"])::["new"] in
        M.alloc Î±0 in
      let* _ :=
        let* Î±0 :=
          ltac:(M.get_method (fun â„ =>
            core.default.Default.default
              (Self := Ty.apply (Ty.path "array") [Ty.path "u8"])
              (Trait := â„))) in
        let* Î±1 := M.call Î±0 in
        let* Î±2 := M.call (M.var "dns::zero_address") in
        let* Î±3 :=
          M.call
            ((Ty.apply
                  (Ty.path "dns::Mapping")
                  [Ty.apply (Ty.path "array") [Ty.path "u8"];
                    Ty.path "dns::AccountId"])::["insert"]
              (borrow_mut name_to_owner)
              Î±1
              Î±2) in
        M.alloc Î±3 in
      let* Î±0 := M.read name_to_address in
      let* Î±1 := M.read name_to_owner in
      let* Î±2 := M.call (M.var "dns::zero_address") in
      let* Î±0 :=
        M.alloc
          {|
            dns.DomainNameService.name_to_address := Î±0;
            dns.DomainNameService.name_to_owner := Î±1;
            dns.DomainNameService.default_address := Î±2;
          |} in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Definition â„ : Instance.t := [("default", InstanceField.Method default)].
End Impl_core_default_Default_for_dns_DomainNameService.

(* Enum Error *)

Module Impl_core_marker_StructuralPartialEq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  Definition â„ : Instance.t := [].
End Impl_core_marker_StructuralPartialEq_for_dns_Error.

Module Impl_core_cmp_PartialEq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  (*
  PartialEq
  *)
  Definition eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* __self_tag :=
        let* Î±0 := M.read self in
        let* Î±1 := M.call ((M.var "core::intrinsics::discriminant_value") Î±0) in
        M.alloc Î±1 in
      let* __arg1_tag :=
        let* Î±0 := M.read other in
        let* Î±1 := M.call ((M.var "core::intrinsics::discriminant_value") Î±0) in
        M.alloc Î±1 in
      let* Î±0 := M.read __self_tag in
      let* Î±1 := M.read __arg1_tag in
      let* Î±0 := M.alloc ((M.var "BinOp::Pure::eq") Î±0 Î±1) in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Definition â„ : Instance.t := [("eq", InstanceField.Method eq)].
End Impl_core_cmp_PartialEq_for_dns_Error.

Module Impl_core_marker_StructuralEq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  Definition â„ : Instance.t := [].
End Impl_core_marker_StructuralEq_for_dns_Error.

Module Impl_core_cmp_Eq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq
      (ðœ : list Ty.t)
      (Î± : list Value.t)
      : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      M.pure tt
    | _, _ => M.impossible
    end.
  
  Definition â„ : Instance.t :=
    [("assert_receiver_is_total_eq",
        InstanceField.Method assert_receiver_is_total_eq)].
End Impl_core_cmp_Eq_for_dns_Error.

Axiom Result :
  forall (T : Ty.t),
  (Ty.path "dns::Result") =
    (Ty.apply (Ty.path "core::result::Result") [T; Ty.path "dns::Error"]).

Module Impl_dns_DomainNameService.
  Definition Self : Ty.t := Ty.path "dns::DomainNameService".
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [] =>
      let* Î±0 := M.read (mk_str "not implemented") in
      let* Î±1 := M.call ((M.var "core::panicking::panic") Î±0) in
      never_to_any Î±1
    | _, _ => M.impossible
    end.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      M.call (Ty.path "dns::DomainNameService")::["init_env"]
    | _, _ => M.impossible
    end.
  
  (*
      pub fn new() -> Self {
          Default::default()
      }
  *)
  Definition new (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [] =>
      let* Î±0 :=
        ltac:(M.get_method (fun â„ =>
          core.default.Default.default
            (Self := Ty.path "dns::DomainNameService")
            (Trait := â„))) in
      M.call Î±0
    | _, _ => M.impossible
    end.
  
  (*
      pub fn register(&mut self, name: Hash) -> Result<()> {
          let caller = self.env().caller();
          if self.name_to_owner.contains(&name) {
              return Err(Error::NameAlreadyExists);
          }
  
          self.name_to_owner.insert(name, caller);
          self.env()
              .emit_event(Event::Register(Register { name, from: caller }));
  
          Ok(())
      }
  *)
  Definition register (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; name] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple []; Ty.path "dns::Error"]) in
      M.catch_return
        (let* caller :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref Î±0))) in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.call ((Ty.path "dns::Env")::["caller"] (borrow Î±2)) in
          M.alloc Î±3 in
        let* _ :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["contains"]
                (borrow
                  ((M.var "dns::DomainNameService::Get_name_to_owner")
                    (deref Î±0)))
                (borrow name)) in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* Î±0 :=
              return_ (core.result.Result.Err dns.Error.NameAlreadyExists) in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2
          else
            M.alloc tt in
        let* _ :=
          let* Î±0 := M.read self in
          let* Î±1 := M.read name in
          let* Î±2 := M.read caller in
          let* Î±3 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["insert"]
                (borrow_mut
                  ((M.var "dns::DomainNameService::Get_name_to_owner")
                    (deref Î±0)))
                Î±1
                Î±2) in
          M.alloc Î±3 in
        let* _ :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref Î±0))) in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.read name in
          let* Î±4 := M.read caller in
          let* Î±5 :=
            M.call
              ((Ty.path "dns::Env")::["emit_event"]
                (borrow Î±2)
                (dns.Event.Register
                  {| dns.Register.name := Î±3; dns.Register.from := Î±4; |})) in
          M.alloc Î±5 in
        let* Î±0 := M.alloc (core.result.Result.Ok tt) in
        M.read Î±0)
    | _, _ => M.impossible
    end.
  
  (*
      fn get_owner_or_default(&self, name: Hash) -> AccountId {
          self.name_to_owner
              .get(&name)
              .unwrap_or(self.default_address)
      }
  *)
  Definition get_owner_or_default (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; name] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* Î±0 := M.read self in
      let* Î±1 :=
        M.call
          ((Ty.apply
                (Ty.path "dns::Mapping")
                [Ty.apply (Ty.path "array") [Ty.path "u8"];
                  Ty.path "dns::AccountId"])::["get"]
            (borrow
              ((M.var "dns::DomainNameService::Get_name_to_owner") (deref Î±0)))
            (borrow name)) in
      let* Î±2 := M.read self in
      let* Î±3 :=
        M.read
          ((M.var "dns::DomainNameService::Get_default_address") (deref Î±2)) in
      M.call
        ((Ty.apply
              (Ty.path "core::option::Option")
              [Ty.path "dns::AccountId"])::["unwrap_or"]
          Î±1
          Î±3)
    | _, _ => M.impossible
    end.
  
  (*
      pub fn set_address(&mut self, name: Hash, new_address: AccountId) -> Result<()> {
          let caller = self.env().caller();
          let owner = self.get_owner_or_default(name);
          if caller != owner {
              return Err(Error::CallerIsNotOwner);
          }
  
          let old_address = self.name_to_address.get(&name);
          self.name_to_address.insert(name, new_address);
  
          self.env().emit_event(Event::SetAddress(SetAddress {
              name,
              from: caller,
              old_address,
              new_address,
          }));
          Ok(())
      }
  *)
  Definition set_address (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; name; new_address] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* new_address := M.alloc new_address in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple []; Ty.path "dns::Error"]) in
      M.catch_return
        (let* caller :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref Î±0))) in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.call ((Ty.path "dns::Env")::["caller"] (borrow Î±2)) in
          M.alloc Î±3 in
        let* owner :=
          let* Î±0 := M.read self in
          let* Î±1 := M.read name in
          let* Î±2 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["get_owner_or_default"]
                (borrow (deref Î±0))
                Î±1) in
          M.alloc Î±2 in
        let* _ :=
          let* Î±0 :=
            ltac:(M.get_method (fun â„ =>
              core.cmp.PartialEq.ne
                (Self := Ty.path "dns::AccountId")
                (Rhs := Ty.path "dns::AccountId")
                (Trait := â„))) in
          let* Î±1 := M.call (Î±0 (borrow caller) (borrow owner)) in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* Î±0 :=
              return_ (core.result.Result.Err dns.Error.CallerIsNotOwner) in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2
          else
            M.alloc tt in
        let* old_address :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["get"]
                (borrow
                  ((M.var "dns::DomainNameService::Get_name_to_address")
                    (deref Î±0)))
                (borrow name)) in
          M.alloc Î±1 in
        let* _ :=
          let* Î±0 := M.read self in
          let* Î±1 := M.read name in
          let* Î±2 := M.read new_address in
          let* Î±3 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["insert"]
                (borrow_mut
                  ((M.var "dns::DomainNameService::Get_name_to_address")
                    (deref Î±0)))
                Î±1
                Î±2) in
          M.alloc Î±3 in
        let* _ :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref Î±0))) in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.read name in
          let* Î±4 := M.read caller in
          let* Î±5 := M.read old_address in
          let* Î±6 := M.read new_address in
          let* Î±7 :=
            M.call
              ((Ty.path "dns::Env")::["emit_event"]
                (borrow Î±2)
                (dns.Event.SetAddress
                  {|
                    dns.SetAddress.name := Î±3;
                    dns.SetAddress.from := Î±4;
                    dns.SetAddress.old_address := Î±5;
                    dns.SetAddress.new_address := Î±6;
                  |})) in
          M.alloc Î±7 in
        let* Î±0 := M.alloc (core.result.Result.Ok tt) in
        M.read Î±0)
    | _, _ => M.impossible
    end.
  
  (*
      pub fn transfer(&mut self, name: Hash, to: AccountId) -> Result<()> {
          let caller = self.env().caller();
          let owner = self.get_owner_or_default(name);
          if caller != owner {
              return Err(Error::CallerIsNotOwner);
          }
  
          let old_owner = self.name_to_owner.get(&name);
          self.name_to_owner.insert(name, to);
  
          self.env().emit_event(Event::Transfer(Transfer {
              name,
              from: caller,
              old_owner,
              new_owner: to,
          }));
  
          Ok(())
      }
  *)
  Definition transfer (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; name; to] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* to := M.alloc to in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple []; Ty.path "dns::Error"]) in
      M.catch_return
        (let* caller :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref Î±0))) in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.call ((Ty.path "dns::Env")::["caller"] (borrow Î±2)) in
          M.alloc Î±3 in
        let* owner :=
          let* Î±0 := M.read self in
          let* Î±1 := M.read name in
          let* Î±2 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["get_owner_or_default"]
                (borrow (deref Î±0))
                Î±1) in
          M.alloc Î±2 in
        let* _ :=
          let* Î±0 :=
            ltac:(M.get_method (fun â„ =>
              core.cmp.PartialEq.ne
                (Self := Ty.path "dns::AccountId")
                (Rhs := Ty.path "dns::AccountId")
                (Trait := â„))) in
          let* Î±1 := M.call (Î±0 (borrow caller) (borrow owner)) in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* Î±0 :=
              return_ (core.result.Result.Err dns.Error.CallerIsNotOwner) in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2
          else
            M.alloc tt in
        let* old_owner :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["get"]
                (borrow
                  ((M.var "dns::DomainNameService::Get_name_to_owner")
                    (deref Î±0)))
                (borrow name)) in
          M.alloc Î±1 in
        let* _ :=
          let* Î±0 := M.read self in
          let* Î±1 := M.read name in
          let* Î±2 := M.read to in
          let* Î±3 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["insert"]
                (borrow_mut
                  ((M.var "dns::DomainNameService::Get_name_to_owner")
                    (deref Î±0)))
                Î±1
                Î±2) in
          M.alloc Î±3 in
        let* _ :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref Î±0))) in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.read name in
          let* Î±4 := M.read caller in
          let* Î±5 := M.read old_owner in
          let* Î±6 := M.read to in
          let* Î±7 :=
            M.call
              ((Ty.path "dns::Env")::["emit_event"]
                (borrow Î±2)
                (dns.Event.Transfer
                  {|
                    dns.Transfer.name := Î±3;
                    dns.Transfer.from := Î±4;
                    dns.Transfer.old_owner := Î±5;
                    dns.Transfer.new_owner := Î±6;
                  |})) in
          M.alloc Î±7 in
        let* Î±0 := M.alloc (core.result.Result.Ok tt) in
        M.read Î±0)
    | _, _ => M.impossible
    end.
  
  (*
      fn get_address_or_default(&self, name: Hash) -> AccountId {
          self.name_to_address
              .get(&name)
              .unwrap_or(self.default_address)
      }
  *)
  Definition get_address_or_default (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; name] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* Î±0 := M.read self in
      let* Î±1 :=
        M.call
          ((Ty.apply
                (Ty.path "dns::Mapping")
                [Ty.apply (Ty.path "array") [Ty.path "u8"];
                  Ty.path "dns::AccountId"])::["get"]
            (borrow
              ((M.var "dns::DomainNameService::Get_name_to_address")
                (deref Î±0)))
            (borrow name)) in
      let* Î±2 := M.read self in
      let* Î±3 :=
        M.read
          ((M.var "dns::DomainNameService::Get_default_address") (deref Î±2)) in
      M.call
        ((Ty.apply
              (Ty.path "core::option::Option")
              [Ty.path "dns::AccountId"])::["unwrap_or"]
          Î±1
          Î±3)
    | _, _ => M.impossible
    end.
  
  (*
      pub fn get_address(&self, name: Hash) -> AccountId {
          self.get_address_or_default(name)
      }
  *)
  Definition get_address (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; name] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* Î±0 := M.read self in
      let* Î±1 := M.read name in
      M.call
        ((Ty.path "dns::DomainNameService")::["get_address_or_default"] Î±0 Î±1)
    | _, _ => M.impossible
    end.
  
  (*
      pub fn get_owner(&self, name: Hash) -> AccountId {
          self.get_owner_or_default(name)
      }
  *)
  Definition get_owner (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; name] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* Î±0 := M.read self in
      let* Î±1 := M.read name in
      M.call
        ((Ty.path "dns::DomainNameService")::["get_owner_or_default"] Î±0 Î±1)
    | _, _ => M.impossible
    end.
End Impl_dns_DomainNameService.
