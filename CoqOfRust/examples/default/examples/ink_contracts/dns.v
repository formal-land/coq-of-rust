(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* StructRecord
  {
    name := "Mapping";
    ty_params := [ "K"; "V" ];
    fields :=
      [
        ("_key", Ty.apply (Ty.path "core::marker::PhantomData") [ K ]);
        ("_value", Ty.apply (Ty.path "core::marker::PhantomData") [ V ])
      ];
  } *)

Module Impl_core_default_Default_for_dns_Mapping_K_V.
  Definition Self (K V : Ty.t) : Ty.t := Ty.apply (Ty.path "dns::Mapping") [ K; V ].
  
  (*
  Default
  *)
  Definition default (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self K V in
    match τ, α with
    | [], [] =>
      let* α0 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply (Ty.path "core::marker::PhantomData") [ K ])
          []
          "default"
          [] in
      let* α1 := M.call_closure α0 [] in
      let* α2 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply (Ty.path "core::marker::PhantomData") [ V ])
          []
          "default"
          [] in
      let* α3 := M.call_closure α2 [] in
      M.pure (Value.StructRecord "dns::Mapping" [ ("_key", α1); ("_value", α3) ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (K V : Ty.t),
    M.IsTraitInstance
      "core::default::Default"
      (Self K V)
      (* Trait polymorphic types *) []
      (* Instance *) [ ("default", InstanceField.Method (default K V)) ].
End Impl_core_default_Default_for_dns_Mapping_K_V.

Module Impl_dns_Mapping_K_V.
  Definition Self (K V : Ty.t) : Ty.t := Ty.apply (Ty.path "dns::Mapping") [ K; V ].
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Parameter contains : forall (K V : Ty.t), (list Ty.t) -> (list Value.t) -> M.
  
  Axiom AssociatedFunction_contains :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "contains" (contains K V).
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Parameter get : forall (K V : Ty.t), (list Ty.t) -> (list Value.t) -> M.
  
  Axiom AssociatedFunction_get :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "get" (get K V).
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Parameter insert : forall (K V : Ty.t), (list Ty.t) -> (list Value.t) -> M.
  
  Axiom AssociatedFunction_insert :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "insert" (insert K V).
  
  (*
      fn new() -> Mapping<K, V> {
          unimplemented!()
      }
  *)
  Parameter new : forall (K V : Ty.t), (list Ty.t) -> (list Value.t) -> M.
  
  Axiom AssociatedFunction_new :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "new" (new K V).
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Parameter remove : forall (K V : Ty.t), (list Ty.t) -> (list Value.t) -> M.
  
  Axiom AssociatedFunction_remove :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "remove" (remove K V).
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Parameter size : forall (K V : Ty.t), (list Ty.t) -> (list Value.t) -> M.
  
  Axiom AssociatedFunction_size :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "size" (size K V).
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Parameter take : forall (K V : Ty.t), (list Ty.t) -> (list Value.t) -> M.
  
  Axiom AssociatedFunction_take :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "take" (take K V).
End Impl_dns_Mapping_K_V.

(* StructTuple
  {
    name := "AccountId";
    ty_params := [];
    fields := [ Ty.path "u128" ];
  } *)

Module Impl_core_default_Default_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
  Default
  *)
  Definition default (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* α0 := M.get_trait_method "core::default::Default" (Ty.path "u128") [] "default" [] in
      let* α1 := M.call_closure α0 [] in M.pure (Value.StructTuple "dns::AccountId" [ α1 ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_dns_AccountId.

Module Impl_core_clone_Clone_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
  Clone
  *)
  Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.match_operator Value.DeclaredButUndefined [ fun γ => M.read self ] in M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_dns_AccountId.

Module Impl_core_marker_Copy_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  Axiom Implements :
    M.IsTraitInstance "core::marker::Copy" Self (* Trait polymorphic types *) [] (* Instance *) [].
End Impl_core_marker_Copy_for_dns_AccountId.

Module Impl_core_marker_StructuralPartialEq_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_dns_AccountId.

Module Impl_core_cmp_PartialEq_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
  PartialEq
  *)
  Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 := M.read self in
      let* α1 := M.read (M.get_struct_tuple_field α0 "dns::AccountId" 0) in
      let* α2 := M.read other in
      let* α3 := M.read (M.get_struct_tuple_field α2 "dns::AccountId" 0) in
      M.pure (BinOp.Pure.eq α1 α3)
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_for_dns_AccountId.

Module Impl_core_convert_From_array_u8_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
      fn from(_value: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Parameter from : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      Self
      (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
      (* Instance *) [ ("from", InstanceField.Method from) ].
End Impl_core_convert_From_array_u8_for_dns_AccountId.

Axiom Balance : (Ty.path "dns::Balance") = (Ty.path "u128").

Axiom Hash : (Ty.path "dns::Hash") = (Ty.apply (Ty.path "array") [ Ty.path "u8" ]).

(* StructRecord
  {
    name := "Env";
    ty_params := [];
    fields := [ ("caller", Ty.path "dns::AccountId") ];
  } *)

(* StructRecord
  {
    name := "Register";
    ty_params := [];
    fields :=
      [ ("name", Ty.apply (Ty.path "array") [ Ty.path "u8" ]); ("from", Ty.path "dns::AccountId") ];
  } *)

(* StructRecord
  {
    name := "SetAddress";
    ty_params := [];
    fields :=
      [
        ("name", Ty.apply (Ty.path "array") [ Ty.path "u8" ]);
        ("from", Ty.path "dns::AccountId");
        ("old_address", Ty.apply (Ty.path "core::option::Option") [ Ty.path "dns::AccountId" ]);
        ("new_address", Ty.path "dns::AccountId")
      ];
  } *)

(* StructRecord
  {
    name := "Transfer";
    ty_params := [];
    fields :=
      [
        ("name", Ty.apply (Ty.path "array") [ Ty.path "u8" ]);
        ("from", Ty.path "dns::AccountId");
        ("old_owner", Ty.apply (Ty.path "core::option::Option") [ Ty.path "dns::AccountId" ]);
        ("new_owner", Ty.path "dns::AccountId")
      ];
  } *)

(* Enum Event *)
(* {
  ty_params := [];
  variants :=
    [
      {
        name := "Register";
        item := StructTuple [ Ty.path "dns::Register" ];
        discriminant := None;
      };
      {
        name := "SetAddress";
        item := StructTuple [ Ty.path "dns::SetAddress" ];
        discriminant := None;
      };
      {
        name := "Transfer";
        item := StructTuple [ Ty.path "dns::Transfer" ];
        discriminant := None;
      }
    ];
} *)

Module Impl_dns_Env.
  Definition Self : Ty.t := Ty.path "dns::Env".
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in M.read (M.get_struct_record_field α0 "dns::Env" "caller")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_caller : M.IsAssociatedFunction Self "caller" caller.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Parameter emit_event : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom AssociatedFunction_emit_event : M.IsAssociatedFunction Self "emit_event" emit_event.
End Impl_dns_Env.

(* StructRecord
  {
    name := "DomainNameService";
    ty_params := [];
    fields :=
      [
        ("name_to_address",
          Ty.apply
            (Ty.path "dns::Mapping")
            [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ]);
        ("name_to_owner",
          Ty.apply
            (Ty.path "dns::Mapping")
            [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ]);
        ("default_address", Ty.path "dns::AccountId")
      ];
  } *)

(*
fn zero_address() -> AccountId {
    [0u8; 32].into()
}
*)
Definition zero_address (τ : list Ty.t) (α : list Value.t) : M :=
  match τ, α with
  | [], [] =>
    let* α0 :=
      M.get_trait_method
        "core::convert::Into"
        (Ty.apply (Ty.path "array") [ Ty.path "u8" ])
        [ Ty.path "dns::AccountId" ]
        "into"
        [] in
    M.call_closure α0 [ repeat (Value.Integer Integer.U8 0) 32 ]
  | _, _ => M.impossible
  end.

Module Impl_core_default_Default_for_dns_DomainNameService.
  Definition Self : Ty.t := Ty.path "dns::DomainNameService".
  
  (*
      fn default() -> Self {
          let mut name_to_address = Mapping::new();
          name_to_address.insert(Hash::default(), zero_address());
          let mut name_to_owner = Mapping::new();
          name_to_owner.insert(Hash::default(), zero_address());
  
          Self {
              name_to_address,
              name_to_owner,
              default_address: zero_address(),
          }
      }
  *)
  Definition default (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* name_to_address :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "dns::Mapping")
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
            "new"
            [] in
        let* α1 := M.call_closure α0 [] in M.alloc α1 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "dns::Mapping")
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
            "insert"
            [] in
        let* α1 :=
          M.get_trait_method
            "core::default::Default"
            (Ty.apply (Ty.path "array") [ Ty.path "u8" ])
            []
            "default"
            [] in
        let* α2 := M.call_closure α1 [] in
        let* α3 := M.get_function "dns::zero_address" [] in
        let* α4 := M.call_closure α3 [] in
        let* α5 := M.call_closure α0 [ name_to_address; α2; α4 ] in M.alloc α5 in
      let* name_to_owner :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "dns::Mapping")
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
            "new"
            [] in
        let* α1 := M.call_closure α0 [] in M.alloc α1 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "dns::Mapping")
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
            "insert"
            [] in
        let* α1 :=
          M.get_trait_method
            "core::default::Default"
            (Ty.apply (Ty.path "array") [ Ty.path "u8" ])
            []
            "default"
            [] in
        let* α2 := M.call_closure α1 [] in
        let* α3 := M.get_function "dns::zero_address" [] in
        let* α4 := M.call_closure α3 [] in
        let* α5 := M.call_closure α0 [ name_to_owner; α2; α4 ] in M.alloc α5 in
      let* α0 := M.read name_to_address in
      let* α1 := M.read name_to_owner in
      let* α2 := M.get_function "dns::zero_address" [] in
      let* α3 := M.call_closure α2 [] in
      let* α0 :=
        M.alloc
          (Value.StructRecord
            "dns::DomainNameService"
            [ ("name_to_address", α0); ("name_to_owner", α1); ("default_address", α3) ]) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_dns_DomainNameService.

(* Enum Error *)
(* {
  ty_params := [];
  variants :=
    [
      {
        name := "NameAlreadyExists";
        item := StructTuple [];
        discriminant := None;
      };
      {
        name := "CallerIsNotOwner";
        item := StructTuple [];
        discriminant := None;
      }
    ];
} *)

Module Impl_core_marker_StructuralPartialEq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_dns_Error.

Module Impl_core_cmp_PartialEq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  (*
  PartialEq
  *)
  Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* __self_tag :=
        let* α0 := M.get_function "core::intrinsics::discriminant_value" [ Ty.path "dns::Error" ] in
        let* α1 := M.read self in let* α2 := M.call_closure α0 [ α1 ] in M.alloc α2 in
      let* __arg1_tag :=
        let* α0 := M.get_function "core::intrinsics::discriminant_value" [ Ty.path "dns::Error" ] in
        let* α1 := M.read other in let* α2 := M.call_closure α0 [ α1 ] in M.alloc α2 in
      let* α0 := M.read __self_tag in
      let* α1 := M.read __arg1_tag in let* α0 := M.alloc (BinOp.Pure.eq α0 α1) in M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_for_dns_Error.

Module Impl_core_marker_StructuralEq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralEq_for_dns_Error.

Module Impl_core_cmp_Eq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] => let* self := M.alloc self in M.pure (Value.Tuple [])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Eq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
End Impl_core_cmp_Eq_for_dns_Error.

Axiom Result :
  forall (T : Ty.t),
  (Ty.apply (Ty.path "dns::Result") [ T ]) =
    (Ty.apply (Ty.path "core::result::Result") [ T; Ty.path "dns::Error" ]).

Module Impl_dns_DomainNameService.
  Definition Self : Ty.t := Ty.path "dns::DomainNameService".
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Parameter init_env : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom AssociatedFunction_init_env : M.IsAssociatedFunction Self "init_env" init_env.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.get_associated_function (Ty.path "dns::DomainNameService") "init_env" [] in
      M.call_closure α0 []
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_env : M.IsAssociatedFunction Self "env" env.
  
  (*
      pub fn new() -> Self {
          Default::default()
      }
  *)
  Definition new (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* α0 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.path "dns::DomainNameService")
          []
          "default"
          [] in
      M.call_closure α0 []
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
  
  (*
      pub fn register(&mut self, name: Hash) -> Result<()> {
          let caller = self.env().caller();
          if self.name_to_owner.contains(&name) {
              return Err(Error::NameAlreadyExists);
          }
  
          self.name_to_owner.insert(name, caller);
          self.env()
              .emit_event(Event::Register(Register { name, from: caller }));
  
          Ok(())
      }
  *)
  Definition register (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; name ] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* caller :=
        let* α0 := M.get_associated_function (Ty.path "dns::Env") "caller" [] in
        let* α1 := M.get_associated_function (Ty.path "dns::DomainNameService") "env" [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in let* α5 := M.call_closure α0 [ α4 ] in M.alloc α5 in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply
                      (Ty.path "dns::Mapping")
                      [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
                    "contains"
                    [] in
                let* α1 := M.read self in
                let* α2 :=
                  M.call_closure
                    α0
                    [ M.get_struct_record_field α1 "dns::DomainNameService" "name_to_owner"; name
                    ] in
                let* α3 := M.alloc α2 in M.pure (M.use α3) in
              let* _ := let* α0 := M.read γ in M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.return_
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "dns::Error::NameAlreadyExists" [] ]) in
              let* α1 := M.read α0 in let* α2 := M.never_to_any α1 in M.alloc α2;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "dns::Mapping")
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
            "insert"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read name in
        let* α3 := M.read caller in
        let* α4 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "dns::DomainNameService" "name_to_owner"; α2; α3 ] in
        M.alloc α4 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "dns::Env") "emit_event" [] in
        let* α1 := M.get_associated_function (Ty.path "dns::DomainNameService") "env" [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read name in
        let* α6 := M.read caller in
        let* α7 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "dns::Event::Register"
                [ Value.StructRecord "dns::Register" [ ("name", α5); ("from", α6) ] ]
            ] in
        M.alloc α7 in
      let* α0 := M.alloc (Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_register : M.IsAssociatedFunction Self "register" register.
  
  (*
      fn get_owner_or_default(&self, name: Hash) -> AccountId {
          self.name_to_owner
              .get(&name)
              .unwrap_or(self.default_address)
      }
  *)
  Definition get_owner_or_default (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; name ] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* α0 :=
        M.get_associated_function
          (Ty.apply (Ty.path "core::option::Option") [ Ty.path "dns::AccountId" ])
          "unwrap_or"
          [] in
      let* α1 :=
        M.get_associated_function
          (Ty.apply
            (Ty.path "dns::Mapping")
            [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
          "get"
          [] in
      let* α2 := M.read self in
      let* α3 :=
        M.call_closure
          α1
          [ M.get_struct_record_field α2 "dns::DomainNameService" "name_to_owner"; name ] in
      let* α4 := M.read self in
      let* α5 := M.read (M.get_struct_record_field α4 "dns::DomainNameService" "default_address") in
      M.call_closure α0 [ α3; α5 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_owner_or_default :
    M.IsAssociatedFunction Self "get_owner_or_default" get_owner_or_default.
  
  (*
      pub fn set_address(&mut self, name: Hash, new_address: AccountId) -> Result<()> {
          let caller = self.env().caller();
          let owner = self.get_owner_or_default(name);
          if caller != owner {
              return Err(Error::CallerIsNotOwner);
          }
  
          let old_address = self.name_to_address.get(&name);
          self.name_to_address.insert(name, new_address);
  
          self.env().emit_event(Event::SetAddress(SetAddress {
              name,
              from: caller,
              old_address,
              new_address,
          }));
          Ok(())
      }
  *)
  Definition set_address (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; name; new_address ] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* new_address := M.alloc new_address in
      let* caller :=
        let* α0 := M.get_associated_function (Ty.path "dns::Env") "caller" [] in
        let* α1 := M.get_associated_function (Ty.path "dns::DomainNameService") "env" [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in let* α5 := M.call_closure α0 [ α4 ] in M.alloc α5 in
      let* owner :=
        let* α0 :=
          M.get_associated_function (Ty.path "dns::DomainNameService") "get_owner_or_default" [] in
        let* α1 := M.read self in
        let* α2 := M.read name in let* α3 := M.call_closure α0 [ α1; α2 ] in M.alloc α3 in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_trait_method
                    "core::cmp::PartialEq"
                    (Ty.path "dns::AccountId")
                    [ Ty.path "dns::AccountId" ]
                    "ne"
                    [] in
                let* α1 := M.call_closure α0 [ caller; owner ] in
                let* α2 := M.alloc α1 in M.pure (M.use α2) in
              let* _ := let* α0 := M.read γ in M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.return_
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "dns::Error::CallerIsNotOwner" [] ]) in
              let* α1 := M.read α0 in let* α2 := M.never_to_any α1 in M.alloc α2;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* old_address :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "dns::Mapping")
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
            "get"
            [] in
        let* α1 := M.read self in
        let* α2 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "dns::DomainNameService" "name_to_address"; name ] in
        M.alloc α2 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "dns::Mapping")
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
            "insert"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read name in
        let* α3 := M.read new_address in
        let* α4 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "dns::DomainNameService" "name_to_address"; α2; α3 ] in
        M.alloc α4 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "dns::Env") "emit_event" [] in
        let* α1 := M.get_associated_function (Ty.path "dns::DomainNameService") "env" [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read name in
        let* α6 := M.read caller in
        let* α7 := M.read old_address in
        let* α8 := M.read new_address in
        let* α9 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "dns::Event::SetAddress"
                [
                  Value.StructRecord
                    "dns::SetAddress"
                    [ ("name", α5); ("from", α6); ("old_address", α7); ("new_address", α8) ]
                ]
            ] in
        M.alloc α9 in
      let* α0 := M.alloc (Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_set_address : M.IsAssociatedFunction Self "set_address" set_address.
  
  (*
      pub fn transfer(&mut self, name: Hash, to: AccountId) -> Result<()> {
          let caller = self.env().caller();
          let owner = self.get_owner_or_default(name);
          if caller != owner {
              return Err(Error::CallerIsNotOwner);
          }
  
          let old_owner = self.name_to_owner.get(&name);
          self.name_to_owner.insert(name, to);
  
          self.env().emit_event(Event::Transfer(Transfer {
              name,
              from: caller,
              old_owner,
              new_owner: to,
          }));
  
          Ok(())
      }
  *)
  Definition transfer (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; name; to ] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* to := M.alloc to in
      let* caller :=
        let* α0 := M.get_associated_function (Ty.path "dns::Env") "caller" [] in
        let* α1 := M.get_associated_function (Ty.path "dns::DomainNameService") "env" [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in let* α5 := M.call_closure α0 [ α4 ] in M.alloc α5 in
      let* owner :=
        let* α0 :=
          M.get_associated_function (Ty.path "dns::DomainNameService") "get_owner_or_default" [] in
        let* α1 := M.read self in
        let* α2 := M.read name in let* α3 := M.call_closure α0 [ α1; α2 ] in M.alloc α3 in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_trait_method
                    "core::cmp::PartialEq"
                    (Ty.path "dns::AccountId")
                    [ Ty.path "dns::AccountId" ]
                    "ne"
                    [] in
                let* α1 := M.call_closure α0 [ caller; owner ] in
                let* α2 := M.alloc α1 in M.pure (M.use α2) in
              let* _ := let* α0 := M.read γ in M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.return_
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "dns::Error::CallerIsNotOwner" [] ]) in
              let* α1 := M.read α0 in let* α2 := M.never_to_any α1 in M.alloc α2;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* old_owner :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "dns::Mapping")
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
            "get"
            [] in
        let* α1 := M.read self in
        let* α2 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "dns::DomainNameService" "name_to_owner"; name ] in
        M.alloc α2 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "dns::Mapping")
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
            "insert"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read name in
        let* α3 := M.read to in
        let* α4 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "dns::DomainNameService" "name_to_owner"; α2; α3 ] in
        M.alloc α4 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "dns::Env") "emit_event" [] in
        let* α1 := M.get_associated_function (Ty.path "dns::DomainNameService") "env" [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read name in
        let* α6 := M.read caller in
        let* α7 := M.read old_owner in
        let* α8 := M.read to in
        let* α9 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "dns::Event::Transfer"
                [
                  Value.StructRecord
                    "dns::Transfer"
                    [ ("name", α5); ("from", α6); ("old_owner", α7); ("new_owner", α8) ]
                ]
            ] in
        M.alloc α9 in
      let* α0 := M.alloc (Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_transfer : M.IsAssociatedFunction Self "transfer" transfer.
  
  (*
      fn get_address_or_default(&self, name: Hash) -> AccountId {
          self.name_to_address
              .get(&name)
              .unwrap_or(self.default_address)
      }
  *)
  Definition get_address_or_default (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; name ] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* α0 :=
        M.get_associated_function
          (Ty.apply (Ty.path "core::option::Option") [ Ty.path "dns::AccountId" ])
          "unwrap_or"
          [] in
      let* α1 :=
        M.get_associated_function
          (Ty.apply
            (Ty.path "dns::Mapping")
            [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.path "dns::AccountId" ])
          "get"
          [] in
      let* α2 := M.read self in
      let* α3 :=
        M.call_closure
          α1
          [ M.get_struct_record_field α2 "dns::DomainNameService" "name_to_address"; name ] in
      let* α4 := M.read self in
      let* α5 := M.read (M.get_struct_record_field α4 "dns::DomainNameService" "default_address") in
      M.call_closure α0 [ α3; α5 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_address_or_default :
    M.IsAssociatedFunction Self "get_address_or_default" get_address_or_default.
  
  (*
      pub fn get_address(&self, name: Hash) -> AccountId {
          self.get_address_or_default(name)
      }
  *)
  Definition get_address (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; name ] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* α0 :=
        M.get_associated_function (Ty.path "dns::DomainNameService") "get_address_or_default" [] in
      let* α1 := M.read self in let* α2 := M.read name in M.call_closure α0 [ α1; α2 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_address : M.IsAssociatedFunction Self "get_address" get_address.
  
  (*
      pub fn get_owner(&self, name: Hash) -> AccountId {
          self.get_owner_or_default(name)
      }
  *)
  Definition get_owner (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; name ] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* α0 :=
        M.get_associated_function (Ty.path "dns::DomainNameService") "get_owner_or_default" [] in
      let* α1 := M.read self in let* α2 := M.read name in M.call_closure α0 [ α1; α2 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_owner : M.IsAssociatedFunction Self "get_owner" get_owner.
End Impl_dns_DomainNameService.
