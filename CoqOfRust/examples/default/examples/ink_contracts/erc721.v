(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Definition Get__key :=
    Ref.map (fun α => Some α.(_key)) (fun β α => Some (α <| _key := β |>)).
  Definition Get__value :=
    Ref.map (fun α => Some α.(_value)) (fun β α => Some (α <| _value := β |>)).
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_erc721_Mapping_t_K_V.
Section Impl_core_default_Default_for_erc721_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := erc721.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (erc721.Mapping.t K V) :=
    let* α0 : M (core.marker.PhantomData.t K) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := core.marker.PhantomData.t K)
          (Trait := ℐ))) in
    let* α1 : core.marker.PhantomData.t K := M.call α0 in
    let* α2 : M (core.marker.PhantomData.t V) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := core.marker.PhantomData.t V)
          (Trait := ℐ))) in
    let* α3 : core.marker.PhantomData.t V := M.call α2 in
    M.pure {| erc721.Mapping._key := α1; erc721.Mapping._value := α3; |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_Mapping_t_K_V.
End Impl_core_default_Default_for_erc721_Mapping_t_K_V.

Module  Impl_erc721_Mapping_t_K_V.
Section Impl_erc721_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := erc721.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref Self) (_key : ref K) : M bool.t :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref Self) (_key : K) : M unit :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref Self)
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon Self "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (self : ref Self) (_key : K) : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_erc721_Mapping_t_K_V.
End Impl_erc721_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_erc721_AccountId_t.
Section Impl_core_default_Default_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M erc721.AccountId.t :=
    let* α0 : M u128.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := u128.t) (Trait := ℐ))) in
    let* α1 : u128.t := M.call α0 in
    M.pure (erc721.AccountId.Build_t α1).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_AccountId_t.
End Impl_core_default_Default_for_erc721_AccountId_t.

Module  Impl_core_clone_Clone_for_erc721_AccountId_t.
Section Impl_core_clone_Clone_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M erc721.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : M.Val erc721.AccountId.t :=
      match_operator
        (DeclaredButUndefinedVariable
          (A := core.clone.AssertParamIsClone.t u128.t))
        [
          fun γ =>
            (let* α0 : ref erc721.AccountId.t := M.read self in
            M.pure (deref α0)) :
            M (M.Val erc721.AccountId.t)
        ] in
    M.read α0.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_erc721_AccountId_t.
End Impl_core_clone_Clone_for_erc721_AccountId_t.

Module  Impl_core_marker_Copy_for_erc721_AccountId_t.
Section Impl_core_marker_Copy_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_erc721_AccountId_t.
End Impl_core_marker_Copy_for_erc721_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
Section Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref erc721.AccountId.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : ref erc721.AccountId.t := M.read self in
    let* α1 : u128.t := M.read (erc721.AccountId.Get_0 (deref α0)) in
    let* α2 : ref erc721.AccountId.t := M.read other in
    let* α3 : u128.t := M.read (erc721.AccountId.Get_0 (deref α2)) in
    M.pure (BinOp.Pure.eq α1 α3).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
End Impl_core_cmp_PartialEq_for_erc721_AccountId_t.

Module  Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
Section Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
      fn from(_value: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Definition from (_value : array u8.t) : M Self :=
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := array u8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
End Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : erc721.AccountId.t;
  }.
  
  Definition Get_caller :=
    Ref.map (fun α => Some α.(caller)) (fun β α => Some (α <| caller := β |>)).
End Env.
End Env.

Ltac TokenId := exact u32.t.

Module  Erc721.
Section Erc721.
  Record t : Set := {
    token_owner : erc721.Mapping.t ltac:(erc721.TokenId) erc721.AccountId.t;
    token_approvals : erc721.Mapping.t ltac:(erc721.TokenId) erc721.AccountId.t;
    owned_tokens_count : erc721.Mapping.t erc721.AccountId.t u32.t;
    operator_approvals :
      erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit;
  }.
  
  Definition Get_token_owner :=
    Ref.map
      (fun α => Some α.(token_owner))
      (fun β α => Some (α <| token_owner := β |>)).
  Definition Get_token_approvals :=
    Ref.map
      (fun α => Some α.(token_approvals))
      (fun β α => Some (α <| token_approvals := β |>)).
  Definition Get_owned_tokens_count :=
    Ref.map
      (fun α => Some α.(owned_tokens_count))
      (fun β α => Some (α <| owned_tokens_count := β |>)).
  Definition Get_operator_approvals :=
    Ref.map
      (fun α => Some α.(operator_approvals))
      (fun β α => Some (α <| operator_approvals := β |>)).
End Erc721.
End Erc721.

Module  Impl_core_default_Default_for_erc721_Erc721_t.
Section Impl_core_default_Default_for_erc721_Erc721_t.
  Definition Self : Set := erc721.Erc721.t.
  
  (*
  Default
  *)
  Definition default : M erc721.Erc721.t :=
    let* α0 : M (erc721.Mapping.t u32.t erc721.AccountId.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := erc721.Mapping.t u32.t erc721.AccountId.t)
          (Trait := ℐ))) in
    let* α1 : erc721.Mapping.t u32.t erc721.AccountId.t := M.call α0 in
    let* α2 : M (erc721.Mapping.t u32.t erc721.AccountId.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := erc721.Mapping.t u32.t erc721.AccountId.t)
          (Trait := ℐ))) in
    let* α3 : erc721.Mapping.t u32.t erc721.AccountId.t := M.call α2 in
    let* α4 : M (erc721.Mapping.t erc721.AccountId.t u32.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := erc721.Mapping.t erc721.AccountId.t u32.t)
          (Trait := ℐ))) in
    let* α5 : erc721.Mapping.t erc721.AccountId.t u32.t := M.call α4 in
    let* α6 :
        M (erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self :=
            erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit)
          (Trait := ℐ))) in
    let* α7 : erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit :=
      M.call α6 in
    M.pure
      {|
        erc721.Erc721.token_owner := α1;
        erc721.Erc721.token_approvals := α3;
        erc721.Erc721.owned_tokens_count := α5;
        erc721.Erc721.operator_approvals := α7;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_Erc721_t.
End Impl_core_default_Default_for_erc721_Erc721_t.

Module Error.
  Inductive t : Set :=
  | NotOwner
  | NotApproved
  | TokenExists
  | TokenNotFound
  | CannotInsert
  | CannotFetchValue
  | NotAllowed.
End Error.

Module  Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
Section Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
End Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.

Module  Impl_core_cmp_PartialEq_for_erc721_Error_t.
Section Impl_core_cmp_PartialEq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref erc721.Error.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* __self_tag : M.Val isize.t :=
      let* α0 : ref erc721.Error.t := M.read self in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* __arg1_tag : M.Val isize.t :=
      let* α0 : ref erc721.Error.t := M.read other in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* α0 : isize.t := M.read __self_tag in
    let* α1 : isize.t := M.read __arg1_tag in
    let* α0 : M.Val bool.t := M.alloc (BinOp.Pure.eq α0 α1) in
    M.read α0.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_erc721_Error_t.
End Impl_core_cmp_PartialEq_for_erc721_Error_t.

Module  Impl_core_marker_StructuralEq_for_erc721_Error_t.
Section Impl_core_marker_StructuralEq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_erc721_Error_t.
End Impl_core_marker_StructuralEq_for_erc721_Error_t.

Module  Impl_core_cmp_Eq_for_erc721_Error_t.
Section Impl_core_cmp_Eq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.pure tt.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_erc721_Error_t.
End Impl_core_cmp_Eq_for_erc721_Error_t.

Module  Impl_core_clone_Clone_for_erc721_Error_t.
Section Impl_core_clone_Clone_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M erc721.Error.t :=
    let* self := M.alloc self in
    let* α0 : ref erc721.Error.t := M.read self in
    M.read (deref α0).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_erc721_Error_t.
End Impl_core_clone_Clone_for_erc721_Error_t.

Module  Impl_core_marker_Copy_for_erc721_Error_t.
Section Impl_core_marker_Copy_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_erc721_Error_t.
End Impl_core_marker_Copy_for_erc721_Error_t.

Module  Transfer.
Section Transfer.
  Record t : Set := {
    from : core.option.Option.t erc721.AccountId.t;
    to : core.option.Option.t erc721.AccountId.t;
    id : ltac:(erc721.TokenId);
  }.
  
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
  Definition Get_to :=
    Ref.map (fun α => Some α.(to)) (fun β α => Some (α <| to := β |>)).
  Definition Get_id :=
    Ref.map (fun α => Some α.(id)) (fun β α => Some (α <| id := β |>)).
End Transfer.
End Transfer.

Module  Approval.
Section Approval.
  Record t : Set := {
    from : erc721.AccountId.t;
    to : erc721.AccountId.t;
    id : ltac:(erc721.TokenId);
  }.
  
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
  Definition Get_to :=
    Ref.map (fun α => Some α.(to)) (fun β α => Some (α <| to := β |>)).
  Definition Get_id :=
    Ref.map (fun α => Some α.(id)) (fun β α => Some (α <| id := β |>)).
End Approval.
End Approval.

Module  ApprovalForAll.
Section ApprovalForAll.
  Record t : Set := {
    owner : erc721.AccountId.t;
    operator : erc721.AccountId.t;
    approved : bool.t;
  }.
  
  Definition Get_owner :=
    Ref.map (fun α => Some α.(owner)) (fun β α => Some (α <| owner := β |>)).
  Definition Get_operator :=
    Ref.map
      (fun α => Some α.(operator))
      (fun β α => Some (α <| operator := β |>)).
  Definition Get_approved :=
    Ref.map
      (fun α => Some α.(approved))
      (fun β α => Some (α <| approved := β |>)).
End ApprovalForAll.
End ApprovalForAll.

Module Event.
  Inductive t : Set :=
  | Transfer (_ : erc721.Transfer.t)
  | Approval (_ : erc721.Approval.t)
  | ApprovalForAll (_ : erc721.ApprovalForAll.t).
  
  Definition Get_Transfer_0 :=
    Ref.map
      (fun α => match α with | Transfer α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Transfer _ => Some (Transfer β) | _ => None end).
  
  Definition Get_Approval_0 :=
    Ref.map
      (fun α => match α with | Approval α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Approval _ => Some (Approval β) | _ => None end).
  
  Definition Get_ApprovalForAll_0 :=
    Ref.map
      (fun α => match α with | ApprovalForAll α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | ApprovalForAll _ => Some (ApprovalForAll β)
        | _ => None
        end).
End Event.

Module  Impl_erc721_Env_t.
Section Impl_erc721_Env_t.
  Definition Self : Set := erc721.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (self : ref Self) : M erc721.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref erc721.Env.t := M.read self in
    M.read (erc721.Env.Get_caller (deref α0)).
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (self : ref Self) (_event : erc721.Event.t) : M unit :=
    let* self := M.alloc self in
    let* _event := M.alloc _event in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_emit_event :
    Notations.DoubleColon Self "emit_event" := {
    Notations.double_colon := emit_event;
  }.
End Impl_erc721_Env_t.
End Impl_erc721_Env_t.

Module  Impl_erc721_Erc721_t.
Section Impl_erc721_Erc721_t.
  Definition Self : Set := erc721.Erc721.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M erc721.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (self : ref Self) : M erc721.Env.t :=
    let* self := M.alloc self in
    M.call erc721.Erc721.t::["init_env"].
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new() -> Self {
          Default::default()
      }
  *)
  Definition new : M Self :=
    let* α0 : M erc721.Erc721.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := erc721.Erc721.t) (Trait := ℐ))) in
    M.call α0.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn balance_of_or_zero(&self, of: &AccountId) -> u32 {
          self.owned_tokens_count.get(of).unwrap_or(0 as u32)
      }
  *)
  Definition balance_of_or_zero
      (self : ref Self)
      (of : ref erc721.AccountId.t)
      : M u32.t :=
    let* self := M.alloc self in
    let* of := M.alloc of in
    let* α0 : ref erc721.Erc721.t := M.read self in
    let* α1 : ref erc721.AccountId.t := M.read of in
    let* α2 : core.option.Option.t u32.t :=
      M.call
        ((erc721.Mapping.t erc721.AccountId.t u32.t)::["get"]
          (borrow (erc721.Erc721.Get_owned_tokens_count (deref α0)))
          α1) in
    let* α3 : M.Val u32.t := M.alloc ((Integer.of_Z 0) : u32.t) in
    let* α4 : u32.t := M.read (use α3) in
    M.call ((core.option.Option.t u32.t)::["unwrap_or"] α2 α4).
  
  Global Instance AssociatedFunction_balance_of_or_zero :
    Notations.DoubleColon Self "balance_of_or_zero" := {
    Notations.double_colon := balance_of_or_zero;
  }.
  
  (*
      fn clear_approval(&mut self, id: TokenId) {
          self.token_approvals.remove(id);
      }
  *)
  Definition clear_approval
      (self : mut_ref Self)
      (id : ltac:(erc721.TokenId))
      : M unit :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref erc721.Erc721.t := M.read self in
      let* α1 : u32.t := M.read id in
      let* α2 : unit :=
        M.call
          ((erc721.Mapping.t u32.t erc721.AccountId.t)::["remove"]
            (borrow (erc721.Erc721.Get_token_approvals (deref α0)))
            α1) in
      M.alloc α2 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_clear_approval :
    Notations.DoubleColon Self "clear_approval" := {
    Notations.double_colon := clear_approval;
  }.
  
  (*
      fn approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {
          self.operator_approvals.contains(&(owner, operator))
      }
  *)
  Definition approved_for_all
      (self : ref Self)
      (owner : erc721.AccountId.t)
      (operator : erc721.AccountId.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* operator := M.alloc operator in
    let* α0 : ref erc721.Erc721.t := M.read self in
    let* α1 : erc721.AccountId.t := M.read owner in
    let* α2 : erc721.AccountId.t := M.read operator in
    let* α3 : M.Val (erc721.AccountId.t * erc721.AccountId.t) :=
      M.alloc (α1, α2) in
    M.call
      ((erc721.Mapping.t
            (erc721.AccountId.t * erc721.AccountId.t)
            unit)::["contains"]
        (borrow (erc721.Erc721.Get_operator_approvals (deref α0)))
        (borrow α3)).
  
  Global Instance AssociatedFunction_approved_for_all :
    Notations.DoubleColon Self "approved_for_all" := {
    Notations.double_colon := approved_for_all;
  }.
  
  (*
      pub fn owner_of(&self, id: TokenId) -> Option<AccountId> {
          self.token_owner.get(&id)
      }
  *)
  Definition owner_of
      (self : ref Self)
      (id : ltac:(erc721.TokenId))
      : M (core.option.Option.t erc721.AccountId.t) :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call
      ((erc721.Mapping.t u32.t erc721.AccountId.t)::["get"]
        (borrow (erc721.Erc721.Get_token_owner (deref α0)))
        (borrow id)).
  
  Global Instance AssociatedFunction_owner_of :
    Notations.DoubleColon Self "owner_of" := {
    Notations.double_colon := owner_of;
  }.
  
  (*
      fn approved_or_owner(&self, from: Option<AccountId>, id: TokenId) -> bool {
          let owner = self.owner_of(id);
          from != Some(AccountId::from([0x0; 32]))
              && (from == owner
                  || from == self.token_approvals.get(&id)
                  || self.approved_for_all(
                      owner.expect("Error with AccountId"),
                      from.expect("Error with AccountId"),
                  ))
      }
  *)
  Definition approved_or_owner
      (self : ref Self)
      (from : core.option.Option.t erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M bool.t :=
    let* self := M.alloc self in
    let* from := M.alloc from in
    let* id := M.alloc id in
    let* owner : M.Val (core.option.Option.t erc721.AccountId.t) :=
      let* α0 : ref erc721.Erc721.t := M.read self in
      let* α1 : u32.t := M.read id in
      let* α2 : core.option.Option.t erc721.AccountId.t :=
        M.call (erc721.Erc721.t::["owner_of"] α0 α1) in
      M.alloc α2 in
    let* α0 :
        (ref (core.option.Option.t erc721.AccountId.t)) ->
          (ref (core.option.Option.t erc721.AccountId.t)) ->
          M bool.t :=
      ltac:(M.get_method (fun ℐ =>
        core.cmp.PartialEq.ne
          (Self := core.option.Option.t erc721.AccountId.t)
          (Rhs := core.option.Option.t erc721.AccountId.t)
          (Trait := ℐ))) in
    let* α1 : (array u8.t) -> M erc721.AccountId.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.From.from
          (Self := erc721.AccountId.t)
          (T := array u8.t)
          (Trait := ℐ))) in
    let* α2 : erc721.AccountId.t :=
      M.call (α1 (repeat ((Integer.of_Z 0) : u8.t) 32)) in
    let* α3 : M.Val (core.option.Option.t erc721.AccountId.t) :=
      M.alloc (core.option.Option.Some α2) in
    let* α4 : bool.t := M.call (α0 (borrow from) (borrow α3)) in
    let* α5 :
        (ref (core.option.Option.t erc721.AccountId.t)) ->
          (ref (core.option.Option.t erc721.AccountId.t)) ->
          M bool.t :=
      ltac:(M.get_method (fun ℐ =>
        core.cmp.PartialEq.eq
          (Self := core.option.Option.t erc721.AccountId.t)
          (Rhs := core.option.Option.t erc721.AccountId.t)
          (Trait := ℐ))) in
    let* α6 : bool.t := M.call (α5 (borrow from) (borrow owner)) in
    let* α7 :
        (ref (core.option.Option.t erc721.AccountId.t)) ->
          (ref (core.option.Option.t erc721.AccountId.t)) ->
          M bool.t :=
      ltac:(M.get_method (fun ℐ =>
        core.cmp.PartialEq.eq
          (Self := core.option.Option.t erc721.AccountId.t)
          (Rhs := core.option.Option.t erc721.AccountId.t)
          (Trait := ℐ))) in
    let* α8 : ref erc721.Erc721.t := M.read self in
    let* α9 : core.option.Option.t erc721.AccountId.t :=
      M.call
        ((erc721.Mapping.t u32.t erc721.AccountId.t)::["get"]
          (borrow (erc721.Erc721.Get_token_approvals (deref α8)))
          (borrow id)) in
    let* α10 : M.Val (core.option.Option.t erc721.AccountId.t) := M.alloc α9 in
    let* α11 : bool.t := M.call (α7 (borrow from) (borrow α10)) in
    let* α12 : ref erc721.Erc721.t := M.read self in
    let* α13 : core.option.Option.t erc721.AccountId.t := M.read owner in
    let* α14 : ref str.t := M.read (mk_str "Error with AccountId") in
    let* α15 : erc721.AccountId.t :=
      M.call ((core.option.Option.t erc721.AccountId.t)::["expect"] α13 α14) in
    let* α16 : core.option.Option.t erc721.AccountId.t := M.read from in
    let* α17 : ref str.t := M.read (mk_str "Error with AccountId") in
    let* α18 : erc721.AccountId.t :=
      M.call ((core.option.Option.t erc721.AccountId.t)::["expect"] α16 α17) in
    let* α19 : bool.t :=
      M.call (erc721.Erc721.t::["approved_for_all"] α12 α15 α18) in
    let* α0 : M.Val bool.t :=
      M.alloc (BinOp.Pure.and α4 (BinOp.Pure.or (BinOp.Pure.or α6 α11) α19)) in
    M.read α0.
  
  Global Instance AssociatedFunction_approved_or_owner :
    Notations.DoubleColon Self "approved_or_owner" := {
    Notations.double_colon := approved_or_owner;
  }.
  
  (*
      fn exists(&self, id: TokenId) -> bool {
          self.token_owner.contains(&id)
      }
  *)
  Definition exists_
      (self : ref Self)
      (id : ltac:(erc721.TokenId))
      : M bool.t :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call
      ((erc721.Mapping.t u32.t erc721.AccountId.t)::["contains"]
        (borrow (erc721.Erc721.Get_token_owner (deref α0)))
        (borrow id)).
  
  Global Instance AssociatedFunction_exists_ :
    Notations.DoubleColon Self "exists_" := {
    Notations.double_colon := exists_;
  }.
  
  (*
      pub fn balance_of(&self, owner: AccountId) -> u32 {
          self.balance_of_or_zero(&owner)
      }
  *)
  Definition balance_of
      (self : ref Self)
      (owner : erc721.AccountId.t)
      : M u32.t :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call (erc721.Erc721.t::["balance_of_or_zero"] α0 (borrow owner)).
  
  Global Instance AssociatedFunction_balance_of :
    Notations.DoubleColon Self "balance_of" := {
    Notations.double_colon := balance_of;
  }.
  
  (*
      pub fn get_approved(&self, id: TokenId) -> Option<AccountId> {
          self.token_approvals.get(&id)
      }
  *)
  Definition get_approved
      (self : ref Self)
      (id : ltac:(erc721.TokenId))
      : M (core.option.Option.t erc721.AccountId.t) :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call
      ((erc721.Mapping.t u32.t erc721.AccountId.t)::["get"]
        (borrow (erc721.Erc721.Get_token_approvals (deref α0)))
        (borrow id)).
  
  Global Instance AssociatedFunction_get_approved :
    Notations.DoubleColon Self "get_approved" := {
    Notations.double_colon := get_approved;
  }.
  
  (*
      pub fn is_approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {
          self.approved_for_all(owner, operator)
      }
  *)
  Definition is_approved_for_all
      (self : ref Self)
      (owner : erc721.AccountId.t)
      (operator : erc721.AccountId.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* operator := M.alloc operator in
    let* α0 : ref erc721.Erc721.t := M.read self in
    let* α1 : erc721.AccountId.t := M.read owner in
    let* α2 : erc721.AccountId.t := M.read operator in
    M.call (erc721.Erc721.t::["approved_for_all"] α0 α1 α2).
  
  Global Instance AssociatedFunction_is_approved_for_all :
    Notations.DoubleColon Self "is_approved_for_all" := {
    Notations.double_colon := is_approved_for_all;
  }.
  
  (*
      fn approve_for_all(&mut self, to: AccountId, approved: bool) -> Result<(), Error> {
          let caller = self.env().caller();
          if to == caller {
              return Err(Error::NotAllowed);
          }
          self.env().emit_event(Event::ApprovalForAll(ApprovalForAll {
              owner: caller,
              operator: to,
              approved,
          }));
  
          if approved {
              self.operator_approvals.insert((caller, to), ());
          } else {
              self.operator_approvals.remove((caller, to));
          }
  
          Ok(())
      }
  *)
  Definition approve_for_all
      (self : mut_ref Self)
      (to : erc721.AccountId.t)
      (approved : bool.t)
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* to := M.alloc to in
    let* approved := M.alloc approved in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (erc721.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 :
            (ref erc721.AccountId.t) -> (ref erc721.AccountId.t) -> M bool.t :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := erc721.AccountId.t)
              (Rhs := erc721.AccountId.t)
              (Trait := ℐ))) in
        let* α1 : bool.t := M.call (α0 (borrow to) (borrow caller)) in
        let* α2 : M.Val bool.t := M.alloc α1 in
        let* α3 : bool.t := M.read (use α2) in
        if α3 then
          let* α0 : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotAllowed) in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t := M.read caller in
        let* α4 : erc721.AccountId.t := M.read to in
        let* α5 : bool.t := M.read approved in
        let* α6 : unit :=
          M.call
            (erc721.Env.t::["emit_event"]
              (borrow α2)
              (erc721.Event.ApprovalForAll
                {|
                  erc721.ApprovalForAll.owner := α3;
                  erc721.ApprovalForAll.operator := α4;
                  erc721.ApprovalForAll.approved := α5;
                |})) in
        M.alloc α6 in
      let* _ : M.Val unit :=
        let* α0 : bool.t := M.read (use approved) in
        if α0 then
          let* _ : M.Val (core.option.Option.t u32.t) :=
            let* α0 : mut_ref erc721.Erc721.t := M.read self in
            let* α1 : erc721.AccountId.t := M.read caller in
            let* α2 : erc721.AccountId.t := M.read to in
            let* α3 : core.option.Option.t u32.t :=
              M.call
                ((erc721.Mapping.t
                      (erc721.AccountId.t * erc721.AccountId.t)
                      unit)::["insert"]
                  (borrow_mut (erc721.Erc721.Get_operator_approvals (deref α0)))
                  (α1, α2)
                  tt) in
            M.alloc α3 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : mut_ref erc721.Erc721.t := M.read self in
            let* α1 : erc721.AccountId.t := M.read caller in
            let* α2 : erc721.AccountId.t := M.read to in
            let* α3 : unit :=
              M.call
                ((erc721.Mapping.t
                      (erc721.AccountId.t * erc721.AccountId.t)
                      unit)::["remove"]
                  (borrow (erc721.Erc721.Get_operator_approvals (deref α0)))
                  (α1, α2)) in
            M.alloc α3 in
          M.alloc tt in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_approve_for_all :
    Notations.DoubleColon Self "approve_for_all" := {
    Notations.double_colon := approve_for_all;
  }.
  
  (*
      pub fn set_approval_for_all(&mut self, to: AccountId, approved: bool) -> Result<(), Error> {
          self.approve_for_all(to, approved)?;
          Ok(())
      }
  *)
  Definition set_approval_for_all
      (self : mut_ref Self)
      (to : erc721.AccountId.t)
      (approved : bool.t)
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* to := M.alloc to in
    let* approved := M.alloc approved in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 :
            (core.result.Result.t unit erc721.Error.t) ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t unit erc721.Error.t)
              (Trait := ℐ))) in
        let* α1 : mut_ref erc721.Erc721.t := M.read self in
        let* α2 : erc721.AccountId.t := M.read to in
        let* α3 : bool.t := M.read approved in
        let* α4 : core.result.Result.t unit erc721.Error.t :=
          M.call (erc721.Erc721.t::["approve_for_all"] α1 α2 α3) in
        let* α5 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call (α0 α4) in
        let* α6 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
                unit) :=
          M.alloc α5 in
        match_operator
          α6
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 :
                    (core.result.Result.t
                        core.convert.Infallible.t
                        erc721.Error.t)
                      ->
                      M (core.result.Result.t unit erc721.Error.t) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.result.Result.t unit erc721.Error.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      erc721.Error.t :=
                  M.read residual in
                let* α2 : core.result.Result.t unit erc721.Error.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : unit := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val unit)
          ] in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_set_approval_for_all :
    Notations.DoubleColon Self "set_approval_for_all" := {
    Notations.double_colon := set_approval_for_all;
  }.
  
  (*
      fn approve_for(&mut self, to: &AccountId, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          let owner = self.owner_of(id);
          if !(owner == Some(caller)
              || self.approved_for_all(owner.expect("Error with AccountId"), caller))
          {
              return Err(Error::NotAllowed);
          };
  
          if *to == AccountId::from([0x0; 32]) {
              return Err(Error::NotAllowed);
          };
  
          if self.token_approvals.contains(&id) {
              return Err(Error::CannotInsert);
          } else {
              self.token_approvals.insert(id, *to);
          }
  
          self.env().emit_event(Event::Approval(Approval {
              from: caller,
              to: *to,
              id,
          }));
  
          Ok(())
      }
  *)
  Definition approve_for
      (self : mut_ref Self)
      (to : ref erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* to := M.alloc to in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (erc721.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* owner : M.Val (core.option.Option.t erc721.AccountId.t) :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : u32.t := M.read id in
        let* α2 : core.option.Option.t erc721.AccountId.t :=
          M.call (erc721.Erc721.t::["owner_of"] (borrow (deref α0)) α1) in
        M.alloc α2 in
      let* _ : M.Val unit :=
        let* α0 :
            (ref (core.option.Option.t erc721.AccountId.t)) ->
              (ref (core.option.Option.t erc721.AccountId.t)) ->
              M bool.t :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := core.option.Option.t erc721.AccountId.t)
              (Rhs := core.option.Option.t erc721.AccountId.t)
              (Trait := ℐ))) in
        let* α1 : erc721.AccountId.t := M.read caller in
        let* α2 : M.Val (core.option.Option.t erc721.AccountId.t) :=
          M.alloc (core.option.Option.Some α1) in
        let* α3 : bool.t := M.call (α0 (borrow owner) (borrow α2)) in
        let* α4 : mut_ref erc721.Erc721.t := M.read self in
        let* α5 : core.option.Option.t erc721.AccountId.t := M.read owner in
        let* α6 : ref str.t := M.read (mk_str "Error with AccountId") in
        let* α7 : erc721.AccountId.t :=
          M.call
            ((core.option.Option.t erc721.AccountId.t)::["expect"] α5 α6) in
        let* α8 : erc721.AccountId.t := M.read caller in
        let* α9 : bool.t :=
          M.call
            (erc721.Erc721.t::["approved_for_all"] (borrow (deref α4)) α7 α8) in
        let* α10 : M.Val bool.t := M.alloc (UnOp.not (BinOp.Pure.or α3 α9)) in
        let* α11 : bool.t := M.read (use α10) in
        if α11 then
          let* α0 : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotAllowed) in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 :
            (ref erc721.AccountId.t) -> (ref erc721.AccountId.t) -> M bool.t :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := erc721.AccountId.t)
              (Rhs := erc721.AccountId.t)
              (Trait := ℐ))) in
        let* α1 : ref erc721.AccountId.t := M.read to in
        let* α2 : (array u8.t) -> M erc721.AccountId.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := erc721.AccountId.t)
              (T := array u8.t)
              (Trait := ℐ))) in
        let* α3 : erc721.AccountId.t :=
          M.call (α2 (repeat ((Integer.of_Z 0) : u8.t) 32)) in
        let* α4 : M.Val erc721.AccountId.t := M.alloc α3 in
        let* α5 : bool.t := M.call (α0 α1 (borrow α4)) in
        let* α6 : M.Val bool.t := M.alloc α5 in
        let* α7 : bool.t := M.read (use α6) in
        if α7 then
          let* α0 : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotAllowed) in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : bool.t :=
          M.call
            ((erc721.Mapping.t u32.t erc721.AccountId.t)::["contains"]
              (borrow (erc721.Erc721.Get_token_approvals (deref α0)))
              (borrow id)) in
        let* α2 : M.Val bool.t := M.alloc α1 in
        let* α3 : bool.t := M.read (use α2) in
        if α3 then
          let* α0 : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.CannotInsert) in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          let* _ : M.Val (core.option.Option.t u32.t) :=
            let* α0 : mut_ref erc721.Erc721.t := M.read self in
            let* α1 : u32.t := M.read id in
            let* α2 : ref erc721.AccountId.t := M.read to in
            let* α3 : erc721.AccountId.t := M.read (deref α2) in
            let* α4 : core.option.Option.t u32.t :=
              M.call
                ((erc721.Mapping.t u32.t erc721.AccountId.t)::["insert"]
                  (borrow_mut (erc721.Erc721.Get_token_approvals (deref α0)))
                  α1
                  α3) in
            M.alloc α4 in
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t := M.read caller in
        let* α4 : ref erc721.AccountId.t := M.read to in
        let* α5 : erc721.AccountId.t := M.read (deref α4) in
        let* α6 : u32.t := M.read id in
        let* α7 : unit :=
          M.call
            (erc721.Env.t::["emit_event"]
              (borrow α2)
              (erc721.Event.Approval
                {|
                  erc721.Approval.from := α3;
                  erc721.Approval.to := α5;
                  erc721.Approval.id := α6;
                |})) in
        M.alloc α7 in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_approve_for :
    Notations.DoubleColon Self "approve_for" := {
    Notations.double_colon := approve_for;
  }.
  
  (*
      pub fn approve(&mut self, to: AccountId, id: TokenId) -> Result<(), Error> {
          self.approve_for(&to, id)?;
          Ok(())
      }
  *)
  Definition approve
      (self : mut_ref Self)
      (to : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* to := M.alloc to in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 :
            (core.result.Result.t unit erc721.Error.t) ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t unit erc721.Error.t)
              (Trait := ℐ))) in
        let* α1 : mut_ref erc721.Erc721.t := M.read self in
        let* α2 : u32.t := M.read id in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call (erc721.Erc721.t::["approve_for"] α1 (borrow to) α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call (α0 α3) in
        let* α5 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
                unit) :=
          M.alloc α4 in
        match_operator
          α5
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 :
                    (core.result.Result.t
                        core.convert.Infallible.t
                        erc721.Error.t)
                      ->
                      M (core.result.Result.t unit erc721.Error.t) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.result.Result.t unit erc721.Error.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      erc721.Error.t :=
                  M.read residual in
                let* α2 : core.result.Result.t unit erc721.Error.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : unit := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val unit)
          ] in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_approve :
    Notations.DoubleColon Self "approve" := {
    Notations.double_colon := approve;
  }.
  
  (*
      fn remove_token_from(&mut self, from: &AccountId, id: TokenId) -> Result<(), Error> {
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          if !token_owner.contains(&id) {
              return Err(Error::TokenNotFound);
          }
  
          let count = owned_tokens_count
              .get(from)
              .map(|c| c - (1 as u32))
              .ok_or(Error::CannotFetchValue)?;
          owned_tokens_count.insert( *from, count);
          token_owner.remove(id);
  
          Ok(())
      }
  *)
  Definition remove_token_from
      (self : mut_ref Self)
      (from : ref erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* from := M.alloc from in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        match_operator
          self
          [
            fun γ =>
              (let* γ :=
                let* α0 := M.read γ in
                M.pure (deref α0) in
              let* α0 := M.read γ in
              match α0 with
              |
                  {|
                    erc721.Erc721.token_owner := _;
                    erc721.Erc721.owned_tokens_count := _;
                  |}
                  =>
                let γ1_0 := erc721.Erc721.Get_token_owner γ in
                let γ1_1 := erc721.Erc721.Get_owned_tokens_count γ in
                let* token_owner := M.alloc (borrow_mut γ1_0) in
                let* owned_tokens_count := M.alloc (borrow_mut γ1_1) in
                let* _ : M.Val unit :=
                  let* α0 :
                      mut_ref (erc721.Mapping.t u32.t erc721.AccountId.t) :=
                    M.read token_owner in
                  let* α1 : bool.t :=
                    M.call
                      ((erc721.Mapping.t u32.t erc721.AccountId.t)::["contains"]
                        (borrow (deref α0))
                        (borrow id)) in
                  let* α2 : M.Val bool.t := M.alloc (UnOp.not α1) in
                  let* α3 : bool.t := M.read (use α2) in
                  if α3 then
                    let* α0 : M.Val never.t :=
                      return_
                        (core.result.Result.Err erc721.Error.TokenNotFound) in
                    let* α1 := M.read α0 in
                    let* α2 : unit := never_to_any α1 in
                    M.alloc α2
                  else
                    M.alloc tt in
                let* count : M.Val u32.t :=
                  let* α0 :
                      (core.result.Result.t u32.t erc721.Error.t) ->
                        M (core.ops.control_flow.ControlFlow.t _ _) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.Try.branch
                        (Self := core.result.Result.t u32.t erc721.Error.t)
                        (Trait := ℐ))) in
                  let* α1 :
                      mut_ref (erc721.Mapping.t erc721.AccountId.t u32.t) :=
                    M.read owned_tokens_count in
                  let* α2 : ref erc721.AccountId.t := M.read from in
                  let* α3 : core.option.Option.t u32.t :=
                    M.call
                      ((erc721.Mapping.t erc721.AccountId.t u32.t)::["get"]
                        (borrow (deref α1))
                        α2) in
                  let* α4 : core.option.Option.t u32.t :=
                    M.call
                      ((core.option.Option.t u32.t)::["map"]
                        α3
                        (fun (α0 : u32.t) =>
                          (let* α0 := M.alloc α0 in
                          match_operator
                            α0
                            [
                              fun γ =>
                                (let* c := M.copy γ in
                                let* α0 : u32.t := M.read c in
                                let* α1 : M.Val u32.t :=
                                  M.alloc ((Integer.of_Z 1) : u32.t) in
                                let* α2 : u32.t := M.read (use α1) in
                                BinOp.Panic.sub α0 α2) :
                                M u32.t
                            ]) :
                          M u32.t)) in
                  let* α5 : core.result.Result.t u32.t erc721.Error.t :=
                    M.call
                      ((core.option.Option.t u32.t)::["ok_or"]
                        α4
                        erc721.Error.CannotFetchValue) in
                  let* α6 :
                      core.ops.control_flow.ControlFlow.t
                        (core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                        u32.t :=
                    M.call (α0 α5) in
                  let* α7 :
                      M.Val
                        (core.ops.control_flow.ControlFlow.t
                          (core.result.Result.t
                            core.convert.Infallible.t
                            erc721.Error.t)
                          u32.t) :=
                    M.alloc α6 in
                  let* α8 : M.Val u32.t :=
                    match_operator
                      α7
                      [
                        fun γ =>
                          (let* α0 := M.read γ in
                          match α0 with
                          | core.ops.control_flow.ControlFlow.Break _ =>
                            let γ0_0 :=
                              core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                            let* residual := M.copy γ0_0 in
                            let* α0 :
                                (core.result.Result.t
                                    core.convert.Infallible.t
                                    erc721.Error.t)
                                  ->
                                  M
                                    (core.result.Result.t
                                      unit
                                      erc721.Error.t) :=
                              ltac:(M.get_method (fun ℐ =>
                                core.ops.try_trait.FromResidual.from_residual
                                  (Self :=
                                    core.result.Result.t unit erc721.Error.t)
                                  (R :=
                                    core.result.Result.t
                                      core.convert.Infallible.t
                                      erc721.Error.t)
                                  (Trait := ℐ))) in
                            let* α1 :
                                core.result.Result.t
                                  core.convert.Infallible.t
                                  erc721.Error.t :=
                              M.read residual in
                            let* α2 :
                                core.result.Result.t unit erc721.Error.t :=
                              M.call (α0 α1) in
                            let* α3 : M.Val never.t := return_ α2 in
                            let* α4 := M.read α3 in
                            let* α5 : u32.t := never_to_any α4 in
                            M.alloc α5
                          | _ => M.break_match
                          end) :
                          M (M.Val u32.t);
                        fun γ =>
                          (let* α0 := M.read γ in
                          match α0 with
                          | core.ops.control_flow.ControlFlow.Continue _ =>
                            let γ0_0 :=
                              core.ops.control_flow.ControlFlow.Get_Continue_0
                                γ in
                            let* val := M.copy γ0_0 in
                            M.pure val
                          | _ => M.break_match
                          end) :
                          M (M.Val u32.t)
                      ] in
                  M.copy α8 in
                let* _ : M.Val (core.option.Option.t u32.t) :=
                  let* α0 :
                      mut_ref (erc721.Mapping.t erc721.AccountId.t u32.t) :=
                    M.read owned_tokens_count in
                  let* α1 : ref erc721.AccountId.t := M.read from in
                  let* α2 : erc721.AccountId.t := M.read (deref α1) in
                  let* α3 : u32.t := M.read count in
                  let* α4 : core.option.Option.t u32.t :=
                    M.call
                      ((erc721.Mapping.t erc721.AccountId.t u32.t)::["insert"]
                        α0
                        α2
                        α3) in
                  M.alloc α4 in
                let* _ : M.Val unit :=
                  let* α0 :
                      mut_ref (erc721.Mapping.t u32.t erc721.AccountId.t) :=
                    M.read token_owner in
                  let* α1 : u32.t := M.read id in
                  let* α2 : unit :=
                    M.call
                      ((erc721.Mapping.t u32.t erc721.AccountId.t)::["remove"]
                        (borrow (deref α0))
                        α1) in
                  M.alloc α2 in
                M.alloc (core.result.Result.Ok tt)
              end) :
              M (M.Val (core.result.Result.t unit erc721.Error.t))
          ] in
      M.read α0).
  
  Global Instance AssociatedFunction_remove_token_from :
    Notations.DoubleColon Self "remove_token_from" := {
    Notations.double_colon := remove_token_from;
  }.
  
  (*
      fn add_token_to(&mut self, to: &AccountId, id: TokenId) -> Result<(), Error> {
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          if token_owner.contains(&id) {
              return Err(Error::TokenExists);
          }
  
          if *to == AccountId::from([0x0; 32]) {
              return Err(Error::NotAllowed);
          };
  
          let count = owned_tokens_count
              .get(to)
              .map(|c| c + (1 as u32))
              .unwrap_or(1);
  
          owned_tokens_count.insert( *to, count);
          token_owner.insert(id, *to);
  
          Ok(())
      }
  *)
  Parameter add_token_to :
      (mut_ref Self) ->
        (ref erc721.AccountId.t) ->
        ltac:(erc721.TokenId) ->
        M (core.result.Result.t unit erc721.Error.t).
  
  Global Instance AssociatedFunction_add_token_to :
    Notations.DoubleColon Self "add_token_to" := {
    Notations.double_colon := add_token_to;
  }.
  
  (*
      fn transfer_token_from(
          &mut self,
          from: &AccountId,
          to: &AccountId,
          id: TokenId,
      ) -> Result<(), Error> {
          let caller = self.env().caller();
          if !self.exists(id) {
              return Err(Error::TokenNotFound);
          };
          if !self.approved_or_owner(Some(caller), id) {
              return Err(Error::NotApproved);
          };
          self.clear_approval(id);
          self.remove_token_from(from, id)?;
          self.add_token_to(to, id)?;
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some( *from),
              to: Some( *to),
              id,
          }));
          Ok(())
      }
  *)
  Parameter transfer_token_from :
      (mut_ref Self) ->
        (ref erc721.AccountId.t) ->
        (ref erc721.AccountId.t) ->
        ltac:(erc721.TokenId) ->
        M (core.result.Result.t unit erc721.Error.t).
  
  Global Instance AssociatedFunction_transfer_token_from :
    Notations.DoubleColon Self "transfer_token_from" := {
    Notations.double_colon := transfer_token_from;
  }.
  
  (*
      pub fn transfer(&mut self, destination: AccountId, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          self.transfer_token_from(&caller, &destination, id)?;
          Ok(())
      }
  *)
  Definition transfer
      (self : mut_ref Self)
      (destination : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* destination := M.alloc destination in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (erc721.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 :
            (core.result.Result.t unit erc721.Error.t) ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t unit erc721.Error.t)
              (Trait := ℐ))) in
        let* α1 : mut_ref erc721.Erc721.t := M.read self in
        let* α2 : u32.t := M.read id in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call
            (erc721.Erc721.t::["transfer_token_from"]
              α1
              (borrow caller)
              (borrow destination)
              α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call (α0 α3) in
        let* α5 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
                unit) :=
          M.alloc α4 in
        match_operator
          α5
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 :
                    (core.result.Result.t
                        core.convert.Infallible.t
                        erc721.Error.t)
                      ->
                      M (core.result.Result.t unit erc721.Error.t) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.result.Result.t unit erc721.Error.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      erc721.Error.t :=
                  M.read residual in
                let* α2 : core.result.Result.t unit erc721.Error.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : unit := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val unit)
          ] in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_transfer :
    Notations.DoubleColon Self "transfer" := {
    Notations.double_colon := transfer;
  }.
  
  (*
      pub fn transfer_from(
          &mut self,
          from: AccountId,
          to: AccountId,
          id: TokenId,
      ) -> Result<(), Error> {
          self.transfer_token_from(&from, &to, id)?;
          Ok(())
      }
  *)
  Definition transfer_from
      (self : mut_ref Self)
      (from : erc721.AccountId.t)
      (to : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* from := M.alloc from in
    let* to := M.alloc to in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 :
            (core.result.Result.t unit erc721.Error.t) ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t unit erc721.Error.t)
              (Trait := ℐ))) in
        let* α1 : mut_ref erc721.Erc721.t := M.read self in
        let* α2 : u32.t := M.read id in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call
            (erc721.Erc721.t::["transfer_token_from"]
              α1
              (borrow from)
              (borrow to)
              α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call (α0 α3) in
        let* α5 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
                unit) :=
          M.alloc α4 in
        match_operator
          α5
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 :
                    (core.result.Result.t
                        core.convert.Infallible.t
                        erc721.Error.t)
                      ->
                      M (core.result.Result.t unit erc721.Error.t) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.result.Result.t unit erc721.Error.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      erc721.Error.t :=
                  M.read residual in
                let* α2 : core.result.Result.t unit erc721.Error.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : unit := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val unit)
          ] in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_transfer_from :
    Notations.DoubleColon Self "transfer_from" := {
    Notations.double_colon := transfer_from;
  }.
  
  (*
      pub fn mint(&mut self, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          self.add_token_to(&caller, id)?;
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some(AccountId::from([0x0; 32])),
              to: Some(caller),
              id,
          }));
          Ok(())
      }
  *)
  Definition mint
      (self : mut_ref Self)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (erc721.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 :
            (core.result.Result.t unit erc721.Error.t) ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t unit erc721.Error.t)
              (Trait := ℐ))) in
        let* α1 : mut_ref erc721.Erc721.t := M.read self in
        let* α2 : u32.t := M.read id in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call (erc721.Erc721.t::["add_token_to"] α1 (borrow caller) α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call (α0 α3) in
        let* α5 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
                unit) :=
          M.alloc α4 in
        match_operator
          α5
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 :
                    (core.result.Result.t
                        core.convert.Infallible.t
                        erc721.Error.t)
                      ->
                      M (core.result.Result.t unit erc721.Error.t) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.result.Result.t unit erc721.Error.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      erc721.Error.t :=
                  M.read residual in
                let* α2 : core.result.Result.t unit erc721.Error.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : unit := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val unit)
          ] in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : (array u8.t) -> M erc721.AccountId.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := erc721.AccountId.t)
              (T := array u8.t)
              (Trait := ℐ))) in
        let* α4 : erc721.AccountId.t :=
          M.call (α3 (repeat ((Integer.of_Z 0) : u8.t) 32)) in
        let* α5 : erc721.AccountId.t := M.read caller in
        let* α6 : u32.t := M.read id in
        let* α7 : unit :=
          M.call
            (erc721.Env.t::["emit_event"]
              (borrow α2)
              (erc721.Event.Transfer
                {|
                  erc721.Transfer.from := core.option.Option.Some α4;
                  erc721.Transfer.to := core.option.Option.Some α5;
                  erc721.Transfer.id := α6;
                |})) in
        M.alloc α7 in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_mint :
    Notations.DoubleColon Self "mint" := {
    Notations.double_colon := mint;
  }.
  
  (*
      pub fn burn(&mut self, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          let owner = token_owner.get(&id).ok_or(Error::TokenNotFound)?;
          if owner != caller {
              return Err(Error::NotOwner);
          };
  
          let count = owned_tokens_count
              .get(&caller)
              .map(|c| c - 1)
              .ok_or(Error::CannotFetchValue)?;
          owned_tokens_count.insert(caller, count);
          token_owner.remove(id);
  
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some(caller),
              to: Some(AccountId::from([0x0; 32])),
              id,
          }));
  
          Ok(())
      }
  *)
  Parameter burn :
      (mut_ref Self) ->
        ltac:(erc721.TokenId) ->
        M (core.result.Result.t unit erc721.Error.t).
  
  Global Instance AssociatedFunction_burn :
    Notations.DoubleColon Self "burn" := {
    Notations.double_colon := burn;
  }.
End Impl_erc721_Erc721_t.
End Impl_erc721_Erc721_t.
