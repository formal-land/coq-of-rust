(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Definition Get__key :=
    Ref.map (fun α => Some α.(_key)) (fun β α => Some (α <| _key := β |>)).
  Definition Get__value :=
    Ref.map (fun α => Some α.(_value)) (fun β α => Some (α <| _value := β |>)).
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_erc721_Mapping_t_K_V.
Section Impl_core_default_Default_for_erc721_Mapping_t_K_V.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.default.Default.Trait K}
    {ℋ_1 : core.default.Default.Trait V}.
  
  Definition Self : Set := erc721.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (erc721.Mapping.t K V) :=
    let* α0 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := core.marker.PhantomData.t K)
          (Trait := ℐ))) in
    let* α1 : core.marker.PhantomData.t K := M.call α0 in
    let* α2 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := core.marker.PhantomData.t V)
          (Trait := ℐ))) in
    let* α3 : core.marker.PhantomData.t V := M.call α2 in
    M.pure {| erc721.Mapping._key := α1; erc721.Mapping._value := α3; |}.
  
  Axiom default_is_impl : impl Self "default" = default.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_Mapping_t_K_V.
End Impl_core_default_Default_for_erc721_Mapping_t_K_V.

Module  Impl_erc721_Mapping_t_K_V.
Section Impl_erc721_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := erc721.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref Self) (_key : ref K) : M bool.t :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom contains_is_impl : impl Self "contains" = contains.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom get_is_impl : impl Self "get" = get.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom insert_is_impl : impl Self "insert" = insert.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref Self) (_key : K) : M unit :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom remove_is_impl : impl Self "remove" = remove.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref Self)
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom size_is_impl : impl Self "size" = size.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (self : ref Self) (_key : K) : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom take_is_impl : impl Self "take" = take.
End Impl_erc721_Mapping_t_K_V.
End Impl_erc721_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_erc721_AccountId_t.
Section Impl_core_default_Default_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M erc721.AccountId.t :=
    let* α0 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := u128.t) (Trait := ℐ))) in
    let* α1 : u128.t := M.call α0 in
    M.pure (erc721.AccountId.Build_t α1).
  
  Axiom default_is_impl : impl Self "default" = default.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_AccountId_t.
End Impl_core_default_Default_for_erc721_AccountId_t.

Module  Impl_core_clone_Clone_for_erc721_AccountId_t.
Section Impl_core_clone_Clone_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M erc721.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : M.Val erc721.AccountId.t :=
      match_operator
        (DeclaredButUndefinedVariable
          (A := core.clone.AssertParamIsClone.t u128.t))
        [
          fun γ =>
            (let* α0 : ref erc721.AccountId.t := M.read self in
            M.pure (deref α0)) :
            M (M.Val erc721.AccountId.t)
        ] in
    M.read α0.
  
  Axiom clone_is_impl : impl Self "clone" = clone.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_erc721_AccountId_t.
End Impl_core_clone_Clone_for_erc721_AccountId_t.

Module  Impl_core_marker_Copy_for_erc721_AccountId_t.
Section Impl_core_marker_Copy_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_erc721_AccountId_t.
End Impl_core_marker_Copy_for_erc721_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
Section Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref erc721.AccountId.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : ref erc721.AccountId.t := M.read self in
    let* α1 : u128.t := M.read (erc721.AccountId.Get_0 (deref α0)) in
    let* α2 : ref erc721.AccountId.t := M.read other in
    let* α3 : u128.t := M.read (erc721.AccountId.Get_0 (deref α2)) in
    M.pure (BinOp.Pure.eq α1 α3).
  
  Axiom eq_is_impl : impl Self "eq" = eq.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
End Impl_core_cmp_PartialEq_for_erc721_AccountId_t.

Module  Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
Section Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
      fn from(_value: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Definition from (_value : array u8.t) : M Self :=
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom from_is_impl : impl Self "from" = from.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := array u8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
End Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : erc721.AccountId.t;
  }.
  
  Definition Get_caller :=
    Ref.map (fun α => Some α.(caller)) (fun β α => Some (α <| caller := β |>)).
End Env.
End Env.

Ltac TokenId := exact u32.t.

Module  Erc721.
Section Erc721.
  Record t : Set := {
    token_owner : erc721.Mapping.t ltac:(erc721.TokenId) erc721.AccountId.t;
    token_approvals : erc721.Mapping.t ltac:(erc721.TokenId) erc721.AccountId.t;
    owned_tokens_count : erc721.Mapping.t erc721.AccountId.t u32.t;
    operator_approvals :
      erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit;
  }.
  
  Definition Get_token_owner :=
    Ref.map
      (fun α => Some α.(token_owner))
      (fun β α => Some (α <| token_owner := β |>)).
  Definition Get_token_approvals :=
    Ref.map
      (fun α => Some α.(token_approvals))
      (fun β α => Some (α <| token_approvals := β |>)).
  Definition Get_owned_tokens_count :=
    Ref.map
      (fun α => Some α.(owned_tokens_count))
      (fun β α => Some (α <| owned_tokens_count := β |>)).
  Definition Get_operator_approvals :=
    Ref.map
      (fun α => Some α.(operator_approvals))
      (fun β α => Some (α <| operator_approvals := β |>)).
End Erc721.
End Erc721.

Module  Impl_core_default_Default_for_erc721_Erc721_t.
Section Impl_core_default_Default_for_erc721_Erc721_t.
  Definition Self : Set := erc721.Erc721.t.
  
  (*
  Default
  *)
  Definition default : M erc721.Erc721.t :=
    let* α0 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := erc721.Mapping.t u32.t erc721.AccountId.t)
          (Trait := ℐ))) in
    let* α1 : erc721.Mapping.t u32.t erc721.AccountId.t := M.call α0 in
    let* α2 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := erc721.Mapping.t u32.t erc721.AccountId.t)
          (Trait := ℐ))) in
    let* α3 : erc721.Mapping.t u32.t erc721.AccountId.t := M.call α2 in
    let* α4 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := erc721.Mapping.t erc721.AccountId.t u32.t)
          (Trait := ℐ))) in
    let* α5 : erc721.Mapping.t erc721.AccountId.t u32.t := M.call α4 in
    let* α6 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self :=
            erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit)
          (Trait := ℐ))) in
    let* α7 : erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit :=
      M.call α6 in
    M.pure
      {|
        erc721.Erc721.token_owner := α1;
        erc721.Erc721.token_approvals := α3;
        erc721.Erc721.owned_tokens_count := α5;
        erc721.Erc721.operator_approvals := α7;
      |}.
  
  Axiom default_is_impl : impl Self "default" = default.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_Erc721_t.
End Impl_core_default_Default_for_erc721_Erc721_t.

Module Error.
  Inductive t : Set :=
  | NotOwner
  | NotApproved
  | TokenExists
  | TokenNotFound
  | CannotInsert
  | CannotFetchValue
  | NotAllowed.
End Error.

Module  Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
Section Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
End Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.

Module  Impl_core_cmp_PartialEq_for_erc721_Error_t.
Section Impl_core_cmp_PartialEq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref erc721.Error.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* __self_tag : M.Val isize.t :=
      let* α0 : ref erc721.Error.t := M.read self in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* __arg1_tag : M.Val isize.t :=
      let* α0 : ref erc721.Error.t := M.read other in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* α0 : isize.t := M.read __self_tag in
    let* α1 : isize.t := M.read __arg1_tag in
    let* α0 : M.Val bool.t := M.alloc (BinOp.Pure.eq α0 α1) in
    M.read α0.
  
  Axiom eq_is_impl : impl Self "eq" = eq.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_erc721_Error_t.
End Impl_core_cmp_PartialEq_for_erc721_Error_t.

Module  Impl_core_marker_StructuralEq_for_erc721_Error_t.
Section Impl_core_marker_StructuralEq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_erc721_Error_t.
End Impl_core_marker_StructuralEq_for_erc721_Error_t.

Module  Impl_core_cmp_Eq_for_erc721_Error_t.
Section Impl_core_cmp_Eq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.pure tt.
  
  Axiom assert_receiver_is_total_eq_is_impl :
      impl Self "assert_receiver_is_total_eq" = assert_receiver_is_total_eq.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_erc721_Error_t.
End Impl_core_cmp_Eq_for_erc721_Error_t.

Module  Impl_core_clone_Clone_for_erc721_Error_t.
Section Impl_core_clone_Clone_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M erc721.Error.t :=
    let* self := M.alloc self in
    let* α0 : ref erc721.Error.t := M.read self in
    M.read (deref α0).
  
  Axiom clone_is_impl : impl Self "clone" = clone.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_erc721_Error_t.
End Impl_core_clone_Clone_for_erc721_Error_t.

Module  Impl_core_marker_Copy_for_erc721_Error_t.
Section Impl_core_marker_Copy_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_erc721_Error_t.
End Impl_core_marker_Copy_for_erc721_Error_t.

Module  Transfer.
Section Transfer.
  Record t : Set := {
    from : core.option.Option.t erc721.AccountId.t;
    to : core.option.Option.t erc721.AccountId.t;
    id : ltac:(erc721.TokenId);
  }.
  
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
  Definition Get_to :=
    Ref.map (fun α => Some α.(to)) (fun β α => Some (α <| to := β |>)).
  Definition Get_id :=
    Ref.map (fun α => Some α.(id)) (fun β α => Some (α <| id := β |>)).
End Transfer.
End Transfer.

Module  Approval.
Section Approval.
  Record t : Set := {
    from : erc721.AccountId.t;
    to : erc721.AccountId.t;
    id : ltac:(erc721.TokenId);
  }.
  
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
  Definition Get_to :=
    Ref.map (fun α => Some α.(to)) (fun β α => Some (α <| to := β |>)).
  Definition Get_id :=
    Ref.map (fun α => Some α.(id)) (fun β α => Some (α <| id := β |>)).
End Approval.
End Approval.

Module  ApprovalForAll.
Section ApprovalForAll.
  Record t : Set := {
    owner : erc721.AccountId.t;
    operator : erc721.AccountId.t;
    approved : bool.t;
  }.
  
  Definition Get_owner :=
    Ref.map (fun α => Some α.(owner)) (fun β α => Some (α <| owner := β |>)).
  Definition Get_operator :=
    Ref.map
      (fun α => Some α.(operator))
      (fun β α => Some (α <| operator := β |>)).
  Definition Get_approved :=
    Ref.map
      (fun α => Some α.(approved))
      (fun β α => Some (α <| approved := β |>)).
End ApprovalForAll.
End ApprovalForAll.

Module Event.
  Inductive t : Set :=
  | Transfer (_ : erc721.Transfer.t)
  | Approval (_ : erc721.Approval.t)
  | ApprovalForAll (_ : erc721.ApprovalForAll.t).
  
  Definition Get_Transfer_0 :=
    Ref.map
      (fun α => match α with | Transfer α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Transfer _ => Some (Transfer β) | _ => None end).
  
  Definition Get_Approval_0 :=
    Ref.map
      (fun α => match α with | Approval α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Approval _ => Some (Approval β) | _ => None end).
  
  Definition Get_ApprovalForAll_0 :=
    Ref.map
      (fun α => match α with | ApprovalForAll α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | ApprovalForAll _ => Some (ApprovalForAll β)
        | _ => None
        end).
End Event.

Module  Impl_erc721_Env_t.
Section Impl_erc721_Env_t.
  Definition Self : Set := erc721.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (self : ref Self) : M erc721.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref erc721.Env.t := M.read self in
    M.read (erc721.Env.Get_caller (deref α0)).
  
  Axiom caller_is_impl : impl Self "caller" = caller.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (self : ref Self) (_event : erc721.Event.t) : M unit :=
    let* self := M.alloc self in
    let* _event := M.alloc _event in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom emit_event_is_impl : impl Self "emit_event" = emit_event.
End Impl_erc721_Env_t.
End Impl_erc721_Env_t.

Module  Impl_erc721_Erc721_t.
Section Impl_erc721_Erc721_t.
  Definition Self : Set := erc721.Erc721.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M erc721.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom init_env_is_impl : impl Self "init_env" = init_env.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (self : ref Self) : M erc721.Env.t :=
    let* self := M.alloc self in
    M.call (impl erc721.Erc721.t "init_env").
  
  Axiom env_is_impl : impl Self "env" = env.
  
  (*
      pub fn new() -> Self {
          Default::default()
      }
  *)
  Definition new : M Self :=
    let* α0 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := erc721.Erc721.t) (Trait := ℐ))) in
    M.call α0.
  
  Axiom new_is_impl : impl Self "new" = new.
  
  (*
      fn balance_of_or_zero(&self, of: &AccountId) -> u32 {
          self.owned_tokens_count.get(of).unwrap_or(0 as u32)
      }
  *)
  Definition balance_of_or_zero
      (self : ref Self)
      (of : ref erc721.AccountId.t)
      : M u32.t :=
    let* self := M.alloc self in
    let* of := M.alloc of in
    let* α0 : ref erc721.Erc721.t := M.read self in
    let* α1 : ref erc721.AccountId.t := M.read of in
    let* α2 : core.option.Option.t u32.t :=
      M.call
        (impl (erc721.Mapping.t erc721.AccountId.t u32.t) "get"
          (borrow (erc721.Erc721.Get_owned_tokens_count (deref α0)))
          α1) in
    let* α3 : M.Val u32.t := M.alloc ((Integer.of_Z 0) : u32.t) in
    let* α4 : u32.t := M.read (use α3) in
    M.call (impl (core.option.Option.t u32.t) "unwrap_or" α2 α4).
  
  Axiom balance_of_or_zero_is_impl :
      impl Self "balance_of_or_zero" = balance_of_or_zero.
  
  (*
      fn clear_approval(&mut self, id: TokenId) {
          self.token_approvals.remove(id);
      }
  *)
  Definition clear_approval
      (self : mut_ref Self)
      (id : ltac:(erc721.TokenId))
      : M unit :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref erc721.Erc721.t := M.read self in
      let* α1 : u32.t := M.read id in
      let* α2 : unit :=
        M.call
          (impl (erc721.Mapping.t u32.t erc721.AccountId.t) "remove"
            (borrow (erc721.Erc721.Get_token_approvals (deref α0)))
            α1) in
      M.alloc α2 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Axiom clear_approval_is_impl : impl Self "clear_approval" = clear_approval.
  
  (*
      fn approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {
          self.operator_approvals.contains(&(owner, operator))
      }
  *)
  Definition approved_for_all
      (self : ref Self)
      (owner : erc721.AccountId.t)
      (operator : erc721.AccountId.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* operator := M.alloc operator in
    let* α0 : ref erc721.Erc721.t := M.read self in
    let* α1 : erc721.AccountId.t := M.read owner in
    let* α2 : erc721.AccountId.t := M.read operator in
    let* α3 : M.Val (erc721.AccountId.t * erc721.AccountId.t) :=
      M.alloc (α1, α2) in
    M.call
      (impl
          (erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit)
          "contains"
        (borrow (erc721.Erc721.Get_operator_approvals (deref α0)))
        (borrow α3)).
  
  Axiom approved_for_all_is_impl :
      impl Self "approved_for_all" = approved_for_all.
  
  (*
      pub fn owner_of(&self, id: TokenId) -> Option<AccountId> {
          self.token_owner.get(&id)
      }
  *)
  Definition owner_of
      (self : ref Self)
      (id : ltac:(erc721.TokenId))
      : M (core.option.Option.t erc721.AccountId.t) :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call
      (impl (erc721.Mapping.t u32.t erc721.AccountId.t) "get"
        (borrow (erc721.Erc721.Get_token_owner (deref α0)))
        (borrow id)).
  
  Axiom owner_of_is_impl : impl Self "owner_of" = owner_of.
  
  (*
      fn approved_or_owner(&self, from: Option<AccountId>, id: TokenId) -> bool {
          let owner = self.owner_of(id);
          from != Some(AccountId::from([0x0; 32]))
              && (from == owner
                  || from == self.token_approvals.get(&id)
                  || self.approved_for_all(
                      owner.expect("Error with AccountId"),
                      from.expect("Error with AccountId"),
                  ))
      }
  *)
  Definition approved_or_owner
      (self : ref Self)
      (from : core.option.Option.t erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M bool.t :=
    let* self := M.alloc self in
    let* from := M.alloc from in
    let* id := M.alloc id in
    let* owner : M.Val (core.option.Option.t erc721.AccountId.t) :=
      let* α0 : ref erc721.Erc721.t := M.read self in
      let* α1 : u32.t := M.read id in
      let* α2 : core.option.Option.t erc721.AccountId.t :=
        M.call (impl erc721.Erc721.t "owner_of" α0 α1) in
      M.alloc α2 in
    let* α0 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.cmp.PartialEq.ne
          (Self := core.option.Option.t erc721.AccountId.t)
          (Rhs := core.option.Option.t erc721.AccountId.t)
          (Trait := ℐ))) in
    let* α1 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.From.from
          (Self := erc721.AccountId.t)
          (T := array u8.t)
          (Trait := ℐ))) in
    let* α2 : erc721.AccountId.t :=
      M.call (α1 (repeat ((Integer.of_Z 0) : u8.t) 32)) in
    let* α3 : M.Val (core.option.Option.t erc721.AccountId.t) :=
      M.alloc (core.option.Option.Some α2) in
    let* α4 : bool.t := M.call (α0 (borrow from) (borrow α3)) in
    let* α5 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.cmp.PartialEq.eq
          (Self := core.option.Option.t erc721.AccountId.t)
          (Rhs := core.option.Option.t erc721.AccountId.t)
          (Trait := ℐ))) in
    let* α6 : bool.t := M.call (α5 (borrow from) (borrow owner)) in
    let* α7 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.cmp.PartialEq.eq
          (Self := core.option.Option.t erc721.AccountId.t)
          (Rhs := core.option.Option.t erc721.AccountId.t)
          (Trait := ℐ))) in
    let* α8 : ref erc721.Erc721.t := M.read self in
    let* α9 : core.option.Option.t erc721.AccountId.t :=
      M.call
        (impl (erc721.Mapping.t u32.t erc721.AccountId.t) "get"
          (borrow (erc721.Erc721.Get_token_approvals (deref α8)))
          (borrow id)) in
    let* α10 : M.Val (core.option.Option.t erc721.AccountId.t) := M.alloc α9 in
    let* α11 : bool.t := M.call (α7 (borrow from) (borrow α10)) in
    let* α12 : ref erc721.Erc721.t := M.read self in
    let* α13 : core.option.Option.t erc721.AccountId.t := M.read owner in
    let* α14 : ref str.t := M.read (mk_str "Error with AccountId") in
    let* α15 : erc721.AccountId.t :=
      M.call
        (impl (core.option.Option.t erc721.AccountId.t) "expect" α13 α14) in
    let* α16 : core.option.Option.t erc721.AccountId.t := M.read from in
    let* α17 : ref str.t := M.read (mk_str "Error with AccountId") in
    let* α18 : erc721.AccountId.t :=
      M.call
        (impl (core.option.Option.t erc721.AccountId.t) "expect" α16 α17) in
    let* α19 : bool.t :=
      M.call (impl erc721.Erc721.t "approved_for_all" α12 α15 α18) in
    let* α0 : M.Val bool.t :=
      M.alloc (BinOp.Pure.and α4 (BinOp.Pure.or (BinOp.Pure.or α6 α11) α19)) in
    M.read α0.
  
  Axiom approved_or_owner_is_impl :
      impl Self "approved_or_owner" = approved_or_owner.
  
  (*
      fn exists(&self, id: TokenId) -> bool {
          self.token_owner.contains(&id)
      }
  *)
  Definition exists_
      (self : ref Self)
      (id : ltac:(erc721.TokenId))
      : M bool.t :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call
      (impl (erc721.Mapping.t u32.t erc721.AccountId.t) "contains"
        (borrow (erc721.Erc721.Get_token_owner (deref α0)))
        (borrow id)).
  
  Axiom exists__is_impl : impl Self "exists_" = exists_.
  
  (*
      pub fn balance_of(&self, owner: AccountId) -> u32 {
          self.balance_of_or_zero(&owner)
      }
  *)
  Definition balance_of
      (self : ref Self)
      (owner : erc721.AccountId.t)
      : M u32.t :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call (impl erc721.Erc721.t "balance_of_or_zero" α0 (borrow owner)).
  
  Axiom balance_of_is_impl : impl Self "balance_of" = balance_of.
  
  (*
      pub fn get_approved(&self, id: TokenId) -> Option<AccountId> {
          self.token_approvals.get(&id)
      }
  *)
  Definition get_approved
      (self : ref Self)
      (id : ltac:(erc721.TokenId))
      : M (core.option.Option.t erc721.AccountId.t) :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call
      (impl (erc721.Mapping.t u32.t erc721.AccountId.t) "get"
        (borrow (erc721.Erc721.Get_token_approvals (deref α0)))
        (borrow id)).
  
  Axiom get_approved_is_impl : impl Self "get_approved" = get_approved.
  
  (*
      pub fn is_approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {
          self.approved_for_all(owner, operator)
      }
  *)
  Definition is_approved_for_all
      (self : ref Self)
      (owner : erc721.AccountId.t)
      (operator : erc721.AccountId.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* operator := M.alloc operator in
    let* α0 : ref erc721.Erc721.t := M.read self in
    let* α1 : erc721.AccountId.t := M.read owner in
    let* α2 : erc721.AccountId.t := M.read operator in
    M.call (impl erc721.Erc721.t "approved_for_all" α0 α1 α2).
  
  Axiom is_approved_for_all_is_impl :
      impl Self "is_approved_for_all" = is_approved_for_all.
  
  (*
      fn approve_for_all(&mut self, to: AccountId, approved: bool) -> Result<(), Error> {
          let caller = self.env().caller();
          if to == caller {
              return Err(Error::NotAllowed);
          }
          self.env().emit_event(Event::ApprovalForAll(ApprovalForAll {
              owner: caller,
              operator: to,
              approved,
          }));
  
          if approved {
              self.operator_approvals.insert((caller, to), ());
          } else {
              self.operator_approvals.remove((caller, to));
          }
  
          Ok(())
      }
  *)
  Definition approve_for_all
      (self : mut_ref Self)
      (to : erc721.AccountId.t)
      (approved : bool.t)
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* to := M.alloc to in
    let* approved := M.alloc approved in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (impl erc721.Erc721.t "env" (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (impl erc721.Env.t "caller" (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : _ :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := erc721.AccountId.t)
              (Rhs := erc721.AccountId.t)
              (Trait := ℐ))) in
        let* α1 : bool.t := M.call (α0 (borrow to) (borrow caller)) in
        let* α2 : M.Val bool.t := M.alloc α1 in
        let* α3 : bool.t := M.read (use α2) in
        if α3 then
          let* α0 : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotAllowed) in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (impl erc721.Erc721.t "env" (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t := M.read caller in
        let* α4 : erc721.AccountId.t := M.read to in
        let* α5 : bool.t := M.read approved in
        let* α6 : unit :=
          M.call
            (impl erc721.Env.t "emit_event"
              (borrow α2)
              (erc721.Event.ApprovalForAll
                {|
                  erc721.ApprovalForAll.owner := α3;
                  erc721.ApprovalForAll.operator := α4;
                  erc721.ApprovalForAll.approved := α5;
                |})) in
        M.alloc α6 in
      let* _ : M.Val unit :=
        let* α0 : bool.t := M.read (use approved) in
        if α0 then
          let* _ : M.Val (core.option.Option.t u32.t) :=
            let* α0 : mut_ref erc721.Erc721.t := M.read self in
            let* α1 : erc721.AccountId.t := M.read caller in
            let* α2 : erc721.AccountId.t := M.read to in
            let* α3 : core.option.Option.t u32.t :=
              M.call
                (impl
                    (erc721.Mapping.t
                      (erc721.AccountId.t * erc721.AccountId.t)
                      unit)
                    "insert"
                  (borrow_mut (erc721.Erc721.Get_operator_approvals (deref α0)))
                  (α1, α2)
                  tt) in
            M.alloc α3 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : mut_ref erc721.Erc721.t := M.read self in
            let* α1 : erc721.AccountId.t := M.read caller in
            let* α2 : erc721.AccountId.t := M.read to in
            let* α3 : unit :=
              M.call
                (impl
                    (erc721.Mapping.t
                      (erc721.AccountId.t * erc721.AccountId.t)
                      unit)
                    "remove"
                  (borrow (erc721.Erc721.Get_operator_approvals (deref α0)))
                  (α1, α2)) in
            M.alloc α3 in
          M.alloc tt in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Axiom approve_for_all_is_impl : impl Self "approve_for_all" = approve_for_all.
  
  (*
      pub fn set_approval_for_all(&mut self, to: AccountId, approved: bool) -> Result<(), Error> {
          self.approve_for_all(to, approved)?;
          Ok(())
      }
  *)
  Definition set_approval_for_all
      (self : mut_ref Self)
      (to : erc721.AccountId.t)
      (approved : bool.t)
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* to := M.alloc to in
    let* approved := M.alloc approved in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : _ :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t unit erc721.Error.t)
              (Trait := ℐ))) in
        let* α1 : mut_ref erc721.Erc721.t := M.read self in
        let* α2 : erc721.AccountId.t := M.read to in
        let* α3 : bool.t := M.read approved in
        let* α4 : core.result.Result.t unit erc721.Error.t :=
          M.call (impl erc721.Erc721.t "approve_for_all" α1 α2 α3) in
        let* α5 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call (α0 α4) in
        let* α6 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
                unit) :=
          M.alloc α5 in
        match_operator
          α6
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 : _ :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.result.Result.t unit erc721.Error.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      erc721.Error.t :=
                  M.read residual in
                let* α2 : core.result.Result.t unit erc721.Error.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : unit := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val unit)
          ] in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Axiom set_approval_for_all_is_impl :
      impl Self "set_approval_for_all" = set_approval_for_all.
  
  (*
      fn approve_for(&mut self, to: &AccountId, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          let owner = self.owner_of(id);
          if !(owner == Some(caller)
              || self.approved_for_all(owner.expect("Error with AccountId"), caller))
          {
              return Err(Error::NotAllowed);
          };
  
          if *to == AccountId::from([0x0; 32]) {
              return Err(Error::NotAllowed);
          };
  
          if self.token_approvals.contains(&id) {
              return Err(Error::CannotInsert);
          } else {
              self.token_approvals.insert(id, *to);
          }
  
          self.env().emit_event(Event::Approval(Approval {
              from: caller,
              to: *to,
              id,
          }));
  
          Ok(())
      }
  *)
  Definition approve_for
      (self : mut_ref Self)
      (to : ref erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* to := M.alloc to in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (impl erc721.Erc721.t "env" (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (impl erc721.Env.t "caller" (borrow α2)) in
        M.alloc α3 in
      let* owner : M.Val (core.option.Option.t erc721.AccountId.t) :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : u32.t := M.read id in
        let* α2 : core.option.Option.t erc721.AccountId.t :=
          M.call (impl erc721.Erc721.t "owner_of" (borrow (deref α0)) α1) in
        M.alloc α2 in
      let* _ : M.Val unit :=
        let* α0 : _ :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := core.option.Option.t erc721.AccountId.t)
              (Rhs := core.option.Option.t erc721.AccountId.t)
              (Trait := ℐ))) in
        let* α1 : erc721.AccountId.t := M.read caller in
        let* α2 : M.Val (core.option.Option.t erc721.AccountId.t) :=
          M.alloc (core.option.Option.Some α1) in
        let* α3 : bool.t := M.call (α0 (borrow owner) (borrow α2)) in
        let* α4 : mut_ref erc721.Erc721.t := M.read self in
        let* α5 : core.option.Option.t erc721.AccountId.t := M.read owner in
        let* α6 : ref str.t := M.read (mk_str "Error with AccountId") in
        let* α7 : erc721.AccountId.t :=
          M.call
            (impl (core.option.Option.t erc721.AccountId.t) "expect" α5 α6) in
        let* α8 : erc721.AccountId.t := M.read caller in
        let* α9 : bool.t :=
          M.call
            (impl erc721.Erc721.t "approved_for_all"
              (borrow (deref α4))
              α7
              α8) in
        let* α10 : M.Val bool.t := M.alloc (UnOp.not (BinOp.Pure.or α3 α9)) in
        let* α11 : bool.t := M.read (use α10) in
        if α11 then
          let* α0 : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotAllowed) in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : _ :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := erc721.AccountId.t)
              (Rhs := erc721.AccountId.t)
              (Trait := ℐ))) in
        let* α1 : ref erc721.AccountId.t := M.read to in
        let* α2 : _ :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := erc721.AccountId.t)
              (T := array u8.t)
              (Trait := ℐ))) in
        let* α3 : erc721.AccountId.t :=
          M.call (α2 (repeat ((Integer.of_Z 0) : u8.t) 32)) in
        let* α4 : M.Val erc721.AccountId.t := M.alloc α3 in
        let* α5 : bool.t := M.call (α0 α1 (borrow α4)) in
        let* α6 : M.Val bool.t := M.alloc α5 in
        let* α7 : bool.t := M.read (use α6) in
        if α7 then
          let* α0 : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotAllowed) in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : bool.t :=
          M.call
            (impl (erc721.Mapping.t u32.t erc721.AccountId.t) "contains"
              (borrow (erc721.Erc721.Get_token_approvals (deref α0)))
              (borrow id)) in
        let* α2 : M.Val bool.t := M.alloc α1 in
        let* α3 : bool.t := M.read (use α2) in
        if α3 then
          let* α0 : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.CannotInsert) in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          let* _ : M.Val (core.option.Option.t u32.t) :=
            let* α0 : mut_ref erc721.Erc721.t := M.read self in
            let* α1 : u32.t := M.read id in
            let* α2 : ref erc721.AccountId.t := M.read to in
            let* α3 : erc721.AccountId.t := M.read (deref α2) in
            let* α4 : core.option.Option.t u32.t :=
              M.call
                (impl (erc721.Mapping.t u32.t erc721.AccountId.t) "insert"
                  (borrow_mut (erc721.Erc721.Get_token_approvals (deref α0)))
                  α1
                  α3) in
            M.alloc α4 in
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (impl erc721.Erc721.t "env" (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t := M.read caller in
        let* α4 : ref erc721.AccountId.t := M.read to in
        let* α5 : erc721.AccountId.t := M.read (deref α4) in
        let* α6 : u32.t := M.read id in
        let* α7 : unit :=
          M.call
            (impl erc721.Env.t "emit_event"
              (borrow α2)
              (erc721.Event.Approval
                {|
                  erc721.Approval.from := α3;
                  erc721.Approval.to := α5;
                  erc721.Approval.id := α6;
                |})) in
        M.alloc α7 in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Axiom approve_for_is_impl : impl Self "approve_for" = approve_for.
  
  (*
      pub fn approve(&mut self, to: AccountId, id: TokenId) -> Result<(), Error> {
          self.approve_for(&to, id)?;
          Ok(())
      }
  *)
  Definition approve
      (self : mut_ref Self)
      (to : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* to := M.alloc to in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : _ :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t unit erc721.Error.t)
              (Trait := ℐ))) in
        let* α1 : mut_ref erc721.Erc721.t := M.read self in
        let* α2 : u32.t := M.read id in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call (impl erc721.Erc721.t "approve_for" α1 (borrow to) α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call (α0 α3) in
        let* α5 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
                unit) :=
          M.alloc α4 in
        match_operator
          α5
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 : _ :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.result.Result.t unit erc721.Error.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      erc721.Error.t :=
                  M.read residual in
                let* α2 : core.result.Result.t unit erc721.Error.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : unit := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val unit)
          ] in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Axiom approve_is_impl : impl Self "approve" = approve.
  
  (*
      fn remove_token_from(&mut self, from: &AccountId, id: TokenId) -> Result<(), Error> {
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          if !token_owner.contains(&id) {
              return Err(Error::TokenNotFound);
          }
  
          let count = owned_tokens_count
              .get(from)
              .map(|c| c - (1 as u32))
              .ok_or(Error::CannotFetchValue)?;
          owned_tokens_count.insert( *from, count);
          token_owner.remove(id);
  
          Ok(())
      }
  *)
  Definition remove_token_from
      (self : mut_ref Self)
      (from : ref erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* from := M.alloc from in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        match_operator
          self
          [
            fun γ =>
              (let* γ :=
                let* α0 := M.read γ in
                M.pure (deref α0) in
              let* α0 := M.read γ in
              match α0 with
              |
                  {|
                    erc721.Erc721.token_owner := _;
                    erc721.Erc721.owned_tokens_count := _;
                  |}
                  =>
                let γ1_0 := erc721.Erc721.Get_token_owner γ in
                let γ1_1 := erc721.Erc721.Get_owned_tokens_count γ in
                let* token_owner := M.alloc (borrow_mut γ1_0) in
                let* owned_tokens_count := M.alloc (borrow_mut γ1_1) in
                let* _ : M.Val unit :=
                  let* α0 :
                      mut_ref (erc721.Mapping.t u32.t erc721.AccountId.t) :=
                    M.read token_owner in
                  let* α1 : bool.t :=
                    M.call
                      (impl
                          (erc721.Mapping.t u32.t erc721.AccountId.t)
                          "contains"
                        (borrow (deref α0))
                        (borrow id)) in
                  let* α2 : M.Val bool.t := M.alloc (UnOp.not α1) in
                  let* α3 : bool.t := M.read (use α2) in
                  if α3 then
                    let* α0 : M.Val never.t :=
                      return_
                        (core.result.Result.Err erc721.Error.TokenNotFound) in
                    let* α1 := M.read α0 in
                    let* α2 : unit := never_to_any α1 in
                    M.alloc α2
                  else
                    M.alloc tt in
                let* count : M.Val u32.t :=
                  let* α0 : _ :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.Try.branch
                        (Self := core.result.Result.t u32.t erc721.Error.t)
                        (Trait := ℐ))) in
                  let* α1 :
                      mut_ref (erc721.Mapping.t erc721.AccountId.t u32.t) :=
                    M.read owned_tokens_count in
                  let* α2 : ref erc721.AccountId.t := M.read from in
                  let* α3 : core.option.Option.t u32.t :=
                    M.call
                      (impl (erc721.Mapping.t erc721.AccountId.t u32.t) "get"
                        (borrow (deref α1))
                        α2) in
                  let* α4 : core.option.Option.t u32.t :=
                    M.call
                      (impl (core.option.Option.t u32.t) "map"
                        α3
                        (fun (α0 : u32.t) =>
                          (let* α0 := M.alloc α0 in
                          match_operator
                            α0
                            [
                              fun γ =>
                                (let* c := M.copy γ in
                                let* α0 : u32.t := M.read c in
                                let* α1 : M.Val u32.t :=
                                  M.alloc ((Integer.of_Z 1) : u32.t) in
                                let* α2 : u32.t := M.read (use α1) in
                                BinOp.Panic.sub α0 α2) :
                                M u32.t
                            ]) :
                          M u32.t)) in
                  let* α5 : core.result.Result.t u32.t erc721.Error.t :=
                    M.call
                      (impl (core.option.Option.t u32.t) "ok_or"
                        α4
                        erc721.Error.CannotFetchValue) in
                  let* α6 :
                      core.ops.control_flow.ControlFlow.t
                        (core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                        u32.t :=
                    M.call (α0 α5) in
                  let* α7 :
                      M.Val
                        (core.ops.control_flow.ControlFlow.t
                          (core.result.Result.t
                            core.convert.Infallible.t
                            erc721.Error.t)
                          u32.t) :=
                    M.alloc α6 in
                  let* α8 : M.Val u32.t :=
                    match_operator
                      α7
                      [
                        fun γ =>
                          (let* α0 := M.read γ in
                          match α0 with
                          | core.ops.control_flow.ControlFlow.Break _ =>
                            let γ0_0 :=
                              core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                            let* residual := M.copy γ0_0 in
                            let* α0 : _ :=
                              ltac:(M.get_method (fun ℐ =>
                                core.ops.try_trait.FromResidual.from_residual
                                  (Self :=
                                    core.result.Result.t unit erc721.Error.t)
                                  (R :=
                                    core.result.Result.t
                                      core.convert.Infallible.t
                                      erc721.Error.t)
                                  (Trait := ℐ))) in
                            let* α1 :
                                core.result.Result.t
                                  core.convert.Infallible.t
                                  erc721.Error.t :=
                              M.read residual in
                            let* α2 :
                                core.result.Result.t unit erc721.Error.t :=
                              M.call (α0 α1) in
                            let* α3 : M.Val never.t := return_ α2 in
                            let* α4 := M.read α3 in
                            let* α5 : u32.t := never_to_any α4 in
                            M.alloc α5
                          | _ => M.break_match
                          end) :
                          M (M.Val u32.t);
                        fun γ =>
                          (let* α0 := M.read γ in
                          match α0 with
                          | core.ops.control_flow.ControlFlow.Continue _ =>
                            let γ0_0 :=
                              core.ops.control_flow.ControlFlow.Get_Continue_0
                                γ in
                            let* val := M.copy γ0_0 in
                            M.pure val
                          | _ => M.break_match
                          end) :
                          M (M.Val u32.t)
                      ] in
                  M.copy α8 in
                let* _ : M.Val (core.option.Option.t u32.t) :=
                  let* α0 :
                      mut_ref (erc721.Mapping.t erc721.AccountId.t u32.t) :=
                    M.read owned_tokens_count in
                  let* α1 : ref erc721.AccountId.t := M.read from in
                  let* α2 : erc721.AccountId.t := M.read (deref α1) in
                  let* α3 : u32.t := M.read count in
                  let* α4 : core.option.Option.t u32.t :=
                    M.call
                      (impl (erc721.Mapping.t erc721.AccountId.t u32.t) "insert"
                        α0
                        α2
                        α3) in
                  M.alloc α4 in
                let* _ : M.Val unit :=
                  let* α0 :
                      mut_ref (erc721.Mapping.t u32.t erc721.AccountId.t) :=
                    M.read token_owner in
                  let* α1 : u32.t := M.read id in
                  let* α2 : unit :=
                    M.call
                      (impl (erc721.Mapping.t u32.t erc721.AccountId.t) "remove"
                        (borrow (deref α0))
                        α1) in
                  M.alloc α2 in
                M.alloc (core.result.Result.Ok tt)
              end) :
              M (M.Val (core.result.Result.t unit erc721.Error.t))
          ] in
      M.read α0).
  
  Axiom remove_token_from_is_impl :
      impl Self "remove_token_from" = remove_token_from.
  
  (*
      fn add_token_to(&mut self, to: &AccountId, id: TokenId) -> Result<(), Error> {
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          if token_owner.contains(&id) {
              return Err(Error::TokenExists);
          }
  
          if *to == AccountId::from([0x0; 32]) {
              return Err(Error::NotAllowed);
          };
  
          let count = owned_tokens_count
              .get(to)
              .map(|c| c + (1 as u32))
              .unwrap_or(1);
  
          owned_tokens_count.insert( *to, count);
          token_owner.insert(id, *to);
  
          Ok(())
      }
  *)
  Parameter add_token_to :
      (mut_ref Self) ->
        (ref erc721.AccountId.t) ->
        ltac:(erc721.TokenId) ->
        M (core.result.Result.t unit erc721.Error.t).
  
  Axiom add_token_to_is_impl : impl Self "add_token_to" = add_token_to.
  
  (*
      fn transfer_token_from(
          &mut self,
          from: &AccountId,
          to: &AccountId,
          id: TokenId,
      ) -> Result<(), Error> {
          let caller = self.env().caller();
          if !self.exists(id) {
              return Err(Error::TokenNotFound);
          };
          if !self.approved_or_owner(Some(caller), id) {
              return Err(Error::NotApproved);
          };
          self.clear_approval(id);
          self.remove_token_from(from, id)?;
          self.add_token_to(to, id)?;
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some( *from),
              to: Some( *to),
              id,
          }));
          Ok(())
      }
  *)
  Parameter transfer_token_from :
      (mut_ref Self) ->
        (ref erc721.AccountId.t) ->
        (ref erc721.AccountId.t) ->
        ltac:(erc721.TokenId) ->
        M (core.result.Result.t unit erc721.Error.t).
  
  Axiom transfer_token_from_is_impl :
      impl Self "transfer_token_from" = transfer_token_from.
  
  (*
      pub fn transfer(&mut self, destination: AccountId, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          self.transfer_token_from(&caller, &destination, id)?;
          Ok(())
      }
  *)
  Definition transfer
      (self : mut_ref Self)
      (destination : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* destination := M.alloc destination in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (impl erc721.Erc721.t "env" (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (impl erc721.Env.t "caller" (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : _ :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t unit erc721.Error.t)
              (Trait := ℐ))) in
        let* α1 : mut_ref erc721.Erc721.t := M.read self in
        let* α2 : u32.t := M.read id in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call
            (impl erc721.Erc721.t "transfer_token_from"
              α1
              (borrow caller)
              (borrow destination)
              α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call (α0 α3) in
        let* α5 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
                unit) :=
          M.alloc α4 in
        match_operator
          α5
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 : _ :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.result.Result.t unit erc721.Error.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      erc721.Error.t :=
                  M.read residual in
                let* α2 : core.result.Result.t unit erc721.Error.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : unit := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val unit)
          ] in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Axiom transfer_is_impl : impl Self "transfer" = transfer.
  
  (*
      pub fn transfer_from(
          &mut self,
          from: AccountId,
          to: AccountId,
          id: TokenId,
      ) -> Result<(), Error> {
          self.transfer_token_from(&from, &to, id)?;
          Ok(())
      }
  *)
  Definition transfer_from
      (self : mut_ref Self)
      (from : erc721.AccountId.t)
      (to : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* from := M.alloc from in
    let* to := M.alloc to in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : _ :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t unit erc721.Error.t)
              (Trait := ℐ))) in
        let* α1 : mut_ref erc721.Erc721.t := M.read self in
        let* α2 : u32.t := M.read id in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call
            (impl erc721.Erc721.t "transfer_token_from"
              α1
              (borrow from)
              (borrow to)
              α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call (α0 α3) in
        let* α5 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
                unit) :=
          M.alloc α4 in
        match_operator
          α5
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 : _ :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.result.Result.t unit erc721.Error.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      erc721.Error.t :=
                  M.read residual in
                let* α2 : core.result.Result.t unit erc721.Error.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : unit := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val unit)
          ] in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Axiom transfer_from_is_impl : impl Self "transfer_from" = transfer_from.
  
  (*
      pub fn mint(&mut self, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          self.add_token_to(&caller, id)?;
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some(AccountId::from([0x0; 32])),
              to: Some(caller),
              id,
          }));
          Ok(())
      }
  *)
  Definition mint
      (self : mut_ref Self)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self := M.alloc self in
    let* id := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (impl erc721.Erc721.t "env" (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (impl erc721.Env.t "caller" (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : _ :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t unit erc721.Error.t)
              (Trait := ℐ))) in
        let* α1 : mut_ref erc721.Erc721.t := M.read self in
        let* α2 : u32.t := M.read id in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call (impl erc721.Erc721.t "add_token_to" α1 (borrow caller) α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call (α0 α3) in
        let* α5 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
                unit) :=
          M.alloc α4 in
        match_operator
          α5
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 : _ :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.result.Result.t unit erc721.Error.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          erc721.Error.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      erc721.Error.t :=
                  M.read residual in
                let* α2 : core.result.Result.t unit erc721.Error.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : unit := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val unit)
          ] in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (impl erc721.Erc721.t "env" (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : _ :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := erc721.AccountId.t)
              (T := array u8.t)
              (Trait := ℐ))) in
        let* α4 : erc721.AccountId.t :=
          M.call (α3 (repeat ((Integer.of_Z 0) : u8.t) 32)) in
        let* α5 : erc721.AccountId.t := M.read caller in
        let* α6 : u32.t := M.read id in
        let* α7 : unit :=
          M.call
            (impl erc721.Env.t "emit_event"
              (borrow α2)
              (erc721.Event.Transfer
                {|
                  erc721.Transfer.from := core.option.Option.Some α4;
                  erc721.Transfer.to := core.option.Option.Some α5;
                  erc721.Transfer.id := α6;
                |})) in
        M.alloc α7 in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Axiom mint_is_impl : impl Self "mint" = mint.
  
  (*
      pub fn burn(&mut self, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          let owner = token_owner.get(&id).ok_or(Error::TokenNotFound)?;
          if owner != caller {
              return Err(Error::NotOwner);
          };
  
          let count = owned_tokens_count
              .get(&caller)
              .map(|c| c - 1)
              .ok_or(Error::CannotFetchValue)?;
          owned_tokens_count.insert(caller, count);
          token_owner.remove(id);
  
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some(caller),
              to: Some(AccountId::from([0x0; 32])),
              id,
          }));
  
          Ok(())
      }
  *)
  Parameter burn :
      (mut_ref Self) ->
        ltac:(erc721.TokenId) ->
        M (core.result.Result.t unit erc721.Error.t).
  
  Axiom burn_is_impl : impl Self "burn" = burn.
End Impl_erc721_Erc721_t.
End Impl_erc721_Erc721_t.
