(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Definition Get__key :=
    Ref.map (fun α => Some α.(_key)) (fun β α => Some (α <| _key := β |>)).
  Definition Get__value :=
    Ref.map (fun α => Some α.(_value)) (fun β α => Some (α <| _value := β |>)).
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_erc721_Mapping_t_K_V.
Section Impl_core_default_Default_for_erc721_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := erc721.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (erc721.Mapping.t K V) :=
    ltac:(M.monadic (
      {|
        erc721.Mapping._key :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := core.marker.PhantomData.t K)
              (Trait := ℐ)))
          |);
        erc721.Mapping._value :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := core.marker.PhantomData.t V)
              (Trait := ℐ)))
          |);
      |} : erc721.Mapping.t K V
    )).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_Mapping_t_K_V.
End Impl_core_default_Default_for_erc721_Mapping_t_K_V.

Module  Impl_erc721_Mapping_t_K_V.
Section Impl_erc721_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := erc721.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref Self) (_key : ref K) : M bool.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := bool.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := core.option.Option.t V)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      let _value := M.alloc (| _value |) in
      (never_to_any (B := core.option.Option.t u32.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref Self) (_key : K) : M unit :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := unit)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref Self)
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := core.option.Option.t u32.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon Self "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (self : ref Self) (_key : K) : M (core.option.Option.t V) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := core.option.Option.t V)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_erc721_Mapping_t_K_V.
End Impl_erc721_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_erc721_AccountId_t.
Section Impl_core_default_Default_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M erc721.AccountId.t :=
    ltac:(M.monadic (
      erc721.AccountId.Build_t
        (M.call (|ltac:(M.get_method (fun ℐ =>
          core.default.Default.default (Self := u128.t) (Trait := ℐ)))
        |))
    )).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_AccountId_t.
End Impl_core_default_Default_for_erc721_AccountId_t.

Module  Impl_core_clone_Clone_for_erc721_AccountId_t.
Section Impl_core_clone_Clone_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M erc721.AccountId.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      M.read (|
        ltac:
          (M.monadic_match_operator
            (DeclaredButUndefinedVariable
              (A := core.clone.AssertParamIsClone.t u128.t))
            [
              fun (γ : M.Val (core.clone.AssertParamIsClone.t u128.t)) =>
                (deref (M.read (| self |))) : M.Val erc721.AccountId.t
            ])
      |)
    )).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_erc721_AccountId_t.
End Impl_core_clone_Clone_for_erc721_AccountId_t.

Module  Impl_core_marker_Copy_for_erc721_AccountId_t.
Section Impl_core_marker_Copy_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_erc721_AccountId_t.
End Impl_core_marker_Copy_for_erc721_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
Section Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref erc721.AccountId.t) : M bool.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let other := M.alloc (| other |) in
      BinOp.Pure.eq
        (M.read (| erc721.AccountId.Get_0 (deref (M.read (| self |))) |))
        (M.read (| erc721.AccountId.Get_0 (deref (M.read (| other |))) |))
    )).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
End Impl_core_cmp_PartialEq_for_erc721_AccountId_t.

Module  Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
Section Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
  Definition Self : Set := erc721.AccountId.t.
  
  (*
      fn from(_value: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Definition from (_value : array u8.t) : M Self :=
    ltac:(M.monadic (
      let _value := M.alloc (| _value |) in
      (never_to_any (B := erc721.AccountId.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := array u8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
End Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : erc721.AccountId.t;
  }.
  
  Definition Get_caller :=
    Ref.map (fun α => Some α.(caller)) (fun β α => Some (α <| caller := β |>)).
End Env.
End Env.

Ltac TokenId := exact u32.t.

Module  Erc721.
Section Erc721.
  Record t : Set := {
    token_owner : erc721.Mapping.t ltac:(erc721.TokenId) erc721.AccountId.t;
    token_approvals : erc721.Mapping.t ltac:(erc721.TokenId) erc721.AccountId.t;
    owned_tokens_count : erc721.Mapping.t erc721.AccountId.t u32.t;
    operator_approvals :
      erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit;
  }.
  
  Definition Get_token_owner :=
    Ref.map
      (fun α => Some α.(token_owner))
      (fun β α => Some (α <| token_owner := β |>)).
  Definition Get_token_approvals :=
    Ref.map
      (fun α => Some α.(token_approvals))
      (fun β α => Some (α <| token_approvals := β |>)).
  Definition Get_owned_tokens_count :=
    Ref.map
      (fun α => Some α.(owned_tokens_count))
      (fun β α => Some (α <| owned_tokens_count := β |>)).
  Definition Get_operator_approvals :=
    Ref.map
      (fun α => Some α.(operator_approvals))
      (fun β α => Some (α <| operator_approvals := β |>)).
End Erc721.
End Erc721.

Module  Impl_core_default_Default_for_erc721_Erc721_t.
Section Impl_core_default_Default_for_erc721_Erc721_t.
  Definition Self : Set := erc721.Erc721.t.
  
  (*
  Default
  *)
  Definition default : M erc721.Erc721.t :=
    ltac:(M.monadic (
      {|
        erc721.Erc721.token_owner :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := erc721.Mapping.t u32.t erc721.AccountId.t)
              (Trait := ℐ)))
          |);
        erc721.Erc721.token_approvals :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := erc721.Mapping.t u32.t erc721.AccountId.t)
              (Trait := ℐ)))
          |);
        erc721.Erc721.owned_tokens_count :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := erc721.Mapping.t erc721.AccountId.t u32.t)
              (Trait := ℐ)))
          |);
        erc721.Erc721.operator_approvals :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self :=
                erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit)
              (Trait := ℐ)))
          |);
      |} : erc721.Erc721.t
    )).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_Erc721_t.
End Impl_core_default_Default_for_erc721_Erc721_t.

Module Error.
  Inductive t : Set :=
  | NotOwner
  | NotApproved
  | TokenExists
  | TokenNotFound
  | CannotInsert
  | CannotFetchValue
  | NotAllowed.
End Error.

Module  Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
Section Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
End Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.

Module  Impl_core_cmp_PartialEq_for_erc721_Error_t.
Section Impl_core_cmp_PartialEq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref erc721.Error.t) : M bool.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let other := M.alloc (| other |) in
      M.read (|
        let __self_tag : M.Val isize.t :=
          M.alloc (|
            M.call (|(core.intrinsics.discriminant_value (M.read (| self |))) |)
          |) in
        let __arg1_tag : M.Val isize.t :=
          M.alloc (|
            M.call (|(core.intrinsics.discriminant_value (M.read (| other |)))
            |)
          |) in
        M.alloc (|
          BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_erc721_Error_t.
End Impl_core_cmp_PartialEq_for_erc721_Error_t.

Module  Impl_core_marker_StructuralEq_for_erc721_Error_t.
Section Impl_core_marker_StructuralEq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_erc721_Error_t.
End Impl_core_marker_StructuralEq_for_erc721_Error_t.

Module  Impl_core_cmp_Eq_for_erc721_Error_t.
Section Impl_core_cmp_Eq_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      tt
    )).
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_erc721_Error_t.
End Impl_core_cmp_Eq_for_erc721_Error_t.

Module  Impl_core_clone_Clone_for_erc721_Error_t.
Section Impl_core_clone_Clone_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M erc721.Error.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      M.read (| deref (M.read (| self |)) |)
    )).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_erc721_Error_t.
End Impl_core_clone_Clone_for_erc721_Error_t.

Module  Impl_core_marker_Copy_for_erc721_Error_t.
Section Impl_core_marker_Copy_for_erc721_Error_t.
  Definition Self : Set := erc721.Error.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_erc721_Error_t.
End Impl_core_marker_Copy_for_erc721_Error_t.

Module  Transfer.
Section Transfer.
  Record t : Set := {
    from : core.option.Option.t erc721.AccountId.t;
    to : core.option.Option.t erc721.AccountId.t;
    id : ltac:(erc721.TokenId);
  }.
  
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
  Definition Get_to :=
    Ref.map (fun α => Some α.(to)) (fun β α => Some (α <| to := β |>)).
  Definition Get_id :=
    Ref.map (fun α => Some α.(id)) (fun β α => Some (α <| id := β |>)).
End Transfer.
End Transfer.

Module  Approval.
Section Approval.
  Record t : Set := {
    from : erc721.AccountId.t;
    to : erc721.AccountId.t;
    id : ltac:(erc721.TokenId);
  }.
  
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
  Definition Get_to :=
    Ref.map (fun α => Some α.(to)) (fun β α => Some (α <| to := β |>)).
  Definition Get_id :=
    Ref.map (fun α => Some α.(id)) (fun β α => Some (α <| id := β |>)).
End Approval.
End Approval.

Module  ApprovalForAll.
Section ApprovalForAll.
  Record t : Set := {
    owner : erc721.AccountId.t;
    operator : erc721.AccountId.t;
    approved : bool.t;
  }.
  
  Definition Get_owner :=
    Ref.map (fun α => Some α.(owner)) (fun β α => Some (α <| owner := β |>)).
  Definition Get_operator :=
    Ref.map
      (fun α => Some α.(operator))
      (fun β α => Some (α <| operator := β |>)).
  Definition Get_approved :=
    Ref.map
      (fun α => Some α.(approved))
      (fun β α => Some (α <| approved := β |>)).
End ApprovalForAll.
End ApprovalForAll.

Module Event.
  Inductive t : Set :=
  | Transfer (_ : erc721.Transfer.t)
  | Approval (_ : erc721.Approval.t)
  | ApprovalForAll (_ : erc721.ApprovalForAll.t).
  
  Definition Get_Transfer_0 :=
    Ref.map
      (fun α => match α with | Transfer α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Transfer _ => Some (Transfer β) | _ => None end).
  
  Definition Get_Approval_0 :=
    Ref.map
      (fun α => match α with | Approval α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Approval _ => Some (Approval β) | _ => None end).
  
  Definition Get_ApprovalForAll_0 :=
    Ref.map
      (fun α => match α with | ApprovalForAll α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | ApprovalForAll _ => Some (ApprovalForAll β)
        | _ => None
        end).
End Event.

Module  Impl_erc721_Env_t.
Section Impl_erc721_Env_t.
  Definition Self : Set := erc721.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (self : ref Self) : M erc721.AccountId.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      M.read (| erc721.Env.Get_caller (deref (M.read (| self |))) |)
    )).
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (self : ref Self) (_event : erc721.Event.t) : M unit :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let _event := M.alloc (| _event |) in
      (never_to_any (B := unit)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_emit_event :
    Notations.DoubleColon Self "emit_event" := {
    Notations.double_colon := emit_event;
  }.
End Impl_erc721_Env_t.
End Impl_erc721_Env_t.

Module  Impl_erc721_Erc721_t.
Section Impl_erc721_Erc721_t.
  Definition Self : Set := erc721.Erc721.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M erc721.Env.t :=
    ltac:(M.monadic (
      (never_to_any (B := erc721.Env.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (self : ref Self) : M erc721.Env.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      M.call (|erc721.Erc721.t::["init_env"] |)
    )).
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new() -> Self {
          Default::default()
      }
  *)
  Definition new : M Self :=
    ltac:(M.monadic (
      M.call (|ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := erc721.Erc721.t) (Trait := ℐ)))
      |)
    )).
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn balance_of_or_zero(&self, of: &AccountId) -> u32 {
          self.owned_tokens_count.get(of).unwrap_or(0 as u32)
      }
  *)
  Definition balance_of_or_zero
      (self : ref Self)
      (of : ref erc721.AccountId.t)
      : M u32.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let of := M.alloc (| of |) in
      M.call (|((core.option.Option.t u32.t)::["unwrap_or"]
        (M.call (|((erc721.Mapping.t erc721.AccountId.t u32.t)::["get"]
          (borrow
            (erc721.Erc721.Get_owned_tokens_count (deref (M.read (| self |)))))
          (M.read (| of |)))
        |))
        (M.read (| use (M.alloc (| (Integer.of_Z 0) : u32.t |)) |)))
      |)
    )).
  
  Global Instance AssociatedFunction_balance_of_or_zero :
    Notations.DoubleColon Self "balance_of_or_zero" := {
    Notations.double_colon := balance_of_or_zero;
  }.
  
  (*
      fn clear_approval(&mut self, id: TokenId) {
          self.token_approvals.remove(id);
      }
  *)
  Definition clear_approval
      (self : mut_ref Self)
      (id : ltac:(erc721.TokenId))
      : M unit :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let id := M.alloc (| id |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|((erc721.Mapping.t u32.t erc721.AccountId.t)::["remove"]
              (borrow
                (erc721.Erc721.Get_token_approvals (deref (M.read (| self |)))))
              (M.read (| id |)))
            |)
          |) in
        M.alloc (| tt |)
      |)
    )).
  
  Global Instance AssociatedFunction_clear_approval :
    Notations.DoubleColon Self "clear_approval" := {
    Notations.double_colon := clear_approval;
  }.
  
  (*
      fn approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {
          self.operator_approvals.contains(&(owner, operator))
      }
  *)
  Definition approved_for_all
      (self : ref Self)
      (owner : erc721.AccountId.t)
      (operator : erc721.AccountId.t)
      : M bool.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let owner := M.alloc (| owner |) in
      let operator := M.alloc (| operator |) in
      M.call (|((erc721.Mapping.t
            (erc721.AccountId.t * erc721.AccountId.t)
            unit)::["contains"]
        (borrow
          (erc721.Erc721.Get_operator_approvals (deref (M.read (| self |)))))
        (borrow (M.alloc (| (M.read (| owner |), M.read (| operator |)) |))))
      |)
    )).
  
  Global Instance AssociatedFunction_approved_for_all :
    Notations.DoubleColon Self "approved_for_all" := {
    Notations.double_colon := approved_for_all;
  }.
  
  (*
      pub fn owner_of(&self, id: TokenId) -> Option<AccountId> {
          self.token_owner.get(&id)
      }
  *)
  Definition owner_of
      (self : ref Self)
      (id : ltac:(erc721.TokenId))
      : M (core.option.Option.t erc721.AccountId.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let id := M.alloc (| id |) in
      M.call (|((erc721.Mapping.t u32.t erc721.AccountId.t)::["get"]
        (borrow (erc721.Erc721.Get_token_owner (deref (M.read (| self |)))))
        (borrow id))
      |)
    )).
  
  Global Instance AssociatedFunction_owner_of :
    Notations.DoubleColon Self "owner_of" := {
    Notations.double_colon := owner_of;
  }.
  
  (*
      fn approved_or_owner(&self, from: Option<AccountId>, id: TokenId) -> bool {
          let owner = self.owner_of(id);
          from != Some(AccountId::from([0x0; 32]))
              && (from == owner
                  || from == self.token_approvals.get(&id)
                  || self.approved_for_all(
                      owner.expect("Error with AccountId"),
                      from.expect("Error with AccountId"),
                  ))
      }
  *)
  Definition approved_or_owner
      (self : ref Self)
      (from : core.option.Option.t erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M bool.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let from := M.alloc (| from |) in
      let id := M.alloc (| id |) in
      M.read (|
        let owner : M.Val (core.option.Option.t erc721.AccountId.t) :=
          M.alloc (|
            M.call (|(erc721.Erc721.t::["owner_of"]
              (M.read (| self |))
              (M.read (| id |)))
            |)
          |) in
        M.alloc (|
          BinOp.Pure.and
            (M.call (|(ltac:(M.get_method (fun ℐ =>
                core.cmp.PartialEq.ne
                  (Self := core.option.Option.t erc721.AccountId.t)
                  (Rhs := core.option.Option.t erc721.AccountId.t)
                  (Trait := ℐ)))
              (borrow from)
              (borrow
                (M.alloc (|
                  core.option.Option.Some
                    (M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.convert.From.from
                          (Self := erc721.AccountId.t)
                          (T := array u8.t)
                          (Trait := ℐ)))
                      (repeat ((Integer.of_Z 0) : u8.t) 32))
                    |))
                |))))
            |))
            (BinOp.Pure.or
              (BinOp.Pure.or
                (M.call (|(ltac:(M.get_method (fun ℐ =>
                    core.cmp.PartialEq.eq
                      (Self := core.option.Option.t erc721.AccountId.t)
                      (Rhs := core.option.Option.t erc721.AccountId.t)
                      (Trait := ℐ)))
                  (borrow from)
                  (borrow owner))
                |))
                (M.call (|(ltac:(M.get_method (fun ℐ =>
                    core.cmp.PartialEq.eq
                      (Self := core.option.Option.t erc721.AccountId.t)
                      (Rhs := core.option.Option.t erc721.AccountId.t)
                      (Trait := ℐ)))
                  (borrow from)
                  (borrow
                    (M.alloc (|
                      M.call (|((erc721.Mapping.t
                            u32.t
                            erc721.AccountId.t)::["get"]
                        (borrow
                          (erc721.Erc721.Get_token_approvals
                            (deref (M.read (| self |)))))
                        (borrow id))
                      |)
                    |))))
                |)))
              (M.call (|(erc721.Erc721.t::["approved_for_all"]
                (M.read (| self |))
                (M.call (|((core.option.Option.t erc721.AccountId.t)::["expect"]
                  (M.read (| owner |))
                  (M.read (| mk_str "Error with AccountId" |)))
                |))
                (M.call (|((core.option.Option.t erc721.AccountId.t)::["expect"]
                  (M.read (| from |))
                  (M.read (| mk_str "Error with AccountId" |)))
                |)))
              |)))
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_approved_or_owner :
    Notations.DoubleColon Self "approved_or_owner" := {
    Notations.double_colon := approved_or_owner;
  }.
  
  (*
      fn exists(&self, id: TokenId) -> bool {
          self.token_owner.contains(&id)
      }
  *)
  Definition exists_
      (self : ref Self)
      (id : ltac:(erc721.TokenId))
      : M bool.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let id := M.alloc (| id |) in
      M.call (|((erc721.Mapping.t u32.t erc721.AccountId.t)::["contains"]
        (borrow (erc721.Erc721.Get_token_owner (deref (M.read (| self |)))))
        (borrow id))
      |)
    )).
  
  Global Instance AssociatedFunction_exists_ :
    Notations.DoubleColon Self "exists_" := {
    Notations.double_colon := exists_;
  }.
  
  (*
      pub fn balance_of(&self, owner: AccountId) -> u32 {
          self.balance_of_or_zero(&owner)
      }
  *)
  Definition balance_of
      (self : ref Self)
      (owner : erc721.AccountId.t)
      : M u32.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let owner := M.alloc (| owner |) in
      M.call (|(erc721.Erc721.t::["balance_of_or_zero"]
        (M.read (| self |))
        (borrow owner))
      |)
    )).
  
  Global Instance AssociatedFunction_balance_of :
    Notations.DoubleColon Self "balance_of" := {
    Notations.double_colon := balance_of;
  }.
  
  (*
      pub fn get_approved(&self, id: TokenId) -> Option<AccountId> {
          self.token_approvals.get(&id)
      }
  *)
  Definition get_approved
      (self : ref Self)
      (id : ltac:(erc721.TokenId))
      : M (core.option.Option.t erc721.AccountId.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let id := M.alloc (| id |) in
      M.call (|((erc721.Mapping.t u32.t erc721.AccountId.t)::["get"]
        (borrow (erc721.Erc721.Get_token_approvals (deref (M.read (| self |)))))
        (borrow id))
      |)
    )).
  
  Global Instance AssociatedFunction_get_approved :
    Notations.DoubleColon Self "get_approved" := {
    Notations.double_colon := get_approved;
  }.
  
  (*
      pub fn is_approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {
          self.approved_for_all(owner, operator)
      }
  *)
  Definition is_approved_for_all
      (self : ref Self)
      (owner : erc721.AccountId.t)
      (operator : erc721.AccountId.t)
      : M bool.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let owner := M.alloc (| owner |) in
      let operator := M.alloc (| operator |) in
      M.call (|(erc721.Erc721.t::["approved_for_all"]
        (M.read (| self |))
        (M.read (| owner |))
        (M.read (| operator |)))
      |)
    )).
  
  Global Instance AssociatedFunction_is_approved_for_all :
    Notations.DoubleColon Self "is_approved_for_all" := {
    Notations.double_colon := is_approved_for_all;
  }.
  
  (*
      fn approve_for_all(&mut self, to: AccountId, approved: bool) -> Result<(), Error> {
          let caller = self.env().caller();
          if to == caller {
              return Err(Error::NotAllowed);
          }
          self.env().emit_event(Event::ApprovalForAll(ApprovalForAll {
              owner: caller,
              operator: to,
              approved,
          }));
  
          if approved {
              self.operator_approvals.insert((caller, to), ());
          } else {
              self.operator_approvals.remove((caller, to));
          }
  
          Ok(())
      }
  *)
  Definition approve_for_all
      (self : mut_ref Self)
      (to : erc721.AccountId.t)
      (approved : bool.t)
      : M (core.result.Result.t unit erc721.Error.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let to := M.alloc (| to |) in
      let approved := M.alloc (| approved |) in
      let return_ :=
        M.return_ (R := core.result.Result.t unit erc721.Error.t) in
      M.catch_return
        (M.read (|
          let caller : M.Val erc721.AccountId.t :=
            M.alloc (|
              M.call (|(erc721.Env.t::["caller"]
                (borrow
                  (M.alloc (|
                    M.call (|(erc721.Erc721.t::["env"]
                      (borrow (deref (M.read (| self |)))))
                    |)
                  |))))
              |)
            |) in
          let _ : M.Val unit :=
            if
              M.read (|
                use
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.cmp.PartialEq.eq
                          (Self := erc721.AccountId.t)
                          (Rhs := erc721.AccountId.t)
                          (Trait := ℐ)))
                      (borrow to)
                      (borrow caller))
                    |)
                  |))
              |)
            then
              M.alloc (|
                (never_to_any (B := unit)) (|
                  M.read (|
                    return_ (core.result.Result.Err erc721.Error.NotAllowed)
                  |)
                |)
              |)
            else
              M.alloc (| tt |) in
          let _ : M.Val unit :=
            M.alloc (|
              M.call (|(erc721.Env.t::["emit_event"]
                (borrow
                  (M.alloc (|
                    M.call (|(erc721.Erc721.t::["env"]
                      (borrow (deref (M.read (| self |)))))
                    |)
                  |)))
                (erc721.Event.ApprovalForAll
                  ({|
                    erc721.ApprovalForAll.owner := M.read (| caller |);
                    erc721.ApprovalForAll.operator := M.read (| to |);
                    erc721.ApprovalForAll.approved := M.read (| approved |);
                  |} : erc721.ApprovalForAll.t)))
              |)
            |) in
          let _ : M.Val unit :=
            if M.read (| use approved |) then
              let _ : M.Val (core.option.Option.t u32.t) :=
                M.alloc (|
                  M.call (|((erc721.Mapping.t
                        (erc721.AccountId.t * erc721.AccountId.t)
                        unit)::["insert"]
                    (borrow_mut
                      (erc721.Erc721.Get_operator_approvals
                        (deref (M.read (| self |)))))
                    (M.read (| caller |), M.read (| to |))
                    tt)
                  |)
                |) in
              M.alloc (| tt |)
            else
              let _ : M.Val unit :=
                M.alloc (|
                  M.call (|((erc721.Mapping.t
                        (erc721.AccountId.t * erc721.AccountId.t)
                        unit)::["remove"]
                    (borrow
                      (erc721.Erc721.Get_operator_approvals
                        (deref (M.read (| self |)))))
                    (M.read (| caller |), M.read (| to |)))
                  |)
                |) in
              M.alloc (| tt |) in
          M.alloc (| core.result.Result.Ok tt |)
        |))
    )).
  
  Global Instance AssociatedFunction_approve_for_all :
    Notations.DoubleColon Self "approve_for_all" := {
    Notations.double_colon := approve_for_all;
  }.
  
  (*
      pub fn set_approval_for_all(&mut self, to: AccountId, approved: bool) -> Result<(), Error> {
          self.approve_for_all(to, approved)?;
          Ok(())
      }
  *)
  Definition set_approval_for_all
      (self : mut_ref Self)
      (to : erc721.AccountId.t)
      (approved : bool.t)
      : M (core.result.Result.t unit erc721.Error.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let to := M.alloc (| to |) in
      let approved := M.alloc (| approved |) in
      let return_ :=
        M.return_ (R := core.result.Result.t unit erc721.Error.t) in
      M.catch_return
        (M.read (|
          let _ : M.Val unit :=
            ltac:
              (M.monadic_match_operator
                (M.alloc (|
                  M.call (|(ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.Try.branch
                        (Self := core.result.Result.t unit erc721.Error.t)
                        (Trait := ℐ)))
                    (M.call (|(erc721.Erc721.t::["approve_for_all"]
                      (M.read (| self |))
                      (M.read (| to |))
                      (M.read (| approved |)))
                    |)))
                  |)
                |))
                [
                  fun
                      (γ :
                        M.Val
                          (core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              erc721.Error.t)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.ops.control_flow.ControlFlow.Break _ =>
                      let γ0_0 :=
                        core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        (never_to_any (B := unit)) (|
                          M.read (|
                            return_
                              (M.call (|(ltac:(M.get_method (fun ℐ =>
                                  core.ops.try_trait.FromResidual.from_residual
                                    (Self :=
                                      core.result.Result.t unit erc721.Error.t)
                                    (R :=
                                      core.result.Result.t
                                        core.convert.Infallible.t
                                        erc721.Error.t)
                                    (Trait := ℐ)))
                                (M.read (| residual |)))
                              |))
                          |)
                        |)
                      |)
                    | _ => M.break_match(||)
                    end :
                    M.Val unit;
                  fun
                      (γ :
                        M.Val
                          (core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              erc721.Error.t)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.ops.control_flow.ControlFlow.Continue _ =>
                      let γ0_0 :=
                        core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                      let val := M.copy (| γ0_0 |) in
                      val
                    | _ => M.break_match(||)
                    end :
                    M.Val unit
                ]) in
          M.alloc (| core.result.Result.Ok tt |)
        |))
    )).
  
  Global Instance AssociatedFunction_set_approval_for_all :
    Notations.DoubleColon Self "set_approval_for_all" := {
    Notations.double_colon := set_approval_for_all;
  }.
  
  (*
      fn approve_for(&mut self, to: &AccountId, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          let owner = self.owner_of(id);
          if !(owner == Some(caller)
              || self.approved_for_all(owner.expect("Error with AccountId"), caller))
          {
              return Err(Error::NotAllowed);
          };
  
          if *to == AccountId::from([0x0; 32]) {
              return Err(Error::NotAllowed);
          };
  
          if self.token_approvals.contains(&id) {
              return Err(Error::CannotInsert);
          } else {
              self.token_approvals.insert(id, *to);
          }
  
          self.env().emit_event(Event::Approval(Approval {
              from: caller,
              to: *to,
              id,
          }));
  
          Ok(())
      }
  *)
  Definition approve_for
      (self : mut_ref Self)
      (to : ref erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let to := M.alloc (| to |) in
      let id := M.alloc (| id |) in
      let return_ :=
        M.return_ (R := core.result.Result.t unit erc721.Error.t) in
      M.catch_return
        (M.read (|
          let caller : M.Val erc721.AccountId.t :=
            M.alloc (|
              M.call (|(erc721.Env.t::["caller"]
                (borrow
                  (M.alloc (|
                    M.call (|(erc721.Erc721.t::["env"]
                      (borrow (deref (M.read (| self |)))))
                    |)
                  |))))
              |)
            |) in
          let owner : M.Val (core.option.Option.t erc721.AccountId.t) :=
            M.alloc (|
              M.call (|(erc721.Erc721.t::["owner_of"]
                (borrow (deref (M.read (| self |))))
                (M.read (| id |)))
              |)
            |) in
          let _ : M.Val unit :=
            if
              M.read (|
                use
                  (M.alloc (|
                    UnOp.not
                      (BinOp.Pure.or
                        (M.call (|(ltac:(M.get_method (fun ℐ =>
                            core.cmp.PartialEq.eq
                              (Self := core.option.Option.t erc721.AccountId.t)
                              (Rhs := core.option.Option.t erc721.AccountId.t)
                              (Trait := ℐ)))
                          (borrow owner)
                          (borrow
                            (M.alloc (|
                              core.option.Option.Some (M.read (| caller |))
                            |))))
                        |))
                        (M.call (|(erc721.Erc721.t::["approved_for_all"]
                          (borrow (deref (M.read (| self |))))
                          (M.call (|((core.option.Option.t
                                erc721.AccountId.t)::["expect"]
                            (M.read (| owner |))
                            (M.read (| mk_str "Error with AccountId" |)))
                          |))
                          (M.read (| caller |)))
                        |)))
                  |))
              |)
            then
              M.alloc (|
                (never_to_any (B := unit)) (|
                  M.read (|
                    return_ (core.result.Result.Err erc721.Error.NotAllowed)
                  |)
                |)
              |)
            else
              M.alloc (| tt |) in
          let _ : M.Val unit :=
            if
              M.read (|
                use
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.cmp.PartialEq.eq
                          (Self := erc721.AccountId.t)
                          (Rhs := erc721.AccountId.t)
                          (Trait := ℐ)))
                      (M.read (| to |))
                      (borrow
                        (M.alloc (|
                          M.call (|(ltac:(M.get_method (fun ℐ =>
                              core.convert.From.from
                                (Self := erc721.AccountId.t)
                                (T := array u8.t)
                                (Trait := ℐ)))
                            (repeat ((Integer.of_Z 0) : u8.t) 32))
                          |)
                        |))))
                    |)
                  |))
              |)
            then
              M.alloc (|
                (never_to_any (B := unit)) (|
                  M.read (|
                    return_ (core.result.Result.Err erc721.Error.NotAllowed)
                  |)
                |)
              |)
            else
              M.alloc (| tt |) in
          let _ : M.Val unit :=
            if
              M.read (|
                use
                  (M.alloc (|
                    M.call (|((erc721.Mapping.t
                          u32.t
                          erc721.AccountId.t)::["contains"]
                      (borrow
                        (erc721.Erc721.Get_token_approvals
                          (deref (M.read (| self |)))))
                      (borrow id))
                    |)
                  |))
              |)
            then
              M.alloc (|
                (never_to_any (B := unit)) (|
                  M.read (|
                    return_ (core.result.Result.Err erc721.Error.CannotInsert)
                  |)
                |)
              |)
            else
              let _ : M.Val (core.option.Option.t u32.t) :=
                M.alloc (|
                  M.call (|((erc721.Mapping.t
                        u32.t
                        erc721.AccountId.t)::["insert"]
                    (borrow_mut
                      (erc721.Erc721.Get_token_approvals
                        (deref (M.read (| self |)))))
                    (M.read (| id |))
                    (M.read (| deref (M.read (| to |)) |)))
                  |)
                |) in
              M.alloc (| tt |) in
          let _ : M.Val unit :=
            M.alloc (|
              M.call (|(erc721.Env.t::["emit_event"]
                (borrow
                  (M.alloc (|
                    M.call (|(erc721.Erc721.t::["env"]
                      (borrow (deref (M.read (| self |)))))
                    |)
                  |)))
                (erc721.Event.Approval
                  ({|
                    erc721.Approval.from := M.read (| caller |);
                    erc721.Approval.to := M.read (| deref (M.read (| to |)) |);
                    erc721.Approval.id := M.read (| id |);
                  |} : erc721.Approval.t)))
              |)
            |) in
          M.alloc (| core.result.Result.Ok tt |)
        |))
    )).
  
  Global Instance AssociatedFunction_approve_for :
    Notations.DoubleColon Self "approve_for" := {
    Notations.double_colon := approve_for;
  }.
  
  (*
      pub fn approve(&mut self, to: AccountId, id: TokenId) -> Result<(), Error> {
          self.approve_for(&to, id)?;
          Ok(())
      }
  *)
  Definition approve
      (self : mut_ref Self)
      (to : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let to := M.alloc (| to |) in
      let id := M.alloc (| id |) in
      let return_ :=
        M.return_ (R := core.result.Result.t unit erc721.Error.t) in
      M.catch_return
        (M.read (|
          let _ : M.Val unit :=
            ltac:
              (M.monadic_match_operator
                (M.alloc (|
                  M.call (|(ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.Try.branch
                        (Self := core.result.Result.t unit erc721.Error.t)
                        (Trait := ℐ)))
                    (M.call (|(erc721.Erc721.t::["approve_for"]
                      (M.read (| self |))
                      (borrow to)
                      (M.read (| id |)))
                    |)))
                  |)
                |))
                [
                  fun
                      (γ :
                        M.Val
                          (core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              erc721.Error.t)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.ops.control_flow.ControlFlow.Break _ =>
                      let γ0_0 :=
                        core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        (never_to_any (B := unit)) (|
                          M.read (|
                            return_
                              (M.call (|(ltac:(M.get_method (fun ℐ =>
                                  core.ops.try_trait.FromResidual.from_residual
                                    (Self :=
                                      core.result.Result.t unit erc721.Error.t)
                                    (R :=
                                      core.result.Result.t
                                        core.convert.Infallible.t
                                        erc721.Error.t)
                                    (Trait := ℐ)))
                                (M.read (| residual |)))
                              |))
                          |)
                        |)
                      |)
                    | _ => M.break_match(||)
                    end :
                    M.Val unit;
                  fun
                      (γ :
                        M.Val
                          (core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              erc721.Error.t)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.ops.control_flow.ControlFlow.Continue _ =>
                      let γ0_0 :=
                        core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                      let val := M.copy (| γ0_0 |) in
                      val
                    | _ => M.break_match(||)
                    end :
                    M.Val unit
                ]) in
          M.alloc (| core.result.Result.Ok tt |)
        |))
    )).
  
  Global Instance AssociatedFunction_approve :
    Notations.DoubleColon Self "approve" := {
    Notations.double_colon := approve;
  }.
  
  (*
      fn remove_token_from(&mut self, from: &AccountId, id: TokenId) -> Result<(), Error> {
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          if !token_owner.contains(&id) {
              return Err(Error::TokenNotFound);
          }
  
          let count = owned_tokens_count
              .get(from)
              .map(|c| c - (1 as u32))
              .ok_or(Error::CannotFetchValue)?;
          owned_tokens_count.insert( *from, count);
          token_owner.remove(id);
  
          Ok(())
      }
  *)
  Definition remove_token_from
      (self : mut_ref Self)
      (from : ref erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let from := M.alloc (| from |) in
      let id := M.alloc (| id |) in
      let return_ :=
        M.return_ (R := core.result.Result.t unit erc721.Error.t) in
      M.catch_return
        (M.read (|
          ltac:
            (M.monadic_match_operator
              self
              [
                fun (γ : M.Val (mut_ref erc721.Erc721.t)) =>
                  (let γ := deref (M.read (| γ |)) in
                  match M.read (| γ |) with
                  |
                      {|
                        erc721.Erc721.token_owner := _;
                        erc721.Erc721.owned_tokens_count := _;
                      |}
                      =>
                    let γ1_0 := erc721.Erc721.Get_token_owner γ in
                    let γ1_1 := erc721.Erc721.Get_owned_tokens_count γ in
                    let token_owner := M.alloc (| borrow_mut γ1_0 |) in
                    let owned_tokens_count := M.alloc (| borrow_mut γ1_1 |) in
                    let _ : M.Val unit :=
                      if
                        M.read (|
                          use
                            (M.alloc (|
                              UnOp.not
                                (M.call (|((erc721.Mapping.t
                                      u32.t
                                      erc721.AccountId.t)::["contains"]
                                  (borrow (deref (M.read (| token_owner |))))
                                  (borrow id))
                                |))
                            |))
                        |)
                      then
                        M.alloc (|
                          (never_to_any (B := unit)) (|
                            M.read (|
                              return_
                                (core.result.Result.Err
                                  erc721.Error.TokenNotFound)
                            |)
                          |)
                        |)
                      else
                        M.alloc (| tt |) in
                    let count : M.Val u32.t :=
                      M.copy (|
                        ltac:
                          (M.monadic_match_operator
                            (M.alloc (|
                              M.call (|(ltac:(M.get_method (fun ℐ =>
                                  core.ops.try_trait.Try.branch
                                    (Self :=
                                      core.result.Result.t u32.t erc721.Error.t)
                                    (Trait := ℐ)))
                                (M.call (|((core.option.Option.t
                                      u32.t)::["ok_or"]
                                  (M.call (|((core.option.Option.t
                                        u32.t)::["map"]
                                    (M.call (|((erc721.Mapping.t
                                          erc721.AccountId.t
                                          u32.t)::["get"]
                                      (borrow
                                        (deref
                                          (M.read (| owned_tokens_count |))))
                                      (M.read (| from |)))
                                    |))
                                    (fun (α0 : u32.t) =>
                                      (ltac:
                                        (M.monadic_match_operator
                                          (M.alloc (| α0 |))
                                          [
                                            fun γ =>
                                              (let c := M.copy (| γ |) in
                                              BinOp.Panic.sub (|
                                                M.read (| c |),
                                                M.read (|
                                                  use
                                                    (M.alloc (|
                                                      (Integer.of_Z 1) : u32.t
                                                    |))
                                                |)
                                              |)) :
                                              u32.t
                                          ])) :
                                      u32.t))
                                  |))
                                  erc721.Error.CannotFetchValue)
                                |)))
                              |)
                            |))
                            [
                              fun
                                  (γ :
                                    M.Val
                                      (core.ops.control_flow.ControlFlow.t
                                        (core.result.Result.t
                                          core.convert.Infallible.t
                                          erc721.Error.t)
                                        u32.t)) =>
                                match M.read (| γ |) with
                                | core.ops.control_flow.ControlFlow.Break _ =>
                                  let γ0_0 :=
                                    core.ops.control_flow.ControlFlow.Get_Break_0
                                      γ in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    (never_to_any (B := u32.t)) (|
                                      M.read (|
                                        return_
                                          (M.call (|(ltac:(M.get_method (fun ℐ =>
                                              core.ops.try_trait.FromResidual.from_residual
                                                (Self :=
                                                  core.result.Result.t
                                                    unit
                                                    erc721.Error.t)
                                                (R :=
                                                  core.result.Result.t
                                                    core.convert.Infallible.t
                                                    erc721.Error.t)
                                                (Trait := ℐ)))
                                            (M.read (| residual |)))
                                          |))
                                      |)
                                    |)
                                  |)
                                | _ => M.break_match(||)
                                end :
                                M.Val u32.t;
                              fun
                                  (γ :
                                    M.Val
                                      (core.ops.control_flow.ControlFlow.t
                                        (core.result.Result.t
                                          core.convert.Infallible.t
                                          erc721.Error.t)
                                        u32.t)) =>
                                match M.read (| γ |) with
                                |
                                    core.ops.control_flow.ControlFlow.Continue _
                                    =>
                                  let γ0_0 :=
                                    core.ops.control_flow.ControlFlow.Get_Continue_0
                                      γ in
                                  let val := M.copy (| γ0_0 |) in
                                  val
                                | _ => M.break_match(||)
                                end :
                                M.Val u32.t
                            ])
                      |) in
                    let _ : M.Val (core.option.Option.t u32.t) :=
                      M.alloc (|
                        M.call (|((erc721.Mapping.t
                              erc721.AccountId.t
                              u32.t)::["insert"]
                          (M.read (| owned_tokens_count |))
                          (M.read (| deref (M.read (| from |)) |))
                          (M.read (| count |)))
                        |)
                      |) in
                    let _ : M.Val unit :=
                      M.alloc (|
                        M.call (|((erc721.Mapping.t
                              u32.t
                              erc721.AccountId.t)::["remove"]
                          (borrow (deref (M.read (| token_owner |))))
                          (M.read (| id |)))
                        |)
                      |) in
                    M.alloc (| core.result.Result.Ok tt |)
                  end) :
                  M.Val (core.result.Result.t unit erc721.Error.t)
              ])
        |))
    )).
  
  Global Instance AssociatedFunction_remove_token_from :
    Notations.DoubleColon Self "remove_token_from" := {
    Notations.double_colon := remove_token_from;
  }.
  
  (*
      fn add_token_to(&mut self, to: &AccountId, id: TokenId) -> Result<(), Error> {
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          if token_owner.contains(&id) {
              return Err(Error::TokenExists);
          }
  
          if *to == AccountId::from([0x0; 32]) {
              return Err(Error::NotAllowed);
          };
  
          let count = owned_tokens_count
              .get(to)
              .map(|c| c + (1 as u32))
              .unwrap_or(1);
  
          owned_tokens_count.insert( *to, count);
          token_owner.insert(id, *to);
  
          Ok(())
      }
  *)
  Parameter add_token_to :
      (mut_ref Self) ->
        (ref erc721.AccountId.t) ->
        ltac:(erc721.TokenId) ->
        M (core.result.Result.t unit erc721.Error.t).
  
  Global Instance AssociatedFunction_add_token_to :
    Notations.DoubleColon Self "add_token_to" := {
    Notations.double_colon := add_token_to;
  }.
  
  (*
      fn transfer_token_from(
          &mut self,
          from: &AccountId,
          to: &AccountId,
          id: TokenId,
      ) -> Result<(), Error> {
          let caller = self.env().caller();
          if !self.exists(id) {
              return Err(Error::TokenNotFound);
          };
          if !self.approved_or_owner(Some(caller), id) {
              return Err(Error::NotApproved);
          };
          self.clear_approval(id);
          self.remove_token_from(from, id)?;
          self.add_token_to(to, id)?;
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some( *from),
              to: Some( *to),
              id,
          }));
          Ok(())
      }
  *)
  Parameter transfer_token_from :
      (mut_ref Self) ->
        (ref erc721.AccountId.t) ->
        (ref erc721.AccountId.t) ->
        ltac:(erc721.TokenId) ->
        M (core.result.Result.t unit erc721.Error.t).
  
  Global Instance AssociatedFunction_transfer_token_from :
    Notations.DoubleColon Self "transfer_token_from" := {
    Notations.double_colon := transfer_token_from;
  }.
  
  (*
      pub fn transfer(&mut self, destination: AccountId, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          self.transfer_token_from(&caller, &destination, id)?;
          Ok(())
      }
  *)
  Definition transfer
      (self : mut_ref Self)
      (destination : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let destination := M.alloc (| destination |) in
      let id := M.alloc (| id |) in
      let return_ :=
        M.return_ (R := core.result.Result.t unit erc721.Error.t) in
      M.catch_return
        (M.read (|
          let caller : M.Val erc721.AccountId.t :=
            M.alloc (|
              M.call (|(erc721.Env.t::["caller"]
                (borrow
                  (M.alloc (|
                    M.call (|(erc721.Erc721.t::["env"]
                      (borrow (deref (M.read (| self |)))))
                    |)
                  |))))
              |)
            |) in
          let _ : M.Val unit :=
            ltac:
              (M.monadic_match_operator
                (M.alloc (|
                  M.call (|(ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.Try.branch
                        (Self := core.result.Result.t unit erc721.Error.t)
                        (Trait := ℐ)))
                    (M.call (|(erc721.Erc721.t::["transfer_token_from"]
                      (M.read (| self |))
                      (borrow caller)
                      (borrow destination)
                      (M.read (| id |)))
                    |)))
                  |)
                |))
                [
                  fun
                      (γ :
                        M.Val
                          (core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              erc721.Error.t)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.ops.control_flow.ControlFlow.Break _ =>
                      let γ0_0 :=
                        core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        (never_to_any (B := unit)) (|
                          M.read (|
                            return_
                              (M.call (|(ltac:(M.get_method (fun ℐ =>
                                  core.ops.try_trait.FromResidual.from_residual
                                    (Self :=
                                      core.result.Result.t unit erc721.Error.t)
                                    (R :=
                                      core.result.Result.t
                                        core.convert.Infallible.t
                                        erc721.Error.t)
                                    (Trait := ℐ)))
                                (M.read (| residual |)))
                              |))
                          |)
                        |)
                      |)
                    | _ => M.break_match(||)
                    end :
                    M.Val unit;
                  fun
                      (γ :
                        M.Val
                          (core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              erc721.Error.t)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.ops.control_flow.ControlFlow.Continue _ =>
                      let γ0_0 :=
                        core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                      let val := M.copy (| γ0_0 |) in
                      val
                    | _ => M.break_match(||)
                    end :
                    M.Val unit
                ]) in
          M.alloc (| core.result.Result.Ok tt |)
        |))
    )).
  
  Global Instance AssociatedFunction_transfer :
    Notations.DoubleColon Self "transfer" := {
    Notations.double_colon := transfer;
  }.
  
  (*
      pub fn transfer_from(
          &mut self,
          from: AccountId,
          to: AccountId,
          id: TokenId,
      ) -> Result<(), Error> {
          self.transfer_token_from(&from, &to, id)?;
          Ok(())
      }
  *)
  Definition transfer_from
      (self : mut_ref Self)
      (from : erc721.AccountId.t)
      (to : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let from := M.alloc (| from |) in
      let to := M.alloc (| to |) in
      let id := M.alloc (| id |) in
      let return_ :=
        M.return_ (R := core.result.Result.t unit erc721.Error.t) in
      M.catch_return
        (M.read (|
          let _ : M.Val unit :=
            ltac:
              (M.monadic_match_operator
                (M.alloc (|
                  M.call (|(ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.Try.branch
                        (Self := core.result.Result.t unit erc721.Error.t)
                        (Trait := ℐ)))
                    (M.call (|(erc721.Erc721.t::["transfer_token_from"]
                      (M.read (| self |))
                      (borrow from)
                      (borrow to)
                      (M.read (| id |)))
                    |)))
                  |)
                |))
                [
                  fun
                      (γ :
                        M.Val
                          (core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              erc721.Error.t)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.ops.control_flow.ControlFlow.Break _ =>
                      let γ0_0 :=
                        core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        (never_to_any (B := unit)) (|
                          M.read (|
                            return_
                              (M.call (|(ltac:(M.get_method (fun ℐ =>
                                  core.ops.try_trait.FromResidual.from_residual
                                    (Self :=
                                      core.result.Result.t unit erc721.Error.t)
                                    (R :=
                                      core.result.Result.t
                                        core.convert.Infallible.t
                                        erc721.Error.t)
                                    (Trait := ℐ)))
                                (M.read (| residual |)))
                              |))
                          |)
                        |)
                      |)
                    | _ => M.break_match(||)
                    end :
                    M.Val unit;
                  fun
                      (γ :
                        M.Val
                          (core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              erc721.Error.t)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.ops.control_flow.ControlFlow.Continue _ =>
                      let γ0_0 :=
                        core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                      let val := M.copy (| γ0_0 |) in
                      val
                    | _ => M.break_match(||)
                    end :
                    M.Val unit
                ]) in
          M.alloc (| core.result.Result.Ok tt |)
        |))
    )).
  
  Global Instance AssociatedFunction_transfer_from :
    Notations.DoubleColon Self "transfer_from" := {
    Notations.double_colon := transfer_from;
  }.
  
  (*
      pub fn mint(&mut self, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          self.add_token_to(&caller, id)?;
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some(AccountId::from([0x0; 32])),
              to: Some(caller),
              id,
          }));
          Ok(())
      }
  *)
  Definition mint
      (self : mut_ref Self)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let id := M.alloc (| id |) in
      let return_ :=
        M.return_ (R := core.result.Result.t unit erc721.Error.t) in
      M.catch_return
        (M.read (|
          let caller : M.Val erc721.AccountId.t :=
            M.alloc (|
              M.call (|(erc721.Env.t::["caller"]
                (borrow
                  (M.alloc (|
                    M.call (|(erc721.Erc721.t::["env"]
                      (borrow (deref (M.read (| self |)))))
                    |)
                  |))))
              |)
            |) in
          let _ : M.Val unit :=
            ltac:
              (M.monadic_match_operator
                (M.alloc (|
                  M.call (|(ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.Try.branch
                        (Self := core.result.Result.t unit erc721.Error.t)
                        (Trait := ℐ)))
                    (M.call (|(erc721.Erc721.t::["add_token_to"]
                      (M.read (| self |))
                      (borrow caller)
                      (M.read (| id |)))
                    |)))
                  |)
                |))
                [
                  fun
                      (γ :
                        M.Val
                          (core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              erc721.Error.t)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.ops.control_flow.ControlFlow.Break _ =>
                      let γ0_0 :=
                        core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        (never_to_any (B := unit)) (|
                          M.read (|
                            return_
                              (M.call (|(ltac:(M.get_method (fun ℐ =>
                                  core.ops.try_trait.FromResidual.from_residual
                                    (Self :=
                                      core.result.Result.t unit erc721.Error.t)
                                    (R :=
                                      core.result.Result.t
                                        core.convert.Infallible.t
                                        erc721.Error.t)
                                    (Trait := ℐ)))
                                (M.read (| residual |)))
                              |))
                          |)
                        |)
                      |)
                    | _ => M.break_match(||)
                    end :
                    M.Val unit;
                  fun
                      (γ :
                        M.Val
                          (core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              erc721.Error.t)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.ops.control_flow.ControlFlow.Continue _ =>
                      let γ0_0 :=
                        core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                      let val := M.copy (| γ0_0 |) in
                      val
                    | _ => M.break_match(||)
                    end :
                    M.Val unit
                ]) in
          let _ : M.Val unit :=
            M.alloc (|
              M.call (|(erc721.Env.t::["emit_event"]
                (borrow
                  (M.alloc (|
                    M.call (|(erc721.Erc721.t::["env"]
                      (borrow (deref (M.read (| self |)))))
                    |)
                  |)))
                (erc721.Event.Transfer
                  ({|
                    erc721.Transfer.from :=
                      core.option.Option.Some
                        (M.call (|(ltac:(M.get_method (fun ℐ =>
                            core.convert.From.from
                              (Self := erc721.AccountId.t)
                              (T := array u8.t)
                              (Trait := ℐ)))
                          (repeat ((Integer.of_Z 0) : u8.t) 32))
                        |));
                    erc721.Transfer.to :=
                      core.option.Option.Some (M.read (| caller |));
                    erc721.Transfer.id := M.read (| id |);
                  |} : erc721.Transfer.t)))
              |)
            |) in
          M.alloc (| core.result.Result.Ok tt |)
        |))
    )).
  
  Global Instance AssociatedFunction_mint :
    Notations.DoubleColon Self "mint" := {
    Notations.double_colon := mint;
  }.
  
  (*
      pub fn burn(&mut self, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          let owner = token_owner.get(&id).ok_or(Error::TokenNotFound)?;
          if owner != caller {
              return Err(Error::NotOwner);
          };
  
          let count = owned_tokens_count
              .get(&caller)
              .map(|c| c - 1)
              .ok_or(Error::CannotFetchValue)?;
          owned_tokens_count.insert(caller, count);
          token_owner.remove(id);
  
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some(caller),
              to: Some(AccountId::from([0x0; 32])),
              id,
          }));
  
          Ok(())
      }
  *)
  Parameter burn :
      (mut_ref Self) ->
        ltac:(erc721.TokenId) ->
        M (core.result.Result.t unit erc721.Error.t).
  
  Global Instance AssociatedFunction_burn :
    Notations.DoubleColon Self "burn" := {
    Notations.double_colon := burn;
  }.
End Impl_erc721_Erc721_t.
End Impl_erc721_Erc721_t.
