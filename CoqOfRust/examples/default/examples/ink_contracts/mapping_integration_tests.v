(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Definition Get__key :=
    Ref.map (fun α => Some α.(_key)) (fun β α => Some (α <| _key := β |>)).
  Definition Get__value :=
    Ref.map (fun α => Some α.(_value)) (fun β α => Some (α <| _value := β |>)).
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
Section Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.default.Default.Trait K}
    {ℋ_1 : core.default.Default.Trait V}.
  
  Definition Self : Set := mapping_integration_tests.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (mapping_integration_tests.Mapping.t K V) :=
    let* α0 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := core.marker.PhantomData.t K)
          (Trait := ℐ))) in
    let* α1 : core.marker.PhantomData.t K := M.call α0 in
    let* α2 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := core.marker.PhantomData.t V)
          (Trait := ℐ))) in
    let* α3 : core.marker.PhantomData.t V := M.call α2 in
    M.pure
      {|
        mapping_integration_tests.Mapping._key := α1;
        mapping_integration_tests.Mapping._value := α3;
      |}.
  
  Axiom default_is_impl : impl Self "default" = default.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
End Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.

Module  Impl_mapping_integration_tests_Mapping_t_K_V.
Section Impl_mapping_integration_tests_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := mapping_integration_tests.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref Self) (_key : ref K) : M bool.t :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom contains_is_impl : impl Self "contains" = contains.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom get_is_impl : impl Self "get" = get.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom insert_is_impl : impl Self "insert" = insert.
  
  (*
      fn new() -> Mapping<K, V> {
          unimplemented!()
      }
  *)
  Definition new : M (mapping_integration_tests.Mapping.t K V) :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom new_is_impl : impl Self "new" = new.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref Self) (_key : K) : M unit :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom remove_is_impl : impl Self "remove" = remove.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref Self)
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom size_is_impl : impl Self "size" = size.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (self : ref Self) (_key : K) : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom take_is_impl : impl Self "take" = take.
End Impl_mapping_integration_tests_Mapping_t_K_V.
End Impl_mapping_integration_tests_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
Section Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
  Definition Self : Set := mapping_integration_tests.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M mapping_integration_tests.AccountId.t :=
    let* α0 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := u128.t) (Trait := ℐ))) in
    let* α1 : u128.t := M.call α0 in
    M.pure (mapping_integration_tests.AccountId.Build_t α1).
  
  Axiom default_is_impl : impl Self "default" = default.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
End Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.

Module  Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
Section Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
  Definition Self : Set := mapping_integration_tests.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M mapping_integration_tests.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : M.Val mapping_integration_tests.AccountId.t :=
      match_operator
        (DeclaredButUndefinedVariable
          (A := core.clone.AssertParamIsClone.t u128.t))
        [
          fun γ =>
            (let* α0 : ref mapping_integration_tests.AccountId.t :=
              M.read self in
            M.pure (deref α0)) :
            M (M.Val mapping_integration_tests.AccountId.t)
        ] in
    M.read α0.
  
  Axiom clone_is_impl : impl Self "clone" = clone.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
End Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.

Module  Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
Section Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
  Definition Self : Set := mapping_integration_tests.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
End Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : mapping_integration_tests.AccountId.t;
  }.
  
  Definition Get_caller :=
    Ref.map (fun α => Some α.(caller)) (fun β α => Some (α <| caller := β |>)).
End Env.
End Env.

Module  Impl_mapping_integration_tests_Env_t.
Section Impl_mapping_integration_tests_Env_t.
  Definition Self : Set := mapping_integration_tests.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller
      (self : ref Self)
      : M mapping_integration_tests.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref mapping_integration_tests.Env.t := M.read self in
    M.read (mapping_integration_tests.Env.Get_caller (deref α0)).
  
  Axiom caller_is_impl : impl Self "caller" = caller.
End Impl_mapping_integration_tests_Env_t.
End Impl_mapping_integration_tests_Env_t.

Module  Mappings.
Section Mappings.
  Record t : Set := {
    balances :
      mapping_integration_tests.Mapping.t
        mapping_integration_tests.AccountId.t
        ltac:(mapping_integration_tests.Balance);
  }.
  
  Definition Get_balances :=
    Ref.map
      (fun α => Some α.(balances))
      (fun β α => Some (α <| balances := β |>)).
End Mappings.
End Mappings.

Module  Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
Section Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
  Definition Self : Set := mapping_integration_tests.Mappings.t.
  
  (*
  Default
  *)
  Definition default : M mapping_integration_tests.Mappings.t :=
    let* α0 : _ :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self :=
            mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)
          (Trait := ℐ))) in
    let* α1 :
        mapping_integration_tests.Mapping.t
          mapping_integration_tests.AccountId.t
          u128.t :=
      M.call α0 in
    M.pure {| mapping_integration_tests.Mappings.balances := α1; |}.
  
  Axiom default_is_impl : impl Self "default" = default.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
End Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.

Module  Impl_mapping_integration_tests_Mappings_t.
Section Impl_mapping_integration_tests_Mappings_t.
  Definition Self : Set := mapping_integration_tests.Mappings.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M mapping_integration_tests.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom init_env_is_impl : impl Self "init_env" = init_env.
  
  (*
      fn env() -> Env {
          unimplemented!()
      }
  *)
  Definition env : M mapping_integration_tests.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Axiom env_is_impl : impl Self "env" = env.
  
  (*
      pub fn new() -> Self {
          let balances = Mapping::default();
          Self { balances }
      }
  *)
  Definition new : M Self :=
    let* balances :
        M.Val
          (mapping_integration_tests.Mapping.t
            mapping_integration_tests.AccountId.t
            u128.t) :=
      let* α0 : _ :=
        ltac:(M.get_method (fun ℐ =>
          core.default.Default.default
            (Self :=
              mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)
            (Trait := ℐ))) in
      let* α1 :
          mapping_integration_tests.Mapping.t
            mapping_integration_tests.AccountId.t
            u128.t :=
        M.call α0 in
      M.alloc α1 in
    let* α0 :
        mapping_integration_tests.Mapping.t
          mapping_integration_tests.AccountId.t
          u128.t :=
      M.read balances in
    let* α0 : M.Val mapping_integration_tests.Mappings.t :=
      M.alloc {| mapping_integration_tests.Mappings.balances := α0; |} in
    M.read α0.
  
  Axiom new_is_impl : impl Self "new" = new.
  
  (*
      pub fn get_balance(&self) -> Option<Balance> {
          let caller = Self::env().caller();
          self.balances.get(&caller)
      }
  *)
  Definition get_balance
      (self : ref Self)
      : M (core.option.Option.t ltac:(mapping_integration_tests.Balance)) :=
    let* self := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call (impl mapping_integration_tests.Mappings.t "env") in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (impl mapping_integration_tests.Env.t "caller" (borrow α1)) in
      M.alloc α2 in
    let* α0 : ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : core.option.Option.t u128.t :=
      M.call
        (impl
            (mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)
            "get"
          (borrow (mapping_integration_tests.Mappings.Get_balances (deref α0)))
          (borrow caller)) in
    let* α0 : M.Val (core.option.Option.t u128.t) := M.alloc α1 in
    M.read α0.
  
  Axiom get_balance_is_impl : impl Self "get_balance" = get_balance.
  
  (*
      pub fn insert_balance(&mut self, value: Balance) -> Option<u32> {
          let caller = Self::env().caller();
          self.balances.insert(caller, value)
      }
  *)
  Definition insert_balance
      (self : mut_ref Self)
      (value : ltac:(mapping_integration_tests.Balance))
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call (impl mapping_integration_tests.Mappings.t "env") in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (impl mapping_integration_tests.Env.t "caller" (borrow α1)) in
      M.alloc α2 in
    let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
    let* α2 : u128.t := M.read value in
    let* α3 : core.option.Option.t u32.t :=
      M.call
        (impl
            (mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)
            "insert"
          (borrow_mut
            (mapping_integration_tests.Mappings.Get_balances (deref α0)))
          α1
          α2) in
    let* α0 : M.Val (core.option.Option.t u32.t) := M.alloc α3 in
    M.read α0.
  
  Axiom insert_balance_is_impl : impl Self "insert_balance" = insert_balance.
  
  (*
      pub fn size_balance(&mut self) -> Option<u32> {
          let caller = Self::env().caller();
          self.balances.size(caller)
      }
  *)
  Definition size_balance
      (self : mut_ref Self)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call (impl mapping_integration_tests.Mappings.t "env") in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (impl mapping_integration_tests.Env.t "caller" (borrow α1)) in
      M.alloc α2 in
    let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
    let* α2 : core.option.Option.t u32.t :=
      M.call
        (impl
            (mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)
            "size"
          (borrow (mapping_integration_tests.Mappings.Get_balances (deref α0)))
          α1) in
    let* α0 : M.Val (core.option.Option.t u32.t) := M.alloc α2 in
    M.read α0.
  
  Axiom size_balance_is_impl : impl Self "size_balance" = size_balance.
  
  (*
      pub fn contains_balance(&self) -> bool {
          let caller = Self::env().caller();
          self.balances.contains(&caller)
      }
  *)
  Definition contains_balance (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call (impl mapping_integration_tests.Mappings.t "env") in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (impl mapping_integration_tests.Env.t "caller" (borrow α1)) in
      M.alloc α2 in
    let* α0 : ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : bool.t :=
      M.call
        (impl
            (mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)
            "contains"
          (borrow (mapping_integration_tests.Mappings.Get_balances (deref α0)))
          (borrow caller)) in
    let* α0 : M.Val bool.t := M.alloc α1 in
    M.read α0.
  
  Axiom contains_balance_is_impl :
      impl Self "contains_balance" = contains_balance.
  
  (*
      pub fn remove_balance(&mut self) {
          let caller = Self::env().caller();
          self.balances.remove(caller);
      }
  *)
  Definition remove_balance (self : mut_ref Self) : M unit :=
    let* self := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call (impl mapping_integration_tests.Mappings.t "env") in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (impl mapping_integration_tests.Env.t "caller" (borrow α1)) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
      let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
      let* α2 : unit :=
        M.call
          (impl
              (mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)
              "remove"
            (borrow
              (mapping_integration_tests.Mappings.Get_balances (deref α0)))
            α1) in
      M.alloc α2 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Axiom remove_balance_is_impl : impl Self "remove_balance" = remove_balance.
  
  (*
      pub fn take_balance(&mut self) -> Option<Balance> {
          let caller = Self::env().caller();
          self.balances.take(caller)
      }
  *)
  Definition take_balance
      (self : mut_ref Self)
      : M (core.option.Option.t ltac:(mapping_integration_tests.Balance)) :=
    let* self := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call (impl mapping_integration_tests.Mappings.t "env") in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (impl mapping_integration_tests.Env.t "caller" (borrow α1)) in
      M.alloc α2 in
    let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
    let* α2 : core.option.Option.t u128.t :=
      M.call
        (impl
            (mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)
            "take"
          (borrow (mapping_integration_tests.Mappings.Get_balances (deref α0)))
          α1) in
    let* α0 : M.Val (core.option.Option.t u128.t) := M.alloc α2 in
    M.read α0.
  
  Axiom take_balance_is_impl : impl Self "take_balance" = take_balance.
End Impl_mapping_integration_tests_Mappings_t.
End Impl_mapping_integration_tests_Mappings_t.
