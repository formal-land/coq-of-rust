(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Definition Get__key :=
    Ref.map (fun α => Some α.(_key)) (fun β α => Some (α <| _key := β |>)).
  Definition Get__value :=
    Ref.map (fun α => Some α.(_value)) (fun β α => Some (α <| _value := β |>)).
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
Section Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := mapping_integration_tests.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (mapping_integration_tests.Mapping.t K V) :=
    ltac:(M.monadic ((
      {|
        mapping_integration_tests.Mapping._key :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := core.marker.PhantomData.t K)
              (Trait := ℐ)))
          |);
        mapping_integration_tests.Mapping._value :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := core.marker.PhantomData.t V)
              (Trait := ℐ)))
          |);
      |} : mapping_integration_tests.Mapping.t K V
    ) : mapping_integration_tests.Mapping.t K V)).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
End Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.

Module  Impl_mapping_integration_tests_Mapping_t_K_V.
Section Impl_mapping_integration_tests_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := mapping_integration_tests.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref Self) (_key : ref K) : M bool.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := bool.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : bool.t)).
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := core.option.Option.t V)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : core.option.Option.t V)).
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      let _value := M.alloc (| _value |) in
      (never_to_any (B := core.option.Option.t u32.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : core.option.Option.t u32.t)).
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn new() -> Mapping<K, V> {
          unimplemented!()
      }
  *)
  Definition new : M (mapping_integration_tests.Mapping.t K V) :=
    ltac:(M.monadic ((
      (never_to_any (B := mapping_integration_tests.Mapping.t K V)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : mapping_integration_tests.Mapping.t K V)).
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref Self) (_key : K) : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := unit)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref Self)
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := core.option.Option.t u32.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : core.option.Option.t u32.t)).
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon Self "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (self : ref Self) (_key : K) : M (core.option.Option.t V) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := core.option.Option.t V)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : core.option.Option.t V)).
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_mapping_integration_tests_Mapping_t_K_V.
End Impl_mapping_integration_tests_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
Section Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
  Definition Self : Set := mapping_integration_tests.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M mapping_integration_tests.AccountId.t :=
    ltac:(M.monadic ((
      mapping_integration_tests.AccountId.Build_t
        (M.call (|ltac:(M.get_method (fun ℐ =>
          core.default.Default.default (Self := u128.t) (Trait := ℐ)))
        |))
    ) : mapping_integration_tests.AccountId.t)).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
End Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.

Module  Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
Section Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
  Definition Self : Set := mapping_integration_tests.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M mapping_integration_tests.AccountId.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        ltac:
          (M.monadic_match_operator
            (DeclaredButUndefinedVariable
              (A := core.clone.AssertParamIsClone.t u128.t))
            [
              fun (γ : M.Val (core.clone.AssertParamIsClone.t u128.t)) =>
                (deref (M.read (| self |))) :
                M.Val mapping_integration_tests.AccountId.t
            ])
      |)
    ) : mapping_integration_tests.AccountId.t)).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
End Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.

Module  Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
Section Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
  Definition Self : Set := mapping_integration_tests.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
End Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : mapping_integration_tests.AccountId.t;
  }.
  
  Definition Get_caller :=
    Ref.map (fun α => Some α.(caller)) (fun β α => Some (α <| caller := β |>)).
End Env.
End Env.

Module  Impl_mapping_integration_tests_Env_t.
Section Impl_mapping_integration_tests_Env_t.
  Definition Self : Set := mapping_integration_tests.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller
      (self : ref Self)
      : M mapping_integration_tests.AccountId.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        mapping_integration_tests.Env.Get_caller (deref (M.read (| self |)))
      |)
    ) : mapping_integration_tests.AccountId.t)).
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
End Impl_mapping_integration_tests_Env_t.
End Impl_mapping_integration_tests_Env_t.

Module  Mappings.
Section Mappings.
  Record t : Set := {
    balances :
      mapping_integration_tests.Mapping.t
        mapping_integration_tests.AccountId.t
        ltac:(mapping_integration_tests.Balance);
  }.
  
  Definition Get_balances :=
    Ref.map
      (fun α => Some α.(balances))
      (fun β α => Some (α <| balances := β |>)).
End Mappings.
End Mappings.

Module  Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
Section Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
  Definition Self : Set := mapping_integration_tests.Mappings.t.
  
  (*
  Default
  *)
  Definition default : M mapping_integration_tests.Mappings.t :=
    ltac:(M.monadic ((
      {|
        mapping_integration_tests.Mappings.balances :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self :=
                mapping_integration_tests.Mapping.t
                  mapping_integration_tests.AccountId.t
                  u128.t)
              (Trait := ℐ)))
          |);
      |} : mapping_integration_tests.Mappings.t
    ) : mapping_integration_tests.Mappings.t)).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
End Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.

Module  Impl_mapping_integration_tests_Mappings_t.
Section Impl_mapping_integration_tests_Mappings_t.
  Definition Self : Set := mapping_integration_tests.Mappings.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M mapping_integration_tests.Env.t :=
    ltac:(M.monadic ((
      (never_to_any (B := mapping_integration_tests.Env.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : mapping_integration_tests.Env.t)).
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env() -> Env {
          unimplemented!()
      }
  *)
  Definition env : M mapping_integration_tests.Env.t :=
    ltac:(M.monadic ((
      (never_to_any (B := mapping_integration_tests.Env.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : mapping_integration_tests.Env.t)).
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new() -> Self {
          let balances = Mapping::default();
          Self { balances }
      }
  *)
  Definition new : M Self :=
    ltac:(M.monadic ((
      M.read (|
        let balances :
            M.Val
              (mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t) :=
          M.alloc (|
            M.call (|ltac:(M.get_method (fun ℐ =>
              core.default.Default.default
                (Self :=
                  mapping_integration_tests.Mapping.t
                    mapping_integration_tests.AccountId.t
                    u128.t)
                (Trait := ℐ)))
            |)
          |) in
        M.alloc (|
          {|
            mapping_integration_tests.Mappings.balances :=
              M.read (| balances |);
          |} : mapping_integration_tests.Mappings.t
        |)
      |)
    ) : Self)).
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn get_balance(&self) -> Option<Balance> {
          let caller = Self::env().caller();
          self.balances.get(&caller)
      }
  *)
  Definition get_balance
      (self : ref Self)
      : M (core.option.Option.t ltac:(mapping_integration_tests.Balance)) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        let caller : M.Val mapping_integration_tests.AccountId.t :=
          M.alloc (|
            M.call (|(mapping_integration_tests.Env.t::["caller"]
              (borrow
                (M.alloc (|
                  M.call (|mapping_integration_tests.Mappings.t::["env"] |)
                |))))
            |)
          |) in
        M.alloc (|
          M.call (|((mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)::["get"]
            (borrow
              (mapping_integration_tests.Mappings.Get_balances
                (deref (M.read (| self |)))))
            (borrow caller))
          |)
        |)
      |)
    ) : core.option.Option.t ltac:(mapping_integration_tests.Balance))).
  
  Global Instance AssociatedFunction_get_balance :
    Notations.DoubleColon Self "get_balance" := {
    Notations.double_colon := get_balance;
  }.
  
  (*
      pub fn insert_balance(&mut self, value: Balance) -> Option<u32> {
          let caller = Self::env().caller();
          self.balances.insert(caller, value)
      }
  *)
  Definition insert_balance
      (self : mut_ref Self)
      (value : ltac:(mapping_integration_tests.Balance))
      : M (core.option.Option.t u32.t) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let value := M.alloc (| value |) in
      M.read (|
        let caller : M.Val mapping_integration_tests.AccountId.t :=
          M.alloc (|
            M.call (|(mapping_integration_tests.Env.t::["caller"]
              (borrow
                (M.alloc (|
                  M.call (|mapping_integration_tests.Mappings.t::["env"] |)
                |))))
            |)
          |) in
        M.alloc (|
          M.call (|((mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)::["insert"]
            (borrow_mut
              (mapping_integration_tests.Mappings.Get_balances
                (deref (M.read (| self |)))))
            (M.read (| caller |))
            (M.read (| value |)))
          |)
        |)
      |)
    ) : core.option.Option.t u32.t)).
  
  Global Instance AssociatedFunction_insert_balance :
    Notations.DoubleColon Self "insert_balance" := {
    Notations.double_colon := insert_balance;
  }.
  
  (*
      pub fn size_balance(&mut self) -> Option<u32> {
          let caller = Self::env().caller();
          self.balances.size(caller)
      }
  *)
  Definition size_balance
      (self : mut_ref Self)
      : M (core.option.Option.t u32.t) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        let caller : M.Val mapping_integration_tests.AccountId.t :=
          M.alloc (|
            M.call (|(mapping_integration_tests.Env.t::["caller"]
              (borrow
                (M.alloc (|
                  M.call (|mapping_integration_tests.Mappings.t::["env"] |)
                |))))
            |)
          |) in
        M.alloc (|
          M.call (|((mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)::["size"]
            (borrow
              (mapping_integration_tests.Mappings.Get_balances
                (deref (M.read (| self |)))))
            (M.read (| caller |)))
          |)
        |)
      |)
    ) : core.option.Option.t u32.t)).
  
  Global Instance AssociatedFunction_size_balance :
    Notations.DoubleColon Self "size_balance" := {
    Notations.double_colon := size_balance;
  }.
  
  (*
      pub fn contains_balance(&self) -> bool {
          let caller = Self::env().caller();
          self.balances.contains(&caller)
      }
  *)
  Definition contains_balance (self : ref Self) : M bool.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        let caller : M.Val mapping_integration_tests.AccountId.t :=
          M.alloc (|
            M.call (|(mapping_integration_tests.Env.t::["caller"]
              (borrow
                (M.alloc (|
                  M.call (|mapping_integration_tests.Mappings.t::["env"] |)
                |))))
            |)
          |) in
        M.alloc (|
          M.call (|((mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)::["contains"]
            (borrow
              (mapping_integration_tests.Mappings.Get_balances
                (deref (M.read (| self |)))))
            (borrow caller))
          |)
        |)
      |)
    ) : bool.t)).
  
  Global Instance AssociatedFunction_contains_balance :
    Notations.DoubleColon Self "contains_balance" := {
    Notations.double_colon := contains_balance;
  }.
  
  (*
      pub fn remove_balance(&mut self) {
          let caller = Self::env().caller();
          self.balances.remove(caller);
      }
  *)
  Definition remove_balance (self : mut_ref Self) : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        let caller : M.Val mapping_integration_tests.AccountId.t :=
          M.alloc (|
            M.call (|(mapping_integration_tests.Env.t::["caller"]
              (borrow
                (M.alloc (|
                  M.call (|mapping_integration_tests.Mappings.t::["env"] |)
                |))))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|((mapping_integration_tests.Mapping.t
                  mapping_integration_tests.AccountId.t
                  u128.t)::["remove"]
              (borrow
                (mapping_integration_tests.Mappings.Get_balances
                  (deref (M.read (| self |)))))
              (M.read (| caller |)))
            |)
          |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_remove_balance :
    Notations.DoubleColon Self "remove_balance" := {
    Notations.double_colon := remove_balance;
  }.
  
  (*
      pub fn take_balance(&mut self) -> Option<Balance> {
          let caller = Self::env().caller();
          self.balances.take(caller)
      }
  *)
  Definition take_balance
      (self : mut_ref Self)
      : M (core.option.Option.t ltac:(mapping_integration_tests.Balance)) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        let caller : M.Val mapping_integration_tests.AccountId.t :=
          M.alloc (|
            M.call (|(mapping_integration_tests.Env.t::["caller"]
              (borrow
                (M.alloc (|
                  M.call (|mapping_integration_tests.Mappings.t::["env"] |)
                |))))
            |)
          |) in
        M.alloc (|
          M.call (|((mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)::["take"]
            (borrow
              (mapping_integration_tests.Mappings.Get_balances
                (deref (M.read (| self |)))))
            (M.read (| caller |)))
          |)
        |)
      |)
    ) : core.option.Option.t ltac:(mapping_integration_tests.Balance))).
  
  Global Instance AssociatedFunction_take_balance :
    Notations.DoubleColon Self "take_balance" := {
    Notations.double_colon := take_balance;
  }.
End Impl_mapping_integration_tests_Mappings_t.
End Impl_mapping_integration_tests_Mappings_t.
