(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Definition Get__key :=
    Ref.map (fun α => Some α.(_key)) (fun β α => Some (α <| _key := β |>)).
  Definition Get__value :=
    Ref.map (fun α => Some α.(_value)) (fun β α => Some (α <| _value := β |>)).
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
Section Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := mapping_integration_tests.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (mapping_integration_tests.Mapping.t K V) :=
    let* α0 : M (core.marker.PhantomData.t K) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := core.marker.PhantomData.t K)
          (Trait := ℐ))) in
    let* α1 : core.marker.PhantomData.t K := M.call α0 in
    let* α2 : M (core.marker.PhantomData.t V) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := core.marker.PhantomData.t V)
          (Trait := ℐ))) in
    let* α3 : core.marker.PhantomData.t V := M.call α2 in
    M.pure
      {|
        mapping_integration_tests.Mapping._key := α1;
        mapping_integration_tests.Mapping._value := α3;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
End Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.

Module  Impl_mapping_integration_tests_Mapping_t_K_V.
Section Impl_mapping_integration_tests_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := mapping_integration_tests.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref Self) (_key : ref K) : M bool.t :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn new() -> Mapping<K, V> {
          unimplemented!()
      }
  *)
  Definition new : M (mapping_integration_tests.Mapping.t K V) :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref Self) (_key : K) : M unit :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref Self)
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon Self "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (self : ref Self) (_key : K) : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_mapping_integration_tests_Mapping_t_K_V.
End Impl_mapping_integration_tests_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
Section Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
  Definition Self : Set := mapping_integration_tests.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M mapping_integration_tests.AccountId.t :=
    let* α0 : M u128.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := u128.t) (Trait := ℐ))) in
    let* α1 : u128.t := M.call α0 in
    M.pure (mapping_integration_tests.AccountId.Build_t α1).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
End Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.

Module  Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
Section Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
  Definition Self : Set := mapping_integration_tests.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref Self)
      : M mapping_integration_tests.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : M.Val mapping_integration_tests.AccountId.t :=
      match_operator
        (DeclaredButUndefinedVariable
          (A := core.clone.AssertParamIsClone.t u128.t))
        [
          fun γ =>
            (let* α0 : ref mapping_integration_tests.AccountId.t :=
              M.read self in
            M.pure (deref α0)) :
            M (M.Val mapping_integration_tests.AccountId.t)
        ] in
    M.read α0.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
End Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.

Module  Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
Section Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
  Definition Self : Set := mapping_integration_tests.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
End Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : mapping_integration_tests.AccountId.t;
  }.
  
  Definition Get_caller :=
    Ref.map (fun α => Some α.(caller)) (fun β α => Some (α <| caller := β |>)).
End Env.
End Env.

Module  Impl_mapping_integration_tests_Env_t.
Section Impl_mapping_integration_tests_Env_t.
  Definition Self : Set := mapping_integration_tests.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller
      (self : ref Self)
      : M mapping_integration_tests.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref mapping_integration_tests.Env.t := M.read self in
    M.read (mapping_integration_tests.Env.Get_caller (deref α0)).
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
End Impl_mapping_integration_tests_Env_t.
End Impl_mapping_integration_tests_Env_t.

Module  Mappings.
Section Mappings.
  Record t : Set := {
    balances :
      mapping_integration_tests.Mapping.t
        mapping_integration_tests.AccountId.t
        ltac:(mapping_integration_tests.Balance);
  }.
  
  Definition Get_balances :=
    Ref.map
      (fun α => Some α.(balances))
      (fun β α => Some (α <| balances := β |>)).
End Mappings.
End Mappings.

Module  Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
Section Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
  Definition Self : Set := mapping_integration_tests.Mappings.t.
  
  (*
  Default
  *)
  Definition default : M mapping_integration_tests.Mappings.t :=
    let* α0 :
        M
          (mapping_integration_tests.Mapping.t
            mapping_integration_tests.AccountId.t
            u128.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self :=
            mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)
          (Trait := ℐ))) in
    let* α1 :
        mapping_integration_tests.Mapping.t
          mapping_integration_tests.AccountId.t
          u128.t :=
      M.call α0 in
    M.pure {| mapping_integration_tests.Mappings.balances := α1; |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
End Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.

Module  Impl_mapping_integration_tests_Mappings_t.
Section Impl_mapping_integration_tests_Mappings_t.
  Definition Self : Set := mapping_integration_tests.Mappings.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M mapping_integration_tests.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env() -> Env {
          unimplemented!()
      }
  *)
  Definition env : M mapping_integration_tests.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new() -> Self {
          let balances = Mapping::default();
          Self { balances }
      }
  *)
  Definition new : M Self :=
    let* balances :
        M.Val
          (mapping_integration_tests.Mapping.t
            mapping_integration_tests.AccountId.t
            u128.t) :=
      let* α0 :
          M
            (mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t) :=
        ltac:(M.get_method (fun ℐ =>
          core.default.Default.default
            (Self :=
              mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)
            (Trait := ℐ))) in
      let* α1 :
          mapping_integration_tests.Mapping.t
            mapping_integration_tests.AccountId.t
            u128.t :=
        M.call α0 in
      M.alloc α1 in
    let* α0 :
        mapping_integration_tests.Mapping.t
          mapping_integration_tests.AccountId.t
          u128.t :=
      M.read balances in
    let* α0 : M.Val mapping_integration_tests.Mappings.t :=
      M.alloc {| mapping_integration_tests.Mappings.balances := α0; |} in
    M.read α0.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn get_balance(&self) -> Option<Balance> {
          let caller = Self::env().caller();
          self.balances.get(&caller)
      }
  *)
  Definition get_balance
      (self : ref Self)
      : M (core.option.Option.t ltac:(mapping_integration_tests.Balance)) :=
    let* self := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* α0 : ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : core.option.Option.t u128.t :=
      M.call
        ((mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)::["get"]
          (borrow (mapping_integration_tests.Mappings.Get_balances (deref α0)))
          (borrow caller)) in
    let* α0 : M.Val (core.option.Option.t u128.t) := M.alloc α1 in
    M.read α0.
  
  Global Instance AssociatedFunction_get_balance :
    Notations.DoubleColon Self "get_balance" := {
    Notations.double_colon := get_balance;
  }.
  
  (*
      pub fn insert_balance(&mut self, value: Balance) -> Option<u32> {
          let caller = Self::env().caller();
          self.balances.insert(caller, value)
      }
  *)
  Definition insert_balance
      (self : mut_ref Self)
      (value : ltac:(mapping_integration_tests.Balance))
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
    let* α2 : u128.t := M.read value in
    let* α3 : core.option.Option.t u32.t :=
      M.call
        ((mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)::["insert"]
          (borrow_mut
            (mapping_integration_tests.Mappings.Get_balances (deref α0)))
          α1
          α2) in
    let* α0 : M.Val (core.option.Option.t u32.t) := M.alloc α3 in
    M.read α0.
  
  Global Instance AssociatedFunction_insert_balance :
    Notations.DoubleColon Self "insert_balance" := {
    Notations.double_colon := insert_balance;
  }.
  
  (*
      pub fn size_balance(&mut self) -> Option<u32> {
          let caller = Self::env().caller();
          self.balances.size(caller)
      }
  *)
  Definition size_balance
      (self : mut_ref Self)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
    let* α2 : core.option.Option.t u32.t :=
      M.call
        ((mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)::["size"]
          (borrow (mapping_integration_tests.Mappings.Get_balances (deref α0)))
          α1) in
    let* α0 : M.Val (core.option.Option.t u32.t) := M.alloc α2 in
    M.read α0.
  
  Global Instance AssociatedFunction_size_balance :
    Notations.DoubleColon Self "size_balance" := {
    Notations.double_colon := size_balance;
  }.
  
  (*
      pub fn contains_balance(&self) -> bool {
          let caller = Self::env().caller();
          self.balances.contains(&caller)
      }
  *)
  Definition contains_balance (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* α0 : ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : bool.t :=
      M.call
        ((mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)::["contains"]
          (borrow (mapping_integration_tests.Mappings.Get_balances (deref α0)))
          (borrow caller)) in
    let* α0 : M.Val bool.t := M.alloc α1 in
    M.read α0.
  
  Global Instance AssociatedFunction_contains_balance :
    Notations.DoubleColon Self "contains_balance" := {
    Notations.double_colon := contains_balance;
  }.
  
  (*
      pub fn remove_balance(&mut self) {
          let caller = Self::env().caller();
          self.balances.remove(caller);
      }
  *)
  Definition remove_balance (self : mut_ref Self) : M unit :=
    let* self := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
      let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
      let* α2 : unit :=
        M.call
          ((mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)::["remove"]
            (borrow
              (mapping_integration_tests.Mappings.Get_balances (deref α0)))
            α1) in
      M.alloc α2 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_remove_balance :
    Notations.DoubleColon Self "remove_balance" := {
    Notations.double_colon := remove_balance;
  }.
  
  (*
      pub fn take_balance(&mut self) -> Option<Balance> {
          let caller = Self::env().caller();
          self.balances.take(caller)
      }
  *)
  Definition take_balance
      (self : mut_ref Self)
      : M (core.option.Option.t ltac:(mapping_integration_tests.Balance)) :=
    let* self := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
    let* α2 : core.option.Option.t u128.t :=
      M.call
        ((mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)::["take"]
          (borrow (mapping_integration_tests.Mappings.Get_balances (deref α0)))
          α1) in
    let* α0 : M.Val (core.option.Option.t u128.t) := M.alloc α2 in
    M.read α0.
  
  Global Instance AssociatedFunction_take_balance :
    Notations.DoubleColon Self "take_balance" := {
    Notations.double_colon := take_balance;
  }.
End Impl_mapping_integration_tests_Mappings_t.
End Impl_mapping_integration_tests_Mappings_t.
