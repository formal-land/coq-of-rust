(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Enum Mapping *)

Module Impl_core_default_Default_for_multisig_Mapping_K_V.
  Definition Self (K V : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "multisig::Mapping") [ K; V ].
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [ K; V ], [] =>
      let* Œ±0 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.apply (Ty.path "core::marker::PhantomData") [ K ] ] in
      let* Œ±1 := M.call Œ±0 [] in
      let* Œ±2 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.apply (Ty.path "core::marker::PhantomData") [ V ] ] in
      let* Œ±3 := M.call Œ±2 [] in
      M.pure
        (Value.StructRecord
          "multisig::Mapping"
          [ ("_key", Œ±1); ("_value", Œ±3) ])
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê (K V : Ty.t) : Instance.t :=
    [ ("default", InstanceField.Method (default K V)) ].
End Impl_core_default_Default_for_multisig_Mapping_K_V.

Module Impl_multisig_Mapping_K_V.
  Definition Self (K V : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "multisig::Mapping") [ K; V ].
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [ K; V ], [ self; _key ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [ K; V ], [ self; _key ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [ K; V ], [ self; _key; _value ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* _value := M.alloc _value in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [ K; V ], [ self; _key ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [ K; V ], [ self; _key ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [ K; V ], [ self; _key ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
End Impl_multisig_Mapping_K_V.

(* Struct AccountId *)

Module Impl_core_default_Default_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "u128" ] in
      let* Œ±1 := M.call Œ±0 [] in
      M.pure (multisig.AccountId.Build_t Œ±1)
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_multisig_AccountId.

Module Impl_core_fmt_Debug_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  Debug
  *)
  Definition fmt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Œ±0 := M.read f in
      let* Œ±1 := M.read (mk_str "AccountId") in
      let* Œ±2 := M.read self in
      let* Œ±3 :=
        M.alloc (borrow ((M.var "multisig::AccountId::Get_0") (deref Œ±2))) in
      M.call
        (Ty.path "core::fmt::Formatter")::["debug_tuple_field1_finish"]
        [ Œ±0; Œ±1; pointer_coercion "Unsize" (borrow Œ±3) ]
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_multisig_AccountId.

Module Impl_core_clone_Clone_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  Clone
  *)
  Definition clone (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Œ±0 :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [ Ty.path "u128" ]))
          [
            fun Œ≥ =>
              (let* Œ±0 := M.read self in
              M.pure (deref Œ±0)) :
              Ty.path "multisig::AccountId"
          ] in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_multisig_AccountId.

Module Impl_core_marker_Copy_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_Copy_for_multisig_AccountId.

Module Impl_core_marker_StructuralPartialEq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId.

Module Impl_core_cmp_PartialEq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  PartialEq
  *)
  Definition eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 := M.read self in
      let* Œ±1 := M.read ((M.var "multisig::AccountId::Get_0") (deref Œ±0)) in
      let* Œ±2 := M.read other in
      let* Œ±3 := M.read ((M.var "multisig::AccountId::Get_0") (deref Œ±2)) in
      M.pure ((M.var "BinOp::Pure::eq") Œ±1 Œ±3)
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_for_multisig_AccountId.

Module Impl_core_marker_StructuralEq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralEq_for_multisig_AccountId.

Module Impl_core_cmp_Eq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq
      (ùúè : list Ty.t)
      (Œ± : list Value.t)
      : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Œ±0 :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::cmp::AssertParamIsEq")
                [ Ty.path "u128" ]))
          [ fun Œ≥ => (M.alloc tt) : Ty.path "unit" ] in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t :=
    [
      ("assert_receiver_is_total_eq",
        InstanceField.Method assert_receiver_is_total_eq)
    ].
End Impl_core_cmp_Eq_for_multisig_AccountId.

Module Impl_core_cmp_PartialOrd_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  PartialOrd
  *)
  Definition partial_cmp (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 :=
        M.get_method
          "core::cmp::PartialOrd"
          "partial_cmp"
          [ (* Self *) Ty.path "u128"; (* Rhs *) Ty.path "u128" ] in
      let* Œ±1 := M.read self in
      let* Œ±2 := M.read other in
      M.call
        Œ±0
        [
          borrow ((M.var "multisig::AccountId::Get_0") (deref Œ±1));
          borrow ((M.var "multisig::AccountId::Get_0") (deref Œ±2))
        ]
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t :=
    [ ("partial_cmp", InstanceField.Method partial_cmp) ].
End Impl_core_cmp_PartialOrd_for_multisig_AccountId.

Module Impl_core_cmp_Ord_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  Ord
  *)
  Definition cmp (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 :=
        M.get_method "core::cmp::Ord" "cmp" [ (* Self *) Ty.path "u128" ] in
      let* Œ±1 := M.read self in
      let* Œ±2 := M.read other in
      M.call
        Œ±0
        [
          borrow ((M.var "multisig::AccountId::Get_0") (deref Œ±1));
          borrow ((M.var "multisig::AccountId::Get_0") (deref Œ±2))
        ]
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("cmp", InstanceField.Method cmp) ].
End Impl_core_cmp_Ord_for_multisig_AccountId.

Axiom Balance : (Ty.path "multisig::Balance") = (Ty.path "u128").

(* Enum Env *)

Definition MAX_OWNERS : Ty.path "u32" :=
  M.run (M.alloc ((Integer.of_Z 50) : Ty.path "u32")).

Axiom TransactionId : (Ty.path "multisig::TransactionId") = (Ty.path "u32").

Definition WRONG_TRANSACTION_ID : Ty.apply (Ty.path "ref") [ Ty.path "str" ] :=
  M.run
    (M.pure (mk_str "The user specified an invalid transaction id. Abort.")).

(* Struct CallInput *)

(* Enum ConfirmationStatus *)

Module Impl_core_clone_Clone_for_multisig_ConfirmationStatus.
  Definition Self : Ty.t := Ty.path "multisig::ConfirmationStatus".
  
  (*
  Clone
  *)
  Definition clone (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Œ±0 :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [ Ty.path "u32" ]))
          [
            fun Œ≥ =>
              (let* Œ±0 := M.read self in
              M.pure (deref Œ±0)) :
              Ty.path "multisig::ConfirmationStatus"
          ] in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus.

Module Impl_core_marker_Copy_for_multisig_ConfirmationStatus.
  Definition Self : Ty.t := Ty.path "multisig::ConfirmationStatus".
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus.

(* Enum Transaction *)

Module Impl_core_default_Default_for_multisig_Transaction.
  Definition Self : Ty.t := Ty.path "multisig::Transaction".
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "multisig::AccountId" ] in
      let* Œ±1 := M.call Œ±0 [] in
      let* Œ±2 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.apply (Ty.path "array") [ Ty.path "u8" ] ] in
      let* Œ±3 := M.call Œ±2 [] in
      let* Œ±4 :=
        M.get_method
          "core::default::Default"
          "default"
          [
            (* Self *)
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
          ] in
      let* Œ±5 := M.call Œ±4 [] in
      let* Œ±6 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "u128" ] in
      let* Œ±7 := M.call Œ±6 [] in
      let* Œ±8 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "u64" ] in
      let* Œ±9 := M.call Œ±8 [] in
      let* Œ±10 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "bool" ] in
      let* Œ±11 := M.call Œ±10 [] in
      M.pure
        (Value.StructRecord
          "multisig::Transaction"
          [
            ("callee", Œ±1);
            ("selector", Œ±3);
            ("input", Œ±5);
            ("transferred_value", Œ±7);
            ("gas_limit", Œ±9);
            ("allow_reentry", Œ±11)
          ])
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_multisig_Transaction.

(* Enum Error *)

Module Impl_core_clone_Clone_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  (*
  Clone
  *)
  Definition clone (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      M.read (deref Œ±0)
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_multisig_Error.

Module Impl_core_marker_Copy_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_Copy_for_multisig_Error.

Module Impl_core_marker_StructuralPartialEq_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralPartialEq_for_multisig_Error.

Module Impl_core_cmp_PartialEq_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  (*
  PartialEq
  *)
  Definition eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.pure true
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_for_multisig_Error.

Module Impl_core_marker_StructuralEq_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralEq_for_multisig_Error.

Module Impl_core_cmp_Eq_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq
      (ùúè : list Ty.t)
      (Œ± : list Value.t)
      : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      M.pure tt
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t :=
    [
      ("assert_receiver_is_total_eq",
        InstanceField.Method assert_receiver_is_total_eq)
    ].
End Impl_core_cmp_Eq_for_multisig_Error.

(* Enum Transactions *)

Module Impl_core_default_Default_for_multisig_Transactions.
  Definition Self : Ty.t := Ty.path "multisig::Transactions".
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 :=
        M.get_method
          "core::default::Default"
          "default"
          [
            (* Self *)
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ]
          ] in
      let* Œ±1 := M.call Œ±0 [] in
      let* Œ±2 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "u32" ] in
      let* Œ±3 := M.call Œ±2 [] in
      M.pure
        (Value.StructRecord
          "multisig::Transactions"
          [ ("transactions", Œ±1); ("next_id", Œ±3) ])
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_multisig_Transactions.

(* Enum Confirmation *)

(* Enum Revocation *)

(* Enum Submission *)

(* Enum Cancellation *)

(* Enum Execution *)

(* Enum OwnerAddition *)

(* Enum OwnerRemoval *)

(* Enum RequirementChange *)

(* Enum Event *)

Module Impl_multisig_Env.
  Definition Self : Ty.t := Ty.path "multisig::Env".
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      M.read ((M.var "multisig::Env::Get_caller") (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; _event ] =>
      let* self := M.alloc self in
      let* _event := M.alloc _event in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition transferred_value (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Definition account_id (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
End Impl_multisig_Env.

(* Enum Multisig *)

Module Impl_core_default_Default_for_multisig_Multisig.
  Definition Self : Ty.t := Ty.path "multisig::Multisig".
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 :=
        M.get_method
          "core::default::Default"
          "default"
          [
            (* Self *)
              Ty.apply
                (Ty.path "multisig::Mapping")
                [
                  Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ];
                  Ty.tuple []
                ]
          ] in
      let* Œ±1 := M.call Œ±0 [] in
      let* Œ±2 :=
        M.get_method
          "core::default::Default"
          "default"
          [
            (* Self *)
              Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "u32"; Ty.path "u32" ]
          ] in
      let* Œ±3 := M.call Œ±2 [] in
      let* Œ±4 :=
        M.get_method
          "core::default::Default"
          "default"
          [
            (* Self *)
              Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "u32"; Ty.path "multisig::Transaction" ]
          ] in
      let* Œ±5 := M.call Œ±4 [] in
      let* Œ±6 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "multisig::Transactions" ] in
      let* Œ±7 := M.call Œ±6 [] in
      let* Œ±8 :=
        M.get_method
          "core::default::Default"
          "default"
          [
            (* Self *)
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global"
                ]
          ] in
      let* Œ±9 := M.call Œ±8 [] in
      let* Œ±10 :=
        M.get_method
          "core::default::Default"
          "default"
          [
            (* Self *)
              Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "multisig::AccountId"; Ty.tuple [] ]
          ] in
      let* Œ±11 := M.call Œ±10 [] in
      let* Œ±12 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "u32" ] in
      let* Œ±13 := M.call Œ±12 [] in
      M.pure
        (Value.StructRecord
          "multisig::Multisig"
          [
            ("confirmations", Œ±1);
            ("confirmation_count", Œ±3);
            ("transactions", Œ±5);
            ("transaction_list", Œ±7);
            ("owners", Œ±9);
            ("is_owner", Œ±11);
            ("requirement", Œ±13)
          ])
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_multisig_Multisig.

(*
fn ensure_requirement_is_valid(owners: u32, requirement: u32) {
    assert!(0 < requirement && requirement <= owners && owners <= MAX_OWNERS);
}
*)
Definition ensure_requirement_is_valid (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [ owners; requirement ] =>
    let* owners := M.alloc owners in
    let* requirement := M.alloc requirement in
    let* _ :=
      let* Œ±0 := M.read requirement in
      let* Œ±1 := M.read requirement in
      let* Œ±2 := M.read owners in
      let* Œ±3 := M.read owners in
      let* Œ±4 := M.read (M.var "multisig::MAX_OWNERS") in
      let* Œ±5 :=
        M.alloc
          ((M.var "UnOp::not")
            ((M.var "BinOp::Pure::and")
              ((M.var "BinOp::Pure::and")
                ((M.var "BinOp::Pure::lt")
                  ((Integer.of_Z 0) : Ty.path "u32")
                  Œ±0)
                ((M.var "BinOp::Pure::le") Œ±1 Œ±2))
              ((M.var "BinOp::Pure::le") Œ±3 Œ±4))) in
      let* Œ±6 := M.read (use Œ±5) in
      if Œ±6 then
        let* Œ±0 :=
          M.read
            (mk_str
              "assertion failed: 0 < requirement && requirement <= owners && owners <= MAX_OWNERS") in
        let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
        let* Œ±2 := never_to_any Œ±1 in
        M.alloc Œ±2
      else
        M.alloc tt in
    let* Œ±0 := M.alloc tt in
    M.read Œ±0
  | _, _ => M.impossible
  end.

Module Impl_multisig_Multisig.
  Definition Self : Ty.t := Ty.path "multisig::Multisig".
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      M.call (Ty.path "multisig::Multisig")::["init_env"] []
    | _, _ => M.impossible
    end.
  
  (*
      pub fn new(requirement: u32, mut owners: Vec<AccountId>) -> Self {
          let mut contract = Multisig::default();
          owners.sort_unstable();
          owners.dedup();
          ensure_requirement_is_valid(owners.len() as u32, requirement);
  
          for owner in &owners {
              contract.is_owner.insert( *owner, ());
          }
  
          contract.owners = owners;
          contract.transaction_list = Default::default();
          contract.requirement = requirement;
          contract
      }
  *)
  Definition new (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ requirement; owners ] =>
      let* requirement := M.alloc requirement in
      let* owners := M.alloc owners in
      let* contract :=
        let* Œ±0 :=
          M.get_method
            "core::default::Default"
            "default"
            [ (* Self *) Ty.path "multisig::Multisig" ] in
        let* Œ±1 := M.call Œ±0 [] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 :=
          M.get_method
            "core::ops::deref::DerefMut"
            "deref_mut"
            [
              (* Self *)
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.path "multisig::AccountId";
                    Ty.path "alloc::alloc::Global"
                  ]
            ] in
        let* Œ±1 := M.call Œ±0 [ borrow_mut owners ] in
        let* Œ±2 :=
          M.call
            (Ty.apply
                (Ty.path "slice")
                [ Ty.path "multisig::AccountId" ])::["sort_unstable"]
            [ Œ±1 ] in
        M.alloc Œ±2 in
      let* _ :=
        let* Œ±0 :=
          M.call
            (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global"
                ])::["dedup"]
            [ borrow_mut owners ] in
        M.alloc Œ±0 in
      let* _ :=
        let* Œ±0 :=
          M.call
            (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global"
                ])::["len"]
            [ borrow owners ] in
        let* Œ±1 := M.read requirement in
        let* Œ±2 :=
          M.call
            (M.var "multisig::ensure_requirement_is_valid")
            [ rust_cast Œ±0; Œ±1 ] in
        M.alloc Œ±2 in
      let* _ :=
        let* Œ±0 :=
          M.get_method
            "core::iter::traits::collect::IntoIterator"
            "into_iter"
            [
              (* Self *)
                Ty.apply
                  (Ty.path "ref")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "multisig::AccountId";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ]
            ] in
        let* Œ±1 := M.call Œ±0 [ borrow owners ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 :=
          match_operator
            Œ±2
            [
              fun Œ≥ =>
                (let* iter := M.copy Œ≥ in
                M.loop
                  (let* _ :=
                    let* Œ±0 :=
                      M.get_method
                        "core::iter::traits::iterator::Iterator"
                        "next"
                        [
                          (* Self *)
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [ Ty.path "multisig::AccountId" ]
                        ] in
                    let* Œ±1 := M.call Œ±0 [ borrow_mut iter ] in
                    let* Œ±2 := M.alloc Œ±1 in
                    match_operator
                      Œ±2
                      [
                        fun Œ≥ =>
                          (let* Œ±0 := M.read Œ≥ in
                          match Œ±0 with
                          | core.option.Option.None =>
                            let* Œ±0 := M.break in
                            let* Œ±1 := M.read Œ±0 in
                            let* Œ±2 := never_to_any Œ±1 in
                            M.alloc Œ±2
                          | _ => M.break_match 
                          end) :
                          Ty.tuple [];
                        fun Œ≥ =>
                          (let* Œ±0 := M.read Œ≥ in
                          match Œ±0 with
                          | core.option.Option.Some _ =>
                            let Œ≥0_0 :=
                              (M.var "core::option::Option::Get_Some_0") Œ≥ in
                            let* owner := M.copy Œ≥0_0 in
                            let* _ :=
                              let* Œ±0 := M.read owner in
                              let* Œ±1 := M.read (deref Œ±0) in
                              let* Œ±2 :=
                                M.call
                                  (Ty.apply
                                      (Ty.path "multisig::Mapping")
                                      [
                                        Ty.path "multisig::AccountId";
                                        Ty.tuple []
                                      ])::["insert"]
                                  [
                                    borrow_mut
                                      ((M.var
                                          "multisig::Multisig::Get_is_owner")
                                        contract);
                                    Œ±1;
                                    tt
                                  ] in
                              M.alloc Œ±2 in
                            M.alloc tt
                          | _ => M.break_match 
                          end) :
                          Ty.tuple []
                      ] in
                  M.alloc tt)) :
                Ty.tuple []
            ] in
        M.pure (use Œ±3) in
      let* _ :=
        let* Œ±0 := M.read owners in
        assign ((M.var "multisig::Multisig::Get_owners") contract) Œ±0 in
      let* _ :=
        let* Œ±0 :=
          M.get_method
            "core::default::Default"
            "default"
            [ (* Self *) Ty.path "multisig::Transactions" ] in
        let* Œ±1 := M.call Œ±0 [] in
        assign
          ((M.var "multisig::Multisig::Get_transaction_list") contract)
          Œ±1 in
      let* _ :=
        let* Œ±0 := M.read requirement in
        assign ((M.var "multisig::Multisig::Get_requirement") contract) Œ±0 in
      M.read contract
    | _, _ => M.impossible
    end.
  
  (*
      fn ensure_confirmed(&self, trans_id: TransactionId) {
          assert!(
              self.confirmation_count
                  .get(&trans_id)
                  .expect(WRONG_TRANSACTION_ID)
                  >= self.requirement
          );
      }
  *)
  Definition ensure_confirmed (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "u32"; Ty.path "u32" ])::["get"]
            [
              borrow
                ((M.var "multisig::Multisig::Get_confirmation_count")
                  (deref Œ±0));
              borrow trans_id
            ] in
        let* Œ±2 := M.read (M.var "multisig::WRONG_TRANSACTION_ID") in
        let* Œ±3 :=
          M.call
            (Ty.apply
                (Ty.path "core::option::Option")
                [ Ty.path "u32" ])::["expect"]
            [ Œ±1; Œ±2 ] in
        let* Œ±4 := M.read self in
        let* Œ±5 :=
          M.read ((M.var "multisig::Multisig::Get_requirement") (deref Œ±4)) in
        let* Œ±6 :=
          M.alloc ((M.var "UnOp::not") ((M.var "BinOp::Pure::ge") Œ±3 Œ±5)) in
        let* Œ±7 := M.read (use Œ±6) in
        if Œ±7 then
          let* Œ±0 :=
            M.read
              (mk_str
                "assertion failed: self.confirmation_count.get(&trans_id).expect(WRONG_TRANSACTION_ID) >=
    self.requirement") in
          let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
          let* Œ±2 := never_to_any Œ±1 in
          M.alloc Œ±2
        else
          M.alloc tt in
      let* Œ±0 := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      fn ensure_transaction_exists(&self, trans_id: TransactionId) {
          self.transactions
              .get(&trans_id)
              .expect(WRONG_TRANSACTION_ID);
      }
  *)
  Definition ensure_transaction_exists (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "u32"; Ty.path "multisig::Transaction" ])::["get"]
            [
              borrow
                ((M.var "multisig::Multisig::Get_transactions") (deref Œ±0));
              borrow trans_id
            ] in
        let* Œ±2 := M.read (M.var "multisig::WRONG_TRANSACTION_ID") in
        let* Œ±3 :=
          M.call
            (Ty.apply
                (Ty.path "core::option::Option")
                [ Ty.path "multisig::Transaction" ])::["expect"]
            [ Œ±1; Œ±2 ] in
        M.alloc Œ±3 in
      let* Œ±0 := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      fn ensure_owner(&self, owner: &AccountId) {
          assert!(self.is_owner.contains(owner));
      }
  *)
  Definition ensure_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; owner ] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read owner in
        let* Œ±2 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "multisig::AccountId"; Ty.tuple [] ])::["contains"]
            [ borrow ((M.var "multisig::Multisig::Get_is_owner") (deref Œ±0)); Œ±1
            ] in
        let* Œ±3 := M.alloc ((M.var "UnOp::not") Œ±2) in
        let* Œ±4 := M.read (use Œ±3) in
        if Œ±4 then
          let* Œ±0 :=
            M.read (mk_str "assertion failed: self.is_owner.contains(owner)") in
          let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
          let* Œ±2 := never_to_any Œ±1 in
          M.alloc Œ±2
        else
          M.alloc tt in
      let* Œ±0 := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      fn ensure_caller_is_owner(&self) {
          self.ensure_owner(&self.env().caller());
      }
  *)
  Definition ensure_caller_is_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read self in
        let* Œ±2 := M.call (Ty.path "multisig::Multisig")::["env"] [ Œ±1 ] in
        let* Œ±3 := M.alloc Œ±2 in
        let* Œ±4 := M.call (Ty.path "multisig::Env")::["caller"] [ borrow Œ±3 ] in
        let* Œ±5 := M.alloc Œ±4 in
        let* Œ±6 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_owner"]
            [ Œ±0; borrow Œ±5 ] in
        M.alloc Œ±6 in
      let* Œ±0 := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      fn ensure_from_wallet(&self) {
          assert_eq!(self.env().caller(), self.env().account_id());
      }
  *)
  Definition ensure_from_wallet (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.call (Ty.path "multisig::Multisig")::["env"] [ Œ±0 ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 := M.call (Ty.path "multisig::Env")::["caller"] [ borrow Œ±2 ] in
        let* Œ±4 := M.alloc Œ±3 in
        let* Œ±5 := M.read self in
        let* Œ±6 := M.call (Ty.path "multisig::Multisig")::["env"] [ Œ±5 ] in
        let* Œ±7 := M.alloc Œ±6 in
        let* Œ±8 :=
          M.call (Ty.path "multisig::Env")::["account_id"] [ borrow Œ±7 ] in
        let* Œ±9 := M.alloc Œ±8 in
        let* Œ±10 := M.alloc (borrow Œ±4, borrow Œ±9) in
        match_operator
          Œ±10
          [
            fun Œ≥ =>
              (let* Œ±0 := M.read Œ≥ in
              match Œ±0 with
              | (_, _) =>
                let Œ≥0_0 := Tuple.Access.left Œ≥ in
                let Œ≥0_1 := Tuple.Access.right Œ≥ in
                let* left_val := M.copy Œ≥0_0 in
                let* right_val := M.copy Œ≥0_1 in
                let* Œ±0 :=
                  M.get_method
                    "core::cmp::PartialEq"
                    "eq"
                    [
                      (* Self *) Ty.path "multisig::AccountId";
                      (* Rhs *) Ty.path "multisig::AccountId"
                    ] in
                let* Œ±1 := M.read left_val in
                let* Œ±2 := M.read right_val in
                let* Œ±3 := M.call Œ±0 [ Œ±1; Œ±2 ] in
                let* Œ±4 := M.alloc ((M.var "UnOp::not") Œ±3) in
                let* Œ±5 := M.read (use Œ±4) in
                if Œ±5 then
                  let* kind := M.alloc core.panicking.AssertKind.Eq in
                  let* Œ±0 := M.read kind in
                  let* Œ±1 := M.read left_val in
                  let* Œ±2 := M.read right_val in
                  let* Œ±3 :=
                    M.call
                      (M.var "core::panicking::assert_failed")
                      [ Œ±0; Œ±1; Œ±2; core.option.Option.None ] in
                  let* Œ±0 := M.alloc Œ±3 in
                  let* Œ±1 := M.read Œ±0 in
                  let* Œ±2 := never_to_any Œ±1 in
                  M.alloc Œ±2
                else
                  M.alloc tt
              end) :
              Ty.tuple []
          ] in
      let* Œ±0 := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      fn ensure_no_owner(&self, owner: &AccountId) {
          assert!(!self.is_owner.contains(owner));
      }
  *)
  Definition ensure_no_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; owner ] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read owner in
        let* Œ±2 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "multisig::AccountId"; Ty.tuple [] ])::["contains"]
            [ borrow ((M.var "multisig::Multisig::Get_is_owner") (deref Œ±0)); Œ±1
            ] in
        let* Œ±3 := M.alloc ((M.var "UnOp::not") ((M.var "UnOp::not") Œ±2)) in
        let* Œ±4 := M.read (use Œ±3) in
        if Œ±4 then
          let* Œ±0 :=
            M.read
              (mk_str "assertion failed: !self.is_owner.contains(owner)") in
          let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
          let* Œ±2 := never_to_any Œ±1 in
          M.alloc Œ±2
        else
          M.alloc tt in
      let* Œ±0 := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      pub fn add_owner(&mut self, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_no_owner(&new_owner);
          ensure_requirement_is_valid(self.owners.len() as u32 + 1, self.requirement);
          self.is_owner.insert(new_owner, ());
          self.owners.push(new_owner);
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition add_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; new_owner ] =>
      let* self := M.alloc self in
      let* new_owner := M.alloc new_owner in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_from_wallet"]
            [ borrow (deref Œ±0) ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_no_owner"]
            [ borrow (deref Œ±0); borrow new_owner ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global"
                ])::["len"]
            [ borrow ((M.var "multisig::Multisig::Get_owners") (deref Œ±0)) ] in
        let* Œ±2 :=
          (M.var "BinOp::Panic::add")
            (rust_cast Œ±1)
            ((Integer.of_Z 1) : Ty.path "u32") in
        let* Œ±3 := M.read self in
        let* Œ±4 :=
          M.read ((M.var "multisig::Multisig::Get_requirement") (deref Œ±3)) in
        let* Œ±5 :=
          M.call (M.var "multisig::ensure_requirement_is_valid") [ Œ±2; Œ±4 ] in
        M.alloc Œ±5 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read new_owner in
        let* Œ±2 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "multisig::AccountId"; Ty.tuple [] ])::["insert"]
            [
              borrow_mut
                ((M.var "multisig::Multisig::Get_is_owner") (deref Œ±0));
              Œ±1;
              tt
            ] in
        M.alloc Œ±2 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read new_owner in
        let* Œ±2 :=
          M.call
            (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global"
                ])::["push"]
            [
              borrow_mut ((M.var "multisig::Multisig::Get_owners") (deref Œ±0));
              Œ±1
            ] in
        M.alloc Œ±2 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["env"]
            [ borrow (deref Œ±0) ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 := M.read new_owner in
        let* Œ±4 :=
          M.call
            (Ty.path "multisig::Env")::["emit_event"]
            [
              borrow Œ±2;
              multisig.Event.OwnerAddition
                (Value.StructRecord "multisig::OwnerAddition" [ ("owner", Œ±3) ])
            ] in
        M.alloc Œ±4 in
      let* Œ±0 := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      fn owner_index(&self, owner: &AccountId) -> u32 {
          self.owners.iter().position(|x| *x == *owner).expect(
              "This is only called after it was already verified that the id is
                 actually an owner.",
          ) as u32
      }
  *)
  Definition owner_index (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; owner ] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* Œ±0 :=
        M.get_method
          "core::iter::traits::iterator::Iterator"
          "position"
          [
            (* Self *)
              Ty.apply
                (Ty.path "core::slice::iter::Iter")
                [ Ty.path "multisig::AccountId" ];
            (* P *)
              Ty.function
                [
                  Ty.tuple
                    [ Ty.apply (Ty.path "ref") [ Ty.path "multisig::AccountId" ]
                    ]
                ]
                (Ty.path "bool")
          ] in
      let* Œ±1 :=
        M.get_method
          "core::ops::deref::Deref"
          "deref"
          [
            (* Self *)
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global"
                ]
          ] in
      let* Œ±2 := M.read self in
      let* Œ±3 :=
        M.call
          Œ±1
          [ borrow ((M.var "multisig::Multisig::Get_owners") (deref Œ±2)) ] in
      let* Œ±4 :=
        M.call
          (Ty.apply
              (Ty.path "slice")
              [ Ty.path "multisig::AccountId" ])::["iter"]
          [ Œ±3 ] in
      let* Œ±5 := M.alloc Œ±4 in
      let* Œ±6 :=
        M.call
          Œ±0
          [
            borrow_mut Œ±5;
            fun
                (Œ±0 :
                  Ty.apply (Ty.path "ref") [ Ty.path "multisig::AccountId" ]) =>
              (let* Œ±0 := M.alloc Œ±0 in
              match_operator
                Œ±0
                [
                  fun Œ≥ =>
                    (let* x := M.copy Œ≥ in
                    let* Œ±0 :=
                      M.get_method
                        "core::cmp::PartialEq"
                        "eq"
                        [
                          (* Self *) Ty.path "multisig::AccountId";
                          (* Rhs *) Ty.path "multisig::AccountId"
                        ] in
                    let* Œ±1 := M.read x in
                    let* Œ±2 := M.read owner in
                    M.call Œ±0 [ Œ±1; Œ±2 ]) :
                    Ty.path "bool"
                ]) :
              Ty.path "bool"
          ] in
      let* Œ±7 :=
        M.read
          (mk_str
            "This is only called after it was already verified that the id is
               actually an owner.") in
      let* Œ±8 :=
        M.call
          (Ty.apply
              (Ty.path "core::option::Option")
              [ Ty.path "usize" ])::["expect"]
          [ Œ±6; Œ±7 ] in
      M.pure (rust_cast Œ±8)
    | _, _ => M.impossible
    end.
  
  (*
      fn clean_owner_confirmations(&mut self, owner: &AccountId) {
          for trans_id in &self.transaction_list.transactions {
              let key = ( *trans_id, *owner);
              if self.confirmations.contains(&key) {
                  self.confirmations.remove(key);
                  let mut count = self.confirmation_count.get(trans_id).unwrap_or(0 as u32);
                  count -= 1;
                  self.confirmation_count.insert( *trans_id, count);
              }
          }
      }
  *)
  Definition clean_owner_confirmations (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; owner ] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* Œ±0 :=
        M.get_method
          "core::iter::traits::collect::IntoIterator"
          "into_iter"
          [
            (* Self *)
              Ty.apply
                (Ty.path "ref")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ]
                ]
          ] in
      let* Œ±1 := M.read self in
      let* Œ±2 :=
        M.call
          Œ±0
          [
            borrow
              ((M.var "multisig::Transactions::Get_transactions")
                ((M.var "multisig::Multisig::Get_transaction_list") (deref Œ±1)))
          ] in
      let* Œ±3 := M.alloc Œ±2 in
      let* Œ±4 :=
        match_operator
          Œ±3
          [
            fun Œ≥ =>
              (let* iter := M.copy Œ≥ in
              M.loop
                (let* _ :=
                  let* Œ±0 :=
                    M.get_method
                      "core::iter::traits::iterator::Iterator"
                      "next"
                      [
                        (* Self *)
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            [ Ty.path "u32" ]
                      ] in
                  let* Œ±1 := M.call Œ±0 [ borrow_mut iter ] in
                  let* Œ±2 := M.alloc Œ±1 in
                  match_operator
                    Œ±2
                    [
                      fun Œ≥ =>
                        (let* Œ±0 := M.read Œ≥ in
                        match Œ±0 with
                        | core.option.Option.None =>
                          let* Œ±0 := M.break in
                          let* Œ±1 := M.read Œ±0 in
                          let* Œ±2 := never_to_any Œ±1 in
                          M.alloc Œ±2
                        | _ => M.break_match 
                        end) :
                        Ty.tuple [];
                      fun Œ≥ =>
                        (let* Œ±0 := M.read Œ≥ in
                        match Œ±0 with
                        | core.option.Option.Some _ =>
                          let Œ≥0_0 :=
                            (M.var "core::option::Option::Get_Some_0") Œ≥ in
                          let* trans_id := M.copy Œ≥0_0 in
                          let* key :=
                            let* Œ±0 := M.read trans_id in
                            let* Œ±1 := M.read (deref Œ±0) in
                            let* Œ±2 := M.read owner in
                            let* Œ±3 := M.read (deref Œ±2) in
                            M.alloc (Œ±1, Œ±3) in
                          let* Œ±0 := M.read self in
                          let* Œ±1 :=
                            M.call
                              (Ty.apply
                                  (Ty.path "multisig::Mapping")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "u32";
                                        Ty.path "multisig::AccountId"
                                      ];
                                    Ty.tuple []
                                  ])::["contains"]
                              [
                                borrow
                                  ((M.var
                                      "multisig::Multisig::Get_confirmations")
                                    (deref Œ±0));
                                borrow key
                              ] in
                          let* Œ±2 := M.alloc Œ±1 in
                          let* Œ±3 := M.read (use Œ±2) in
                          if Œ±3 then
                            let* _ :=
                              let* Œ±0 := M.read self in
                              let* Œ±1 := M.read key in
                              let* Œ±2 :=
                                M.call
                                  (Ty.apply
                                      (Ty.path "multisig::Mapping")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "u32";
                                            Ty.path "multisig::AccountId"
                                          ];
                                        Ty.tuple []
                                      ])::["remove"]
                                  [
                                    borrow
                                      ((M.var
                                          "multisig::Multisig::Get_confirmations")
                                        (deref Œ±0));
                                    Œ±1
                                  ] in
                              M.alloc Œ±2 in
                            let* count :=
                              let* Œ±0 := M.read self in
                              let* Œ±1 := M.read trans_id in
                              let* Œ±2 :=
                                M.call
                                  (Ty.apply
                                      (Ty.path "multisig::Mapping")
                                      [ Ty.path "u32"; Ty.path "u32" ])::["get"]
                                  [
                                    borrow
                                      ((M.var
                                          "multisig::Multisig::Get_confirmation_count")
                                        (deref Œ±0));
                                    Œ±1
                                  ] in
                              let* Œ±3 :=
                                M.alloc ((Integer.of_Z 0) : Ty.path "u32") in
                              let* Œ±4 := M.read (use Œ±3) in
                              let* Œ±5 :=
                                M.call
                                  (Ty.apply
                                      (Ty.path "core::option::Option")
                                      [ Ty.path "u32" ])::["unwrap_or"]
                                  [ Œ±2; Œ±4 ] in
                              M.alloc Œ±5 in
                            let* _ :=
                              let Œ≤ := count in
                              let* Œ±0 := M.read Œ≤ in
                              let* Œ±1 :=
                                (M.var "BinOp::Panic::sub")
                                  Œ±0
                                  ((Integer.of_Z 1) : Ty.path "u32") in
                              (M.var "assign") Œ≤ Œ±1 in
                            let* _ :=
                              let* Œ±0 := M.read self in
                              let* Œ±1 := M.read trans_id in
                              let* Œ±2 := M.read (deref Œ±1) in
                              let* Œ±3 := M.read count in
                              let* Œ±4 :=
                                M.call
                                  (Ty.apply
                                      (Ty.path "multisig::Mapping")
                                      [ Ty.path "u32"; Ty.path "u32"
                                      ])::["insert"]
                                  [
                                    borrow_mut
                                      ((M.var
                                          "multisig::Multisig::Get_confirmation_count")
                                        (deref Œ±0));
                                    Œ±2;
                                    Œ±3
                                  ] in
                              M.alloc Œ±4 in
                            M.alloc tt
                          else
                            M.alloc tt
                        | _ => M.break_match 
                        end) :
                        Ty.tuple []
                    ] in
                M.alloc tt)) :
              Ty.tuple []
          ] in
      M.read (use Œ±4)
    | _, _ => M.impossible
    end.
  
  (*
      pub fn remove_owner(&mut self, owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&owner);
          let len = self.owners.len() as u32 - 1;
          let requirement = u32::min(len, self.requirement);
          ensure_requirement_is_valid(len, requirement);
          let owner_index = self.owner_index(&owner) as usize;
          self.owners.swap_remove(owner_index);
          self.is_owner.remove(owner);
          self.requirement = requirement;
          self.clean_owner_confirmations(&owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner }));
      }
  *)
  Definition remove_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; owner ] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_from_wallet"]
            [ borrow (deref Œ±0) ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_owner"]
            [ borrow (deref Œ±0); borrow owner ] in
        M.alloc Œ±1 in
      let* len :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global"
                ])::["len"]
            [ borrow ((M.var "multisig::Multisig::Get_owners") (deref Œ±0)) ] in
        let* Œ±2 :=
          (M.var "BinOp::Panic::sub")
            (rust_cast Œ±1)
            ((Integer.of_Z 1) : Ty.path "u32") in
        M.alloc Œ±2 in
      let* requirement :=
        let* Œ±0 :=
          M.get_method "core::cmp::Ord" "min" [ (* Self *) Ty.path "u32" ] in
        let* Œ±1 := M.read len in
        let* Œ±2 := M.read self in
        let* Œ±3 :=
          M.read ((M.var "multisig::Multisig::Get_requirement") (deref Œ±2)) in
        let* Œ±4 := M.call Œ±0 [ Œ±1; Œ±3 ] in
        M.alloc Œ±4 in
      let* _ :=
        let* Œ±0 := M.read len in
        let* Œ±1 := M.read requirement in
        let* Œ±2 :=
          M.call (M.var "multisig::ensure_requirement_is_valid") [ Œ±0; Œ±1 ] in
        M.alloc Œ±2 in
      let* owner_index :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["owner_index"]
            [ borrow (deref Œ±0); borrow owner ] in
        M.alloc (rust_cast Œ±1) in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read owner_index in
        let* Œ±2 :=
          M.call
            (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global"
                ])::["swap_remove"]
            [
              borrow_mut ((M.var "multisig::Multisig::Get_owners") (deref Œ±0));
              Œ±1
            ] in
        M.alloc Œ±2 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read owner in
        let* Œ±2 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "multisig::AccountId"; Ty.tuple [] ])::["remove"]
            [ borrow ((M.var "multisig::Multisig::Get_is_owner") (deref Œ±0)); Œ±1
            ] in
        M.alloc Œ±2 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read requirement in
        assign ((M.var "multisig::Multisig::Get_requirement") (deref Œ±0)) Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["clean_owner_confirmations"]
            [ Œ±0; borrow owner ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["env"]
            [ borrow (deref Œ±0) ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 := M.read owner in
        let* Œ±4 :=
          M.call
            (Ty.path "multisig::Env")::["emit_event"]
            [
              borrow Œ±2;
              multisig.Event.OwnerRemoval
                (Value.StructRecord "multisig::OwnerRemoval" [ ("owner", Œ±3) ])
            ] in
        M.alloc Œ±4 in
      let* Œ±0 := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      pub fn replace_owner(&mut self, old_owner: AccountId, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&old_owner);
          self.ensure_no_owner(&new_owner);
          let owner_index = self.owner_index(&old_owner);
          self.owners[owner_index as usize] = new_owner;
          self.is_owner.remove(old_owner);
          self.is_owner.insert(new_owner, ());
          self.clean_owner_confirmations(&old_owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner: old_owner }));
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition replace_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; old_owner; new_owner ] =>
      let* self := M.alloc self in
      let* old_owner := M.alloc old_owner in
      let* new_owner := M.alloc new_owner in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_from_wallet"]
            [ borrow (deref Œ±0) ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_owner"]
            [ borrow (deref Œ±0); borrow old_owner ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_no_owner"]
            [ borrow (deref Œ±0); borrow new_owner ] in
        M.alloc Œ±1 in
      let* owner_index :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["owner_index"]
            [ borrow (deref Œ±0); borrow old_owner ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 :=
          M.get_method
            "core::ops::index::IndexMut"
            "index_mut"
            [
              (* Self *)
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.path "multisig::AccountId";
                    Ty.path "alloc::alloc::Global"
                  ];
              (* Idx *) Ty.path "usize"
            ] in
        let* Œ±1 := M.read self in
        let* Œ±2 := M.read owner_index in
        let* Œ±3 :=
          M.call
            Œ±0
            [
              borrow_mut ((M.var "multisig::Multisig::Get_owners") (deref Œ±1));
              rust_cast Œ±2
            ] in
        let* Œ±4 := M.read new_owner in
        assign (deref Œ±3) Œ±4 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read old_owner in
        let* Œ±2 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "multisig::AccountId"; Ty.tuple [] ])::["remove"]
            [ borrow ((M.var "multisig::Multisig::Get_is_owner") (deref Œ±0)); Œ±1
            ] in
        M.alloc Œ±2 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read new_owner in
        let* Œ±2 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "multisig::AccountId"; Ty.tuple [] ])::["insert"]
            [
              borrow_mut
                ((M.var "multisig::Multisig::Get_is_owner") (deref Œ±0));
              Œ±1;
              tt
            ] in
        M.alloc Œ±2 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["clean_owner_confirmations"]
            [ Œ±0; borrow old_owner ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["env"]
            [ borrow (deref Œ±0) ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 := M.read old_owner in
        let* Œ±4 :=
          M.call
            (Ty.path "multisig::Env")::["emit_event"]
            [
              borrow Œ±2;
              multisig.Event.OwnerRemoval
                (Value.StructRecord "multisig::OwnerRemoval" [ ("owner", Œ±3) ])
            ] in
        M.alloc Œ±4 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["env"]
            [ borrow (deref Œ±0) ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 := M.read new_owner in
        let* Œ±4 :=
          M.call
            (Ty.path "multisig::Env")::["emit_event"]
            [
              borrow Œ±2;
              multisig.Event.OwnerAddition
                (Value.StructRecord "multisig::OwnerAddition" [ ("owner", Œ±3) ])
            ] in
        M.alloc Œ±4 in
      let* Œ±0 := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      pub fn change_requirement(&mut self, new_requirement: u32) {
          self.ensure_from_wallet();
          ensure_requirement_is_valid(self.owners.len() as u32, new_requirement);
          self.requirement = new_requirement;
          self.env()
              .emit_event(Event::RequirementChange(RequirementChange {
                  new_requirement,
              }));
      }
  *)
  Definition change_requirement (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; new_requirement ] =>
      let* self := M.alloc self in
      let* new_requirement := M.alloc new_requirement in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_from_wallet"]
            [ borrow (deref Œ±0) ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global"
                ])::["len"]
            [ borrow ((M.var "multisig::Multisig::Get_owners") (deref Œ±0)) ] in
        let* Œ±2 := M.read new_requirement in
        let* Œ±3 :=
          M.call
            (M.var "multisig::ensure_requirement_is_valid")
            [ rust_cast Œ±1; Œ±2 ] in
        M.alloc Œ±3 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read new_requirement in
        assign ((M.var "multisig::Multisig::Get_requirement") (deref Œ±0)) Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["env"]
            [ borrow (deref Œ±0) ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 := M.read new_requirement in
        let* Œ±4 :=
          M.call
            (Ty.path "multisig::Env")::["emit_event"]
            [
              borrow Œ±2;
              multisig.Event.RequirementChange
                (Value.StructRecord
                  "multisig::RequirementChange"
                  [ ("new_requirement", Œ±3) ])
            ] in
        M.alloc Œ±4 in
      let* Œ±0 := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      fn confirm_by_caller(
          &mut self,
          confirmer: AccountId,
          transaction: TransactionId,
      ) -> ConfirmationStatus {
          let mut count = self
              .confirmation_count
              .get(&transaction)
              .unwrap_or(0 as u32);
          let key = (transaction, confirmer);
          let new_confirmation = !self.confirmations.contains(&key);
          if new_confirmation {
              count += 1;
              self.confirmations.insert(key, ());
              self.confirmation_count.insert(transaction, count);
          }
          let status = {
              if count >= self.requirement {
                  ConfirmationStatus::Confirmed
              } else {
                  ConfirmationStatus::ConfirmationsNeeded(self.requirement - count)
              }
          };
          if new_confirmation {
              self.env().emit_event(Event::Confirmation(Confirmation {
                  transaction,
                  from: confirmer,
                  status,
              }));
          }
          status
      }
  *)
  Definition confirm_by_caller (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; confirmer; transaction ] =>
      let* self := M.alloc self in
      let* confirmer := M.alloc confirmer in
      let* transaction := M.alloc transaction in
      let* count :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "u32"; Ty.path "u32" ])::["get"]
            [
              borrow
                ((M.var "multisig::Multisig::Get_confirmation_count")
                  (deref Œ±0));
              borrow transaction
            ] in
        let* Œ±2 := M.alloc ((Integer.of_Z 0) : Ty.path "u32") in
        let* Œ±3 := M.read (use Œ±2) in
        let* Œ±4 :=
          M.call
            (Ty.apply
                (Ty.path "core::option::Option")
                [ Ty.path "u32" ])::["unwrap_or"]
            [ Œ±1; Œ±3 ] in
        M.alloc Œ±4 in
      let* key :=
        let* Œ±0 := M.read transaction in
        let* Œ±1 := M.read confirmer in
        M.alloc (Œ±0, Œ±1) in
      let* new_confirmation :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [
                  Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ];
                  Ty.tuple []
                ])::["contains"]
            [
              borrow
                ((M.var "multisig::Multisig::Get_confirmations") (deref Œ±0));
              borrow key
            ] in
        M.alloc ((M.var "UnOp::not") Œ±1) in
      let* _ :=
        let* Œ±0 := M.read (use new_confirmation) in
        if Œ±0 then
          let* _ :=
            let Œ≤ := count in
            let* Œ±0 := M.read Œ≤ in
            let* Œ±1 :=
              (M.var "BinOp::Panic::add")
                Œ±0
                ((Integer.of_Z 1) : Ty.path "u32") in
            (M.var "assign") Œ≤ Œ±1 in
          let* _ :=
            let* Œ±0 := M.read self in
            let* Œ±1 := M.read key in
            let* Œ±2 :=
              M.call
                (Ty.apply
                    (Ty.path "multisig::Mapping")
                    [
                      Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ];
                      Ty.tuple []
                    ])::["insert"]
                [
                  borrow_mut
                    ((M.var "multisig::Multisig::Get_confirmations")
                      (deref Œ±0));
                  Œ±1;
                  tt
                ] in
            M.alloc Œ±2 in
          let* _ :=
            let* Œ±0 := M.read self in
            let* Œ±1 := M.read transaction in
            let* Œ±2 := M.read count in
            let* Œ±3 :=
              M.call
                (Ty.apply
                    (Ty.path "multisig::Mapping")
                    [ Ty.path "u32"; Ty.path "u32" ])::["insert"]
                [
                  borrow_mut
                    ((M.var "multisig::Multisig::Get_confirmation_count")
                      (deref Œ±0));
                  Œ±1;
                  Œ±2
                ] in
            M.alloc Œ±3 in
          M.alloc tt
        else
          M.alloc tt in
      let* status :=
        let* Œ±0 := M.read count in
        let* Œ±1 := M.read self in
        let* Œ±2 :=
          M.read ((M.var "multisig::Multisig::Get_requirement") (deref Œ±1)) in
        let* Œ±3 := M.alloc ((M.var "BinOp::Pure::ge") Œ±0 Œ±2) in
        let* Œ±4 := M.read (use Œ±3) in
        let* Œ±5 :=
          if Œ±4 then
            M.alloc multisig.ConfirmationStatus.Confirmed
          else
            let* Œ±0 := M.read self in
            let* Œ±1 :=
              M.read
                ((M.var "multisig::Multisig::Get_requirement") (deref Œ±0)) in
            let* Œ±2 := M.read count in
            let* Œ±3 := (M.var "BinOp::Panic::sub") Œ±1 Œ±2 in
            M.alloc (multisig.ConfirmationStatus.ConfirmationsNeeded Œ±3) in
        M.copy Œ±5 in
      let* _ :=
        let* Œ±0 := M.read (use new_confirmation) in
        if Œ±0 then
          let* _ :=
            let* Œ±0 := M.read self in
            let* Œ±1 :=
              M.call
                (Ty.path "multisig::Multisig")::["env"]
                [ borrow (deref Œ±0) ] in
            let* Œ±2 := M.alloc Œ±1 in
            let* Œ±3 := M.read transaction in
            let* Œ±4 := M.read confirmer in
            let* Œ±5 := M.read status in
            let* Œ±6 :=
              M.call
                (Ty.path "multisig::Env")::["emit_event"]
                [
                  borrow Œ±2;
                  multisig.Event.Confirmation
                    (Value.StructRecord
                      "multisig::Confirmation"
                      [ ("transaction", Œ±3); ("from", Œ±4); ("status", Œ±5) ])
                ] in
            M.alloc Œ±6 in
          M.alloc tt
        else
          M.alloc tt in
      M.read status
    | _, _ => M.impossible
    end.
  
  (*
      pub fn submit_transaction(
          &mut self,
          transaction: Transaction,
      ) -> (TransactionId, ConfirmationStatus) {
          self.ensure_caller_is_owner();
          let trans_id = self.transaction_list.next_id;
          self.transaction_list.next_id = trans_id
              .checked_add(1 as u32)
              .expect("Transaction ids exhausted.");
          self.transactions.insert(trans_id, transaction);
          self.transaction_list.transactions.push(trans_id);
          self.env().emit_event(Event::Submission(Submission {
              transaction: trans_id,
          }));
          (
              trans_id,
              self.confirm_by_caller(self.env().caller(), trans_id),
          )
      }
  *)
  Definition submit_transaction (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; transaction ] =>
      let* self := M.alloc self in
      let* transaction := M.alloc transaction in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_caller_is_owner"]
            [ borrow (deref Œ±0) ] in
        M.alloc Œ±1 in
      let* trans_id :=
        let* Œ±0 := M.read self in
        M.copy
          ((M.var "multisig::Transactions::Get_next_id")
            ((M.var "multisig::Multisig::Get_transaction_list") (deref Œ±0))) in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read trans_id in
        let* Œ±2 := M.alloc ((Integer.of_Z 1) : Ty.path "u32") in
        let* Œ±3 := M.read (use Œ±2) in
        let* Œ±4 := M.call (Ty.path "u32")::["checked_add"] [ Œ±1; Œ±3 ] in
        let* Œ±5 := M.read (mk_str "Transaction ids exhausted.") in
        let* Œ±6 :=
          M.call
            (Ty.apply
                (Ty.path "core::option::Option")
                [ Ty.path "u32" ])::["expect"]
            [ Œ±4; Œ±5 ] in
        assign
          ((M.var "multisig::Transactions::Get_next_id")
            ((M.var "multisig::Multisig::Get_transaction_list") (deref Œ±0)))
          Œ±6 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read trans_id in
        let* Œ±2 := M.read transaction in
        let* Œ±3 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "u32"; Ty.path "multisig::Transaction" ])::["insert"]
            [
              borrow_mut
                ((M.var "multisig::Multisig::Get_transactions") (deref Œ±0));
              Œ±1;
              Œ±2
            ] in
        M.alloc Œ±3 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read trans_id in
        let* Œ±2 :=
          M.call
            (Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ])::["push"]
            [
              borrow_mut
                ((M.var "multisig::Transactions::Get_transactions")
                  ((M.var "multisig::Multisig::Get_transaction_list")
                    (deref Œ±0)));
              Œ±1
            ] in
        M.alloc Œ±2 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["env"]
            [ borrow (deref Œ±0) ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 := M.read trans_id in
        let* Œ±4 :=
          M.call
            (Ty.path "multisig::Env")::["emit_event"]
            [
              borrow Œ±2;
              multisig.Event.Submission
                (Value.StructRecord
                  "multisig::Submission"
                  [ ("transaction", Œ±3) ])
            ] in
        M.alloc Œ±4 in
      let* Œ±0 := M.read trans_id in
      let* Œ±1 := M.read self in
      let* Œ±2 := M.read self in
      let* Œ±3 :=
        M.call (Ty.path "multisig::Multisig")::["env"] [ borrow (deref Œ±2) ] in
      let* Œ±4 := M.alloc Œ±3 in
      let* Œ±5 := M.call (Ty.path "multisig::Env")::["caller"] [ borrow Œ±4 ] in
      let* Œ±6 := M.read trans_id in
      let* Œ±7 :=
        M.call
          (Ty.path "multisig::Multisig")::["confirm_by_caller"]
          [ Œ±1; Œ±5; Œ±6 ] in
      let* Œ±0 := M.alloc (Œ±0, Œ±7) in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      fn take_transaction(&mut self, trans_id: TransactionId) -> Option<Transaction> {
          let transaction = self.transactions.get(&trans_id);
          if transaction.is_some() {
              self.transactions.remove(trans_id);
              let pos = self
                  .transaction_list
                  .transactions
                  .iter()
                  .position(|t| t == &trans_id)
                  .expect("The transaction exists hence it must also be in the list.");
              self.transaction_list.transactions.swap_remove(pos);
              for owner in self.owners.iter() {
                  self.confirmations.remove((trans_id, *owner));
              }
              self.confirmation_count.remove(trans_id);
          }
          transaction
      }
  *)
  Definition take_transaction (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* transaction :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.apply
                (Ty.path "multisig::Mapping")
                [ Ty.path "u32"; Ty.path "multisig::Transaction" ])::["get"]
            [
              borrow
                ((M.var "multisig::Multisig::Get_transactions") (deref Œ±0));
              borrow trans_id
            ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 :=
          M.call
            (Ty.apply
                (Ty.path "core::option::Option")
                [ Ty.path "multisig::Transaction" ])::["is_some"]
            [ borrow transaction ] in
        let* Œ±1 := M.alloc Œ±0 in
        let* Œ±2 := M.read (use Œ±1) in
        if Œ±2 then
          let* _ :=
            let* Œ±0 := M.read self in
            let* Œ±1 := M.read trans_id in
            let* Œ±2 :=
              M.call
                (Ty.apply
                    (Ty.path "multisig::Mapping")
                    [ Ty.path "u32"; Ty.path "multisig::Transaction"
                    ])::["remove"]
                [
                  borrow
                    ((M.var "multisig::Multisig::Get_transactions") (deref Œ±0));
                  Œ±1
                ] in
            M.alloc Œ±2 in
          let* pos :=
            let* Œ±0 :=
              M.get_method
                "core::iter::traits::iterator::Iterator"
                "position"
                [
                  (* Self *)
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      [ Ty.path "u32" ];
                  (* P *)
                    Ty.function
                      [ Ty.tuple [ Ty.apply (Ty.path "ref") [ Ty.path "u32" ] ]
                      ]
                      (Ty.path "bool")
                ] in
            let* Œ±1 :=
              M.get_method
                "core::ops::deref::Deref"
                "deref"
                [
                  (* Self *)
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ]
                ] in
            let* Œ±2 := M.read self in
            let* Œ±3 :=
              M.call
                Œ±1
                [
                  borrow
                    ((M.var "multisig::Transactions::Get_transactions")
                      ((M.var "multisig::Multisig::Get_transaction_list")
                        (deref Œ±2)))
                ] in
            let* Œ±4 :=
              M.call
                (Ty.apply (Ty.path "slice") [ Ty.path "u32" ])::["iter"]
                [ Œ±3 ] in
            let* Œ±5 := M.alloc Œ±4 in
            let* Œ±6 :=
              M.call
                Œ±0
                [
                  borrow_mut Œ±5;
                  fun (Œ±0 : Ty.apply (Ty.path "ref") [ Ty.path "u32" ]) =>
                    (let* Œ±0 := M.alloc Œ±0 in
                    match_operator
                      Œ±0
                      [
                        fun Œ≥ =>
                          (let* t := M.copy Œ≥ in
                          let* Œ±0 :=
                            M.get_method
                              "core::cmp::PartialEq"
                              "eq"
                              [
                                (* Self *)
                                  Ty.apply (Ty.path "ref") [ Ty.path "u32" ];
                                (* Rhs *)
                                  Ty.apply (Ty.path "ref") [ Ty.path "u32" ]
                              ] in
                          let* Œ±1 := M.alloc (borrow trans_id) in
                          M.call Œ±0 [ borrow t; borrow Œ±1 ]) :
                          Ty.path "bool"
                      ]) :
                    Ty.path "bool"
                ] in
            let* Œ±7 :=
              M.read
                (mk_str
                  "The transaction exists hence it must also be in the list.") in
            let* Œ±8 :=
              M.call
                (Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "usize" ])::["expect"]
                [ Œ±6; Œ±7 ] in
            M.alloc Œ±8 in
          let* _ :=
            let* Œ±0 := M.read self in
            let* Œ±1 := M.read pos in
            let* Œ±2 :=
              M.call
                (Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u32"; Ty.path "alloc::alloc::Global"
                    ])::["swap_remove"]
                [
                  borrow_mut
                    ((M.var "multisig::Transactions::Get_transactions")
                      ((M.var "multisig::Multisig::Get_transaction_list")
                        (deref Œ±0)));
                  Œ±1
                ] in
            M.alloc Œ±2 in
          let* _ :=
            let* Œ±0 :=
              M.get_method
                "core::iter::traits::collect::IntoIterator"
                "into_iter"
                [
                  (* Self *)
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      [ Ty.path "multisig::AccountId" ]
                ] in
            let* Œ±1 :=
              M.get_method
                "core::ops::deref::Deref"
                "deref"
                [
                  (* Self *)
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "multisig::AccountId";
                        Ty.path "alloc::alloc::Global"
                      ]
                ] in
            let* Œ±2 := M.read self in
            let* Œ±3 :=
              M.call
                Œ±1
                [ borrow ((M.var "multisig::Multisig::Get_owners") (deref Œ±2))
                ] in
            let* Œ±4 :=
              M.call
                (Ty.apply
                    (Ty.path "slice")
                    [ Ty.path "multisig::AccountId" ])::["iter"]
                [ Œ±3 ] in
            let* Œ±5 := M.call Œ±0 [ Œ±4 ] in
            let* Œ±6 := M.alloc Œ±5 in
            let* Œ±7 :=
              match_operator
                Œ±6
                [
                  fun Œ≥ =>
                    (let* iter := M.copy Œ≥ in
                    M.loop
                      (let* _ :=
                        let* Œ±0 :=
                          M.get_method
                            "core::iter::traits::iterator::Iterator"
                            "next"
                            [
                              (* Self *)
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  [ Ty.path "multisig::AccountId" ]
                            ] in
                        let* Œ±1 := M.call Œ±0 [ borrow_mut iter ] in
                        let* Œ±2 := M.alloc Œ±1 in
                        match_operator
                          Œ±2
                          [
                            fun Œ≥ =>
                              (let* Œ±0 := M.read Œ≥ in
                              match Œ±0 with
                              | core.option.Option.None =>
                                let* Œ±0 := M.break in
                                let* Œ±1 := M.read Œ±0 in
                                let* Œ±2 := never_to_any Œ±1 in
                                M.alloc Œ±2
                              | _ => M.break_match 
                              end) :
                              Ty.tuple [];
                            fun Œ≥ =>
                              (let* Œ±0 := M.read Œ≥ in
                              match Œ±0 with
                              | core.option.Option.Some _ =>
                                let Œ≥0_0 :=
                                  (M.var "core::option::Option::Get_Some_0")
                                    Œ≥ in
                                let* owner := M.copy Œ≥0_0 in
                                let* _ :=
                                  let* Œ±0 := M.read self in
                                  let* Œ±1 := M.read trans_id in
                                  let* Œ±2 := M.read owner in
                                  let* Œ±3 := M.read (deref Œ±2) in
                                  let* Œ±4 :=
                                    M.call
                                      (Ty.apply
                                          (Ty.path "multisig::Mapping")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "u32";
                                                Ty.path "multisig::AccountId"
                                              ];
                                            Ty.tuple []
                                          ])::["remove"]
                                      [
                                        borrow
                                          ((M.var
                                              "multisig::Multisig::Get_confirmations")
                                            (deref Œ±0));
                                        (Œ±1, Œ±3)
                                      ] in
                                  M.alloc Œ±4 in
                                M.alloc tt
                              | _ => M.break_match 
                              end) :
                              Ty.tuple []
                          ] in
                      M.alloc tt)) :
                    Ty.tuple []
                ] in
            M.pure (use Œ±7) in
          let* _ :=
            let* Œ±0 := M.read self in
            let* Œ±1 := M.read trans_id in
            let* Œ±2 :=
              M.call
                (Ty.apply
                    (Ty.path "multisig::Mapping")
                    [ Ty.path "u32"; Ty.path "u32" ])::["remove"]
                [
                  borrow
                    ((M.var "multisig::Multisig::Get_confirmation_count")
                      (deref Œ±0));
                  Œ±1
                ] in
            M.alloc Œ±2 in
          M.alloc tt
        else
          M.alloc tt in
      M.read transaction
    | _, _ => M.impossible
    end.
  
  (*
      pub fn cancel_transaction(&mut self, trans_id: TransactionId) {
          self.ensure_from_wallet();
          if self.take_transaction(trans_id).is_some() {
              self.env().emit_event(Event::Cancellation(Cancellation {
                  transaction: trans_id,
              }));
          }
      }
  *)
  Definition cancel_transaction (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_from_wallet"]
            [ borrow (deref Œ±0) ] in
        M.alloc Œ±1 in
      let* Œ±0 := M.read self in
      let* Œ±1 := M.read trans_id in
      let* Œ±2 :=
        M.call
          (Ty.path "multisig::Multisig")::["take_transaction"]
          [ Œ±0; Œ±1 ] in
      let* Œ±3 := M.alloc Œ±2 in
      let* Œ±4 :=
        M.call
          (Ty.apply
              (Ty.path "core::option::Option")
              [ Ty.path "multisig::Transaction" ])::["is_some"]
          [ borrow Œ±3 ] in
      let* Œ±5 := M.alloc Œ±4 in
      let* Œ±6 := M.read (use Œ±5) in
      let* Œ±0 :=
        if Œ±6 then
          let* _ :=
            let* Œ±0 := M.read self in
            let* Œ±1 :=
              M.call
                (Ty.path "multisig::Multisig")::["env"]
                [ borrow (deref Œ±0) ] in
            let* Œ±2 := M.alloc Œ±1 in
            let* Œ±3 := M.read trans_id in
            let* Œ±4 :=
              M.call
                (Ty.path "multisig::Env")::["emit_event"]
                [
                  borrow Œ±2;
                  multisig.Event.Cancellation
                    (Value.StructRecord
                      "multisig::Cancellation"
                      [ ("transaction", Œ±3) ])
                ] in
            M.alloc Œ±4 in
          M.alloc tt
        else
          M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      pub fn confirm_transaction(&mut self, trans_id: TransactionId) -> ConfirmationStatus {
          self.ensure_caller_is_owner();
          self.ensure_transaction_exists(trans_id);
          self.confirm_by_caller(self.env().caller(), trans_id)
      }
  *)
  Definition confirm_transaction (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_caller_is_owner"]
            [ borrow (deref Œ±0) ] in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read trans_id in
        let* Œ±2 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_transaction_exists"]
            [ borrow (deref Œ±0); Œ±1 ] in
        M.alloc Œ±2 in
      let* Œ±0 := M.read self in
      let* Œ±1 := M.read self in
      let* Œ±2 :=
        M.call (Ty.path "multisig::Multisig")::["env"] [ borrow (deref Œ±1) ] in
      let* Œ±3 := M.alloc Œ±2 in
      let* Œ±4 := M.call (Ty.path "multisig::Env")::["caller"] [ borrow Œ±3 ] in
      let* Œ±5 := M.read trans_id in
      let* Œ±6 :=
        M.call
          (Ty.path "multisig::Multisig")::["confirm_by_caller"]
          [ Œ±0; Œ±4; Œ±5 ] in
      let* Œ±0 := M.alloc Œ±6 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      pub fn revoke_confirmation(&mut self, trans_id: TransactionId) {
          self.ensure_caller_is_owner();
          let caller = self.env().caller();
          if self.confirmations.contains(&(trans_id, caller)) {
              self.confirmations.remove((trans_id, caller));
              let mut confirmation_count = self
                  .confirmation_count
                  .get(&trans_id)
                  .expect("There is a entry in `self.confirmations`. Hence a count must exit.");
              // Will not underflow as there is at least one confirmation
              confirmation_count -= 1;
              self.confirmation_count.insert(trans_id, confirmation_count);
              self.env().emit_event(Event::Revocation(Revocation {
                  transaction: trans_id,
                  from: caller,
              }));
          }
      }
  *)
  Definition revoke_confirmation (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_caller_is_owner"]
            [ borrow (deref Œ±0) ] in
        M.alloc Œ±1 in
      let* caller :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["env"]
            [ borrow (deref Œ±0) ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 := M.call (Ty.path "multisig::Env")::["caller"] [ borrow Œ±2 ] in
        M.alloc Œ±3 in
      let* Œ±0 := M.read self in
      let* Œ±1 := M.read trans_id in
      let* Œ±2 := M.read caller in
      let* Œ±3 := M.alloc (Œ±1, Œ±2) in
      let* Œ±4 :=
        M.call
          (Ty.apply
              (Ty.path "multisig::Mapping")
              [
                Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ];
                Ty.tuple []
              ])::["contains"]
          [
            borrow ((M.var "multisig::Multisig::Get_confirmations") (deref Œ±0));
            borrow Œ±3
          ] in
      let* Œ±5 := M.alloc Œ±4 in
      let* Œ±6 := M.read (use Œ±5) in
      let* Œ±0 :=
        if Œ±6 then
          let* _ :=
            let* Œ±0 := M.read self in
            let* Œ±1 := M.read trans_id in
            let* Œ±2 := M.read caller in
            let* Œ±3 :=
              M.call
                (Ty.apply
                    (Ty.path "multisig::Mapping")
                    [
                      Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ];
                      Ty.tuple []
                    ])::["remove"]
                [
                  borrow
                    ((M.var "multisig::Multisig::Get_confirmations")
                      (deref Œ±0));
                  (Œ±1, Œ±2)
                ] in
            M.alloc Œ±3 in
          let* confirmation_count :=
            let* Œ±0 := M.read self in
            let* Œ±1 :=
              M.call
                (Ty.apply
                    (Ty.path "multisig::Mapping")
                    [ Ty.path "u32"; Ty.path "u32" ])::["get"]
                [
                  borrow
                    ((M.var "multisig::Multisig::Get_confirmation_count")
                      (deref Œ±0));
                  borrow trans_id
                ] in
            let* Œ±2 :=
              M.read
                (mk_str
                  "There is a entry in `self.confirmations`. Hence a count must exit.") in
            let* Œ±3 :=
              M.call
                (Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "u32" ])::["expect"]
                [ Œ±1; Œ±2 ] in
            M.alloc Œ±3 in
          let* _ :=
            let Œ≤ := confirmation_count in
            let* Œ±0 := M.read Œ≤ in
            let* Œ±1 :=
              (M.var "BinOp::Panic::sub")
                Œ±0
                ((Integer.of_Z 1) : Ty.path "u32") in
            (M.var "assign") Œ≤ Œ±1 in
          let* _ :=
            let* Œ±0 := M.read self in
            let* Œ±1 := M.read trans_id in
            let* Œ±2 := M.read confirmation_count in
            let* Œ±3 :=
              M.call
                (Ty.apply
                    (Ty.path "multisig::Mapping")
                    [ Ty.path "u32"; Ty.path "u32" ])::["insert"]
                [
                  borrow_mut
                    ((M.var "multisig::Multisig::Get_confirmation_count")
                      (deref Œ±0));
                  Œ±1;
                  Œ±2
                ] in
            M.alloc Œ±3 in
          let* _ :=
            let* Œ±0 := M.read self in
            let* Œ±1 :=
              M.call
                (Ty.path "multisig::Multisig")::["env"]
                [ borrow (deref Œ±0) ] in
            let* Œ±2 := M.alloc Œ±1 in
            let* Œ±3 := M.read trans_id in
            let* Œ±4 := M.read caller in
            let* Œ±5 :=
              M.call
                (Ty.path "multisig::Env")::["emit_event"]
                [
                  borrow Œ±2;
                  multisig.Event.Revocation
                    (Value.StructRecord
                      "multisig::Revocation"
                      [ ("transaction", Œ±3); ("from", Œ±4) ])
                ] in
            M.alloc Œ±5 in
          M.alloc tt
        else
          M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  (*
      pub fn invoke_transaction(&mut self, trans_id: TransactionId) -> Result<(), Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          assert!(self.env().transferred_value() == t.transferred_value);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<()>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(_)) => Ok(()),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.map(|_| None),
          }));
          result
      }
  *)
  Definition invoke_transaction (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read trans_id in
        let* Œ±2 :=
          M.call
            (Ty.path "multisig::Multisig")::["ensure_confirmed"]
            [ borrow (deref Œ±0); Œ±1 ] in
        M.alloc Œ±2 in
      let* t :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.read trans_id in
        let* Œ±2 :=
          M.call
            (Ty.path "multisig::Multisig")::["take_transaction"]
            [ Œ±0; Œ±1 ] in
        let* Œ±3 := M.read (M.var "multisig::WRONG_TRANSACTION_ID") in
        let* Œ±4 :=
          M.call
            (Ty.apply
                (Ty.path "core::option::Option")
                [ Ty.path "multisig::Transaction" ])::["expect"]
            [ Œ±2; Œ±3 ] in
        M.alloc Œ±4 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["env"]
            [ borrow (deref Œ±0) ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 :=
          M.call
            (Ty.path "multisig::Env")::["transferred_value"]
            [ borrow Œ±2 ] in
        let* Œ±4 :=
          M.read ((M.var "multisig::Transaction::Get_transferred_value") t) in
        let* Œ±5 :=
          M.alloc ((M.var "UnOp::not") ((M.var "BinOp::Pure::eq") Œ±3 Œ±4)) in
        let* Œ±6 := M.read (use Œ±5) in
        if Œ±6 then
          let* Œ±0 :=
            M.read
              (mk_str
                "assertion failed: self.env().transferred_value() == t.transferred_value") in
          let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
          let* Œ±2 := never_to_any Œ±1 in
          M.alloc Œ±2
        else
          M.alloc tt in
      let* result :=
        let* Œ±0 := M.read (mk_str "not yet implemented") in
        let* Œ±1 := M.call (M.var "core::panicking::panic") [ Œ±0 ] in
        let* Œ±2 := never_to_any Œ±1 in
        M.alloc Œ±2 in
      let* result :=
        let* Œ±0 :=
          match_operator
            result
            [
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | core.result.Result.Ok _ =>
                  let Œ≥0_0 := (M.var "core::result::Result::Get_Ok_0") Œ≥ in
                  let* Œ±0 := M.read Œ≥0_0 in
                  match Œ±0 with
                  | core.result.Result.Ok _ =>
                    let Œ≥1_0 := (M.var "core::result::Result::Get_Ok_0") Œ≥0_0 in
                    M.alloc (core.result.Result.Ok tt)
                  | _ => M.break_match 
                  end
                | _ => M.break_match 
                end) :
                Ty.apply
                  (Ty.path "core::result::Result")
                  [ Ty.tuple []; Ty.path "multisig::Error" ];
              fun Œ≥ =>
                (M.alloc
                  (core.result.Result.Err multisig.Error.TransactionFailed)) :
                Ty.apply
                  (Ty.path "core::result::Result")
                  [ Ty.tuple []; Ty.path "multisig::Error" ]
            ] in
        M.copy Œ±0 in
      let* _ :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            (Ty.path "multisig::Multisig")::["env"]
            [ borrow (deref Œ±0) ] in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 := M.read trans_id in
        let* Œ±4 := M.read result in
        let* Œ±5 :=
          M.call
            (Ty.apply
                (Ty.path "core::result::Result")
                [ Ty.tuple []; Ty.path "multisig::Error" ])::["map"]
            [
              Œ±4;
              fun (Œ±0 : Ty.tuple []) =>
                (let* Œ±0 := M.alloc Œ±0 in
                match_operator
                  Œ±0
                  [
                    fun Œ≥ =>
                      (M.pure core.option.Option.None) :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ]
                  ]) :
                Ty.apply
                  (Ty.path "core::option::Option")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                  ]
            ] in
        let* Œ±6 :=
          M.call
            (Ty.path "multisig::Env")::["emit_event"]
            [
              borrow Œ±2;
              multisig.Event.Execution
                (Value.StructRecord
                  "multisig::Execution"
                  [ ("transaction", Œ±3); ("result", Œ±5) ])
            ] in
        M.alloc Œ±6 in
      M.read result
    | _, _ => M.impossible
    end.
  
  (*
      pub fn eval_transaction(&mut self, trans_id: TransactionId) -> Result<Vec<u8>, Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<Vec<u8>>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(v)) => Ok(v),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.clone().map(Some),
          }));
          result
      }
  *)
  Parameter eval_transaction : (list Ty.t) -> (list Value.t) -> M.
End Impl_multisig_Multisig.
