(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Definition Get__key :=
    Ref.map (fun α => Some α.(_key)) (fun β α => Some (α <| _key := β |>)).
  Definition Get__value :=
    Ref.map (fun α => Some α.(_value)) (fun β α => Some (α <| _value := β |>)).
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_multisig_Mapping_t_K_V.
Section Impl_core_default_Default_for_multisig_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := multisig.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (multisig.Mapping.t K V) :=
    ltac:(M.monadic ((
      {|
        multisig.Mapping._key :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := core.marker.PhantomData.t K)
              (Trait := ℐ)))
          |);
        multisig.Mapping._value :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := core.marker.PhantomData.t V)
              (Trait := ℐ)))
          |);
      |} : multisig.Mapping.t K V
    ) : multisig.Mapping.t K V)).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Mapping_t_K_V.
End Impl_core_default_Default_for_multisig_Mapping_t_K_V.

Module  Impl_multisig_Mapping_t_K_V.
Section Impl_multisig_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := multisig.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref Self) (_key : ref K) : M bool.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := bool.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : bool.t)).
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := core.option.Option.t V)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : core.option.Option.t V)).
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      let _value := M.alloc (| _value |) in
      (never_to_any (B := core.option.Option.t u32.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : core.option.Option.t u32.t)).
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref Self) (_key : K) : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := unit)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref Self)
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := core.option.Option.t u32.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : core.option.Option.t u32.t)).
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon Self "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (self : ref Self) (_key : K) : M (core.option.Option.t V) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _key := M.alloc (| _key |) in
      (never_to_any (B := core.option.Option.t V)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : core.option.Option.t V)).
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_multisig_Mapping_t_K_V.
End Impl_multisig_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_multisig_AccountId_t.
Section Impl_core_default_Default_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M multisig.AccountId.t :=
    ltac:(M.monadic ((
      multisig.AccountId.Build_t
        (M.call (|ltac:(M.get_method (fun ℐ =>
          core.default.Default.default (Self := u128.t) (Trait := ℐ)))
        |))
    ) : multisig.AccountId.t)).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_AccountId_t.
End Impl_core_default_Default_for_multisig_AccountId_t.

Module  Impl_core_fmt_Debug_for_multisig_AccountId_t.
Section Impl_core_fmt_Debug_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let f := M.alloc (| f |) in
      M.call (|(core.fmt.Formatter.t::["debug_tuple_field1_finish"]
        (M.read (| f |))
        (M.read (| mk_str "AccountId" |))
        (pointer_coercion
          "Unsize"
          (borrow
            (M.alloc (|
              borrow (multisig.AccountId.Get_0 (deref (M.read (| self |))))
            |)))))
      |)
    ) : ltac:(core.fmt.Result))).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_multisig_AccountId_t.
End Impl_core_fmt_Debug_for_multisig_AccountId_t.

Module  Impl_core_clone_Clone_for_multisig_AccountId_t.
Section Impl_core_clone_Clone_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M multisig.AccountId.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        ltac:
          (M.monadic_match_operator
            (DeclaredButUndefinedVariable
              (A := core.clone.AssertParamIsClone.t u128.t))
            [
              fun (γ : M.Val (core.clone.AssertParamIsClone.t u128.t)) =>
                (deref (M.read (| self |))) : M.Val multisig.AccountId.t
            ])
      |)
    ) : multisig.AccountId.t)).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_AccountId_t.
End Impl_core_clone_Clone_for_multisig_AccountId_t.

Module  Impl_core_marker_Copy_for_multisig_AccountId_t.
Section Impl_core_marker_Copy_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_AccountId_t.
End Impl_core_marker_Copy_for_multisig_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
Section Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref multisig.AccountId.t)
      : M bool.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let other := M.alloc (| other |) in
      BinOp.Pure.eq
        (M.read (| multisig.AccountId.Get_0 (deref (M.read (| self |))) |))
        (M.read (| multisig.AccountId.Get_0 (deref (M.read (| other |))) |))
    ) : bool.t)).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
End Impl_core_cmp_PartialEq_for_multisig_AccountId_t.

Module  Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
Section Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
End Impl_core_marker_StructuralEq_for_multisig_AccountId_t.

Module  Impl_core_cmp_Eq_for_multisig_AccountId_t.
Section Impl_core_cmp_Eq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        ltac:
          (M.monadic_match_operator
            (DeclaredButUndefinedVariable
              (A := core.cmp.AssertParamIsEq.t u128.t))
            [
              fun (γ : M.Val (core.cmp.AssertParamIsEq.t u128.t)) =>
                (M.alloc (| tt |)) : M.Val unit
            ])
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_multisig_AccountId_t.
End Impl_core_cmp_Eq_for_multisig_AccountId_t.

Module  Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
Section Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  PartialOrd
  *)
  Definition partial_cmp
      (self : ref Self)
      (other : ref multisig.AccountId.t)
      : M (core.option.Option.t core.cmp.Ordering.t) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let other := M.alloc (| other |) in
      M.call (|(ltac:(M.get_method (fun ℐ =>
          core.cmp.PartialOrd.partial_cmp
            (Self := u128.t)
            (Rhs := u128.t)
            (Trait := ℐ)))
        (borrow (multisig.AccountId.Get_0 (deref (M.read (| self |)))))
        (borrow (multisig.AccountId.Get_0 (deref (M.read (| other |))))))
      |)
    ) : core.option.Option.t core.cmp.Ordering.t)).
  
  Global Instance AssociatedFunction_partial_cmp :
    Notations.DoubleColon Self "partial_cmp" := {
    Notations.double_colon := partial_cmp;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialOrd.Required.Trait Self
      (Rhs := core.cmp.PartialOrd.Default.Rhs Self) := {
    core.cmp.PartialOrd.partial_cmp := partial_cmp;
    core.cmp.PartialOrd.lt := Datatypes.None;
    core.cmp.PartialOrd.le := Datatypes.None;
    core.cmp.PartialOrd.gt := Datatypes.None;
    core.cmp.PartialOrd.ge := Datatypes.None;
  }.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.

Module  Impl_core_cmp_Ord_for_multisig_AccountId_t.
Section Impl_core_cmp_Ord_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Ord
  *)
  Definition cmp
      (self : ref Self)
      (other : ref multisig.AccountId.t)
      : M core.cmp.Ordering.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let other := M.alloc (| other |) in
      M.call (|(ltac:(M.get_method (fun ℐ =>
          core.cmp.Ord.cmp (Self := u128.t) (Trait := ℐ)))
        (borrow (multisig.AccountId.Get_0 (deref (M.read (| self |)))))
        (borrow (multisig.AccountId.Get_0 (deref (M.read (| other |))))))
      |)
    ) : core.cmp.Ordering.t)).
  
  Global Instance AssociatedFunction_cmp : Notations.DoubleColon Self "cmp" := {
    Notations.double_colon := cmp;
  }.
  
  Global Instance ℐ : core.cmp.Ord.Required.Trait Self := {
    core.cmp.Ord.cmp := cmp;
    core.cmp.Ord.max := Datatypes.None;
    core.cmp.Ord.min := Datatypes.None;
    core.cmp.Ord.clamp := Datatypes.None;
  }.
End Impl_core_cmp_Ord_for_multisig_AccountId_t.
End Impl_core_cmp_Ord_for_multisig_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : multisig.AccountId.t;
  }.
  
  Definition Get_caller :=
    Ref.map (fun α => Some α.(caller)) (fun β α => Some (α <| caller := β |>)).
End Env.
End Env.

Definition MAX_OWNERS : M.Val u32.t :=
  M.run (ltac:(M.monadic (M.alloc (| (Integer.of_Z 50) : u32.t |)))).

Ltac TransactionId := exact u32.t.

Definition WRONG_TRANSACTION_ID : M.Val (ref str.t) :=
  M.run (ltac:(M.monadic (mk_str
        "The user specified an invalid transaction id. Abort."))).

Module  CallInput.
Section CallInput.
  Record t : Set := {
    x0 : ref (slice u8.t);
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End CallInput.
End CallInput.

Module ConfirmationStatus.
  Inductive t : Set :=
  | Confirmed
  | ConfirmationsNeeded (_ : u32.t).
  
  Definition Get_ConfirmationsNeeded_0 :=
    Ref.map
      (fun α =>
        match α with | ConfirmationsNeeded α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | ConfirmationsNeeded _ => Some (ConfirmationsNeeded β)
        | _ => None
        end).
End ConfirmationStatus.

Module  Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
Section Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
  Definition Self : Set := multisig.ConfirmationStatus.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M multisig.ConfirmationStatus.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        ltac:
          (M.monadic_match_operator
            (DeclaredButUndefinedVariable
              (A := core.clone.AssertParamIsClone.t u32.t))
            [
              fun (γ : M.Val (core.clone.AssertParamIsClone.t u32.t)) =>
                (deref (M.read (| self |))) :
                M.Val multisig.ConfirmationStatus.t
            ])
      |)
    ) : multisig.ConfirmationStatus.t)).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.

Module  Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
Section Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
  Definition Self : Set := multisig.ConfirmationStatus.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.

Module  Transaction.
Section Transaction.
  Record t : Set := {
    callee : multisig.AccountId.t;
    selector : array u8.t;
    input : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A;
    transferred_value : ltac:(multisig.Balance);
    gas_limit : u64.t;
    allow_reentry : bool.t;
  }.
  
  Definition Get_callee :=
    Ref.map (fun α => Some α.(callee)) (fun β α => Some (α <| callee := β |>)).
  Definition Get_selector :=
    Ref.map
      (fun α => Some α.(selector))
      (fun β α => Some (α <| selector := β |>)).
  Definition Get_input :=
    Ref.map (fun α => Some α.(input)) (fun β α => Some (α <| input := β |>)).
  Definition Get_transferred_value :=
    Ref.map
      (fun α => Some α.(transferred_value))
      (fun β α => Some (α <| transferred_value := β |>)).
  Definition Get_gas_limit :=
    Ref.map
      (fun α => Some α.(gas_limit))
      (fun β α => Some (α <| gas_limit := β |>)).
  Definition Get_allow_reentry :=
    Ref.map
      (fun α => Some α.(allow_reentry))
      (fun β α => Some (α <| allow_reentry := β |>)).
End Transaction.
End Transaction.

Module  Impl_core_default_Default_for_multisig_Transaction_t.
Section Impl_core_default_Default_for_multisig_Transaction_t.
  Definition Self : Set := multisig.Transaction.t.
  
  (*
  Default
  *)
  Definition default : M multisig.Transaction.t :=
    ltac:(M.monadic ((
      {|
        multisig.Transaction.callee :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := multisig.AccountId.t)
              (Trait := ℐ)))
          |);
        multisig.Transaction.selector :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default (Self := array u8.t) (Trait := ℐ)))
          |);
        multisig.Transaction.input :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
              (Trait := ℐ)))
          |);
        multisig.Transaction.transferred_value :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default (Self := u128.t) (Trait := ℐ)))
          |);
        multisig.Transaction.gas_limit :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default (Self := u64.t) (Trait := ℐ)))
          |);
        multisig.Transaction.allow_reentry :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default (Self := bool.t) (Trait := ℐ)))
          |);
      |} : multisig.Transaction.t
    ) : multisig.Transaction.t)).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Transaction_t.
End Impl_core_default_Default_for_multisig_Transaction_t.

Module Error.
  Inductive t : Set :=
  | TransactionFailed.
End Error.

Module  Impl_core_clone_Clone_for_multisig_Error_t.
Section Impl_core_clone_Clone_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M multisig.Error.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (| deref (M.read (| self |)) |)
    ) : multisig.Error.t)).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_Error_t.
End Impl_core_clone_Clone_for_multisig_Error_t.

Module  Impl_core_marker_Copy_for_multisig_Error_t.
Section Impl_core_marker_Copy_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_Error_t.
End Impl_core_marker_Copy_for_multisig_Error_t.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
Section Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.

Module  Impl_core_cmp_PartialEq_for_multisig_Error_t.
Section Impl_core_cmp_PartialEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref multisig.Error.t) : M bool.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let other := M.alloc (| other |) in
      true
    ) : bool.t)).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_multisig_Error_t.
End Impl_core_cmp_PartialEq_for_multisig_Error_t.

Module  Impl_core_marker_StructuralEq_for_multisig_Error_t.
Section Impl_core_marker_StructuralEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_multisig_Error_t.
End Impl_core_marker_StructuralEq_for_multisig_Error_t.

Module  Impl_core_cmp_Eq_for_multisig_Error_t.
Section Impl_core_cmp_Eq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      tt
    ) : unit)).
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_multisig_Error_t.
End Impl_core_cmp_Eq_for_multisig_Error_t.

Module  Transactions.
Section Transactions.
  Record t : Set := {
    transactions :
      alloc.vec.Vec.t ltac:(multisig.TransactionId) alloc.vec.Vec.Default.A;
    next_id : ltac:(multisig.TransactionId);
  }.
  
  Definition Get_transactions :=
    Ref.map
      (fun α => Some α.(transactions))
      (fun β α => Some (α <| transactions := β |>)).
  Definition Get_next_id :=
    Ref.map
      (fun α => Some α.(next_id))
      (fun β α => Some (α <| next_id := β |>)).
End Transactions.
End Transactions.

Module  Impl_core_default_Default_for_multisig_Transactions_t.
Section Impl_core_default_Default_for_multisig_Transactions_t.
  Definition Self : Set := multisig.Transactions.t.
  
  (*
  Default
  *)
  Definition default : M multisig.Transactions.t :=
    ltac:(M.monadic ((
      {|
        multisig.Transactions.transactions :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := alloc.vec.Vec.t u32.t alloc.alloc.Global.t)
              (Trait := ℐ)))
          |);
        multisig.Transactions.next_id :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default (Self := u32.t) (Trait := ℐ)))
          |);
      |} : multisig.Transactions.t
    ) : multisig.Transactions.t)).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Transactions_t.
End Impl_core_default_Default_for_multisig_Transactions_t.

Module  Confirmation.
Section Confirmation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    from : multisig.AccountId.t;
    status : multisig.ConfirmationStatus.t;
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
  Definition Get_status :=
    Ref.map (fun α => Some α.(status)) (fun β α => Some (α <| status := β |>)).
End Confirmation.
End Confirmation.

Module  Revocation.
Section Revocation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    from : multisig.AccountId.t;
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
End Revocation.
End Revocation.

Module  Submission.
Section Submission.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
End Submission.
End Submission.

Module  Cancellation.
Section Cancellation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
End Cancellation.
End Cancellation.

Module  Execution.
Section Execution.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    result :
      core.result.Result.t
        (core.option.Option.t (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        multisig.Error.t;
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
  Definition Get_result :=
    Ref.map (fun α => Some α.(result)) (fun β α => Some (α <| result := β |>)).
End Execution.
End Execution.

Module  OwnerAddition.
Section OwnerAddition.
  Record t : Set := {
    owner : multisig.AccountId.t;
  }.
  
  Definition Get_owner :=
    Ref.map (fun α => Some α.(owner)) (fun β α => Some (α <| owner := β |>)).
End OwnerAddition.
End OwnerAddition.

Module  OwnerRemoval.
Section OwnerRemoval.
  Record t : Set := {
    owner : multisig.AccountId.t;
  }.
  
  Definition Get_owner :=
    Ref.map (fun α => Some α.(owner)) (fun β α => Some (α <| owner := β |>)).
End OwnerRemoval.
End OwnerRemoval.

Module  RequirementChange.
Section RequirementChange.
  Record t : Set := {
    new_requirement : u32.t;
  }.
  
  Definition Get_new_requirement :=
    Ref.map
      (fun α => Some α.(new_requirement))
      (fun β α => Some (α <| new_requirement := β |>)).
End RequirementChange.
End RequirementChange.

Module Event.
  Inductive t : Set :=
  | Confirmation (_ : multisig.Confirmation.t)
  | Revocation (_ : multisig.Revocation.t)
  | Submission (_ : multisig.Submission.t)
  | Cancellation (_ : multisig.Cancellation.t)
  | Execution (_ : multisig.Execution.t)
  | OwnerAddition (_ : multisig.OwnerAddition.t)
  | OwnerRemoval (_ : multisig.OwnerRemoval.t)
  | RequirementChange (_ : multisig.RequirementChange.t).
  
  Definition Get_Confirmation_0 :=
    Ref.map
      (fun α => match α with | Confirmation α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Confirmation _ => Some (Confirmation β) | _ => None end).
  
  Definition Get_Revocation_0 :=
    Ref.map
      (fun α => match α with | Revocation α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Revocation _ => Some (Revocation β) | _ => None end).
  
  Definition Get_Submission_0 :=
    Ref.map
      (fun α => match α with | Submission α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Submission _ => Some (Submission β) | _ => None end).
  
  Definition Get_Cancellation_0 :=
    Ref.map
      (fun α => match α with | Cancellation α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Cancellation _ => Some (Cancellation β) | _ => None end).
  
  Definition Get_Execution_0 :=
    Ref.map
      (fun α => match α with | Execution α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Execution _ => Some (Execution β) | _ => None end).
  
  Definition Get_OwnerAddition_0 :=
    Ref.map
      (fun α => match α with | OwnerAddition α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | OwnerAddition _ => Some (OwnerAddition β)
        | _ => None
        end).
  
  Definition Get_OwnerRemoval_0 :=
    Ref.map
      (fun α => match α with | OwnerRemoval α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | OwnerRemoval _ => Some (OwnerRemoval β) | _ => None end).
  
  Definition Get_RequirementChange_0 :=
    Ref.map
      (fun α => match α with | RequirementChange α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | RequirementChange _ => Some (RequirementChange β)
        | _ => None
        end).
End Event.

Module  Impl_multisig_Env_t.
Section Impl_multisig_Env_t.
  Definition Self : Set := multisig.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (self : ref Self) : M multisig.AccountId.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (| multisig.Env.Get_caller (deref (M.read (| self |))) |)
    ) : multisig.AccountId.t)).
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event
      (self : ref Self)
      (_event : multisig.Event.t)
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let _event := M.alloc (| _event |) in
      (never_to_any (B := unit)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_emit_event :
    Notations.DoubleColon Self "emit_event" := {
    Notations.double_colon := emit_event;
  }.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition transferred_value (self : ref Self) : M ltac:(multisig.Balance) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      (never_to_any (B := u128.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : ltac:(multisig.Balance))).
  
  Global Instance AssociatedFunction_transferred_value :
    Notations.DoubleColon Self "transferred_value" := {
    Notations.double_colon := transferred_value;
  }.
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Definition account_id (self : ref Self) : M multisig.AccountId.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      (never_to_any (B := multisig.AccountId.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : multisig.AccountId.t)).
  
  Global Instance AssociatedFunction_account_id :
    Notations.DoubleColon Self "account_id" := {
    Notations.double_colon := account_id;
  }.
End Impl_multisig_Env_t.
End Impl_multisig_Env_t.

Module  Multisig.
Section Multisig.
  Record t : Set := {
    confirmations :
      multisig.Mapping.t
        (ltac:(multisig.TransactionId) * multisig.AccountId.t)
        unit;
    confirmation_count : multisig.Mapping.t ltac:(multisig.TransactionId) u32.t;
    transactions :
      multisig.Mapping.t ltac:(multisig.TransactionId) multisig.Transaction.t;
    transaction_list : multisig.Transactions.t;
    owners : alloc.vec.Vec.t multisig.AccountId.t alloc.vec.Vec.Default.A;
    is_owner : multisig.Mapping.t multisig.AccountId.t unit;
    requirement : u32.t;
  }.
  
  Definition Get_confirmations :=
    Ref.map
      (fun α => Some α.(confirmations))
      (fun β α => Some (α <| confirmations := β |>)).
  Definition Get_confirmation_count :=
    Ref.map
      (fun α => Some α.(confirmation_count))
      (fun β α => Some (α <| confirmation_count := β |>)).
  Definition Get_transactions :=
    Ref.map
      (fun α => Some α.(transactions))
      (fun β α => Some (α <| transactions := β |>)).
  Definition Get_transaction_list :=
    Ref.map
      (fun α => Some α.(transaction_list))
      (fun β α => Some (α <| transaction_list := β |>)).
  Definition Get_owners :=
    Ref.map (fun α => Some α.(owners)) (fun β α => Some (α <| owners := β |>)).
  Definition Get_is_owner :=
    Ref.map
      (fun α => Some α.(is_owner))
      (fun β α => Some (α <| is_owner := β |>)).
  Definition Get_requirement :=
    Ref.map
      (fun α => Some α.(requirement))
      (fun β α => Some (α <| requirement := β |>)).
End Multisig.
End Multisig.

Module  Impl_core_default_Default_for_multisig_Multisig_t.
Section Impl_core_default_Default_for_multisig_Multisig_t.
  Definition Self : Set := multisig.Multisig.t.
  
  (*
  Default
  *)
  Definition default : M multisig.Multisig.t :=
    ltac:(M.monadic ((
      {|
        multisig.Multisig.confirmations :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := multisig.Mapping.t (u32.t * multisig.AccountId.t) unit)
              (Trait := ℐ)))
          |);
        multisig.Multisig.confirmation_count :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := multisig.Mapping.t u32.t u32.t)
              (Trait := ℐ)))
          |);
        multisig.Multisig.transactions :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := multisig.Mapping.t u32.t multisig.Transaction.t)
              (Trait := ℐ)))
          |);
        multisig.Multisig.transaction_list :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := multisig.Transactions.t)
              (Trait := ℐ)))
          |);
        multisig.Multisig.owners :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self :=
                alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
              (Trait := ℐ)))
          |);
        multisig.Multisig.is_owner :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := multisig.Mapping.t multisig.AccountId.t unit)
              (Trait := ℐ)))
          |);
        multisig.Multisig.requirement :=
          M.call (|ltac:(M.get_method (fun ℐ =>
            core.default.Default.default (Self := u32.t) (Trait := ℐ)))
          |);
      |} : multisig.Multisig.t
    ) : multisig.Multisig.t)).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Multisig_t.
End Impl_core_default_Default_for_multisig_Multisig_t.

(*
fn ensure_requirement_is_valid(owners: u32, requirement: u32) {
    assert!(0 < requirement && requirement <= owners && owners <= MAX_OWNERS);
}
*)
Definition ensure_requirement_is_valid
    (owners : u32.t)
    (requirement : u32.t)
    : M unit :=
  ltac:(M.monadic ((
    let owners := M.alloc (| owners |) in
    let requirement := M.alloc (| requirement |) in
    M.read (|
      let _ : M.Val unit :=
        if
          M.read (|
            use
              (M.alloc (|
                UnOp.not
                  (BinOp.Pure.and
                    (BinOp.Pure.and
                      (BinOp.Pure.lt
                        ((Integer.of_Z 0) : u32.t)
                        (M.read (| requirement |)))
                      (BinOp.Pure.le
                        (M.read (| requirement |))
                        (M.read (| owners |))))
                    (BinOp.Pure.le
                      (M.read (| owners |))
                      (M.read (| multisig.MAX_OWNERS |))))
              |))
          |)
        then
          M.alloc (|
            (never_to_any (B := unit)) (|
              M.call (|(core.panicking.panic
                (M.read (|
                  mk_str
                    "assertion failed: 0 < requirement && requirement <= owners && owners <= MAX_OWNERS"
                |)))
              |)
            |)
          |)
        else
          M.alloc (| tt |) in
      M.alloc (| tt |)
    |)
  ) : unit)).

Module  Impl_multisig_Multisig_t.
Section Impl_multisig_Multisig_t.
  Definition Self : Set := multisig.Multisig.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M multisig.Env.t :=
    ltac:(M.monadic ((
      (never_to_any (B := multisig.Env.t)) (|
        M.call (|(core.panicking.panic (M.read (| mk_str "not implemented" |)))
        |)
      |)
    ) : multisig.Env.t)).
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (self : ref Self) : M multisig.Env.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.call (|multisig.Multisig.t::["init_env"] |)
    ) : multisig.Env.t)).
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new(requirement: u32, mut owners: Vec<AccountId>) -> Self {
          let mut contract = Multisig::default();
          owners.sort_unstable();
          owners.dedup();
          ensure_requirement_is_valid(owners.len() as u32, requirement);
  
          for owner in &owners {
              contract.is_owner.insert( *owner, ());
          }
  
          contract.owners = owners;
          contract.transaction_list = Default::default();
          contract.requirement = requirement;
          contract
      }
  *)
  Definition new
      (requirement : u32.t)
      (owners : alloc.vec.Vec.t multisig.AccountId.t alloc.vec.Vec.Default.A)
      : M Self :=
    ltac:(M.monadic ((
      let requirement := M.alloc (| requirement |) in
      let owners := M.alloc (| owners |) in
      M.read (|
        let contract : M.Val multisig.Multisig.t :=
          M.alloc (|
            M.call (|ltac:(M.get_method (fun ℐ =>
              core.default.Default.default
                (Self := multisig.Multisig.t)
                (Trait := ℐ)))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|((slice multisig.AccountId.t)::["sort_unstable"]
              (M.call (|(ltac:(M.get_method (fun ℐ =>
                  core.ops.deref.DerefMut.deref_mut
                    (Self :=
                      alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
                    (Trait := ℐ)))
                (borrow_mut owners))
              |)))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|((alloc.vec.Vec.t
                  multisig.AccountId.t
                  alloc.alloc.Global.t)::["dedup"]
              (borrow_mut owners))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.ensure_requirement_is_valid
              (rust_cast
                (M.call (|((alloc.vec.Vec.t
                      multisig.AccountId.t
                      alloc.alloc.Global.t)::["len"]
                  (borrow owners))
                |)))
              (M.read (| requirement |)))
            |)
          |) in
        let _ : M.Val unit :=
          use
            (ltac:
              (M.monadic_match_operator
                (M.alloc (|
                  M.call (|(ltac:(M.get_method (fun ℐ =>
                      core.iter.traits.collect.IntoIterator.into_iter
                        (Self :=
                          ref
                            (alloc.vec.Vec.t
                              multisig.AccountId.t
                              alloc.alloc.Global.t))
                        (Trait := ℐ)))
                    (borrow owners))
                  |)
                |))
                [
                  fun
                      (γ :
                        M.Val (core.slice.iter.Iter.t multisig.AccountId.t)) =>
                    (let iter := M.copy (| γ |) in
                    M.loop
                      (let _ : M.Val unit :=
                        ltac:
                          (M.monadic_match_operator
                            (M.alloc (|
                              M.call (|(ltac:(M.get_method (fun ℐ =>
                                  core.iter.traits.iterator.Iterator.next
                                    (Self :=
                                      core.slice.iter.Iter.t
                                        multisig.AccountId.t)
                                    (Trait := ℐ)))
                                (borrow_mut iter))
                              |)
                            |))
                            [
                              fun
                                  (γ :
                                    M.Val
                                      (core.option.Option.t
                                        (ref multisig.AccountId.t))) =>
                                match M.read (| γ |) with
                                | core.option.Option.None =>
                                  M.alloc (|
                                    (never_to_any (B := unit)) (|
                                      M.read (| M.break |)
                                    |)
                                  |)
                                | _ => M.break_match(||)
                                end :
                                M.Val unit;
                              fun
                                  (γ :
                                    M.Val
                                      (core.option.Option.t
                                        (ref multisig.AccountId.t))) =>
                                match M.read (| γ |) with
                                | core.option.Option.Some _ =>
                                  let γ0_0 := core.option.Option.Get_Some_0 γ in
                                  let owner := M.copy (| γ0_0 |) in
                                  let _ : M.Val (core.option.Option.t u32.t) :=
                                    M.alloc (|
                                      M.call (|((multisig.Mapping.t
                                            multisig.AccountId.t
                                            unit)::["insert"]
                                        (borrow_mut
                                          (multisig.Multisig.Get_is_owner
                                            contract))
                                        (M.read (| deref (M.read (| owner |))
                                        |))
                                        tt)
                                      |)
                                    |) in
                                  M.alloc (| tt |)
                                | _ => M.break_match(||)
                                end :
                                M.Val unit
                            ]) in
                      M.alloc (| tt |))) :
                    M.Val unit
                ])) in
        let _ : M.Val unit :=
          assign (| multisig.Multisig.Get_owners contract, M.read (| owners |)
          |) in
        let _ : M.Val unit :=
          assign (|
            multisig.Multisig.Get_transaction_list contract,
            M.call (|ltac:(M.get_method (fun ℐ =>
              core.default.Default.default
                (Self := multisig.Transactions.t)
                (Trait := ℐ)))
            |)
          |) in
        let _ : M.Val unit :=
          assign (|
            multisig.Multisig.Get_requirement contract,
            M.read (| requirement |)
          |) in
        contract
      |)
    ) : Self)).
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn ensure_confirmed(&self, trans_id: TransactionId) {
          assert!(
              self.confirmation_count
                  .get(&trans_id)
                  .expect(WRONG_TRANSACTION_ID)
                  >= self.requirement
          );
      }
  *)
  Definition ensure_confirmed
      (self : ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let trans_id := M.alloc (| trans_id |) in
      M.read (|
        let _ : M.Val unit :=
          if
            M.read (|
              use
                (M.alloc (|
                  UnOp.not
                    (BinOp.Pure.ge
                      (M.call (|((core.option.Option.t u32.t)::["expect"]
                        (M.call (|((multisig.Mapping.t u32.t u32.t)::["get"]
                          (borrow
                            (multisig.Multisig.Get_confirmation_count
                              (deref (M.read (| self |)))))
                          (borrow trans_id))
                        |))
                        (M.read (| multisig.WRONG_TRANSACTION_ID |)))
                      |))
                      (M.read (|
                        multisig.Multisig.Get_requirement
                          (deref (M.read (| self |)))
                      |)))
                |))
            |)
          then
            M.alloc (|
              (never_to_any (B := unit)) (|
                M.call (|(core.panicking.panic
                  (M.read (|
                    mk_str
                      "assertion failed: self.confirmation_count.get(&trans_id).expect(WRONG_TRANSACTION_ID) >=
    self.requirement"
                  |)))
                |)
              |)
            |)
          else
            M.alloc (| tt |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_ensure_confirmed :
    Notations.DoubleColon Self "ensure_confirmed" := {
    Notations.double_colon := ensure_confirmed;
  }.
  
  (*
      fn ensure_transaction_exists(&self, trans_id: TransactionId) {
          self.transactions
              .get(&trans_id)
              .expect(WRONG_TRANSACTION_ID);
      }
  *)
  Definition ensure_transaction_exists
      (self : ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let trans_id := M.alloc (| trans_id |) in
      M.read (|
        let _ : M.Val multisig.Transaction.t :=
          M.alloc (|
            M.call (|((core.option.Option.t multisig.Transaction.t)::["expect"]
              (M.call (|((multisig.Mapping.t
                    u32.t
                    multisig.Transaction.t)::["get"]
                (borrow
                  (multisig.Multisig.Get_transactions
                    (deref (M.read (| self |)))))
                (borrow trans_id))
              |))
              (M.read (| multisig.WRONG_TRANSACTION_ID |)))
            |)
          |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_ensure_transaction_exists :
    Notations.DoubleColon Self "ensure_transaction_exists" := {
    Notations.double_colon := ensure_transaction_exists;
  }.
  
  (*
      fn ensure_owner(&self, owner: &AccountId) {
          assert!(self.is_owner.contains(owner));
      }
  *)
  Definition ensure_owner
      (self : ref Self)
      (owner : ref multisig.AccountId.t)
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let owner := M.alloc (| owner |) in
      M.read (|
        let _ : M.Val unit :=
          if
            M.read (|
              use
                (M.alloc (|
                  UnOp.not
                    (M.call (|((multisig.Mapping.t
                          multisig.AccountId.t
                          unit)::["contains"]
                      (borrow
                        (multisig.Multisig.Get_is_owner
                          (deref (M.read (| self |)))))
                      (M.read (| owner |)))
                    |))
                |))
            |)
          then
            M.alloc (|
              (never_to_any (B := unit)) (|
                M.call (|(core.panicking.panic
                  (M.read (|
                    mk_str "assertion failed: self.is_owner.contains(owner)"
                  |)))
                |)
              |)
            |)
          else
            M.alloc (| tt |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_ensure_owner :
    Notations.DoubleColon Self "ensure_owner" := {
    Notations.double_colon := ensure_owner;
  }.
  
  (*
      fn ensure_caller_is_owner(&self) {
          self.ensure_owner(&self.env().caller());
      }
  *)
  Definition ensure_caller_is_owner (self : ref Self) : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_owner"]
              (M.read (| self |))
              (borrow
                (M.alloc (|
                  M.call (|(multisig.Env.t::["caller"]
                    (borrow
                      (M.alloc (|
                        M.call (|(multisig.Multisig.t::["env"]
                          (M.read (| self |)))
                        |)
                      |))))
                  |)
                |))))
            |)
          |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_ensure_caller_is_owner :
    Notations.DoubleColon Self "ensure_caller_is_owner" := {
    Notations.double_colon := ensure_caller_is_owner;
  }.
  
  (*
      fn ensure_from_wallet(&self) {
          assert_eq!(self.env().caller(), self.env().account_id());
      }
  *)
  Definition ensure_from_wallet (self : ref Self) : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        let _ : M.Val unit :=
          ltac:
            (M.monadic_match_operator
              (M.alloc (|
                (borrow
                    (M.alloc (|
                      M.call (|(multisig.Env.t::["caller"]
                        (borrow
                          (M.alloc (|
                            M.call (|(multisig.Multisig.t::["env"]
                              (M.read (| self |)))
                            |)
                          |))))
                      |)
                    |)),
                  borrow
                    (M.alloc (|
                      M.call (|(multisig.Env.t::["account_id"]
                        (borrow
                          (M.alloc (|
                            M.call (|(multisig.Multisig.t::["env"]
                              (M.read (| self |)))
                            |)
                          |))))
                      |)
                    |)))
              |))
              [
                fun
                    (γ :
                      M.Val
                        ((ref multisig.AccountId.t)
                        *
                        (ref multisig.AccountId.t))) =>
                  match M.read (| γ |) with
                  | (_, _) =>
                    let γ0_0 := Tuple.Access.left γ in
                    let γ0_1 := Tuple.Access.right γ in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    if
                      M.read (|
                        use
                          (M.alloc (|
                            UnOp.not
                              (M.call (|(ltac:(M.get_method (fun ℐ =>
                                  core.cmp.PartialEq.eq
                                    (Self := multisig.AccountId.t)
                                    (Rhs := multisig.AccountId.t)
                                    (Trait := ℐ)))
                                (M.read (| left_val |))
                                (M.read (| right_val |)))
                              |))
                          |))
                      |)
                    then
                      M.alloc (|
                        (never_to_any (B := unit)) (|
                          M.read (|
                            let kind : M.Val core.panicking.AssertKind.t :=
                              M.alloc (| core.panicking.AssertKind.Eq |) in
                            M.alloc (|
                              M.call (|(core.panicking.assert_failed
                                (M.read (| kind |))
                                (M.read (| left_val |))
                                (M.read (| right_val |))
                                core.option.Option.None)
                              |)
                            |)
                          |)
                        |)
                      |)
                    else
                      M.alloc (| tt |)
                  end :
                  M.Val unit
              ]) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_ensure_from_wallet :
    Notations.DoubleColon Self "ensure_from_wallet" := {
    Notations.double_colon := ensure_from_wallet;
  }.
  
  (*
      fn ensure_no_owner(&self, owner: &AccountId) {
          assert!(!self.is_owner.contains(owner));
      }
  *)
  Definition ensure_no_owner
      (self : ref Self)
      (owner : ref multisig.AccountId.t)
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let owner := M.alloc (| owner |) in
      M.read (|
        let _ : M.Val unit :=
          if
            M.read (|
              use
                (M.alloc (|
                  UnOp.not
                    (UnOp.not
                      (M.call (|((multisig.Mapping.t
                            multisig.AccountId.t
                            unit)::["contains"]
                        (borrow
                          (multisig.Multisig.Get_is_owner
                            (deref (M.read (| self |)))))
                        (M.read (| owner |)))
                      |)))
                |))
            |)
          then
            M.alloc (|
              (never_to_any (B := unit)) (|
                M.call (|(core.panicking.panic
                  (M.read (|
                    mk_str "assertion failed: !self.is_owner.contains(owner)"
                  |)))
                |)
              |)
            |)
          else
            M.alloc (| tt |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_ensure_no_owner :
    Notations.DoubleColon Self "ensure_no_owner" := {
    Notations.double_colon := ensure_no_owner;
  }.
  
  (*
      pub fn add_owner(&mut self, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_no_owner(&new_owner);
          ensure_requirement_is_valid(self.owners.len() as u32 + 1, self.requirement);
          self.is_owner.insert(new_owner, ());
          self.owners.push(new_owner);
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition add_owner
      (self : mut_ref Self)
      (new_owner : multisig.AccountId.t)
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let new_owner := M.alloc (| new_owner |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_from_wallet"]
              (borrow (deref (M.read (| self |)))))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_no_owner"]
              (borrow (deref (M.read (| self |))))
              (borrow new_owner))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.ensure_requirement_is_valid
              (BinOp.Panic.add (|
                rust_cast
                  (M.call (|((alloc.vec.Vec.t
                        multisig.AccountId.t
                        alloc.alloc.Global.t)::["len"]
                    (borrow
                      (multisig.Multisig.Get_owners
                        (deref (M.read (| self |))))))
                  |)),
                (Integer.of_Z 1) : u32.t
              |))
              (M.read (|
                multisig.Multisig.Get_requirement (deref (M.read (| self |)))
              |)))
            |)
          |) in
        let _ : M.Val (core.option.Option.t u32.t) :=
          M.alloc (|
            M.call (|((multisig.Mapping.t multisig.AccountId.t unit)::["insert"]
              (borrow_mut
                (multisig.Multisig.Get_is_owner (deref (M.read (| self |)))))
              (M.read (| new_owner |))
              tt)
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|((alloc.vec.Vec.t
                  multisig.AccountId.t
                  alloc.alloc.Global.t)::["push"]
              (borrow_mut
                (multisig.Multisig.Get_owners (deref (M.read (| self |)))))
              (M.read (| new_owner |)))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Env.t::["emit_event"]
              (borrow
                (M.alloc (|
                  M.call (|(multisig.Multisig.t::["env"]
                    (borrow (deref (M.read (| self |)))))
                  |)
                |)))
              (multisig.Event.OwnerAddition
                ({| multisig.OwnerAddition.owner := M.read (| new_owner |);
                |} : multisig.OwnerAddition.t)))
            |)
          |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_add_owner :
    Notations.DoubleColon Self "add_owner" := {
    Notations.double_colon := add_owner;
  }.
  
  (*
      fn owner_index(&self, owner: &AccountId) -> u32 {
          self.owners.iter().position(|x| *x == *owner).expect(
              "This is only called after it was already verified that the id is
                 actually an owner.",
          ) as u32
      }
  *)
  Definition owner_index
      (self : ref Self)
      (owner : ref multisig.AccountId.t)
      : M u32.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let owner := M.alloc (| owner |) in
      rust_cast
        (M.call (|((core.option.Option.t usize.t)::["expect"]
          (M.call (|(ltac:(M.get_method (fun ℐ =>
              core.iter.traits.iterator.Iterator.position
                (Self := core.slice.iter.Iter.t multisig.AccountId.t)
                (P := (ref multisig.AccountId.t) -> bool.t)
                (Trait := ℐ)))
            (borrow_mut
              (M.alloc (|
                M.call (|((slice multisig.AccountId.t)::["iter"]
                  (M.call (|(ltac:(M.get_method (fun ℐ =>
                      core.ops.deref.Deref.deref
                        (Self :=
                          alloc.vec.Vec.t
                            multisig.AccountId.t
                            alloc.alloc.Global.t)
                        (Trait := ℐ)))
                    (borrow
                      (multisig.Multisig.Get_owners
                        (deref (M.read (| self |))))))
                  |)))
                |)
              |)))
            (fun (α0 : ref multisig.AccountId.t) =>
              (ltac:
                (M.monadic_match_operator
                  (M.alloc (| α0 |))
                  [
                    fun γ =>
                      (let x := M.copy (| γ |) in
                      M.call (|(ltac:(M.get_method (fun ℐ =>
                          core.cmp.PartialEq.eq
                            (Self := multisig.AccountId.t)
                            (Rhs := multisig.AccountId.t)
                            (Trait := ℐ)))
                        (M.read (| x |))
                        (M.read (| owner |)))
                      |)) :
                      bool.t
                  ])) :
              bool.t))
          |))
          (M.read (|
            mk_str
              "This is only called after it was already verified that the id is
               actually an owner."
          |)))
        |))
    ) : u32.t)).
  
  Global Instance AssociatedFunction_owner_index :
    Notations.DoubleColon Self "owner_index" := {
    Notations.double_colon := owner_index;
  }.
  
  (*
      fn clean_owner_confirmations(&mut self, owner: &AccountId) {
          for trans_id in &self.transaction_list.transactions {
              let key = ( *trans_id, *owner);
              if self.confirmations.contains(&key) {
                  self.confirmations.remove(key);
                  let mut count = self.confirmation_count.get(trans_id).unwrap_or(0 as u32);
                  count -= 1;
                  self.confirmation_count.insert( *trans_id, count);
              }
          }
      }
  *)
  Definition clean_owner_confirmations
      (self : mut_ref Self)
      (owner : ref multisig.AccountId.t)
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let owner := M.alloc (| owner |) in
      M.read (|
        use
          (ltac:
            (M.monadic_match_operator
              (M.alloc (|
                M.call (|(ltac:(M.get_method (fun ℐ =>
                    core.iter.traits.collect.IntoIterator.into_iter
                      (Self := ref (alloc.vec.Vec.t u32.t alloc.alloc.Global.t))
                      (Trait := ℐ)))
                  (borrow
                    (multisig.Transactions.Get_transactions
                      (multisig.Multisig.Get_transaction_list
                        (deref (M.read (| self |)))))))
                |)
              |))
              [
                fun (γ : M.Val (core.slice.iter.Iter.t u32.t)) =>
                  (let iter := M.copy (| γ |) in
                  M.loop
                    (let _ : M.Val unit :=
                      ltac:
                        (M.monadic_match_operator
                          (M.alloc (|
                            M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.iter.traits.iterator.Iterator.next
                                  (Self := core.slice.iter.Iter.t u32.t)
                                  (Trait := ℐ)))
                              (borrow_mut iter))
                            |)
                          |))
                          [
                            fun
                                (γ :
                                  M.Val (core.option.Option.t (ref u32.t))) =>
                              match M.read (| γ |) with
                              | core.option.Option.None =>
                                M.alloc (|
                                  (never_to_any (B := unit)) (|
                                    M.read (| M.break |)
                                  |)
                                |)
                              | _ => M.break_match(||)
                              end :
                              M.Val unit;
                            fun
                                (γ :
                                  M.Val (core.option.Option.t (ref u32.t))) =>
                              match M.read (| γ |) with
                              | core.option.Option.Some _ =>
                                let γ0_0 := core.option.Option.Get_Some_0 γ in
                                let trans_id := M.copy (| γ0_0 |) in
                                let key :
                                    M.Val (u32.t * multisig.AccountId.t) :=
                                  M.alloc (|
                                    (M.read (| deref (M.read (| trans_id |)) |),
                                      M.read (| deref (M.read (| owner |)) |))
                                  |) in
                                if
                                  M.read (|
                                    use
                                      (M.alloc (|
                                        M.call (|((multisig.Mapping.t
                                              (u32.t * multisig.AccountId.t)
                                              unit)::["contains"]
                                          (borrow
                                            (multisig.Multisig.Get_confirmations
                                              (deref (M.read (| self |)))))
                                          (borrow key))
                                        |)
                                      |))
                                  |)
                                then
                                  let _ : M.Val unit :=
                                    M.alloc (|
                                      M.call (|((multisig.Mapping.t
                                            (u32.t * multisig.AccountId.t)
                                            unit)::["remove"]
                                        (borrow
                                          (multisig.Multisig.Get_confirmations
                                            (deref (M.read (| self |)))))
                                        (M.read (| key |)))
                                      |)
                                    |) in
                                  let count : M.Val u32.t :=
                                    M.alloc (|
                                      M.call (|((core.option.Option.t
                                            u32.t)::["unwrap_or"]
                                        (M.call (|((multisig.Mapping.t
                                              u32.t
                                              u32.t)::["get"]
                                          (borrow
                                            (multisig.Multisig.Get_confirmation_count
                                              (deref (M.read (| self |)))))
                                          (M.read (| trans_id |)))
                                        |))
                                        (M.read (|
                                          use
                                            (M.alloc (| (Integer.of_Z 0) : u32.t
                                            |))
                                        |)))
                                      |)
                                    |) in
                                  let _ : M.Val unit :=
                                    let β : M.Val u32.t := count in
                                    assign (|
                                      β,
                                      BinOp.Panic.sub (|
                                        M.read (| β |),
                                        (Integer.of_Z 1) : u32.t
                                      |)
                                    |) in
                                  let _ : M.Val (core.option.Option.t u32.t) :=
                                    M.alloc (|
                                      M.call (|((multisig.Mapping.t
                                            u32.t
                                            u32.t)::["insert"]
                                        (borrow_mut
                                          (multisig.Multisig.Get_confirmation_count
                                            (deref (M.read (| self |)))))
                                        (M.read (| deref (M.read (| trans_id |))
                                        |))
                                        (M.read (| count |)))
                                      |)
                                    |) in
                                  M.alloc (| tt |)
                                else
                                  M.alloc (| tt |)
                              | _ => M.break_match(||)
                              end :
                              M.Val unit
                          ]) in
                    M.alloc (| tt |))) :
                  M.Val unit
              ]))
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_clean_owner_confirmations :
    Notations.DoubleColon Self "clean_owner_confirmations" := {
    Notations.double_colon := clean_owner_confirmations;
  }.
  
  (*
      pub fn remove_owner(&mut self, owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&owner);
          let len = self.owners.len() as u32 - 1;
          let requirement = u32::min(len, self.requirement);
          ensure_requirement_is_valid(len, requirement);
          let owner_index = self.owner_index(&owner) as usize;
          self.owners.swap_remove(owner_index);
          self.is_owner.remove(owner);
          self.requirement = requirement;
          self.clean_owner_confirmations(&owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner }));
      }
  *)
  Definition remove_owner
      (self : mut_ref Self)
      (owner : multisig.AccountId.t)
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let owner := M.alloc (| owner |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_from_wallet"]
              (borrow (deref (M.read (| self |)))))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_owner"]
              (borrow (deref (M.read (| self |))))
              (borrow owner))
            |)
          |) in
        let len : M.Val u32.t :=
          M.alloc (|
            BinOp.Panic.sub (|
              rust_cast
                (M.call (|((alloc.vec.Vec.t
                      multisig.AccountId.t
                      alloc.alloc.Global.t)::["len"]
                  (borrow
                    (multisig.Multisig.Get_owners (deref (M.read (| self |))))))
                |)),
              (Integer.of_Z 1) : u32.t
            |)
          |) in
        let requirement : M.Val u32.t :=
          M.alloc (|
            M.call (|(ltac:(M.get_method (fun ℐ =>
                core.cmp.Ord.min (Self := u32.t) (Trait := ℐ)))
              (M.read (| len |))
              (M.read (|
                multisig.Multisig.Get_requirement (deref (M.read (| self |)))
              |)))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.ensure_requirement_is_valid
              (M.read (| len |))
              (M.read (| requirement |)))
            |)
          |) in
        let owner_index : M.Val usize.t :=
          M.alloc (|
            rust_cast
              (M.call (|(multisig.Multisig.t::["owner_index"]
                (borrow (deref (M.read (| self |))))
                (borrow owner))
              |))
          |) in
        let _ : M.Val multisig.AccountId.t :=
          M.alloc (|
            M.call (|((alloc.vec.Vec.t
                  multisig.AccountId.t
                  alloc.alloc.Global.t)::["swap_remove"]
              (borrow_mut
                (multisig.Multisig.Get_owners (deref (M.read (| self |)))))
              (M.read (| owner_index |)))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|((multisig.Mapping.t multisig.AccountId.t unit)::["remove"]
              (borrow
                (multisig.Multisig.Get_is_owner (deref (M.read (| self |)))))
              (M.read (| owner |)))
            |)
          |) in
        let _ : M.Val unit :=
          assign (|
            multisig.Multisig.Get_requirement (deref (M.read (| self |))),
            M.read (| requirement |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["clean_owner_confirmations"]
              (M.read (| self |))
              (borrow owner))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Env.t::["emit_event"]
              (borrow
                (M.alloc (|
                  M.call (|(multisig.Multisig.t::["env"]
                    (borrow (deref (M.read (| self |)))))
                  |)
                |)))
              (multisig.Event.OwnerRemoval
                ({| multisig.OwnerRemoval.owner := M.read (| owner |);
                |} : multisig.OwnerRemoval.t)))
            |)
          |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_remove_owner :
    Notations.DoubleColon Self "remove_owner" := {
    Notations.double_colon := remove_owner;
  }.
  
  (*
      pub fn replace_owner(&mut self, old_owner: AccountId, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&old_owner);
          self.ensure_no_owner(&new_owner);
          let owner_index = self.owner_index(&old_owner);
          self.owners[owner_index as usize] = new_owner;
          self.is_owner.remove(old_owner);
          self.is_owner.insert(new_owner, ());
          self.clean_owner_confirmations(&old_owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner: old_owner }));
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition replace_owner
      (self : mut_ref Self)
      (old_owner : multisig.AccountId.t)
      (new_owner : multisig.AccountId.t)
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let old_owner := M.alloc (| old_owner |) in
      let new_owner := M.alloc (| new_owner |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_from_wallet"]
              (borrow (deref (M.read (| self |)))))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_owner"]
              (borrow (deref (M.read (| self |))))
              (borrow old_owner))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_no_owner"]
              (borrow (deref (M.read (| self |))))
              (borrow new_owner))
            |)
          |) in
        let owner_index : M.Val u32.t :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["owner_index"]
              (borrow (deref (M.read (| self |))))
              (borrow old_owner))
            |)
          |) in
        let _ : M.Val unit :=
          assign (|
            deref
              (M.call (|(ltac:(M.get_method (fun ℐ =>
                  core.ops.index.IndexMut.index_mut
                    (Self :=
                      alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
                    (Idx := usize.t)
                    (Trait := ℐ)))
                (borrow_mut
                  (multisig.Multisig.Get_owners (deref (M.read (| self |)))))
                (rust_cast (M.read (| owner_index |))))
              |)),
            M.read (| new_owner |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|((multisig.Mapping.t multisig.AccountId.t unit)::["remove"]
              (borrow
                (multisig.Multisig.Get_is_owner (deref (M.read (| self |)))))
              (M.read (| old_owner |)))
            |)
          |) in
        let _ : M.Val (core.option.Option.t u32.t) :=
          M.alloc (|
            M.call (|((multisig.Mapping.t multisig.AccountId.t unit)::["insert"]
              (borrow_mut
                (multisig.Multisig.Get_is_owner (deref (M.read (| self |)))))
              (M.read (| new_owner |))
              tt)
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["clean_owner_confirmations"]
              (M.read (| self |))
              (borrow old_owner))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Env.t::["emit_event"]
              (borrow
                (M.alloc (|
                  M.call (|(multisig.Multisig.t::["env"]
                    (borrow (deref (M.read (| self |)))))
                  |)
                |)))
              (multisig.Event.OwnerRemoval
                ({| multisig.OwnerRemoval.owner := M.read (| old_owner |);
                |} : multisig.OwnerRemoval.t)))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Env.t::["emit_event"]
              (borrow
                (M.alloc (|
                  M.call (|(multisig.Multisig.t::["env"]
                    (borrow (deref (M.read (| self |)))))
                  |)
                |)))
              (multisig.Event.OwnerAddition
                ({| multisig.OwnerAddition.owner := M.read (| new_owner |);
                |} : multisig.OwnerAddition.t)))
            |)
          |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_replace_owner :
    Notations.DoubleColon Self "replace_owner" := {
    Notations.double_colon := replace_owner;
  }.
  
  (*
      pub fn change_requirement(&mut self, new_requirement: u32) {
          self.ensure_from_wallet();
          ensure_requirement_is_valid(self.owners.len() as u32, new_requirement);
          self.requirement = new_requirement;
          self.env()
              .emit_event(Event::RequirementChange(RequirementChange {
                  new_requirement,
              }));
      }
  *)
  Definition change_requirement
      (self : mut_ref Self)
      (new_requirement : u32.t)
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let new_requirement := M.alloc (| new_requirement |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_from_wallet"]
              (borrow (deref (M.read (| self |)))))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.ensure_requirement_is_valid
              (rust_cast
                (M.call (|((alloc.vec.Vec.t
                      multisig.AccountId.t
                      alloc.alloc.Global.t)::["len"]
                  (borrow
                    (multisig.Multisig.Get_owners (deref (M.read (| self |))))))
                |)))
              (M.read (| new_requirement |)))
            |)
          |) in
        let _ : M.Val unit :=
          assign (|
            multisig.Multisig.Get_requirement (deref (M.read (| self |))),
            M.read (| new_requirement |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Env.t::["emit_event"]
              (borrow
                (M.alloc (|
                  M.call (|(multisig.Multisig.t::["env"]
                    (borrow (deref (M.read (| self |)))))
                  |)
                |)))
              (multisig.Event.RequirementChange
                ({|
                  multisig.RequirementChange.new_requirement :=
                    M.read (| new_requirement |);
                |} : multisig.RequirementChange.t)))
            |)
          |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_change_requirement :
    Notations.DoubleColon Self "change_requirement" := {
    Notations.double_colon := change_requirement;
  }.
  
  (*
      fn confirm_by_caller(
          &mut self,
          confirmer: AccountId,
          transaction: TransactionId,
      ) -> ConfirmationStatus {
          let mut count = self
              .confirmation_count
              .get(&transaction)
              .unwrap_or(0 as u32);
          let key = (transaction, confirmer);
          let new_confirmation = !self.confirmations.contains(&key);
          if new_confirmation {
              count += 1;
              self.confirmations.insert(key, ());
              self.confirmation_count.insert(transaction, count);
          }
          let status = {
              if count >= self.requirement {
                  ConfirmationStatus::Confirmed
              } else {
                  ConfirmationStatus::ConfirmationsNeeded(self.requirement - count)
              }
          };
          if new_confirmation {
              self.env().emit_event(Event::Confirmation(Confirmation {
                  transaction,
                  from: confirmer,
                  status,
              }));
          }
          status
      }
  *)
  Definition confirm_by_caller
      (self : mut_ref Self)
      (confirmer : multisig.AccountId.t)
      (transaction : ltac:(multisig.TransactionId))
      : M multisig.ConfirmationStatus.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let confirmer := M.alloc (| confirmer |) in
      let transaction := M.alloc (| transaction |) in
      M.read (|
        let count : M.Val u32.t :=
          M.alloc (|
            M.call (|((core.option.Option.t u32.t)::["unwrap_or"]
              (M.call (|((multisig.Mapping.t u32.t u32.t)::["get"]
                (borrow
                  (multisig.Multisig.Get_confirmation_count
                    (deref (M.read (| self |)))))
                (borrow transaction))
              |))
              (M.read (| use (M.alloc (| (Integer.of_Z 0) : u32.t |)) |)))
            |)
          |) in
        let key : M.Val (u32.t * multisig.AccountId.t) :=
          M.alloc (| (M.read (| transaction |), M.read (| confirmer |)) |) in
        let new_confirmation : M.Val bool.t :=
          M.alloc (|
            UnOp.not
              (M.call (|((multisig.Mapping.t
                    (u32.t * multisig.AccountId.t)
                    unit)::["contains"]
                (borrow
                  (multisig.Multisig.Get_confirmations
                    (deref (M.read (| self |)))))
                (borrow key))
              |))
          |) in
        let _ : M.Val unit :=
          if M.read (| use new_confirmation |) then
            let _ : M.Val unit :=
              let β : M.Val u32.t := count in
              assign (|
                β,
                BinOp.Panic.add (| M.read (| β |), (Integer.of_Z 1) : u32.t |)
              |) in
            let _ : M.Val (core.option.Option.t u32.t) :=
              M.alloc (|
                M.call (|((multisig.Mapping.t
                      (u32.t * multisig.AccountId.t)
                      unit)::["insert"]
                  (borrow_mut
                    (multisig.Multisig.Get_confirmations
                      (deref (M.read (| self |)))))
                  (M.read (| key |))
                  tt)
                |)
              |) in
            let _ : M.Val (core.option.Option.t u32.t) :=
              M.alloc (|
                M.call (|((multisig.Mapping.t u32.t u32.t)::["insert"]
                  (borrow_mut
                    (multisig.Multisig.Get_confirmation_count
                      (deref (M.read (| self |)))))
                  (M.read (| transaction |))
                  (M.read (| count |)))
                |)
              |) in
            M.alloc (| tt |)
          else
            M.alloc (| tt |) in
        let status : M.Val multisig.ConfirmationStatus.t :=
          M.copy (|
            if
              M.read (|
                use
                  (M.alloc (|
                    BinOp.Pure.ge
                      (M.read (| count |))
                      (M.read (|
                        multisig.Multisig.Get_requirement
                          (deref (M.read (| self |)))
                      |))
                  |))
              |)
            then
              M.alloc (| multisig.ConfirmationStatus.Confirmed |)
            else
              M.alloc (|
                multisig.ConfirmationStatus.ConfirmationsNeeded
                  (BinOp.Panic.sub (|
                    M.read (|
                      multisig.Multisig.Get_requirement
                        (deref (M.read (| self |)))
                    |),
                    M.read (| count |)
                  |))
              |)
          |) in
        let _ : M.Val unit :=
          if M.read (| use new_confirmation |) then
            let _ : M.Val unit :=
              M.alloc (|
                M.call (|(multisig.Env.t::["emit_event"]
                  (borrow
                    (M.alloc (|
                      M.call (|(multisig.Multisig.t::["env"]
                        (borrow (deref (M.read (| self |)))))
                      |)
                    |)))
                  (multisig.Event.Confirmation
                    ({|
                      multisig.Confirmation.transaction :=
                        M.read (| transaction |);
                      multisig.Confirmation.from := M.read (| confirmer |);
                      multisig.Confirmation.status := M.read (| status |);
                    |} : multisig.Confirmation.t)))
                |)
              |) in
            M.alloc (| tt |)
          else
            M.alloc (| tt |) in
        status
      |)
    ) : multisig.ConfirmationStatus.t)).
  
  Global Instance AssociatedFunction_confirm_by_caller :
    Notations.DoubleColon Self "confirm_by_caller" := {
    Notations.double_colon := confirm_by_caller;
  }.
  
  (*
      pub fn submit_transaction(
          &mut self,
          transaction: Transaction,
      ) -> (TransactionId, ConfirmationStatus) {
          self.ensure_caller_is_owner();
          let trans_id = self.transaction_list.next_id;
          self.transaction_list.next_id = trans_id
              .checked_add(1 as u32)
              .expect("Transaction ids exhausted.");
          self.transactions.insert(trans_id, transaction);
          self.transaction_list.transactions.push(trans_id);
          self.env().emit_event(Event::Submission(Submission {
              transaction: trans_id,
          }));
          (
              trans_id,
              self.confirm_by_caller(self.env().caller(), trans_id),
          )
      }
  *)
  Definition submit_transaction
      (self : mut_ref Self)
      (transaction : multisig.Transaction.t)
      : M (ltac:(multisig.TransactionId) * multisig.ConfirmationStatus.t) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let transaction := M.alloc (| transaction |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_caller_is_owner"]
              (borrow (deref (M.read (| self |)))))
            |)
          |) in
        let trans_id : M.Val u32.t :=
          M.copy (|
            multisig.Transactions.Get_next_id
              (multisig.Multisig.Get_transaction_list
                (deref (M.read (| self |))))
          |) in
        let _ : M.Val unit :=
          assign (|
            multisig.Transactions.Get_next_id
              (multisig.Multisig.Get_transaction_list
                (deref (M.read (| self |)))),
            M.call (|((core.option.Option.t u32.t)::["expect"]
              (M.call (|(u32.t::["checked_add"]
                (M.read (| trans_id |))
                (M.read (| use (M.alloc (| (Integer.of_Z 1) : u32.t |)) |)))
              |))
              (M.read (| mk_str "Transaction ids exhausted." |)))
            |)
          |) in
        let _ : M.Val (core.option.Option.t u32.t) :=
          M.alloc (|
            M.call (|((multisig.Mapping.t
                  u32.t
                  multisig.Transaction.t)::["insert"]
              (borrow_mut
                (multisig.Multisig.Get_transactions
                  (deref (M.read (| self |)))))
              (M.read (| trans_id |))
              (M.read (| transaction |)))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|((alloc.vec.Vec.t u32.t alloc.alloc.Global.t)::["push"]
              (borrow_mut
                (multisig.Transactions.Get_transactions
                  (multisig.Multisig.Get_transaction_list
                    (deref (M.read (| self |))))))
              (M.read (| trans_id |)))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Env.t::["emit_event"]
              (borrow
                (M.alloc (|
                  M.call (|(multisig.Multisig.t::["env"]
                    (borrow (deref (M.read (| self |)))))
                  |)
                |)))
              (multisig.Event.Submission
                ({| multisig.Submission.transaction := M.read (| trans_id |);
                |} : multisig.Submission.t)))
            |)
          |) in
        M.alloc (|
          (M.read (| trans_id |),
            M.call (|(multisig.Multisig.t::["confirm_by_caller"]
              (M.read (| self |))
              (M.call (|(multisig.Env.t::["caller"]
                (borrow
                  (M.alloc (|
                    M.call (|(multisig.Multisig.t::["env"]
                      (borrow (deref (M.read (| self |)))))
                    |)
                  |))))
              |))
              (M.read (| trans_id |)))
            |))
        |)
      |)
    ) : ltac:(multisig.TransactionId) * multisig.ConfirmationStatus.t)).
  
  Global Instance AssociatedFunction_submit_transaction :
    Notations.DoubleColon Self "submit_transaction" := {
    Notations.double_colon := submit_transaction;
  }.
  
  (*
      fn take_transaction(&mut self, trans_id: TransactionId) -> Option<Transaction> {
          let transaction = self.transactions.get(&trans_id);
          if transaction.is_some() {
              self.transactions.remove(trans_id);
              let pos = self
                  .transaction_list
                  .transactions
                  .iter()
                  .position(|t| t == &trans_id)
                  .expect("The transaction exists hence it must also be in the list.");
              self.transaction_list.transactions.swap_remove(pos);
              for owner in self.owners.iter() {
                  self.confirmations.remove((trans_id, *owner));
              }
              self.confirmation_count.remove(trans_id);
          }
          transaction
      }
  *)
  Definition take_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M (core.option.Option.t multisig.Transaction.t) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let trans_id := M.alloc (| trans_id |) in
      M.read (|
        let transaction : M.Val (core.option.Option.t multisig.Transaction.t) :=
          M.alloc (|
            M.call (|((multisig.Mapping.t u32.t multisig.Transaction.t)::["get"]
              (borrow
                (multisig.Multisig.Get_transactions
                  (deref (M.read (| self |)))))
              (borrow trans_id))
            |)
          |) in
        let _ : M.Val unit :=
          if
            M.read (|
              use
                (M.alloc (|
                  M.call (|((core.option.Option.t
                        multisig.Transaction.t)::["is_some"]
                    (borrow transaction))
                  |)
                |))
            |)
          then
            let _ : M.Val unit :=
              M.alloc (|
                M.call (|((multisig.Mapping.t
                      u32.t
                      multisig.Transaction.t)::["remove"]
                  (borrow
                    (multisig.Multisig.Get_transactions
                      (deref (M.read (| self |)))))
                  (M.read (| trans_id |)))
                |)
              |) in
            let pos : M.Val usize.t :=
              M.alloc (|
                M.call (|((core.option.Option.t usize.t)::["expect"]
                  (M.call (|(ltac:(M.get_method (fun ℐ =>
                      core.iter.traits.iterator.Iterator.position
                        (Self := core.slice.iter.Iter.t u32.t)
                        (P := (ref u32.t) -> bool.t)
                        (Trait := ℐ)))
                    (borrow_mut
                      (M.alloc (|
                        M.call (|((slice u32.t)::["iter"]
                          (M.call (|(ltac:(M.get_method (fun ℐ =>
                              core.ops.deref.Deref.deref
                                (Self :=
                                  alloc.vec.Vec.t u32.t alloc.alloc.Global.t)
                                (Trait := ℐ)))
                            (borrow
                              (multisig.Transactions.Get_transactions
                                (multisig.Multisig.Get_transaction_list
                                  (deref (M.read (| self |)))))))
                          |)))
                        |)
                      |)))
                    (fun (α0 : ref u32.t) =>
                      (ltac:
                        (M.monadic_match_operator
                          (M.alloc (| α0 |))
                          [
                            fun γ =>
                              (let t := M.copy (| γ |) in
                              M.call (|(ltac:(M.get_method (fun ℐ =>
                                  core.cmp.PartialEq.eq
                                    (Self := ref u32.t)
                                    (Rhs := ref u32.t)
                                    (Trait := ℐ)))
                                (borrow t)
                                (borrow (M.alloc (| borrow trans_id |))))
                              |)) :
                              bool.t
                          ])) :
                      bool.t))
                  |))
                  (M.read (|
                    mk_str
                      "The transaction exists hence it must also be in the list."
                  |)))
                |)
              |) in
            let _ : M.Val u32.t :=
              M.alloc (|
                M.call (|((alloc.vec.Vec.t
                      u32.t
                      alloc.alloc.Global.t)::["swap_remove"]
                  (borrow_mut
                    (multisig.Transactions.Get_transactions
                      (multisig.Multisig.Get_transaction_list
                        (deref (M.read (| self |))))))
                  (M.read (| pos |)))
                |)
              |) in
            let _ : M.Val unit :=
              use
                (ltac:
                  (M.monadic_match_operator
                    (M.alloc (|
                      M.call (|(ltac:(M.get_method (fun ℐ =>
                          core.iter.traits.collect.IntoIterator.into_iter
                            (Self :=
                              core.slice.iter.Iter.t multisig.AccountId.t)
                            (Trait := ℐ)))
                        (M.call (|((slice multisig.AccountId.t)::["iter"]
                          (M.call (|(ltac:(M.get_method (fun ℐ =>
                              core.ops.deref.Deref.deref
                                (Self :=
                                  alloc.vec.Vec.t
                                    multisig.AccountId.t
                                    alloc.alloc.Global.t)
                                (Trait := ℐ)))
                            (borrow
                              (multisig.Multisig.Get_owners
                                (deref (M.read (| self |))))))
                          |)))
                        |)))
                      |)
                    |))
                    [
                      fun
                          (γ :
                            M.Val
                              (core.slice.iter.Iter.t multisig.AccountId.t)) =>
                        (let iter := M.copy (| γ |) in
                        M.loop
                          (let _ : M.Val unit :=
                            ltac:
                              (M.monadic_match_operator
                                (M.alloc (|
                                  M.call (|(ltac:(M.get_method (fun ℐ =>
                                      core.iter.traits.iterator.Iterator.next
                                        (Self :=
                                          core.slice.iter.Iter.t
                                            multisig.AccountId.t)
                                        (Trait := ℐ)))
                                    (borrow_mut iter))
                                  |)
                                |))
                                [
                                  fun
                                      (γ :
                                        M.Val
                                          (core.option.Option.t
                                            (ref multisig.AccountId.t))) =>
                                    match M.read (| γ |) with
                                    | core.option.Option.None =>
                                      M.alloc (|
                                        (never_to_any (B := unit)) (|
                                          M.read (| M.break |)
                                        |)
                                      |)
                                    | _ => M.break_match(||)
                                    end :
                                    M.Val unit;
                                  fun
                                      (γ :
                                        M.Val
                                          (core.option.Option.t
                                            (ref multisig.AccountId.t))) =>
                                    match M.read (| γ |) with
                                    | core.option.Option.Some _ =>
                                      let γ0_0 :=
                                        core.option.Option.Get_Some_0 γ in
                                      let owner := M.copy (| γ0_0 |) in
                                      let _ : M.Val unit :=
                                        M.alloc (|
                                          M.call (|((multisig.Mapping.t
                                                (u32.t * multisig.AccountId.t)
                                                unit)::["remove"]
                                            (borrow
                                              (multisig.Multisig.Get_confirmations
                                                (deref (M.read (| self |)))))
                                            (M.read (| trans_id |),
                                              M.read (|
                                                deref (M.read (| owner |))
                                              |)))
                                          |)
                                        |) in
                                      M.alloc (| tt |)
                                    | _ => M.break_match(||)
                                    end :
                                    M.Val unit
                                ]) in
                          M.alloc (| tt |))) :
                        M.Val unit
                    ])) in
            let _ : M.Val unit :=
              M.alloc (|
                M.call (|((multisig.Mapping.t u32.t u32.t)::["remove"]
                  (borrow
                    (multisig.Multisig.Get_confirmation_count
                      (deref (M.read (| self |)))))
                  (M.read (| trans_id |)))
                |)
              |) in
            M.alloc (| tt |)
          else
            M.alloc (| tt |) in
        transaction
      |)
    ) : core.option.Option.t multisig.Transaction.t)).
  
  Global Instance AssociatedFunction_take_transaction :
    Notations.DoubleColon Self "take_transaction" := {
    Notations.double_colon := take_transaction;
  }.
  
  (*
      pub fn cancel_transaction(&mut self, trans_id: TransactionId) {
          self.ensure_from_wallet();
          if self.take_transaction(trans_id).is_some() {
              self.env().emit_event(Event::Cancellation(Cancellation {
                  transaction: trans_id,
              }));
          }
      }
  *)
  Definition cancel_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let trans_id := M.alloc (| trans_id |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_from_wallet"]
              (borrow (deref (M.read (| self |)))))
            |)
          |) in
        if
          M.read (|
            use
              (M.alloc (|
                M.call (|((core.option.Option.t
                      multisig.Transaction.t)::["is_some"]
                  (borrow
                    (M.alloc (|
                      M.call (|(multisig.Multisig.t::["take_transaction"]
                        (M.read (| self |))
                        (M.read (| trans_id |)))
                      |)
                    |))))
                |)
              |))
          |)
        then
          let _ : M.Val unit :=
            M.alloc (|
              M.call (|(multisig.Env.t::["emit_event"]
                (borrow
                  (M.alloc (|
                    M.call (|(multisig.Multisig.t::["env"]
                      (borrow (deref (M.read (| self |)))))
                    |)
                  |)))
                (multisig.Event.Cancellation
                  ({|
                    multisig.Cancellation.transaction := M.read (| trans_id |);
                  |} : multisig.Cancellation.t)))
              |)
            |) in
          M.alloc (| tt |)
        else
          M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_cancel_transaction :
    Notations.DoubleColon Self "cancel_transaction" := {
    Notations.double_colon := cancel_transaction;
  }.
  
  (*
      pub fn confirm_transaction(&mut self, trans_id: TransactionId) -> ConfirmationStatus {
          self.ensure_caller_is_owner();
          self.ensure_transaction_exists(trans_id);
          self.confirm_by_caller(self.env().caller(), trans_id)
      }
  *)
  Definition confirm_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M multisig.ConfirmationStatus.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let trans_id := M.alloc (| trans_id |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_caller_is_owner"]
              (borrow (deref (M.read (| self |)))))
            |)
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_transaction_exists"]
              (borrow (deref (M.read (| self |))))
              (M.read (| trans_id |)))
            |)
          |) in
        M.alloc (|
          M.call (|(multisig.Multisig.t::["confirm_by_caller"]
            (M.read (| self |))
            (M.call (|(multisig.Env.t::["caller"]
              (borrow
                (M.alloc (|
                  M.call (|(multisig.Multisig.t::["env"]
                    (borrow (deref (M.read (| self |)))))
                  |)
                |))))
            |))
            (M.read (| trans_id |)))
          |)
        |)
      |)
    ) : multisig.ConfirmationStatus.t)).
  
  Global Instance AssociatedFunction_confirm_transaction :
    Notations.DoubleColon Self "confirm_transaction" := {
    Notations.double_colon := confirm_transaction;
  }.
  
  (*
      pub fn revoke_confirmation(&mut self, trans_id: TransactionId) {
          self.ensure_caller_is_owner();
          let caller = self.env().caller();
          if self.confirmations.contains(&(trans_id, caller)) {
              self.confirmations.remove((trans_id, caller));
              let mut confirmation_count = self
                  .confirmation_count
                  .get(&trans_id)
                  .expect("There is a entry in `self.confirmations`. Hence a count must exit.");
              // Will not underflow as there is at least one confirmation
              confirmation_count -= 1;
              self.confirmation_count.insert(trans_id, confirmation_count);
              self.env().emit_event(Event::Revocation(Revocation {
                  transaction: trans_id,
                  from: caller,
              }));
          }
      }
  *)
  Definition revoke_confirmation
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let trans_id := M.alloc (| trans_id |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_caller_is_owner"]
              (borrow (deref (M.read (| self |)))))
            |)
          |) in
        let caller : M.Val multisig.AccountId.t :=
          M.alloc (|
            M.call (|(multisig.Env.t::["caller"]
              (borrow
                (M.alloc (|
                  M.call (|(multisig.Multisig.t::["env"]
                    (borrow (deref (M.read (| self |)))))
                  |)
                |))))
            |)
          |) in
        if
          M.read (|
            use
              (M.alloc (|
                M.call (|((multisig.Mapping.t
                      (u32.t * multisig.AccountId.t)
                      unit)::["contains"]
                  (borrow
                    (multisig.Multisig.Get_confirmations
                      (deref (M.read (| self |)))))
                  (borrow
                    (M.alloc (| (M.read (| trans_id |), M.read (| caller |))
                    |))))
                |)
              |))
          |)
        then
          let _ : M.Val unit :=
            M.alloc (|
              M.call (|((multisig.Mapping.t
                    (u32.t * multisig.AccountId.t)
                    unit)::["remove"]
                (borrow
                  (multisig.Multisig.Get_confirmations
                    (deref (M.read (| self |)))))
                (M.read (| trans_id |), M.read (| caller |)))
              |)
            |) in
          let confirmation_count : M.Val u32.t :=
            M.alloc (|
              M.call (|((core.option.Option.t u32.t)::["expect"]
                (M.call (|((multisig.Mapping.t u32.t u32.t)::["get"]
                  (borrow
                    (multisig.Multisig.Get_confirmation_count
                      (deref (M.read (| self |)))))
                  (borrow trans_id))
                |))
                (M.read (|
                  mk_str
                    "There is a entry in `self.confirmations`. Hence a count must exit."
                |)))
              |)
            |) in
          let _ : M.Val unit :=
            let β : M.Val u32.t := confirmation_count in
            assign (|
              β,
              BinOp.Panic.sub (| M.read (| β |), (Integer.of_Z 1) : u32.t |)
            |) in
          let _ : M.Val (core.option.Option.t u32.t) :=
            M.alloc (|
              M.call (|((multisig.Mapping.t u32.t u32.t)::["insert"]
                (borrow_mut
                  (multisig.Multisig.Get_confirmation_count
                    (deref (M.read (| self |)))))
                (M.read (| trans_id |))
                (M.read (| confirmation_count |)))
              |)
            |) in
          let _ : M.Val unit :=
            M.alloc (|
              M.call (|(multisig.Env.t::["emit_event"]
                (borrow
                  (M.alloc (|
                    M.call (|(multisig.Multisig.t::["env"]
                      (borrow (deref (M.read (| self |)))))
                    |)
                  |)))
                (multisig.Event.Revocation
                  ({|
                    multisig.Revocation.transaction := M.read (| trans_id |);
                    multisig.Revocation.from := M.read (| caller |);
                  |} : multisig.Revocation.t)))
              |)
            |) in
          M.alloc (| tt |)
        else
          M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_revoke_confirmation :
    Notations.DoubleColon Self "revoke_confirmation" := {
    Notations.double_colon := revoke_confirmation;
  }.
  
  (*
      pub fn invoke_transaction(&mut self, trans_id: TransactionId) -> Result<(), Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          assert!(self.env().transferred_value() == t.transferred_value);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<()>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(_)) => Ok(()),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.map(|_| None),
          }));
          result
      }
  *)
  Definition invoke_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M (core.result.Result.t unit multisig.Error.t) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let trans_id := M.alloc (| trans_id |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Multisig.t::["ensure_confirmed"]
              (borrow (deref (M.read (| self |))))
              (M.read (| trans_id |)))
            |)
          |) in
        let t : M.Val multisig.Transaction.t :=
          M.alloc (|
            M.call (|((core.option.Option.t multisig.Transaction.t)::["expect"]
              (M.call (|(multisig.Multisig.t::["take_transaction"]
                (M.read (| self |))
                (M.read (| trans_id |)))
              |))
              (M.read (| multisig.WRONG_TRANSACTION_ID |)))
            |)
          |) in
        let _ : M.Val unit :=
          if
            M.read (|
              use
                (M.alloc (|
                  UnOp.not
                    (BinOp.Pure.eq
                      (M.call (|(multisig.Env.t::["transferred_value"]
                        (borrow
                          (M.alloc (|
                            M.call (|(multisig.Multisig.t::["env"]
                              (borrow (deref (M.read (| self |)))))
                            |)
                          |))))
                      |))
                      (M.read (| multisig.Transaction.Get_transferred_value t
                      |)))
                |))
            |)
          then
            M.alloc (|
              (never_to_any (B := unit)) (|
                M.call (|(core.panicking.panic
                  (M.read (|
                    mk_str
                      "assertion failed: self.env().transferred_value() == t.transferred_value"
                  |)))
                |)
              |)
            |)
          else
            M.alloc (| tt |) in
        let result :
            M.Val
              (core.result.Result.t
                (core.result.Result.t
                  (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
                  unit)
                unit) :=
          M.alloc (|
            (never_to_any
              (B :=
                core.result.Result.t
                  (core.result.Result.t
                    (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
                    unit)
                  unit)) (|
              M.call (|(core.panicking.panic
                (M.read (| mk_str "not yet implemented" |)))
              |)
            |)
          |) in
        let result : M.Val (core.result.Result.t unit multisig.Error.t) :=
          M.copy (|
            ltac:
              (M.monadic_match_operator
                result
                [
                  fun
                      (γ :
                        M.Val
                          (core.result.Result.t
                            (core.result.Result.t
                              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
                              unit)
                            unit)) =>
                    match M.read (| γ |) with
                    | core.result.Result.Ok _ =>
                      let γ0_0 := core.result.Result.Get_Ok_0 γ in
                      match M.read (| γ0_0 |) with
                      | core.result.Result.Ok _ =>
                        let γ1_0 := core.result.Result.Get_Ok_0 γ0_0 in
                        M.alloc (| core.result.Result.Ok tt |)
                      | _ => M.break_match(||)
                      end
                    | _ => M.break_match(||)
                    end :
                    M.Val (core.result.Result.t unit multisig.Error.t);
                  fun
                      (γ :
                        M.Val
                          (core.result.Result.t
                            (core.result.Result.t
                              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
                              unit)
                            unit)) =>
                    (M.alloc (|
                      core.result.Result.Err multisig.Error.TransactionFailed
                    |)) :
                    M.Val (core.result.Result.t unit multisig.Error.t)
                ])
          |) in
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(multisig.Env.t::["emit_event"]
              (borrow
                (M.alloc (|
                  M.call (|(multisig.Multisig.t::["env"]
                    (borrow (deref (M.read (| self |)))))
                  |)
                |)))
              (multisig.Event.Execution
                ({|
                  multisig.Execution.transaction := M.read (| trans_id |);
                  multisig.Execution.result :=
                    M.call (|((core.result.Result.t
                          unit
                          multisig.Error.t)::["map"]
                      (M.read (| result |))
                      (fun (α0 : unit) =>
                        (ltac:
                          (M.monadic_match_operator
                            (M.alloc (| α0 |))
                            [
                              fun γ =>
                                core.option.Option.None :
                                core.option.Option.t
                                  (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
                            ])) :
                        core.option.Option.t
                          (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)))
                    |);
                |} : multisig.Execution.t)))
            |)
          |) in
        result
      |)
    ) : core.result.Result.t unit multisig.Error.t)).
  
  Global Instance AssociatedFunction_invoke_transaction :
    Notations.DoubleColon Self "invoke_transaction" := {
    Notations.double_colon := invoke_transaction;
  }.
  
  (*
      pub fn eval_transaction(&mut self, trans_id: TransactionId) -> Result<Vec<u8>, Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<Vec<u8>>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(v)) => Ok(v),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.clone().map(Some),
          }));
          result
      }
  *)
  Parameter eval_transaction :
      (mut_ref Self) ->
        ltac:(multisig.TransactionId) ->
        M
          (core.result.Result.t
            (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
            multisig.Error.t).
  
  Global Instance AssociatedFunction_eval_transaction :
    Notations.DoubleColon Self "eval_transaction" := {
    Notations.double_colon := eval_transaction;
  }.
End Impl_multisig_Multisig_t.
End Impl_multisig_Multisig_t.
