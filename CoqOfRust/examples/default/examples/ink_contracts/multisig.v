(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Definition Get__key :=
    Ref.map (fun α => Some α.(_key)) (fun β α => Some (α <| _key := β |>)).
  Definition Get__value :=
    Ref.map (fun α => Some α.(_value)) (fun β α => Some (α <| _value := β |>)).
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_multisig_Mapping_t_K_V.
Section Impl_core_default_Default_for_multisig_Mapping_t_K_V.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.default.Default.Trait K}
    {ℋ_1 : core.default.Default.Trait V}.
  
  Definition Self : Set := multisig.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (multisig.Mapping.t K V) :=
    let* α0 : M (core.marker.PhantomData.t K) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := core.marker.PhantomData.t K)
          (Trait := ℐ))) in
    let* α1 : core.marker.PhantomData.t K := M.call α0 in
    let* α2 : M (core.marker.PhantomData.t V) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := core.marker.PhantomData.t V)
          (Trait := ℐ))) in
    let* α3 : core.marker.PhantomData.t V := M.call α2 in
    M.pure {| multisig.Mapping._key := α1; multisig.Mapping._value := α3; |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Mapping_t_K_V.
End Impl_core_default_Default_for_multisig_Mapping_t_K_V.

Module  Impl_multisig_Mapping_t_K_V.
Section Impl_multisig_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := multisig.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref Self) (_key : ref K) : M bool.t :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref Self) (_key : K) : M unit :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref Self)
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon Self "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (self : ref Self) (_key : K) : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_multisig_Mapping_t_K_V.
End Impl_multisig_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_multisig_AccountId_t.
Section Impl_core_default_Default_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M multisig.AccountId.t :=
    let* α0 : M u128.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := u128.t) (Trait := ℐ))) in
    let* α1 : u128.t := M.call α0 in
    M.pure (multisig.AccountId.Build_t α1).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_AccountId_t.
End Impl_core_default_Default_for_multisig_AccountId_t.

Module  Impl_core_fmt_Debug_for_multisig_AccountId_t.
Section Impl_core_fmt_Debug_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
    let* α1 : ref str.t := M.read (mk_str "AccountId") in
    let* α2 : ref multisig.AccountId.t := M.read self in
    let* α3 : M.Val (ref u128.t) :=
      M.alloc (borrow (multisig.AccountId.Get_0 (deref α2))) in
    M.call
      (core.fmt.Formatter.t::["debug_tuple_field1_finish"]
        α0
        α1
        (pointer_coercion "Unsize" (borrow α3))).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_multisig_AccountId_t.
End Impl_core_fmt_Debug_for_multisig_AccountId_t.

Module  Impl_core_clone_Clone_for_multisig_AccountId_t.
Section Impl_core_clone_Clone_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M multisig.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : M.Val multisig.AccountId.t :=
      match_operator
        (DeclaredButUndefinedVariable
          (A := core.clone.AssertParamIsClone.t u128.t))
        [
          fun γ =>
            (let* α0 : ref multisig.AccountId.t := M.read self in
            M.pure (deref α0)) :
            M (M.Val multisig.AccountId.t)
        ] in
    M.read α0.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_AccountId_t.
End Impl_core_clone_Clone_for_multisig_AccountId_t.

Module  Impl_core_marker_Copy_for_multisig_AccountId_t.
Section Impl_core_marker_Copy_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_AccountId_t.
End Impl_core_marker_Copy_for_multisig_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
Section Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref multisig.AccountId.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : ref multisig.AccountId.t := M.read self in
    let* α1 : u128.t := M.read (multisig.AccountId.Get_0 (deref α0)) in
    let* α2 : ref multisig.AccountId.t := M.read other in
    let* α3 : u128.t := M.read (multisig.AccountId.Get_0 (deref α2)) in
    M.pure (BinOp.Pure.eq α1 α3).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
End Impl_core_cmp_PartialEq_for_multisig_AccountId_t.

Module  Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
Section Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
End Impl_core_marker_StructuralEq_for_multisig_AccountId_t.

Module  Impl_core_cmp_Eq_for_multisig_AccountId_t.
Section Impl_core_cmp_Eq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let* α0 : M.Val unit :=
      match_operator
        (DeclaredButUndefinedVariable (A := core.cmp.AssertParamIsEq.t u128.t))
        [ fun γ => (M.alloc tt) : M (M.Val unit) ] in
    M.read α0.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_multisig_AccountId_t.
End Impl_core_cmp_Eq_for_multisig_AccountId_t.

Module  Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
Section Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  PartialOrd
  *)
  Definition partial_cmp
      (self : ref Self)
      (other : ref multisig.AccountId.t)
      : M (core.option.Option.t core.cmp.Ordering.t) :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 :
        (ref u128.t) ->
          (ref u128.t) ->
          M (core.option.Option.t core.cmp.Ordering.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.cmp.PartialOrd.partial_cmp
          (Self := u128.t)
          (Rhs := u128.t)
          (Trait := ℐ))) in
    let* α1 : ref multisig.AccountId.t := M.read self in
    let* α2 : ref multisig.AccountId.t := M.read other in
    M.call
      (α0
        (borrow (multisig.AccountId.Get_0 (deref α1)))
        (borrow (multisig.AccountId.Get_0 (deref α2)))).
  
  Global Instance AssociatedFunction_partial_cmp :
    Notations.DoubleColon Self "partial_cmp" := {
    Notations.double_colon := partial_cmp;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialOrd.Required.Trait Self
      (Rhs := core.cmp.PartialOrd.Default.Rhs Self) := {
    core.cmp.PartialOrd.partial_cmp := partial_cmp;
    core.cmp.PartialOrd.lt := Datatypes.None;
    core.cmp.PartialOrd.le := Datatypes.None;
    core.cmp.PartialOrd.gt := Datatypes.None;
    core.cmp.PartialOrd.ge := Datatypes.None;
  }.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.

Module  Impl_core_cmp_Ord_for_multisig_AccountId_t.
Section Impl_core_cmp_Ord_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Ord
  *)
  Definition cmp
      (self : ref Self)
      (other : ref multisig.AccountId.t)
      : M core.cmp.Ordering.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : (ref u128.t) -> (ref u128.t) -> M core.cmp.Ordering.t :=
      ltac:(M.get_method (fun ℐ =>
        core.cmp.Ord.cmp (Self := u128.t) (Trait := ℐ))) in
    let* α1 : ref multisig.AccountId.t := M.read self in
    let* α2 : ref multisig.AccountId.t := M.read other in
    M.call
      (α0
        (borrow (multisig.AccountId.Get_0 (deref α1)))
        (borrow (multisig.AccountId.Get_0 (deref α2)))).
  
  Global Instance AssociatedFunction_cmp : Notations.DoubleColon Self "cmp" := {
    Notations.double_colon := cmp;
  }.
  
  Global Instance ℐ : core.cmp.Ord.Required.Trait Self := {
    core.cmp.Ord.cmp := cmp;
    core.cmp.Ord.max := Datatypes.None;
    core.cmp.Ord.min := Datatypes.None;
    core.cmp.Ord.clamp := Datatypes.None;
  }.
End Impl_core_cmp_Ord_for_multisig_AccountId_t.
End Impl_core_cmp_Ord_for_multisig_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : multisig.AccountId.t;
  }.
  
  Definition Get_caller :=
    Ref.map (fun α => Some α.(caller)) (fun β α => Some (α <| caller := β |>)).
End Env.
End Env.

Definition MAX_OWNERS : M.Val u32.t :=
  M.run (M.alloc ((Integer.of_Z 50) : u32.t)).

Ltac TransactionId := exact u32.t.

Definition WRONG_TRANSACTION_ID : M.Val (ref str.t) :=
  M.run
    (M.pure (mk_str "The user specified an invalid transaction id. Abort.")).

Module  CallInput.
Section CallInput.
  Record t : Set := {
    x0 : ref (slice u8.t);
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End CallInput.
End CallInput.

Module ConfirmationStatus.
  Inductive t : Set :=
  | Confirmed
  | ConfirmationsNeeded (_ : u32.t).
  
  Definition Get_ConfirmationsNeeded_0 :=
    Ref.map
      (fun α =>
        match α with | ConfirmationsNeeded α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | ConfirmationsNeeded _ => Some (ConfirmationsNeeded β)
        | _ => None
        end).
End ConfirmationStatus.

Module  Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
Section Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
  Definition Self : Set := multisig.ConfirmationStatus.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M multisig.ConfirmationStatus.t :=
    let* self := M.alloc self in
    let* α0 : M.Val multisig.ConfirmationStatus.t :=
      match_operator
        (DeclaredButUndefinedVariable
          (A := core.clone.AssertParamIsClone.t u32.t))
        [
          fun γ =>
            (let* α0 : ref multisig.ConfirmationStatus.t := M.read self in
            M.pure (deref α0)) :
            M (M.Val multisig.ConfirmationStatus.t)
        ] in
    M.read α0.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.

Module  Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
Section Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
  Definition Self : Set := multisig.ConfirmationStatus.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.

Module  Transaction.
Section Transaction.
  Record t : Set := {
    callee : multisig.AccountId.t;
    selector : array u8.t;
    input : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A;
    transferred_value : ltac:(multisig.Balance);
    gas_limit : u64.t;
    allow_reentry : bool.t;
  }.
  
  Definition Get_callee :=
    Ref.map (fun α => Some α.(callee)) (fun β α => Some (α <| callee := β |>)).
  Definition Get_selector :=
    Ref.map
      (fun α => Some α.(selector))
      (fun β α => Some (α <| selector := β |>)).
  Definition Get_input :=
    Ref.map (fun α => Some α.(input)) (fun β α => Some (α <| input := β |>)).
  Definition Get_transferred_value :=
    Ref.map
      (fun α => Some α.(transferred_value))
      (fun β α => Some (α <| transferred_value := β |>)).
  Definition Get_gas_limit :=
    Ref.map
      (fun α => Some α.(gas_limit))
      (fun β α => Some (α <| gas_limit := β |>)).
  Definition Get_allow_reentry :=
    Ref.map
      (fun α => Some α.(allow_reentry))
      (fun β α => Some (α <| allow_reentry := β |>)).
End Transaction.
End Transaction.

Module  Impl_core_default_Default_for_multisig_Transaction_t.
Section Impl_core_default_Default_for_multisig_Transaction_t.
  Definition Self : Set := multisig.Transaction.t.
  
  (*
  Default
  *)
  Definition default : M multisig.Transaction.t :=
    let* α0 : M multisig.AccountId.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := multisig.AccountId.t)
          (Trait := ℐ))) in
    let* α1 : multisig.AccountId.t := M.call α0 in
    let* α2 : M (array u8.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := array u8.t) (Trait := ℐ))) in
    let* α3 : array u8.t := M.call α2 in
    let* α4 : M (alloc.vec.Vec.t u8.t alloc.alloc.Global.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
          (Trait := ℐ))) in
    let* α5 : alloc.vec.Vec.t u8.t alloc.alloc.Global.t := M.call α4 in
    let* α6 : M u128.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := u128.t) (Trait := ℐ))) in
    let* α7 : u128.t := M.call α6 in
    let* α8 : M u64.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := u64.t) (Trait := ℐ))) in
    let* α9 : u64.t := M.call α8 in
    let* α10 : M bool.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := bool.t) (Trait := ℐ))) in
    let* α11 : bool.t := M.call α10 in
    M.pure
      {|
        multisig.Transaction.callee := α1;
        multisig.Transaction.selector := α3;
        multisig.Transaction.input := α5;
        multisig.Transaction.transferred_value := α7;
        multisig.Transaction.gas_limit := α9;
        multisig.Transaction.allow_reentry := α11;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Transaction_t.
End Impl_core_default_Default_for_multisig_Transaction_t.

Module Error.
  Inductive t : Set :=
  | TransactionFailed.
End Error.

Module  Impl_core_clone_Clone_for_multisig_Error_t.
Section Impl_core_clone_Clone_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M multisig.Error.t :=
    let* self := M.alloc self in
    let* α0 : ref multisig.Error.t := M.read self in
    M.read (deref α0).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_Error_t.
End Impl_core_clone_Clone_for_multisig_Error_t.

Module  Impl_core_marker_Copy_for_multisig_Error_t.
Section Impl_core_marker_Copy_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_Error_t.
End Impl_core_marker_Copy_for_multisig_Error_t.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
Section Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.

Module  Impl_core_cmp_PartialEq_for_multisig_Error_t.
Section Impl_core_cmp_PartialEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref multisig.Error.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.pure true.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_multisig_Error_t.
End Impl_core_cmp_PartialEq_for_multisig_Error_t.

Module  Impl_core_marker_StructuralEq_for_multisig_Error_t.
Section Impl_core_marker_StructuralEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_multisig_Error_t.
End Impl_core_marker_StructuralEq_for_multisig_Error_t.

Module  Impl_core_cmp_Eq_for_multisig_Error_t.
Section Impl_core_cmp_Eq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.pure tt.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_multisig_Error_t.
End Impl_core_cmp_Eq_for_multisig_Error_t.

Module  Transactions.
Section Transactions.
  Record t : Set := {
    transactions :
      alloc.vec.Vec.t ltac:(multisig.TransactionId) alloc.vec.Vec.Default.A;
    next_id : ltac:(multisig.TransactionId);
  }.
  
  Definition Get_transactions :=
    Ref.map
      (fun α => Some α.(transactions))
      (fun β α => Some (α <| transactions := β |>)).
  Definition Get_next_id :=
    Ref.map
      (fun α => Some α.(next_id))
      (fun β α => Some (α <| next_id := β |>)).
End Transactions.
End Transactions.

Module  Impl_core_default_Default_for_multisig_Transactions_t.
Section Impl_core_default_Default_for_multisig_Transactions_t.
  Definition Self : Set := multisig.Transactions.t.
  
  (*
  Default
  *)
  Definition default : M multisig.Transactions.t :=
    let* α0 : M (alloc.vec.Vec.t u32.t alloc.alloc.Global.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := alloc.vec.Vec.t u32.t alloc.alloc.Global.t)
          (Trait := ℐ))) in
    let* α1 : alloc.vec.Vec.t u32.t alloc.alloc.Global.t := M.call α0 in
    let* α2 : M u32.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := u32.t) (Trait := ℐ))) in
    let* α3 : u32.t := M.call α2 in
    M.pure
      {|
        multisig.Transactions.transactions := α1;
        multisig.Transactions.next_id := α3;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Transactions_t.
End Impl_core_default_Default_for_multisig_Transactions_t.

Module  Confirmation.
Section Confirmation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    from : multisig.AccountId.t;
    status : multisig.ConfirmationStatus.t;
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
  Definition Get_status :=
    Ref.map (fun α => Some α.(status)) (fun β α => Some (α <| status := β |>)).
End Confirmation.
End Confirmation.

Module  Revocation.
Section Revocation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    from : multisig.AccountId.t;
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
  Definition Get_from :=
    Ref.map (fun α => Some α.(from)) (fun β α => Some (α <| from := β |>)).
End Revocation.
End Revocation.

Module  Submission.
Section Submission.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
End Submission.
End Submission.

Module  Cancellation.
Section Cancellation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
End Cancellation.
End Cancellation.

Module  Execution.
Section Execution.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    result :
      core.result.Result.t
        (core.option.Option.t (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        multisig.Error.t;
  }.
  
  Definition Get_transaction :=
    Ref.map
      (fun α => Some α.(transaction))
      (fun β α => Some (α <| transaction := β |>)).
  Definition Get_result :=
    Ref.map (fun α => Some α.(result)) (fun β α => Some (α <| result := β |>)).
End Execution.
End Execution.

Module  OwnerAddition.
Section OwnerAddition.
  Record t : Set := {
    owner : multisig.AccountId.t;
  }.
  
  Definition Get_owner :=
    Ref.map (fun α => Some α.(owner)) (fun β α => Some (α <| owner := β |>)).
End OwnerAddition.
End OwnerAddition.

Module  OwnerRemoval.
Section OwnerRemoval.
  Record t : Set := {
    owner : multisig.AccountId.t;
  }.
  
  Definition Get_owner :=
    Ref.map (fun α => Some α.(owner)) (fun β α => Some (α <| owner := β |>)).
End OwnerRemoval.
End OwnerRemoval.

Module  RequirementChange.
Section RequirementChange.
  Record t : Set := {
    new_requirement : u32.t;
  }.
  
  Definition Get_new_requirement :=
    Ref.map
      (fun α => Some α.(new_requirement))
      (fun β α => Some (α <| new_requirement := β |>)).
End RequirementChange.
End RequirementChange.

Module Event.
  Inductive t : Set :=
  | Confirmation (_ : multisig.Confirmation.t)
  | Revocation (_ : multisig.Revocation.t)
  | Submission (_ : multisig.Submission.t)
  | Cancellation (_ : multisig.Cancellation.t)
  | Execution (_ : multisig.Execution.t)
  | OwnerAddition (_ : multisig.OwnerAddition.t)
  | OwnerRemoval (_ : multisig.OwnerRemoval.t)
  | RequirementChange (_ : multisig.RequirementChange.t).
  
  Definition Get_Confirmation_0 :=
    Ref.map
      (fun α => match α with | Confirmation α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Confirmation _ => Some (Confirmation β) | _ => None end).
  
  Definition Get_Revocation_0 :=
    Ref.map
      (fun α => match α with | Revocation α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Revocation _ => Some (Revocation β) | _ => None end).
  
  Definition Get_Submission_0 :=
    Ref.map
      (fun α => match α with | Submission α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Submission _ => Some (Submission β) | _ => None end).
  
  Definition Get_Cancellation_0 :=
    Ref.map
      (fun α => match α with | Cancellation α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Cancellation _ => Some (Cancellation β) | _ => None end).
  
  Definition Get_Execution_0 :=
    Ref.map
      (fun α => match α with | Execution α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | Execution _ => Some (Execution β) | _ => None end).
  
  Definition Get_OwnerAddition_0 :=
    Ref.map
      (fun α => match α with | OwnerAddition α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | OwnerAddition _ => Some (OwnerAddition β)
        | _ => None
        end).
  
  Definition Get_OwnerRemoval_0 :=
    Ref.map
      (fun α => match α with | OwnerRemoval α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with | OwnerRemoval _ => Some (OwnerRemoval β) | _ => None end).
  
  Definition Get_RequirementChange_0 :=
    Ref.map
      (fun α => match α with | RequirementChange α0 => Some α0 | _ => None end)
      (fun β α =>
        match α with
        | RequirementChange _ => Some (RequirementChange β)
        | _ => None
        end).
End Event.

Module  Impl_multisig_Env_t.
Section Impl_multisig_Env_t.
  Definition Self : Set := multisig.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (self : ref Self) : M multisig.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref multisig.Env.t := M.read self in
    M.read (multisig.Env.Get_caller (deref α0)).
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event
      (self : ref Self)
      (_event : multisig.Event.t)
      : M unit :=
    let* self := M.alloc self in
    let* _event := M.alloc _event in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_emit_event :
    Notations.DoubleColon Self "emit_event" := {
    Notations.double_colon := emit_event;
  }.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition transferred_value (self : ref Self) : M ltac:(multisig.Balance) :=
    let* self := M.alloc self in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_transferred_value :
    Notations.DoubleColon Self "transferred_value" := {
    Notations.double_colon := transferred_value;
  }.
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Definition account_id (self : ref Self) : M multisig.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_account_id :
    Notations.DoubleColon Self "account_id" := {
    Notations.double_colon := account_id;
  }.
End Impl_multisig_Env_t.
End Impl_multisig_Env_t.

Module  Multisig.
Section Multisig.
  Record t : Set := {
    confirmations :
      multisig.Mapping.t
        (ltac:(multisig.TransactionId) * multisig.AccountId.t)
        unit;
    confirmation_count : multisig.Mapping.t ltac:(multisig.TransactionId) u32.t;
    transactions :
      multisig.Mapping.t ltac:(multisig.TransactionId) multisig.Transaction.t;
    transaction_list : multisig.Transactions.t;
    owners : alloc.vec.Vec.t multisig.AccountId.t alloc.vec.Vec.Default.A;
    is_owner : multisig.Mapping.t multisig.AccountId.t unit;
    requirement : u32.t;
  }.
  
  Definition Get_confirmations :=
    Ref.map
      (fun α => Some α.(confirmations))
      (fun β α => Some (α <| confirmations := β |>)).
  Definition Get_confirmation_count :=
    Ref.map
      (fun α => Some α.(confirmation_count))
      (fun β α => Some (α <| confirmation_count := β |>)).
  Definition Get_transactions :=
    Ref.map
      (fun α => Some α.(transactions))
      (fun β α => Some (α <| transactions := β |>)).
  Definition Get_transaction_list :=
    Ref.map
      (fun α => Some α.(transaction_list))
      (fun β α => Some (α <| transaction_list := β |>)).
  Definition Get_owners :=
    Ref.map (fun α => Some α.(owners)) (fun β α => Some (α <| owners := β |>)).
  Definition Get_is_owner :=
    Ref.map
      (fun α => Some α.(is_owner))
      (fun β α => Some (α <| is_owner := β |>)).
  Definition Get_requirement :=
    Ref.map
      (fun α => Some α.(requirement))
      (fun β α => Some (α <| requirement := β |>)).
End Multisig.
End Multisig.

Module  Impl_core_default_Default_for_multisig_Multisig_t.
Section Impl_core_default_Default_for_multisig_Multisig_t.
  Definition Self : Set := multisig.Multisig.t.
  
  (*
  Default
  *)
  Definition default : M multisig.Multisig.t :=
    let* α0 : M (multisig.Mapping.t (u32.t * multisig.AccountId.t) unit) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := multisig.Mapping.t (u32.t * multisig.AccountId.t) unit)
          (Trait := ℐ))) in
    let* α1 : multisig.Mapping.t (u32.t * multisig.AccountId.t) unit :=
      M.call α0 in
    let* α2 : M (multisig.Mapping.t u32.t u32.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := multisig.Mapping.t u32.t u32.t)
          (Trait := ℐ))) in
    let* α3 : multisig.Mapping.t u32.t u32.t := M.call α2 in
    let* α4 : M (multisig.Mapping.t u32.t multisig.Transaction.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := multisig.Mapping.t u32.t multisig.Transaction.t)
          (Trait := ℐ))) in
    let* α5 : multisig.Mapping.t u32.t multisig.Transaction.t := M.call α4 in
    let* α6 : M multisig.Transactions.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := multisig.Transactions.t)
          (Trait := ℐ))) in
    let* α7 : multisig.Transactions.t := M.call α6 in
    let* α8 : M (alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
          (Trait := ℐ))) in
    let* α9 : alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t :=
      M.call α8 in
    let* α10 : M (multisig.Mapping.t multisig.AccountId.t unit) :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := multisig.Mapping.t multisig.AccountId.t unit)
          (Trait := ℐ))) in
    let* α11 : multisig.Mapping.t multisig.AccountId.t unit := M.call α10 in
    let* α12 : M u32.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := u32.t) (Trait := ℐ))) in
    let* α13 : u32.t := M.call α12 in
    M.pure
      {|
        multisig.Multisig.confirmations := α1;
        multisig.Multisig.confirmation_count := α3;
        multisig.Multisig.transactions := α5;
        multisig.Multisig.transaction_list := α7;
        multisig.Multisig.owners := α9;
        multisig.Multisig.is_owner := α11;
        multisig.Multisig.requirement := α13;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Multisig_t.
End Impl_core_default_Default_for_multisig_Multisig_t.

(*
fn ensure_requirement_is_valid(owners: u32, requirement: u32) {
    assert!(0 < requirement && requirement <= owners && owners <= MAX_OWNERS);
}
*)
Definition ensure_requirement_is_valid
    (owners : u32.t)
    (requirement : u32.t)
    : M unit :=
  let* owners := M.alloc owners in
  let* requirement := M.alloc requirement in
  let* _ : M.Val unit :=
    let* α0 : u32.t := M.read requirement in
    let* α1 : u32.t := M.read requirement in
    let* α2 : u32.t := M.read owners in
    let* α3 : u32.t := M.read owners in
    let* α4 : u32.t := M.read multisig.MAX_OWNERS in
    let* α5 : M.Val bool.t :=
      M.alloc
        (UnOp.not
          (BinOp.Pure.and
            (BinOp.Pure.and
              (BinOp.Pure.lt ((Integer.of_Z 0) : u32.t) α0)
              (BinOp.Pure.le α1 α2))
            (BinOp.Pure.le α3 α4))) in
    let* α6 : bool.t := M.read (use α5) in
    if α6 then
      let* α0 : ref str.t :=
        M.read
          (mk_str
            "assertion failed: 0 < requirement && requirement <= owners && owners <= MAX_OWNERS") in
      let* α1 : never.t := M.call (core.panicking.panic α0) in
      let* α2 : unit := never_to_any α1 in
      M.alloc α2
    else
      M.alloc tt in
  let* α0 : M.Val unit := M.alloc tt in
  M.read α0.

Module  Impl_multisig_Multisig_t.
Section Impl_multisig_Multisig_t.
  Definition Self : Set := multisig.Multisig.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M multisig.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (self : ref Self) : M multisig.Env.t :=
    let* self := M.alloc self in
    M.call multisig.Multisig.t::["init_env"].
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new(requirement: u32, mut owners: Vec<AccountId>) -> Self {
          let mut contract = Multisig::default();
          owners.sort_unstable();
          owners.dedup();
          ensure_requirement_is_valid(owners.len() as u32, requirement);
  
          for owner in &owners {
              contract.is_owner.insert( *owner, ());
          }
  
          contract.owners = owners;
          contract.transaction_list = Default::default();
          contract.requirement = requirement;
          contract
      }
  *)
  Definition new
      (requirement : u32.t)
      (owners : alloc.vec.Vec.t multisig.AccountId.t alloc.vec.Vec.Default.A)
      : M Self :=
    let* requirement := M.alloc requirement in
    let* owners := M.alloc owners in
    let* contract : M.Val multisig.Multisig.t :=
      let* α0 : M multisig.Multisig.t :=
        ltac:(M.get_method (fun ℐ =>
          core.default.Default.default
            (Self := multisig.Multisig.t)
            (Trait := ℐ))) in
      let* α1 : multisig.Multisig.t := M.call α0 in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 :
          (mut_ref (alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t))
            ->
            M (mut_ref _) :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.deref.DerefMut.deref_mut
            (Self := alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
            (Trait := ℐ))) in
      let* α1 : mut_ref (slice multisig.AccountId.t) :=
        M.call (α0 (borrow_mut owners)) in
      let* α2 : unit :=
        M.call ((slice multisig.AccountId.t)::["sort_unstable"] α1) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : unit :=
        M.call
          ((alloc.vec.Vec.t
                multisig.AccountId.t
                alloc.alloc.Global.t)::["dedup"]
            (borrow_mut owners)) in
      M.alloc α0 in
    let* _ : M.Val unit :=
      let* α0 : usize.t :=
        M.call
          ((alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)::["len"]
            (borrow owners)) in
      let* α1 : u32.t := M.read requirement in
      let* α2 : unit :=
        M.call (multisig.ensure_requirement_is_valid (rust_cast α0) α1) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 :
          (ref (alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)) ->
            M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.collect.IntoIterator.into_iter
            (Self :=
              ref (alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t))
            (Trait := ℐ))) in
      let* α1 : core.slice.iter.Iter.t multisig.AccountId.t :=
        M.call (α0 (borrow owners)) in
      let* α2 : M.Val (core.slice.iter.Iter.t multisig.AccountId.t) :=
        M.alloc α1 in
      let* α3 : M.Val unit :=
        match_operator
          α2
          [
            fun γ =>
              (let* iter := M.copy γ in
              M.loop
                (let* _ : M.Val unit :=
                  let* α0 :
                      (mut_ref (core.slice.iter.Iter.t multisig.AccountId.t)) ->
                        M (core.option.Option.t _) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.iter.traits.iterator.Iterator.next
                        (Self := core.slice.iter.Iter.t multisig.AccountId.t)
                        (Trait := ℐ))) in
                  let* α1 : core.option.Option.t (ref multisig.AccountId.t) :=
                    M.call (α0 (borrow_mut iter)) in
                  let* α2 :
                      M.Val (core.option.Option.t (ref multisig.AccountId.t)) :=
                    M.alloc α1 in
                  match_operator
                    α2
                    [
                      fun γ =>
                        (let* α0 := M.read γ in
                        match α0 with
                        | core.option.Option.None =>
                          let* α0 : M.Val never.t := M.break in
                          let* α1 := M.read α0 in
                          let* α2 : unit := never_to_any α1 in
                          M.alloc α2
                        | _ => M.break_match
                        end) :
                        M (M.Val unit);
                      fun γ =>
                        (let* α0 := M.read γ in
                        match α0 with
                        | core.option.Option.Some _ =>
                          let γ0_0 := core.option.Option.Get_Some_0 γ in
                          let* owner := M.copy γ0_0 in
                          let* _ : M.Val (core.option.Option.t u32.t) :=
                            let* α0 : ref multisig.AccountId.t :=
                              M.read owner in
                            let* α1 : multisig.AccountId.t :=
                              M.read (deref α0) in
                            let* α2 : core.option.Option.t u32.t :=
                              M.call
                                ((multisig.Mapping.t
                                      multisig.AccountId.t
                                      unit)::["insert"]
                                  (borrow_mut
                                    (multisig.Multisig.Get_is_owner contract))
                                  α1
                                  tt) in
                            M.alloc α2 in
                          M.alloc tt
                        | _ => M.break_match
                        end) :
                        M (M.Val unit)
                    ] in
                M.alloc tt)) :
              M (M.Val unit)
          ] in
      M.pure (use α3) in
    let* _ : M.Val unit :=
      let* α0 : alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t :=
        M.read owners in
      assign (multisig.Multisig.Get_owners contract) α0 in
    let* _ : M.Val unit :=
      let* α0 : M multisig.Transactions.t :=
        ltac:(M.get_method (fun ℐ =>
          core.default.Default.default
            (Self := multisig.Transactions.t)
            (Trait := ℐ))) in
      let* α1 : multisig.Transactions.t := M.call α0 in
      assign (multisig.Multisig.Get_transaction_list contract) α1 in
    let* _ : M.Val unit :=
      let* α0 : u32.t := M.read requirement in
      assign (multisig.Multisig.Get_requirement contract) α0 in
    M.read contract.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn ensure_confirmed(&self, trans_id: TransactionId) {
          assert!(
              self.confirmation_count
                  .get(&trans_id)
                  .expect(WRONG_TRANSACTION_ID)
                  >= self.requirement
          );
      }
  *)
  Definition ensure_confirmed
      (self : ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : core.option.Option.t u32.t :=
        M.call
          ((multisig.Mapping.t u32.t u32.t)::["get"]
            (borrow (multisig.Multisig.Get_confirmation_count (deref α0)))
            (borrow trans_id)) in
      let* α2 : ref str.t := M.read multisig.WRONG_TRANSACTION_ID in
      let* α3 : u32.t :=
        M.call ((core.option.Option.t u32.t)::["expect"] α1 α2) in
      let* α4 : ref multisig.Multisig.t := M.read self in
      let* α5 : u32.t :=
        M.read (multisig.Multisig.Get_requirement (deref α4)) in
      let* α6 : M.Val bool.t := M.alloc (UnOp.not (BinOp.Pure.ge α3 α5)) in
      let* α7 : bool.t := M.read (use α6) in
      if α7 then
        let* α0 : ref str.t :=
          M.read
            (mk_str
              "assertion failed: self.confirmation_count.get(&trans_id).expect(WRONG_TRANSACTION_ID) >=
    self.requirement") in
        let* α1 : never.t := M.call (core.panicking.panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_confirmed :
    Notations.DoubleColon Self "ensure_confirmed" := {
    Notations.double_colon := ensure_confirmed;
  }.
  
  (*
      fn ensure_transaction_exists(&self, trans_id: TransactionId) {
          self.transactions
              .get(&trans_id)
              .expect(WRONG_TRANSACTION_ID);
      }
  *)
  Definition ensure_transaction_exists
      (self : ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val multisig.Transaction.t :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : core.option.Option.t multisig.Transaction.t :=
        M.call
          ((multisig.Mapping.t u32.t multisig.Transaction.t)::["get"]
            (borrow (multisig.Multisig.Get_transactions (deref α0)))
            (borrow trans_id)) in
      let* α2 : ref str.t := M.read multisig.WRONG_TRANSACTION_ID in
      let* α3 : multisig.Transaction.t :=
        M.call
          ((core.option.Option.t multisig.Transaction.t)::["expect"] α1 α2) in
      M.alloc α3 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_transaction_exists :
    Notations.DoubleColon Self "ensure_transaction_exists" := {
    Notations.double_colon := ensure_transaction_exists;
  }.
  
  (*
      fn ensure_owner(&self, owner: &AccountId) {
          assert!(self.is_owner.contains(owner));
      }
  *)
  Definition ensure_owner
      (self : ref Self)
      (owner : ref multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* _ : M.Val unit :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : ref multisig.AccountId.t := M.read owner in
      let* α2 : bool.t :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["contains"]
            (borrow (multisig.Multisig.Get_is_owner (deref α0)))
            α1) in
      let* α3 : M.Val bool.t := M.alloc (UnOp.not α2) in
      let* α4 : bool.t := M.read (use α3) in
      if α4 then
        let* α0 : ref str.t :=
          M.read (mk_str "assertion failed: self.is_owner.contains(owner)") in
        let* α1 : never.t := M.call (core.panicking.panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_owner :
    Notations.DoubleColon Self "ensure_owner" := {
    Notations.double_colon := ensure_owner;
  }.
  
  (*
      fn ensure_caller_is_owner(&self) {
          self.ensure_owner(&self.env().caller());
      }
  *)
  Definition ensure_caller_is_owner (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let* _ : M.Val unit :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : ref multisig.Multisig.t := M.read self in
      let* α2 : multisig.Env.t := M.call (multisig.Multisig.t::["env"] α1) in
      let* α3 : M.Val multisig.Env.t := M.alloc α2 in
      let* α4 : multisig.AccountId.t :=
        M.call (multisig.Env.t::["caller"] (borrow α3)) in
      let* α5 : M.Val multisig.AccountId.t := M.alloc α4 in
      let* α6 : unit :=
        M.call (multisig.Multisig.t::["ensure_owner"] α0 (borrow α5)) in
      M.alloc α6 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_caller_is_owner :
    Notations.DoubleColon Self "ensure_caller_is_owner" := {
    Notations.double_colon := ensure_caller_is_owner;
  }.
  
  (*
      fn ensure_from_wallet(&self) {
          assert_eq!(self.env().caller(), self.env().account_id());
      }
  *)
  Definition ensure_from_wallet (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let* _ : M.Val unit :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t := M.call (multisig.Multisig.t::["env"] α0) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t :=
        M.call (multisig.Env.t::["caller"] (borrow α2)) in
      let* α4 : M.Val multisig.AccountId.t := M.alloc α3 in
      let* α5 : ref multisig.Multisig.t := M.read self in
      let* α6 : multisig.Env.t := M.call (multisig.Multisig.t::["env"] α5) in
      let* α7 : M.Val multisig.Env.t := M.alloc α6 in
      let* α8 : multisig.AccountId.t :=
        M.call (multisig.Env.t::["account_id"] (borrow α7)) in
      let* α9 : M.Val multisig.AccountId.t := M.alloc α8 in
      let* α10 :
          M.Val ((ref multisig.AccountId.t) * (ref multisig.AccountId.t)) :=
        M.alloc (borrow α4, borrow α9) in
      match_operator
        α10
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | (_, _) =>
              let γ0_0 := Tuple.Access.left γ in
              let γ0_1 := Tuple.Access.right γ in
              let* left_val := M.copy γ0_0 in
              let* right_val := M.copy γ0_1 in
              let* α0 :
                  (ref multisig.AccountId.t) ->
                    (ref multisig.AccountId.t) ->
                    M bool.t :=
                ltac:(M.get_method (fun ℐ =>
                  core.cmp.PartialEq.eq
                    (Self := multisig.AccountId.t)
                    (Rhs := multisig.AccountId.t)
                    (Trait := ℐ))) in
              let* α1 : ref multisig.AccountId.t := M.read left_val in
              let* α2 : ref multisig.AccountId.t := M.read right_val in
              let* α3 : bool.t := M.call (α0 α1 α2) in
              let* α4 : M.Val bool.t := M.alloc (UnOp.not α3) in
              let* α5 : bool.t := M.read (use α4) in
              if α5 then
                let* kind : M.Val core.panicking.AssertKind.t :=
                  M.alloc core.panicking.AssertKind.Eq in
                let* α0 : core.panicking.AssertKind.t := M.read kind in
                let* α1 : ref multisig.AccountId.t := M.read left_val in
                let* α2 : ref multisig.AccountId.t := M.read right_val in
                let* α3 : never.t :=
                  M.call
                    (core.panicking.assert_failed
                      α0
                      α1
                      α2
                      core.option.Option.None) in
                let* α0 : M.Val never.t := M.alloc α3 in
                let* α1 := M.read α0 in
                let* α2 : unit := never_to_any α1 in
                M.alloc α2
              else
                M.alloc tt
            end) :
            M (M.Val unit)
        ] in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_from_wallet :
    Notations.DoubleColon Self "ensure_from_wallet" := {
    Notations.double_colon := ensure_from_wallet;
  }.
  
  (*
      fn ensure_no_owner(&self, owner: &AccountId) {
          assert!(!self.is_owner.contains(owner));
      }
  *)
  Definition ensure_no_owner
      (self : ref Self)
      (owner : ref multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* _ : M.Val unit :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : ref multisig.AccountId.t := M.read owner in
      let* α2 : bool.t :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["contains"]
            (borrow (multisig.Multisig.Get_is_owner (deref α0)))
            α1) in
      let* α3 : M.Val bool.t := M.alloc (UnOp.not (UnOp.not α2)) in
      let* α4 : bool.t := M.read (use α3) in
      if α4 then
        let* α0 : ref str.t :=
          M.read (mk_str "assertion failed: !self.is_owner.contains(owner)") in
        let* α1 : never.t := M.call (core.panicking.panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_no_owner :
    Notations.DoubleColon Self "ensure_no_owner" := {
    Notations.double_colon := ensure_no_owner;
  }.
  
  (*
      pub fn add_owner(&mut self, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_no_owner(&new_owner);
          ensure_requirement_is_valid(self.owners.len() as u32 + 1, self.requirement);
          self.is_owner.insert(new_owner, ());
          self.owners.push(new_owner);
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition add_owner
      (self : mut_ref Self)
      (new_owner : multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* new_owner := M.alloc new_owner in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_from_wallet"] (borrow (deref α0))) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_no_owner"]
            (borrow (deref α0))
            (borrow new_owner)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : usize.t :=
        M.call
          ((alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)::["len"]
            (borrow (multisig.Multisig.Get_owners (deref α0)))) in
      let* α2 : u32.t :=
        BinOp.Panic.add (rust_cast α1) ((Integer.of_Z 1) : u32.t) in
      let* α3 : mut_ref multisig.Multisig.t := M.read self in
      let* α4 : u32.t :=
        M.read (multisig.Multisig.Get_requirement (deref α3)) in
      let* α5 : unit := M.call (multisig.ensure_requirement_is_valid α2 α4) in
      M.alloc α5 in
    let* _ : M.Val (core.option.Option.t u32.t) :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.AccountId.t := M.read new_owner in
      let* α2 : core.option.Option.t u32.t :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["insert"]
            (borrow_mut (multisig.Multisig.Get_is_owner (deref α0)))
            α1
            tt) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.AccountId.t := M.read new_owner in
      let* α2 : unit :=
        M.call
          ((alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)::["push"]
            (borrow_mut (multisig.Multisig.Get_owners (deref α0)))
            α1) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t := M.read new_owner in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.OwnerAddition
              {| multisig.OwnerAddition.owner := α3; |})) in
      M.alloc α4 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_add_owner :
    Notations.DoubleColon Self "add_owner" := {
    Notations.double_colon := add_owner;
  }.
  
  (*
      fn owner_index(&self, owner: &AccountId) -> u32 {
          self.owners.iter().position(|x| *x == *owner).expect(
              "This is only called after it was already verified that the id is
                 actually an owner.",
          ) as u32
      }
  *)
  Definition owner_index
      (self : ref Self)
      (owner : ref multisig.AccountId.t)
      : M u32.t :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* α0 :
        (mut_ref (core.slice.iter.Iter.t multisig.AccountId.t)) ->
          ((ref multisig.AccountId.t) -> M bool.t) ->
          M (core.option.Option.t usize.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.iter.traits.iterator.Iterator.position
          (Self := core.slice.iter.Iter.t multisig.AccountId.t)
          (P := (ref multisig.AccountId.t) -> M bool.t)
          (Trait := ℐ))) in
    let* α1 :
        (ref (alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)) ->
          M (ref _) :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.deref.Deref.deref
          (Self := alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
          (Trait := ℐ))) in
    let* α2 : ref multisig.Multisig.t := M.read self in
    let* α3 : ref (slice multisig.AccountId.t) :=
      M.call (α1 (borrow (multisig.Multisig.Get_owners (deref α2)))) in
    let* α4 : core.slice.iter.Iter.t multisig.AccountId.t :=
      M.call ((slice multisig.AccountId.t)::["iter"] α3) in
    let* α5 : M.Val (core.slice.iter.Iter.t multisig.AccountId.t) :=
      M.alloc α4 in
    let* α6 : core.option.Option.t usize.t :=
      M.call
        (α0
          (borrow_mut α5)
          (fun (α0 : ref multisig.AccountId.t) =>
            (let* α0 := M.alloc α0 in
            match_operator
              α0
              [
                fun γ =>
                  (let* x := M.copy γ in
                  let* α0 :
                      (ref multisig.AccountId.t) ->
                        (ref multisig.AccountId.t) ->
                        M bool.t :=
                    ltac:(M.get_method (fun ℐ =>
                      core.cmp.PartialEq.eq
                        (Self := multisig.AccountId.t)
                        (Rhs := multisig.AccountId.t)
                        (Trait := ℐ))) in
                  let* α1 : ref multisig.AccountId.t := M.read x in
                  let* α2 : ref multisig.AccountId.t := M.read owner in
                  M.call (α0 α1 α2)) :
                  M bool.t
              ]) :
            M bool.t)) in
    let* α7 : ref str.t :=
      M.read
        (mk_str
          "This is only called after it was already verified that the id is
               actually an owner.") in
    let* α8 : usize.t :=
      M.call ((core.option.Option.t usize.t)::["expect"] α6 α7) in
    M.pure (rust_cast α8).
  
  Global Instance AssociatedFunction_owner_index :
    Notations.DoubleColon Self "owner_index" := {
    Notations.double_colon := owner_index;
  }.
  
  (*
      fn clean_owner_confirmations(&mut self, owner: &AccountId) {
          for trans_id in &self.transaction_list.transactions {
              let key = ( *trans_id, *owner);
              if self.confirmations.contains(&key) {
                  self.confirmations.remove(key);
                  let mut count = self.confirmation_count.get(trans_id).unwrap_or(0 as u32);
                  count -= 1;
                  self.confirmation_count.insert( *trans_id, count);
              }
          }
      }
  *)
  Definition clean_owner_confirmations
      (self : mut_ref Self)
      (owner : ref multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* α0 : (ref (alloc.vec.Vec.t u32.t alloc.alloc.Global.t)) -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.iter.traits.collect.IntoIterator.into_iter
          (Self := ref (alloc.vec.Vec.t u32.t alloc.alloc.Global.t))
          (Trait := ℐ))) in
    let* α1 : mut_ref multisig.Multisig.t := M.read self in
    let* α2 : core.slice.iter.Iter.t u32.t :=
      M.call
        (α0
          (borrow
            (multisig.Transactions.Get_transactions
              (multisig.Multisig.Get_transaction_list (deref α1))))) in
    let* α3 : M.Val (core.slice.iter.Iter.t u32.t) := M.alloc α2 in
    let* α4 : M.Val unit :=
      match_operator
        α3
        [
          fun γ =>
            (let* iter := M.copy γ in
            M.loop
              (let* _ : M.Val unit :=
                let* α0 :
                    (mut_ref (core.slice.iter.Iter.t u32.t)) ->
                      M (core.option.Option.t _) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.iter.traits.iterator.Iterator.next
                      (Self := core.slice.iter.Iter.t u32.t)
                      (Trait := ℐ))) in
                let* α1 : core.option.Option.t (ref u32.t) :=
                  M.call (α0 (borrow_mut iter)) in
                let* α2 : M.Val (core.option.Option.t (ref u32.t)) :=
                  M.alloc α1 in
                match_operator
                  α2
                  [
                    fun γ =>
                      (let* α0 := M.read γ in
                      match α0 with
                      | core.option.Option.None =>
                        let* α0 : M.Val never.t := M.break in
                        let* α1 := M.read α0 in
                        let* α2 : unit := never_to_any α1 in
                        M.alloc α2
                      | _ => M.break_match
                      end) :
                      M (M.Val unit);
                    fun γ =>
                      (let* α0 := M.read γ in
                      match α0 with
                      | core.option.Option.Some _ =>
                        let γ0_0 := core.option.Option.Get_Some_0 γ in
                        let* trans_id := M.copy γ0_0 in
                        let* key : M.Val (u32.t * multisig.AccountId.t) :=
                          let* α0 : ref u32.t := M.read trans_id in
                          let* α1 : u32.t := M.read (deref α0) in
                          let* α2 : ref multisig.AccountId.t := M.read owner in
                          let* α3 : multisig.AccountId.t := M.read (deref α2) in
                          M.alloc (α1, α3) in
                        let* α0 : mut_ref multisig.Multisig.t := M.read self in
                        let* α1 : bool.t :=
                          M.call
                            ((multisig.Mapping.t
                                  (u32.t * multisig.AccountId.t)
                                  unit)::["contains"]
                              (borrow
                                (multisig.Multisig.Get_confirmations
                                  (deref α0)))
                              (borrow key)) in
                        let* α2 : M.Val bool.t := M.alloc α1 in
                        let* α3 : bool.t := M.read (use α2) in
                        if α3 then
                          let* _ : M.Val unit :=
                            let* α0 : mut_ref multisig.Multisig.t :=
                              M.read self in
                            let* α1 : u32.t * multisig.AccountId.t :=
                              M.read key in
                            let* α2 : unit :=
                              M.call
                                ((multisig.Mapping.t
                                      (u32.t * multisig.AccountId.t)
                                      unit)::["remove"]
                                  (borrow
                                    (multisig.Multisig.Get_confirmations
                                      (deref α0)))
                                  α1) in
                            M.alloc α2 in
                          let* count : M.Val u32.t :=
                            let* α0 : mut_ref multisig.Multisig.t :=
                              M.read self in
                            let* α1 : ref u32.t := M.read trans_id in
                            let* α2 : core.option.Option.t u32.t :=
                              M.call
                                ((multisig.Mapping.t u32.t u32.t)::["get"]
                                  (borrow
                                    (multisig.Multisig.Get_confirmation_count
                                      (deref α0)))
                                  α1) in
                            let* α3 : M.Val u32.t :=
                              M.alloc ((Integer.of_Z 0) : u32.t) in
                            let* α4 : u32.t := M.read (use α3) in
                            let* α5 : u32.t :=
                              M.call
                                ((core.option.Option.t u32.t)::["unwrap_or"]
                                  α2
                                  α4) in
                            M.alloc α5 in
                          let* _ : M.Val unit :=
                            let β : M.Val u32.t := count in
                            let* α0 := M.read β in
                            let* α1 :=
                              BinOp.Panic.sub α0 ((Integer.of_Z 1) : u32.t) in
                            assign β α1 in
                          let* _ : M.Val (core.option.Option.t u32.t) :=
                            let* α0 : mut_ref multisig.Multisig.t :=
                              M.read self in
                            let* α1 : ref u32.t := M.read trans_id in
                            let* α2 : u32.t := M.read (deref α1) in
                            let* α3 : u32.t := M.read count in
                            let* α4 : core.option.Option.t u32.t :=
                              M.call
                                ((multisig.Mapping.t u32.t u32.t)::["insert"]
                                  (borrow_mut
                                    (multisig.Multisig.Get_confirmation_count
                                      (deref α0)))
                                  α2
                                  α3) in
                            M.alloc α4 in
                          M.alloc tt
                        else
                          M.alloc tt
                      | _ => M.break_match
                      end) :
                      M (M.Val unit)
                  ] in
              M.alloc tt)) :
            M (M.Val unit)
        ] in
    M.read (use α4).
  
  Global Instance AssociatedFunction_clean_owner_confirmations :
    Notations.DoubleColon Self "clean_owner_confirmations" := {
    Notations.double_colon := clean_owner_confirmations;
  }.
  
  (*
      pub fn remove_owner(&mut self, owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&owner);
          let len = self.owners.len() as u32 - 1;
          let requirement = u32::min(len, self.requirement);
          ensure_requirement_is_valid(len, requirement);
          let owner_index = self.owner_index(&owner) as usize;
          self.owners.swap_remove(owner_index);
          self.is_owner.remove(owner);
          self.requirement = requirement;
          self.clean_owner_confirmations(&owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner }));
      }
  *)
  Definition remove_owner
      (self : mut_ref Self)
      (owner : multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_from_wallet"] (borrow (deref α0))) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_owner"]
            (borrow (deref α0))
            (borrow owner)) in
      M.alloc α1 in
    let* len : M.Val u32.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : usize.t :=
        M.call
          ((alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)::["len"]
            (borrow (multisig.Multisig.Get_owners (deref α0)))) in
      let* α2 : u32.t :=
        BinOp.Panic.sub (rust_cast α1) ((Integer.of_Z 1) : u32.t) in
      M.alloc α2 in
    let* requirement : M.Val u32.t :=
      let* α0 : u32.t -> u32.t -> M u32.t :=
        ltac:(M.get_method (fun ℐ =>
          core.cmp.Ord.min (Self := u32.t) (Trait := ℐ))) in
      let* α1 : u32.t := M.read len in
      let* α2 : mut_ref multisig.Multisig.t := M.read self in
      let* α3 : u32.t :=
        M.read (multisig.Multisig.Get_requirement (deref α2)) in
      let* α4 : u32.t := M.call (α0 α1 α3) in
      M.alloc α4 in
    let* _ : M.Val unit :=
      let* α0 : u32.t := M.read len in
      let* α1 : u32.t := M.read requirement in
      let* α2 : unit := M.call (multisig.ensure_requirement_is_valid α0 α1) in
      M.alloc α2 in
    let* owner_index : M.Val usize.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t :=
        M.call
          (multisig.Multisig.t::["owner_index"]
            (borrow (deref α0))
            (borrow owner)) in
      M.alloc (rust_cast α1) in
    let* _ : M.Val multisig.AccountId.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : usize.t := M.read owner_index in
      let* α2 : multisig.AccountId.t :=
        M.call
          ((alloc.vec.Vec.t
                multisig.AccountId.t
                alloc.alloc.Global.t)::["swap_remove"]
            (borrow_mut (multisig.Multisig.Get_owners (deref α0)))
            α1) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.AccountId.t := M.read owner in
      let* α2 : unit :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["remove"]
            (borrow (multisig.Multisig.Get_is_owner (deref α0)))
            α1) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read requirement in
      assign (multisig.Multisig.Get_requirement (deref α0)) α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["clean_owner_confirmations"]
            α0
            (borrow owner)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t := M.read owner in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.OwnerRemoval
              {| multisig.OwnerRemoval.owner := α3; |})) in
      M.alloc α4 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_remove_owner :
    Notations.DoubleColon Self "remove_owner" := {
    Notations.double_colon := remove_owner;
  }.
  
  (*
      pub fn replace_owner(&mut self, old_owner: AccountId, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&old_owner);
          self.ensure_no_owner(&new_owner);
          let owner_index = self.owner_index(&old_owner);
          self.owners[owner_index as usize] = new_owner;
          self.is_owner.remove(old_owner);
          self.is_owner.insert(new_owner, ());
          self.clean_owner_confirmations(&old_owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner: old_owner }));
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition replace_owner
      (self : mut_ref Self)
      (old_owner : multisig.AccountId.t)
      (new_owner : multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* old_owner := M.alloc old_owner in
    let* new_owner := M.alloc new_owner in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_from_wallet"] (borrow (deref α0))) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_owner"]
            (borrow (deref α0))
            (borrow old_owner)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_no_owner"]
            (borrow (deref α0))
            (borrow new_owner)) in
      M.alloc α1 in
    let* owner_index : M.Val u32.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t :=
        M.call
          (multisig.Multisig.t::["owner_index"]
            (borrow (deref α0))
            (borrow old_owner)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 :
          (mut_ref (alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t))
            ->
            usize.t ->
            M (mut_ref _) :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.index.IndexMut.index_mut
            (Self := alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
            (Idx := usize.t)
            (Trait := ℐ))) in
      let* α1 : mut_ref multisig.Multisig.t := M.read self in
      let* α2 : u32.t := M.read owner_index in
      let* α3 : mut_ref multisig.AccountId.t :=
        M.call
          (α0
            (borrow_mut (multisig.Multisig.Get_owners (deref α1)))
            (rust_cast α2)) in
      let* α4 : multisig.AccountId.t := M.read new_owner in
      assign (deref α3) α4 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.AccountId.t := M.read old_owner in
      let* α2 : unit :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["remove"]
            (borrow (multisig.Multisig.Get_is_owner (deref α0)))
            α1) in
      M.alloc α2 in
    let* _ : M.Val (core.option.Option.t u32.t) :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.AccountId.t := M.read new_owner in
      let* α2 : core.option.Option.t u32.t :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["insert"]
            (borrow_mut (multisig.Multisig.Get_is_owner (deref α0)))
            α1
            tt) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["clean_owner_confirmations"]
            α0
            (borrow old_owner)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t := M.read old_owner in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.OwnerRemoval
              {| multisig.OwnerRemoval.owner := α3; |})) in
      M.alloc α4 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t := M.read new_owner in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.OwnerAddition
              {| multisig.OwnerAddition.owner := α3; |})) in
      M.alloc α4 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_replace_owner :
    Notations.DoubleColon Self "replace_owner" := {
    Notations.double_colon := replace_owner;
  }.
  
  (*
      pub fn change_requirement(&mut self, new_requirement: u32) {
          self.ensure_from_wallet();
          ensure_requirement_is_valid(self.owners.len() as u32, new_requirement);
          self.requirement = new_requirement;
          self.env()
              .emit_event(Event::RequirementChange(RequirementChange {
                  new_requirement,
              }));
      }
  *)
  Definition change_requirement
      (self : mut_ref Self)
      (new_requirement : u32.t)
      : M unit :=
    let* self := M.alloc self in
    let* new_requirement := M.alloc new_requirement in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_from_wallet"] (borrow (deref α0))) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : usize.t :=
        M.call
          ((alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)::["len"]
            (borrow (multisig.Multisig.Get_owners (deref α0)))) in
      let* α2 : u32.t := M.read new_requirement in
      let* α3 : unit :=
        M.call (multisig.ensure_requirement_is_valid (rust_cast α1) α2) in
      M.alloc α3 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read new_requirement in
      assign (multisig.Multisig.Get_requirement (deref α0)) α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : u32.t := M.read new_requirement in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.RequirementChange
              {| multisig.RequirementChange.new_requirement := α3; |})) in
      M.alloc α4 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_change_requirement :
    Notations.DoubleColon Self "change_requirement" := {
    Notations.double_colon := change_requirement;
  }.
  
  (*
      fn confirm_by_caller(
          &mut self,
          confirmer: AccountId,
          transaction: TransactionId,
      ) -> ConfirmationStatus {
          let mut count = self
              .confirmation_count
              .get(&transaction)
              .unwrap_or(0 as u32);
          let key = (transaction, confirmer);
          let new_confirmation = !self.confirmations.contains(&key);
          if new_confirmation {
              count += 1;
              self.confirmations.insert(key, ());
              self.confirmation_count.insert(transaction, count);
          }
          let status = {
              if count >= self.requirement {
                  ConfirmationStatus::Confirmed
              } else {
                  ConfirmationStatus::ConfirmationsNeeded(self.requirement - count)
              }
          };
          if new_confirmation {
              self.env().emit_event(Event::Confirmation(Confirmation {
                  transaction,
                  from: confirmer,
                  status,
              }));
          }
          status
      }
  *)
  Definition confirm_by_caller
      (self : mut_ref Self)
      (confirmer : multisig.AccountId.t)
      (transaction : ltac:(multisig.TransactionId))
      : M multisig.ConfirmationStatus.t :=
    let* self := M.alloc self in
    let* confirmer := M.alloc confirmer in
    let* transaction := M.alloc transaction in
    let* count : M.Val u32.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : core.option.Option.t u32.t :=
        M.call
          ((multisig.Mapping.t u32.t u32.t)::["get"]
            (borrow (multisig.Multisig.Get_confirmation_count (deref α0)))
            (borrow transaction)) in
      let* α2 : M.Val u32.t := M.alloc ((Integer.of_Z 0) : u32.t) in
      let* α3 : u32.t := M.read (use α2) in
      let* α4 : u32.t :=
        M.call ((core.option.Option.t u32.t)::["unwrap_or"] α1 α3) in
      M.alloc α4 in
    let* key : M.Val (u32.t * multisig.AccountId.t) :=
      let* α0 : u32.t := M.read transaction in
      let* α1 : multisig.AccountId.t := M.read confirmer in
      M.alloc (α0, α1) in
    let* new_confirmation : M.Val bool.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : bool.t :=
        M.call
          ((multisig.Mapping.t
                (u32.t * multisig.AccountId.t)
                unit)::["contains"]
            (borrow (multisig.Multisig.Get_confirmations (deref α0)))
            (borrow key)) in
      M.alloc (UnOp.not α1) in
    let* _ : M.Val unit :=
      let* α0 : bool.t := M.read (use new_confirmation) in
      if α0 then
        let* _ : M.Val unit :=
          let β : M.Val u32.t := count in
          let* α0 := M.read β in
          let* α1 := BinOp.Panic.add α0 ((Integer.of_Z 1) : u32.t) in
          assign β α1 in
        let* _ : M.Val (core.option.Option.t u32.t) :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t * multisig.AccountId.t := M.read key in
          let* α2 : core.option.Option.t u32.t :=
            M.call
              ((multisig.Mapping.t
                    (u32.t * multisig.AccountId.t)
                    unit)::["insert"]
                (borrow_mut (multisig.Multisig.Get_confirmations (deref α0)))
                α1
                tt) in
          M.alloc α2 in
        let* _ : M.Val (core.option.Option.t u32.t) :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read transaction in
          let* α2 : u32.t := M.read count in
          let* α3 : core.option.Option.t u32.t :=
            M.call
              ((multisig.Mapping.t u32.t u32.t)::["insert"]
                (borrow_mut
                  (multisig.Multisig.Get_confirmation_count (deref α0)))
                α1
                α2) in
          M.alloc α3 in
        M.alloc tt
      else
        M.alloc tt in
    let* status : M.Val multisig.ConfirmationStatus.t :=
      let* α0 : u32.t := M.read count in
      let* α1 : mut_ref multisig.Multisig.t := M.read self in
      let* α2 : u32.t :=
        M.read (multisig.Multisig.Get_requirement (deref α1)) in
      let* α3 : M.Val bool.t := M.alloc (BinOp.Pure.ge α0 α2) in
      let* α4 : bool.t := M.read (use α3) in
      let* α5 : M.Val multisig.ConfirmationStatus.t :=
        if α4 then
          M.alloc multisig.ConfirmationStatus.Confirmed
        else
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t :=
            M.read (multisig.Multisig.Get_requirement (deref α0)) in
          let* α2 : u32.t := M.read count in
          let* α3 : u32.t := BinOp.Panic.sub α1 α2 in
          M.alloc (multisig.ConfirmationStatus.ConfirmationsNeeded α3) in
      M.copy α5 in
    let* _ : M.Val unit :=
      let* α0 : bool.t := M.read (use new_confirmation) in
      if α0 then
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : multisig.Env.t :=
            M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
          let* α2 : M.Val multisig.Env.t := M.alloc α1 in
          let* α3 : u32.t := M.read transaction in
          let* α4 : multisig.AccountId.t := M.read confirmer in
          let* α5 : multisig.ConfirmationStatus.t := M.read status in
          let* α6 : unit :=
            M.call
              (multisig.Env.t::["emit_event"]
                (borrow α2)
                (multisig.Event.Confirmation
                  {|
                    multisig.Confirmation.transaction := α3;
                    multisig.Confirmation.from := α4;
                    multisig.Confirmation.status := α5;
                  |})) in
          M.alloc α6 in
        M.alloc tt
      else
        M.alloc tt in
    M.read status.
  
  Global Instance AssociatedFunction_confirm_by_caller :
    Notations.DoubleColon Self "confirm_by_caller" := {
    Notations.double_colon := confirm_by_caller;
  }.
  
  (*
      pub fn submit_transaction(
          &mut self,
          transaction: Transaction,
      ) -> (TransactionId, ConfirmationStatus) {
          self.ensure_caller_is_owner();
          let trans_id = self.transaction_list.next_id;
          self.transaction_list.next_id = trans_id
              .checked_add(1 as u32)
              .expect("Transaction ids exhausted.");
          self.transactions.insert(trans_id, transaction);
          self.transaction_list.transactions.push(trans_id);
          self.env().emit_event(Event::Submission(Submission {
              transaction: trans_id,
          }));
          (
              trans_id,
              self.confirm_by_caller(self.env().caller(), trans_id),
          )
      }
  *)
  Definition submit_transaction
      (self : mut_ref Self)
      (transaction : multisig.Transaction.t)
      : M (ltac:(multisig.TransactionId) * multisig.ConfirmationStatus.t) :=
    let* self := M.alloc self in
    let* transaction := M.alloc transaction in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_caller_is_owner"]
            (borrow (deref α0))) in
      M.alloc α1 in
    let* trans_id : M.Val u32.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      M.copy
        (multisig.Transactions.Get_next_id
          (multisig.Multisig.Get_transaction_list (deref α0))) in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : M.Val u32.t := M.alloc ((Integer.of_Z 1) : u32.t) in
      let* α3 : u32.t := M.read (use α2) in
      let* α4 : core.option.Option.t u32.t :=
        M.call (u32.t::["checked_add"] α1 α3) in
      let* α5 : ref str.t := M.read (mk_str "Transaction ids exhausted.") in
      let* α6 : u32.t :=
        M.call ((core.option.Option.t u32.t)::["expect"] α4 α5) in
      assign
        (multisig.Transactions.Get_next_id
          (multisig.Multisig.Get_transaction_list (deref α0)))
        α6 in
    let* _ : M.Val (core.option.Option.t u32.t) :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : multisig.Transaction.t := M.read transaction in
      let* α3 : core.option.Option.t u32.t :=
        M.call
          ((multisig.Mapping.t u32.t multisig.Transaction.t)::["insert"]
            (borrow_mut (multisig.Multisig.Get_transactions (deref α0)))
            α1
            α2) in
      M.alloc α3 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : unit :=
        M.call
          ((alloc.vec.Vec.t u32.t alloc.alloc.Global.t)::["push"]
            (borrow_mut
              (multisig.Transactions.Get_transactions
                (multisig.Multisig.Get_transaction_list (deref α0))))
            α1) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : u32.t := M.read trans_id in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.Submission
              {| multisig.Submission.transaction := α3; |})) in
      M.alloc α4 in
    let* α0 : u32.t := M.read trans_id in
    let* α1 : mut_ref multisig.Multisig.t := M.read self in
    let* α2 : mut_ref multisig.Multisig.t := M.read self in
    let* α3 : multisig.Env.t :=
      M.call (multisig.Multisig.t::["env"] (borrow (deref α2))) in
    let* α4 : M.Val multisig.Env.t := M.alloc α3 in
    let* α5 : multisig.AccountId.t :=
      M.call (multisig.Env.t::["caller"] (borrow α4)) in
    let* α6 : u32.t := M.read trans_id in
    let* α7 : multisig.ConfirmationStatus.t :=
      M.call (multisig.Multisig.t::["confirm_by_caller"] α1 α5 α6) in
    let* α0 : M.Val (u32.t * multisig.ConfirmationStatus.t) :=
      M.alloc (α0, α7) in
    M.read α0.
  
  Global Instance AssociatedFunction_submit_transaction :
    Notations.DoubleColon Self "submit_transaction" := {
    Notations.double_colon := submit_transaction;
  }.
  
  (*
      fn take_transaction(&mut self, trans_id: TransactionId) -> Option<Transaction> {
          let transaction = self.transactions.get(&trans_id);
          if transaction.is_some() {
              self.transactions.remove(trans_id);
              let pos = self
                  .transaction_list
                  .transactions
                  .iter()
                  .position(|t| t == &trans_id)
                  .expect("The transaction exists hence it must also be in the list.");
              self.transaction_list.transactions.swap_remove(pos);
              for owner in self.owners.iter() {
                  self.confirmations.remove((trans_id, *owner));
              }
              self.confirmation_count.remove(trans_id);
          }
          transaction
      }
  *)
  Definition take_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M (core.option.Option.t multisig.Transaction.t) :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* transaction : M.Val (core.option.Option.t multisig.Transaction.t) :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : core.option.Option.t multisig.Transaction.t :=
        M.call
          ((multisig.Mapping.t u32.t multisig.Transaction.t)::["get"]
            (borrow (multisig.Multisig.Get_transactions (deref α0)))
            (borrow trans_id)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : bool.t :=
        M.call
          ((core.option.Option.t multisig.Transaction.t)::["is_some"]
            (borrow transaction)) in
      let* α1 : M.Val bool.t := M.alloc α0 in
      let* α2 : bool.t := M.read (use α1) in
      if α2 then
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read trans_id in
          let* α2 : unit :=
            M.call
              ((multisig.Mapping.t u32.t multisig.Transaction.t)::["remove"]
                (borrow (multisig.Multisig.Get_transactions (deref α0)))
                α1) in
          M.alloc α2 in
        let* pos : M.Val usize.t :=
          let* α0 :
              (mut_ref (core.slice.iter.Iter.t u32.t)) ->
                ((ref u32.t) -> M bool.t) ->
                M (core.option.Option.t usize.t) :=
            ltac:(M.get_method (fun ℐ =>
              core.iter.traits.iterator.Iterator.position
                (Self := core.slice.iter.Iter.t u32.t)
                (P := (ref u32.t) -> M bool.t)
                (Trait := ℐ))) in
          let* α1 :
              (ref (alloc.vec.Vec.t u32.t alloc.alloc.Global.t)) -> M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self := alloc.vec.Vec.t u32.t alloc.alloc.Global.t)
                (Trait := ℐ))) in
          let* α2 : mut_ref multisig.Multisig.t := M.read self in
          let* α3 : ref (slice u32.t) :=
            M.call
              (α1
                (borrow
                  (multisig.Transactions.Get_transactions
                    (multisig.Multisig.Get_transaction_list (deref α2))))) in
          let* α4 : core.slice.iter.Iter.t u32.t :=
            M.call ((slice u32.t)::["iter"] α3) in
          let* α5 : M.Val (core.slice.iter.Iter.t u32.t) := M.alloc α4 in
          let* α6 : core.option.Option.t usize.t :=
            M.call
              (α0
                (borrow_mut α5)
                (fun (α0 : ref u32.t) =>
                  (let* α0 := M.alloc α0 in
                  match_operator
                    α0
                    [
                      fun γ =>
                        (let* t := M.copy γ in
                        let* α0 :
                            (ref (ref u32.t)) ->
                              (ref (ref u32.t)) ->
                              M bool.t :=
                          ltac:(M.get_method (fun ℐ =>
                            core.cmp.PartialEq.eq
                              (Self := ref u32.t)
                              (Rhs := ref u32.t)
                              (Trait := ℐ))) in
                        let* α1 : M.Val (ref u32.t) :=
                          M.alloc (borrow trans_id) in
                        M.call (α0 (borrow t) (borrow α1))) :
                        M bool.t
                    ]) :
                  M bool.t)) in
          let* α7 : ref str.t :=
            M.read
              (mk_str
                "The transaction exists hence it must also be in the list.") in
          let* α8 : usize.t :=
            M.call ((core.option.Option.t usize.t)::["expect"] α6 α7) in
          M.alloc α8 in
        let* _ : M.Val u32.t :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : usize.t := M.read pos in
          let* α2 : u32.t :=
            M.call
              ((alloc.vec.Vec.t u32.t alloc.alloc.Global.t)::["swap_remove"]
                (borrow_mut
                  (multisig.Transactions.Get_transactions
                    (multisig.Multisig.Get_transaction_list (deref α0))))
                α1) in
          M.alloc α2 in
        let* _ : M.Val unit :=
          let* α0 : (core.slice.iter.Iter.t multisig.AccountId.t) -> M _ :=
            ltac:(M.get_method (fun ℐ =>
              core.iter.traits.collect.IntoIterator.into_iter
                (Self := core.slice.iter.Iter.t multisig.AccountId.t)
                (Trait := ℐ))) in
          let* α1 :
              (ref (alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t))
                ->
                M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self :=
                  alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
                (Trait := ℐ))) in
          let* α2 : mut_ref multisig.Multisig.t := M.read self in
          let* α3 : ref (slice multisig.AccountId.t) :=
            M.call (α1 (borrow (multisig.Multisig.Get_owners (deref α2)))) in
          let* α4 : core.slice.iter.Iter.t multisig.AccountId.t :=
            M.call ((slice multisig.AccountId.t)::["iter"] α3) in
          let* α5 : core.slice.iter.Iter.t multisig.AccountId.t :=
            M.call (α0 α4) in
          let* α6 : M.Val (core.slice.iter.Iter.t multisig.AccountId.t) :=
            M.alloc α5 in
          let* α7 : M.Val unit :=
            match_operator
              α6
              [
                fun γ =>
                  (let* iter := M.copy γ in
                  M.loop
                    (let* _ : M.Val unit :=
                      let* α0 :
                          (mut_ref
                              (core.slice.iter.Iter.t multisig.AccountId.t))
                            ->
                            M (core.option.Option.t _) :=
                        ltac:(M.get_method (fun ℐ =>
                          core.iter.traits.iterator.Iterator.next
                            (Self :=
                              core.slice.iter.Iter.t multisig.AccountId.t)
                            (Trait := ℐ))) in
                      let* α1 :
                          core.option.Option.t (ref multisig.AccountId.t) :=
                        M.call (α0 (borrow_mut iter)) in
                      let* α2 :
                          M.Val
                            (core.option.Option.t (ref multisig.AccountId.t)) :=
                        M.alloc α1 in
                      match_operator
                        α2
                        [
                          fun γ =>
                            (let* α0 := M.read γ in
                            match α0 with
                            | core.option.Option.None =>
                              let* α0 : M.Val never.t := M.break in
                              let* α1 := M.read α0 in
                              let* α2 : unit := never_to_any α1 in
                              M.alloc α2
                            | _ => M.break_match
                            end) :
                            M (M.Val unit);
                          fun γ =>
                            (let* α0 := M.read γ in
                            match α0 with
                            | core.option.Option.Some _ =>
                              let γ0_0 := core.option.Option.Get_Some_0 γ in
                              let* owner := M.copy γ0_0 in
                              let* _ : M.Val unit :=
                                let* α0 : mut_ref multisig.Multisig.t :=
                                  M.read self in
                                let* α1 : u32.t := M.read trans_id in
                                let* α2 : ref multisig.AccountId.t :=
                                  M.read owner in
                                let* α3 : multisig.AccountId.t :=
                                  M.read (deref α2) in
                                let* α4 : unit :=
                                  M.call
                                    ((multisig.Mapping.t
                                          (u32.t * multisig.AccountId.t)
                                          unit)::["remove"]
                                      (borrow
                                        (multisig.Multisig.Get_confirmations
                                          (deref α0)))
                                      (α1, α3)) in
                                M.alloc α4 in
                              M.alloc tt
                            | _ => M.break_match
                            end) :
                            M (M.Val unit)
                        ] in
                    M.alloc tt)) :
                  M (M.Val unit)
              ] in
          M.pure (use α7) in
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read trans_id in
          let* α2 : unit :=
            M.call
              ((multisig.Mapping.t u32.t u32.t)::["remove"]
                (borrow (multisig.Multisig.Get_confirmation_count (deref α0)))
                α1) in
          M.alloc α2 in
        M.alloc tt
      else
        M.alloc tt in
    M.read transaction.
  
  Global Instance AssociatedFunction_take_transaction :
    Notations.DoubleColon Self "take_transaction" := {
    Notations.double_colon := take_transaction;
  }.
  
  (*
      pub fn cancel_transaction(&mut self, trans_id: TransactionId) {
          self.ensure_from_wallet();
          if self.take_transaction(trans_id).is_some() {
              self.env().emit_event(Event::Cancellation(Cancellation {
                  transaction: trans_id,
              }));
          }
      }
  *)
  Definition cancel_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_from_wallet"] (borrow (deref α0))) in
      M.alloc α1 in
    let* α0 : mut_ref multisig.Multisig.t := M.read self in
    let* α1 : u32.t := M.read trans_id in
    let* α2 : core.option.Option.t multisig.Transaction.t :=
      M.call (multisig.Multisig.t::["take_transaction"] α0 α1) in
    let* α3 : M.Val (core.option.Option.t multisig.Transaction.t) :=
      M.alloc α2 in
    let* α4 : bool.t :=
      M.call
        ((core.option.Option.t multisig.Transaction.t)::["is_some"]
          (borrow α3)) in
    let* α5 : M.Val bool.t := M.alloc α4 in
    let* α6 : bool.t := M.read (use α5) in
    let* α0 : M.Val unit :=
      if α6 then
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : multisig.Env.t :=
            M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
          let* α2 : M.Val multisig.Env.t := M.alloc α1 in
          let* α3 : u32.t := M.read trans_id in
          let* α4 : unit :=
            M.call
              (multisig.Env.t::["emit_event"]
                (borrow α2)
                (multisig.Event.Cancellation
                  {| multisig.Cancellation.transaction := α3; |})) in
          M.alloc α4 in
        M.alloc tt
      else
        M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_cancel_transaction :
    Notations.DoubleColon Self "cancel_transaction" := {
    Notations.double_colon := cancel_transaction;
  }.
  
  (*
      pub fn confirm_transaction(&mut self, trans_id: TransactionId) -> ConfirmationStatus {
          self.ensure_caller_is_owner();
          self.ensure_transaction_exists(trans_id);
          self.confirm_by_caller(self.env().caller(), trans_id)
      }
  *)
  Definition confirm_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M multisig.ConfirmationStatus.t :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_caller_is_owner"]
            (borrow (deref α0))) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_transaction_exists"]
            (borrow (deref α0))
            α1) in
      M.alloc α2 in
    let* α0 : mut_ref multisig.Multisig.t := M.read self in
    let* α1 : mut_ref multisig.Multisig.t := M.read self in
    let* α2 : multisig.Env.t :=
      M.call (multisig.Multisig.t::["env"] (borrow (deref α1))) in
    let* α3 : M.Val multisig.Env.t := M.alloc α2 in
    let* α4 : multisig.AccountId.t :=
      M.call (multisig.Env.t::["caller"] (borrow α3)) in
    let* α5 : u32.t := M.read trans_id in
    let* α6 : multisig.ConfirmationStatus.t :=
      M.call (multisig.Multisig.t::["confirm_by_caller"] α0 α4 α5) in
    let* α0 : M.Val multisig.ConfirmationStatus.t := M.alloc α6 in
    M.read α0.
  
  Global Instance AssociatedFunction_confirm_transaction :
    Notations.DoubleColon Self "confirm_transaction" := {
    Notations.double_colon := confirm_transaction;
  }.
  
  (*
      pub fn revoke_confirmation(&mut self, trans_id: TransactionId) {
          self.ensure_caller_is_owner();
          let caller = self.env().caller();
          if self.confirmations.contains(&(trans_id, caller)) {
              self.confirmations.remove((trans_id, caller));
              let mut confirmation_count = self
                  .confirmation_count
                  .get(&trans_id)
                  .expect("There is a entry in `self.confirmations`. Hence a count must exit.");
              // Will not underflow as there is at least one confirmation
              confirmation_count -= 1;
              self.confirmation_count.insert(trans_id, confirmation_count);
              self.env().emit_event(Event::Revocation(Revocation {
                  transaction: trans_id,
                  from: caller,
              }));
          }
      }
  *)
  Definition revoke_confirmation
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_caller_is_owner"]
            (borrow (deref α0))) in
      M.alloc α1 in
    let* caller : M.Val multisig.AccountId.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t :=
        M.call (multisig.Env.t::["caller"] (borrow α2)) in
      M.alloc α3 in
    let* α0 : mut_ref multisig.Multisig.t := M.read self in
    let* α1 : u32.t := M.read trans_id in
    let* α2 : multisig.AccountId.t := M.read caller in
    let* α3 : M.Val (u32.t * multisig.AccountId.t) := M.alloc (α1, α2) in
    let* α4 : bool.t :=
      M.call
        ((multisig.Mapping.t (u32.t * multisig.AccountId.t) unit)::["contains"]
          (borrow (multisig.Multisig.Get_confirmations (deref α0)))
          (borrow α3)) in
    let* α5 : M.Val bool.t := M.alloc α4 in
    let* α6 : bool.t := M.read (use α5) in
    let* α0 : M.Val unit :=
      if α6 then
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read trans_id in
          let* α2 : multisig.AccountId.t := M.read caller in
          let* α3 : unit :=
            M.call
              ((multisig.Mapping.t
                    (u32.t * multisig.AccountId.t)
                    unit)::["remove"]
                (borrow (multisig.Multisig.Get_confirmations (deref α0)))
                (α1, α2)) in
          M.alloc α3 in
        let* confirmation_count : M.Val u32.t :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : core.option.Option.t u32.t :=
            M.call
              ((multisig.Mapping.t u32.t u32.t)::["get"]
                (borrow (multisig.Multisig.Get_confirmation_count (deref α0)))
                (borrow trans_id)) in
          let* α2 : ref str.t :=
            M.read
              (mk_str
                "There is a entry in `self.confirmations`. Hence a count must exit.") in
          let* α3 : u32.t :=
            M.call ((core.option.Option.t u32.t)::["expect"] α1 α2) in
          M.alloc α3 in
        let* _ : M.Val unit :=
          let β : M.Val u32.t := confirmation_count in
          let* α0 := M.read β in
          let* α1 := BinOp.Panic.sub α0 ((Integer.of_Z 1) : u32.t) in
          assign β α1 in
        let* _ : M.Val (core.option.Option.t u32.t) :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read trans_id in
          let* α2 : u32.t := M.read confirmation_count in
          let* α3 : core.option.Option.t u32.t :=
            M.call
              ((multisig.Mapping.t u32.t u32.t)::["insert"]
                (borrow_mut
                  (multisig.Multisig.Get_confirmation_count (deref α0)))
                α1
                α2) in
          M.alloc α3 in
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : multisig.Env.t :=
            M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
          let* α2 : M.Val multisig.Env.t := M.alloc α1 in
          let* α3 : u32.t := M.read trans_id in
          let* α4 : multisig.AccountId.t := M.read caller in
          let* α5 : unit :=
            M.call
              (multisig.Env.t::["emit_event"]
                (borrow α2)
                (multisig.Event.Revocation
                  {|
                    multisig.Revocation.transaction := α3;
                    multisig.Revocation.from := α4;
                  |})) in
          M.alloc α5 in
        M.alloc tt
      else
        M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_revoke_confirmation :
    Notations.DoubleColon Self "revoke_confirmation" := {
    Notations.double_colon := revoke_confirmation;
  }.
  
  (*
      pub fn invoke_transaction(&mut self, trans_id: TransactionId) -> Result<(), Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          assert!(self.env().transferred_value() == t.transferred_value);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<()>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(_)) => Ok(()),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.map(|_| None),
          }));
          result
      }
  *)
  Definition invoke_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M (core.result.Result.t unit multisig.Error.t) :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_confirmed"] (borrow (deref α0)) α1) in
      M.alloc α2 in
    let* t : M.Val multisig.Transaction.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : core.option.Option.t multisig.Transaction.t :=
        M.call (multisig.Multisig.t::["take_transaction"] α0 α1) in
      let* α3 : ref str.t := M.read multisig.WRONG_TRANSACTION_ID in
      let* α4 : multisig.Transaction.t :=
        M.call
          ((core.option.Option.t multisig.Transaction.t)::["expect"] α2 α3) in
      M.alloc α4 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : u128.t :=
        M.call (multisig.Env.t::["transferred_value"] (borrow α2)) in
      let* α4 : u128.t :=
        M.read (multisig.Transaction.Get_transferred_value t) in
      let* α5 : M.Val bool.t := M.alloc (UnOp.not (BinOp.Pure.eq α3 α4)) in
      let* α6 : bool.t := M.read (use α5) in
      if α6 then
        let* α0 : ref str.t :=
          M.read
            (mk_str
              "assertion failed: self.env().transferred_value() == t.transferred_value") in
        let* α1 : never.t := M.call (core.panicking.panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* result :
        M.Val
          (core.result.Result.t
            (core.result.Result.t
              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
              unit)
            unit) :=
      let* α0 : ref str.t := M.read (mk_str "not yet implemented") in
      let* α1 : never.t := M.call (core.panicking.panic α0) in
      let* α2 :
          core.result.Result.t
            (core.result.Result.t
              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
              unit)
            unit :=
        never_to_any α1 in
      M.alloc α2 in
    let* result : M.Val (core.result.Result.t unit multisig.Error.t) :=
      let* α0 : M.Val (core.result.Result.t unit multisig.Error.t) :=
        match_operator
          result
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.result.Result.Ok _ =>
                let γ0_0 := core.result.Result.Get_Ok_0 γ in
                let* α0 := M.read γ0_0 in
                match α0 with
                | core.result.Result.Ok _ =>
                  let γ1_0 := core.result.Result.Get_Ok_0 γ0_0 in
                  M.alloc (core.result.Result.Ok tt)
                | _ => M.break_match
                end
              | _ => M.break_match
              end) :
              M (M.Val (core.result.Result.t unit multisig.Error.t));
            fun γ =>
              (M.alloc
                (core.result.Result.Err multisig.Error.TransactionFailed)) :
              M (M.Val (core.result.Result.t unit multisig.Error.t))
          ] in
      M.copy α0 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : u32.t := M.read trans_id in
      let* α4 : core.result.Result.t unit multisig.Error.t := M.read result in
      let* α5 :
          core.result.Result.t
            (core.option.Option.t (alloc.vec.Vec.t u8.t alloc.alloc.Global.t))
            multisig.Error.t :=
        M.call
          ((core.result.Result.t unit multisig.Error.t)::["map"]
            α4
            (fun (α0 : unit) =>
              (let* α0 := M.alloc α0 in
              match_operator
                α0
                [
                  fun γ =>
                    (M.pure core.option.Option.None) :
                    M
                      (core.option.Option.t
                        (alloc.vec.Vec.t u8.t alloc.alloc.Global.t))
                ]) :
              M
                (core.option.Option.t
                  (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)))) in
      let* α6 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.Execution
              {|
                multisig.Execution.transaction := α3;
                multisig.Execution.result := α5;
              |})) in
      M.alloc α6 in
    M.read result.
  
  Global Instance AssociatedFunction_invoke_transaction :
    Notations.DoubleColon Self "invoke_transaction" := {
    Notations.double_colon := invoke_transaction;
  }.
  
  (*
      pub fn eval_transaction(&mut self, trans_id: TransactionId) -> Result<Vec<u8>, Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<Vec<u8>>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(v)) => Ok(v),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.clone().map(Some),
          }));
          result
      }
  *)
  Parameter eval_transaction :
      (mut_ref Self) ->
        ltac:(multisig.TransactionId) ->
        M
          (core.result.Result.t
            (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
            multisig.Error.t).
  
  Global Instance AssociatedFunction_eval_transaction :
    Notations.DoubleColon Self "eval_transaction" := {
    Notations.double_colon := eval_transaction;
  }.
End Impl_multisig_Multisig_t.
End Impl_multisig_Multisig_t.
