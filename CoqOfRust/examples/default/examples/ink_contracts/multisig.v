(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* StructRecord
  {
    name := "Mapping";
    ty_params := [ "K"; "V" ];
    fields :=
      [
        ("_key", Ty.apply (Ty.path "core::marker::PhantomData") [ K ] []);
        ("_value", Ty.apply (Ty.path "core::marker::PhantomData") [ V ] [])
      ];
  } *)

Module Impl_core_default_Default_for_multisig_Mapping_K_V.
  Definition Self (K V : Ty.t) : Ty.t := Ty.apply (Ty.path "multisig::Mapping") [ K; V ] [].
  
  (*
  Default
  *)
  Definition default (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self K V in
    match τ, α with
    | [], [] =>
      let* α0 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply (Ty.path "core::marker::PhantomData") [ K ] [])
          []
          []
          "default"
          []
          [] in
      let* α1 := M.call_closure α0 [] in
      let* α2 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply (Ty.path "core::marker::PhantomData") [ V ] [])
          []
          []
          "default"
          []
          [] in
      let* α3 := M.call_closure α2 [] in
      M.pure (Value.StructRecord "multisig::Mapping" [ ("_key", α1); ("_value", α3) ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (K V : Ty.t),
    M.IsTraitInstance
      "core::default::Default"
      (Self K V)
      (* Trait polymorphic types *) []
      (* Instance *) [ ("default", InstanceField.Method (default K V)) ].
End Impl_core_default_Default_for_multisig_Mapping_K_V.

Module Impl_multisig_Mapping_K_V.
  Definition Self (K V : Ty.t) : Ty.t := Ty.apply (Ty.path "multisig::Mapping") [ K; V ] [].
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self K V in
    match τ, α with
    | [], [ self; _key ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_contains :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "contains" (contains K V).
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self K V in
    match τ, α with
    | [], [ self; _key ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "get" (get K V).
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self K V in
    match τ, α with
    | [], [ self; _key; _value ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* _value := M.alloc _value in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_insert :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "insert" (insert K V).
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self K V in
    match τ, α with
    | [], [ self; _key ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_remove :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "remove" (remove K V).
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self K V in
    match τ, α with
    | [], [ self; _key ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_size :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "size" (size K V).
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self K V in
    match τ, α with
    | [], [ self; _key ] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_take :
    forall (K V : Ty.t),
    M.IsAssociatedFunction (Self K V) "take" (take K V).
End Impl_multisig_Mapping_K_V.

(* StructTuple
  {
    name := "AccountId";
    ty_params := [];
    fields := [ Ty.path "u128" ];
  } *)

Module Impl_core_default_Default_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  Default
  *)
  Definition default (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* α0 :=
        M.get_trait_method "core::default::Default" (Ty.path "u128") [] [] "default" [] [] in
      let* α1 := M.call_closure α0 [] in
      M.pure (Value.StructTuple "multisig::AccountId" [ α1 ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_multisig_AccountId.

Module Impl_core_fmt_Debug_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  Debug
  *)
  Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* α0 :=
        M.get_associated_function
          (Ty.path "core::fmt::Formatter")
          "debug_tuple_field1_finish"
          []
          [] in
      let* α1 := M.read f in
      let* α2 := M.read (mk_str "AccountId") in
      let* α5 :=
        (* Unsize *)
          let* α3 := M.read self in
          let* α4 := M.alloc (M.get_struct_tuple_field α3 "multisig::AccountId" 0) in
          M.pure (M.pointer_coercion α4) in
      M.call_closure α0 [ α1; α2; α5 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_multisig_AccountId.

Module Impl_core_clone_Clone_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  Clone
  *)
  Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.match_operator Value.DeclaredButUndefined [ fun γ => M.read self ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_multisig_AccountId.

Module Impl_core_marker_Copy_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  Axiom Implements :
    M.IsTraitInstance "core::marker::Copy" Self (* Trait polymorphic types *) [] (* Instance *) [].
End Impl_core_marker_Copy_for_multisig_AccountId.

Module Impl_core_marker_StructuralPartialEq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId.

Module Impl_core_cmp_PartialEq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  PartialEq
  *)
  Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 := M.read self in
      let* α1 := M.read (M.get_struct_tuple_field α0 "multisig::AccountId" 0) in
      let* α2 := M.read other in
      let* α3 := M.read (M.get_struct_tuple_field α2 "multisig::AccountId" 0) in
      M.pure (BinOp.Pure.eq α1 α3)
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_for_multisig_AccountId.

Module Impl_core_marker_StructuralEq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralEq_for_multisig_AccountId.

Module Impl_core_cmp_Eq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 :=
        M.match_operator Value.DeclaredButUndefined [ fun γ => M.alloc (Value.Tuple []) ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Eq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
End Impl_core_cmp_Eq_for_multisig_AccountId.

Module Impl_core_cmp_PartialOrd_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  PartialOrd
  *)
  Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 :=
        M.get_trait_method
          "core::cmp::PartialOrd"
          (Ty.path "u128")
          [ Ty.path "u128" ]
          []
          "partial_cmp"
          []
          [] in
      let* α1 := M.read self in
      let* α2 := M.read other in
      M.call_closure
        α0
        [
          M.get_struct_tuple_field α1 "multisig::AccountId" 0;
          M.get_struct_tuple_field α2 "multisig::AccountId" 0
        ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialOrd"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
End Impl_core_cmp_PartialOrd_for_multisig_AccountId.

Module Impl_core_cmp_Ord_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.path "multisig::AccountId".
  
  (*
  Ord
  *)
  Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 := M.get_trait_method "core::cmp::Ord" (Ty.path "u128") [] [] "cmp" [] [] in
      let* α1 := M.read self in
      let* α2 := M.read other in
      M.call_closure
        α0
        [
          M.get_struct_tuple_field α1 "multisig::AccountId" 0;
          M.get_struct_tuple_field α2 "multisig::AccountId" 0
        ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Ord"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
End Impl_core_cmp_Ord_for_multisig_AccountId.

Axiom Balance : (Ty.path "multisig::Balance") = (Ty.path "u128").

(* StructRecord
  {
    name := "Env";
    ty_params := [];
    fields := [ ("caller", Ty.path "multisig::AccountId") ];
  } *)

Definition value_MAX_OWNERS : Value.t := M.run (M.alloc (Value.Integer Integer.U32 50)).

Axiom TransactionId : (Ty.path "multisig::TransactionId") = (Ty.path "u32").

Definition value_WRONG_TRANSACTION_ID : Value.t :=
  M.run (M.pure (mk_str "The user specified an invalid transaction id. Abort.")).

(* StructTuple
  {
    name := "CallInput";
    ty_params := [];
    fields := [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] [] ] [] ];
  } *)

(* Enum ConfirmationStatus *)
(* {
  ty_params := [];
  variants :=
    [
      {
        name := "Confirmed";
        item := StructTuple [];
        discriminant := None;
      };
      {
        name := "ConfirmationsNeeded";
        item := StructTuple [ Ty.path "u32" ];
        discriminant := None;
      }
    ];
} *)

Module Impl_core_clone_Clone_for_multisig_ConfirmationStatus.
  Definition Self : Ty.t := Ty.path "multisig::ConfirmationStatus".
  
  (*
  Clone
  *)
  Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.match_operator Value.DeclaredButUndefined [ fun γ => M.read self ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus.

Module Impl_core_marker_Copy_for_multisig_ConfirmationStatus.
  Definition Self : Ty.t := Ty.path "multisig::ConfirmationStatus".
  
  Axiom Implements :
    M.IsTraitInstance "core::marker::Copy" Self (* Trait polymorphic types *) [] (* Instance *) [].
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus.

(* StructRecord
  {
    name := "Transaction";
    ty_params := [];
    fields :=
      [
        ("callee", Ty.path "multisig::AccountId");
        ("selector", Ty.apply (Ty.path "array") [ Ty.path "u8" ] [ Value.Integer Integer.Usize 4 ]);
        ("input",
          Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ] []);
        ("transferred_value", Ty.path "u128");
        ("gas_limit", Ty.path "u64");
        ("allow_reentry", Ty.path "bool")
      ];
  } *)

Module Impl_core_default_Default_for_multisig_Transaction.
  Definition Self : Ty.t := Ty.path "multisig::Transaction".
  
  (*
  Default
  *)
  Definition default (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* α0 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.path "multisig::AccountId")
          []
          []
          "default"
          []
          [] in
      let* α1 := M.call_closure α0 [] in
      let* α2 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply (Ty.path "array") [ Ty.path "u8" ] [ Value.Integer Integer.Usize 4 ])
          []
          []
          "default"
          []
          [] in
      let* α3 := M.call_closure α2 [] in
      let* α4 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ] [])
          []
          []
          "default"
          []
          [] in
      let* α5 := M.call_closure α4 [] in
      let* α6 :=
        M.get_trait_method "core::default::Default" (Ty.path "u128") [] [] "default" [] [] in
      let* α7 := M.call_closure α6 [] in
      let* α8 :=
        M.get_trait_method "core::default::Default" (Ty.path "u64") [] [] "default" [] [] in
      let* α9 := M.call_closure α8 [] in
      let* α10 :=
        M.get_trait_method "core::default::Default" (Ty.path "bool") [] [] "default" [] [] in
      let* α11 := M.call_closure α10 [] in
      M.pure
        (Value.StructRecord
          "multisig::Transaction"
          [
            ("callee", α1);
            ("selector", α3);
            ("input", α5);
            ("transferred_value", α7);
            ("gas_limit", α9);
            ("allow_reentry", α11)
          ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_multisig_Transaction.

(* Enum Error *)
(* {
  ty_params := [];
  variants :=
    [
      {
        name := "TransactionFailed";
        item := StructTuple [];
        discriminant := None;
      }
    ];
} *)

Module Impl_core_clone_Clone_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  (*
  Clone
  *)
  Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_multisig_Error.

Module Impl_core_marker_Copy_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  Axiom Implements :
    M.IsTraitInstance "core::marker::Copy" Self (* Trait polymorphic types *) [] (* Instance *) [].
End Impl_core_marker_Copy_for_multisig_Error.

Module Impl_core_marker_StructuralPartialEq_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_multisig_Error.

Module Impl_core_cmp_PartialEq_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  (*
  PartialEq
  *)
  Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.pure (Value.Bool true)
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_for_multisig_Error.

Module Impl_core_marker_StructuralEq_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralEq_for_multisig_Error.

Module Impl_core_cmp_Eq_for_multisig_Error.
  Definition Self : Ty.t := Ty.path "multisig::Error".
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      M.pure (Value.Tuple [])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Eq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
End Impl_core_cmp_Eq_for_multisig_Error.

(* StructRecord
  {
    name := "Transactions";
    ty_params := [];
    fields :=
      [
        ("transactions",
          Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ]
            []);
        ("next_id", Ty.path "u32")
      ];
  } *)

Module Impl_core_default_Default_for_multisig_Transactions.
  Definition Self : Ty.t := Ty.path "multisig::Transactions".
  
  (*
  Default
  *)
  Definition default (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* α0 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ]
            [])
          []
          []
          "default"
          []
          [] in
      let* α1 := M.call_closure α0 [] in
      let* α2 :=
        M.get_trait_method "core::default::Default" (Ty.path "u32") [] [] "default" [] [] in
      let* α3 := M.call_closure α2 [] in
      M.pure (Value.StructRecord "multisig::Transactions" [ ("transactions", α1); ("next_id", α3) ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_multisig_Transactions.

(* StructRecord
  {
    name := "Confirmation";
    ty_params := [];
    fields :=
      [
        ("transaction", Ty.path "u32");
        ("from", Ty.path "multisig::AccountId");
        ("status", Ty.path "multisig::ConfirmationStatus")
      ];
  } *)

(* StructRecord
  {
    name := "Revocation";
    ty_params := [];
    fields := [ ("transaction", Ty.path "u32"); ("from", Ty.path "multisig::AccountId") ];
  } *)

(* StructRecord
  {
    name := "Submission";
    ty_params := [];
    fields := [ ("transaction", Ty.path "u32") ];
  } *)

(* StructRecord
  {
    name := "Cancellation";
    ty_params := [];
    fields := [ ("transaction", Ty.path "u32") ];
  } *)

(* StructRecord
  {
    name := "Execution";
    ty_params := [];
    fields :=
      [
        ("transaction", Ty.path "u32");
        ("result",
          Ty.apply
            (Ty.path "core::result::Result")
            [
              Ty.apply
                (Ty.path "core::option::Option")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                    []
                ]
                [];
              Ty.path "multisig::Error"
            ]
            [])
      ];
  } *)

(* StructRecord
  {
    name := "OwnerAddition";
    ty_params := [];
    fields := [ ("owner", Ty.path "multisig::AccountId") ];
  } *)

(* StructRecord
  {
    name := "OwnerRemoval";
    ty_params := [];
    fields := [ ("owner", Ty.path "multisig::AccountId") ];
  } *)

(* StructRecord
  {
    name := "RequirementChange";
    ty_params := [];
    fields := [ ("new_requirement", Ty.path "u32") ];
  } *)

(* Enum Event *)
(* {
  ty_params := [];
  variants :=
    [
      {
        name := "Confirmation";
        item := StructTuple [ Ty.path "multisig::Confirmation" ];
        discriminant := None;
      };
      {
        name := "Revocation";
        item := StructTuple [ Ty.path "multisig::Revocation" ];
        discriminant := None;
      };
      {
        name := "Submission";
        item := StructTuple [ Ty.path "multisig::Submission" ];
        discriminant := None;
      };
      {
        name := "Cancellation";
        item := StructTuple [ Ty.path "multisig::Cancellation" ];
        discriminant := None;
      };
      {
        name := "Execution";
        item := StructTuple [ Ty.path "multisig::Execution" ];
        discriminant := None;
      };
      {
        name := "OwnerAddition";
        item := StructTuple [ Ty.path "multisig::OwnerAddition" ];
        discriminant := None;
      };
      {
        name := "OwnerRemoval";
        item := StructTuple [ Ty.path "multisig::OwnerRemoval" ];
        discriminant := None;
      };
      {
        name := "RequirementChange";
        item := StructTuple [ Ty.path "multisig::RequirementChange" ];
        discriminant := None;
      }
    ];
} *)

Module Impl_multisig_Env.
  Definition Self : Ty.t := Ty.path "multisig::Env".
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read (M.get_struct_record_field α0 "multisig::Env" "caller")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_caller : M.IsAssociatedFunction Self "caller" caller.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; _event ] =>
      let* self := M.alloc self in
      let* _event := M.alloc _event in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_emit_event : M.IsAssociatedFunction Self "emit_event" emit_event.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition transferred_value (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_transferred_value :
    M.IsAssociatedFunction Self "transferred_value" transferred_value.
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Definition account_id (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_account_id : M.IsAssociatedFunction Self "account_id" account_id.
End Impl_multisig_Env.

(* StructRecord
  {
    name := "Multisig";
    ty_params := [];
    fields :=
      [
        ("confirmations",
          Ty.apply
            (Ty.path "multisig::Mapping")
            [ Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ]; Ty.tuple [] ]
            []);
        ("confirmation_count",
          Ty.apply (Ty.path "multisig::Mapping") [ Ty.path "u32"; Ty.path "u32" ] []);
        ("transactions",
          Ty.apply
            (Ty.path "multisig::Mapping")
            [ Ty.path "u32"; Ty.path "multisig::Transaction" ]
            []);
        ("transaction_list", Ty.path "multisig::Transactions");
        ("owners",
          Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
            []);
        ("is_owner",
          Ty.apply (Ty.path "multisig::Mapping") [ Ty.path "multisig::AccountId"; Ty.tuple [] ] []);
        ("requirement", Ty.path "u32")
      ];
  } *)

Module Impl_core_default_Default_for_multisig_Multisig.
  Definition Self : Ty.t := Ty.path "multisig::Multisig".
  
  (*
  Default
  *)
  Definition default (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* α0 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply
            (Ty.path "multisig::Mapping")
            [ Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ]; Ty.tuple [] ]
            [])
          []
          []
          "default"
          []
          [] in
      let* α1 := M.call_closure α0 [] in
      let* α2 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply (Ty.path "multisig::Mapping") [ Ty.path "u32"; Ty.path "u32" ] [])
          []
          []
          "default"
          []
          [] in
      let* α3 := M.call_closure α2 [] in
      let* α4 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply
            (Ty.path "multisig::Mapping")
            [ Ty.path "u32"; Ty.path "multisig::Transaction" ]
            [])
          []
          []
          "default"
          []
          [] in
      let* α5 := M.call_closure α4 [] in
      let* α6 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.path "multisig::Transactions")
          []
          []
          "default"
          []
          [] in
      let* α7 := M.call_closure α6 [] in
      let* α8 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
            [])
          []
          []
          "default"
          []
          [] in
      let* α9 := M.call_closure α8 [] in
      let* α10 :=
        M.get_trait_method
          "core::default::Default"
          (Ty.apply (Ty.path "multisig::Mapping") [ Ty.path "multisig::AccountId"; Ty.tuple [] ] [])
          []
          []
          "default"
          []
          [] in
      let* α11 := M.call_closure α10 [] in
      let* α12 :=
        M.get_trait_method "core::default::Default" (Ty.path "u32") [] [] "default" [] [] in
      let* α13 := M.call_closure α12 [] in
      M.pure
        (Value.StructRecord
          "multisig::Multisig"
          [
            ("confirmations", α1);
            ("confirmation_count", α3);
            ("transactions", α5);
            ("transaction_list", α7);
            ("owners", α9);
            ("is_owner", α11);
            ("requirement", α13)
          ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_multisig_Multisig.

(*
fn ensure_requirement_is_valid(owners: u32, requirement: u32) {
    assert!(0 < requirement && requirement <= owners && owners <= MAX_OWNERS);
}
*)
Definition ensure_requirement_is_valid (τ : list Ty.t) (α : list Value.t) : M :=
  match τ, α with
  | [], [ owners; requirement ] =>
    let* owners := M.alloc owners in
    let* requirement := M.alloc requirement in
    let* _ :=
      let* α0 := M.alloc (Value.Tuple []) in
      M.match_operator
        α0
        [
          fun γ =>
            let* γ :=
              let* α0 := M.read requirement in
              let* α1 :=
                LogicalOp.and
                  (BinOp.Pure.lt (Value.Integer Integer.U32 0) α0)
                  (let* α0 := M.read requirement in
                  let* α1 := M.read owners in
                  M.pure (BinOp.Pure.le α0 α1)) in
              let* α2 :=
                LogicalOp.and
                  α1
                  (let* α0 := M.read owners in
                  let* α1 := M.get_constant "multisig::MAX_OWNERS" in
                  let* α2 := M.read α1 in
                  M.pure (BinOp.Pure.le α0 α2)) in
              let* α3 := M.alloc (UnOp.Pure.not α2) in
              M.pure (M.use α3) in
            let* _ :=
              let* α0 := M.read γ in
              M.is_constant_or_break_match α0 (Value.Bool true) in
            let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
            let* α1 :=
              M.read
                (mk_str
                  "assertion failed: 0 < requirement && requirement <= owners && owners <= MAX_OWNERS") in
            let* α2 := M.call_closure α0 [ α1 ] in
            let* α3 := M.never_to_any α2 in
            M.alloc α3;
          fun γ => M.alloc (Value.Tuple [])
        ] in
    let* α0 := M.alloc (Value.Tuple []) in
    M.read α0
  | _, _ => M.impossible
  end.

Module Impl_multisig_Multisig.
  Definition Self : Ty.t := Ty.path "multisig::Multisig".
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_init_env : M.IsAssociatedFunction Self "init_env" init_env.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.get_associated_function (Ty.path "multisig::Multisig") "init_env" [] [] in
      M.call_closure α0 []
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_env : M.IsAssociatedFunction Self "env" env.
  
  (*
      pub fn new(requirement: u32, mut owners: Vec<AccountId>) -> Self {
          let mut contract = Multisig::default();
          owners.sort_unstable();
          owners.dedup();
          ensure_requirement_is_valid(owners.len() as u32, requirement);
  
          for owner in &owners {
              contract.is_owner.insert( *owner, ());
          }
  
          contract.owners = owners;
          contract.transaction_list = Default::default();
          contract.requirement = requirement;
          contract
      }
  *)
  Definition new (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ requirement; owners ] =>
      let* requirement := M.alloc requirement in
      let* owners := M.alloc owners in
      let* contract :=
        let* α0 :=
          M.get_trait_method
            "core::default::Default"
            (Ty.path "multisig::Multisig")
            []
            []
            "default"
            []
            [] in
        let* α1 := M.call_closure α0 [] in
        M.alloc α1 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "slice") [ Ty.path "multisig::AccountId" ] [])
            "sort_unstable"
            []
            [] in
        let* α1 :=
          M.get_trait_method
            "core::ops::deref::DerefMut"
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
              [])
            []
            []
            "deref_mut"
            []
            [] in
        let* α2 := M.call_closure α1 [ owners ] in
        let* α3 := M.call_closure α0 [ α2 ] in
        M.alloc α3 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
              [])
            "dedup"
            []
            [] in
        let* α1 := M.call_closure α0 [ owners ] in
        M.alloc α1 in
      let* _ :=
        let* α0 := M.get_function "multisig::ensure_requirement_is_valid" [] [] in
        let* α1 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
              [])
            "len"
            []
            [] in
        let* α2 := M.call_closure α1 [ owners ] in
        let* α3 := M.read requirement in
        let* α4 := M.call_closure α0 [ M.rust_cast α2; α3 ] in
        M.alloc α4 in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "core::iter::traits::collect::IntoIterator"
            (Ty.apply
              (Ty.path "&")
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
                  []
              ]
              [])
            []
            []
            "into_iter"
            []
            [] in
        let* α1 := M.call_closure α0 [ owners ] in
        let* α2 := M.alloc α1 in
        let* α3 :=
          M.match_operator
            α2
            [
              fun γ =>
                let* iter := M.copy γ in
                M.loop
                  (let* _ :=
                    let* α0 :=
                      M.get_trait_method
                        "core::iter::traits::iterator::Iterator"
                        (Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          [ Ty.path "multisig::AccountId" ]
                          [])
                        []
                        []
                        "next"
                        []
                        [] in
                    let* α1 := M.call_closure α0 [ iter ] in
                    let* α2 := M.alloc α1 in
                    M.match_operator
                      α2
                      [
                        fun γ =>
                          let* α0 := M.break in
                          let* α1 := M.read α0 in
                          let* α2 := M.never_to_any α1 in
                          M.alloc α2;
                        fun γ =>
                          let* γ0_0 :=
                            M.get_struct_tuple_field_or_break_match
                              γ
                              "core::option::Option::Some"
                              0 in
                          let* owner := M.copy γ0_0 in
                          let* _ :=
                            let* α0 :=
                              M.get_associated_function
                                (Ty.apply
                                  (Ty.path "multisig::Mapping")
                                  [ Ty.path "multisig::AccountId"; Ty.tuple [] ]
                                  [])
                                "insert"
                                []
                                [] in
                            let* α1 := M.read owner in
                            let* α2 := M.read α1 in
                            let* α3 :=
                              M.call_closure
                                α0
                                [
                                  M.get_struct_record_field
                                    contract
                                    "multisig::Multisig"
                                    "is_owner";
                                  α2;
                                  Value.Tuple []
                                ] in
                            M.alloc α3 in
                          M.alloc (Value.Tuple [])
                      ] in
                  M.alloc (Value.Tuple []))
            ] in
        M.pure (M.use α3) in
      let* _ :=
        let* α0 := M.read owners in
        M.assign (M.get_struct_record_field contract "multisig::Multisig" "owners") α0 in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "core::default::Default"
            (Ty.path "multisig::Transactions")
            []
            []
            "default"
            []
            [] in
        let* α1 := M.call_closure α0 [] in
        M.assign (M.get_struct_record_field contract "multisig::Multisig" "transaction_list") α1 in
      let* _ :=
        let* α0 := M.read requirement in
        M.assign (M.get_struct_record_field contract "multisig::Multisig" "requirement") α0 in
      M.read contract
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
  
  (*
      fn ensure_confirmed(&self, trans_id: TransactionId) {
          assert!(
              self.confirmation_count
                  .get(&trans_id)
                  .expect(WRONG_TRANSACTION_ID)
                  >= self.requirement
          );
      }
  *)
  Definition ensure_confirmed (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ] [])
                    "expect"
                    []
                    [ Value.Bool true ] in
                let* α1 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "multisig::Mapping") [ Ty.path "u32"; Ty.path "u32" ] [])
                    "get"
                    []
                    [] in
                let* α2 := M.read self in
                let* α3 :=
                  M.call_closure
                    α1
                    [
                      M.get_struct_record_field α2 "multisig::Multisig" "confirmation_count";
                      trans_id
                    ] in
                let* α4 := M.get_constant "multisig::WRONG_TRANSACTION_ID" in
                let* α5 := M.read α4 in
                let* α6 := M.call_closure α0 [ α3; α5 ] in
                let* α7 := M.read self in
                let* α8 :=
                  M.read (M.get_struct_record_field α7 "multisig::Multisig" "requirement") in
                let* α9 := M.alloc (UnOp.Pure.not (BinOp.Pure.ge α6 α8)) in
                M.pure (M.use α9) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
              let* α1 :=
                M.read
                  (mk_str
                    "assertion failed: self.confirmation_count.get(&trans_id).expect(WRONG_TRANSACTION_ID) >=
    self.requirement") in
              let* α2 := M.call_closure α0 [ α1 ] in
              let* α3 := M.never_to_any α2 in
              M.alloc α3;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_ensure_confirmed :
    M.IsAssociatedFunction Self "ensure_confirmed" ensure_confirmed.
  
  (*
      fn ensure_transaction_exists(&self, trans_id: TransactionId) {
          self.transactions
              .get(&trans_id)
              .expect(WRONG_TRANSACTION_ID);
      }
  *)
  Definition ensure_transaction_exists (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "core::option::Option") [ Ty.path "multisig::Transaction" ] [])
            "expect"
            []
            [ Value.Bool true ] in
        let* α1 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [ Ty.path "u32"; Ty.path "multisig::Transaction" ]
              [])
            "get"
            []
            [] in
        let* α2 := M.read self in
        let* α3 :=
          M.call_closure
            α1
            [ M.get_struct_record_field α2 "multisig::Multisig" "transactions"; trans_id ] in
        let* α4 := M.get_constant "multisig::WRONG_TRANSACTION_ID" in
        let* α5 := M.read α4 in
        let* α6 := M.call_closure α0 [ α3; α5 ] in
        M.alloc α6 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_ensure_transaction_exists :
    M.IsAssociatedFunction Self "ensure_transaction_exists" ensure_transaction_exists.
  
  (*
      fn ensure_owner(&self, owner: &AccountId) {
          assert!(self.is_owner.contains(owner));
      }
  *)
  Definition ensure_owner (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; owner ] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply
                      (Ty.path "multisig::Mapping")
                      [ Ty.path "multisig::AccountId"; Ty.tuple [] ]
                      [])
                    "contains"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read owner in
                let* α3 :=
                  M.call_closure
                    α0
                    [ M.get_struct_record_field α1 "multisig::Multisig" "is_owner"; α2 ] in
                let* α4 := M.alloc (UnOp.Pure.not α3) in
                M.pure (M.use α4) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
              let* α1 := M.read (mk_str "assertion failed: self.is_owner.contains(owner)") in
              let* α2 := M.call_closure α0 [ α1 ] in
              let* α3 := M.never_to_any α2 in
              M.alloc α3;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_ensure_owner : M.IsAssociatedFunction Self "ensure_owner" ensure_owner.
  
  (*
      fn ensure_caller_is_owner(&self) {
          self.ensure_owner(&self.env().caller());
      }
  *)
  Definition ensure_caller_is_owner (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Multisig") "ensure_owner" [] [] in
        let* α1 := M.read self in
        let* α2 := M.get_associated_function (Ty.path "multisig::Env") "caller" [] [] in
        let* α3 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α4 := M.read self in
        let* α5 := M.call_closure α3 [ α4 ] in
        let* α6 := M.alloc α5 in
        let* α7 := M.call_closure α2 [ α6 ] in
        let* α8 := M.alloc α7 in
        let* α9 := M.call_closure α0 [ α1; α8 ] in
        M.alloc α9 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_ensure_caller_is_owner :
    M.IsAssociatedFunction Self "ensure_caller_is_owner" ensure_caller_is_owner.
  
  (*
      fn ensure_from_wallet(&self) {
          assert_eq!(self.env().caller(), self.env().account_id());
      }
  *)
  Definition ensure_from_wallet (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Env") "caller" [] [] in
        let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.call_closure α0 [ α4 ] in
        let* α6 := M.alloc α5 in
        let* α7 := M.get_associated_function (Ty.path "multisig::Env") "account_id" [] [] in
        let* α8 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α9 := M.read self in
        let* α10 := M.call_closure α8 [ α9 ] in
        let* α11 := M.alloc α10 in
        let* α12 := M.call_closure α7 [ α11 ] in
        let* α13 := M.alloc α12 in
        let* α14 := M.alloc (Value.Tuple [ α6; α13 ]) in
        M.match_operator
          α14
          [
            fun γ =>
              let γ0_0 := M.get_tuple_field γ 0 in
              let γ0_1 := M.get_tuple_field γ 1 in
              let* left_val := M.copy γ0_0 in
              let* right_val := M.copy γ0_1 in
              let* α0 := M.alloc (Value.Tuple []) in
              M.match_operator
                α0
                [
                  fun γ =>
                    let* γ :=
                      let* α0 :=
                        M.get_trait_method
                          "core::cmp::PartialEq"
                          (Ty.path "multisig::AccountId")
                          [ Ty.path "multisig::AccountId" ]
                          [ Value.Bool true ]
                          "eq"
                          []
                          [] in
                      let* α1 := M.read left_val in
                      let* α2 := M.read right_val in
                      let* α3 := M.call_closure α0 [ α1; α2 ] in
                      let* α4 := M.alloc (UnOp.Pure.not α3) in
                      M.pure (M.use α4) in
                    let* _ :=
                      let* α0 := M.read γ in
                      M.is_constant_or_break_match α0 (Value.Bool true) in
                    let* kind := M.alloc (Value.StructTuple "core::panicking::AssertKind::Eq" []) in
                    let* α0 :=
                      M.get_function
                        "core::panicking::assert_failed"
                        [ Ty.path "multisig::AccountId"; Ty.path "multisig::AccountId" ]
                        [] in
                    let* α1 := M.read kind in
                    let* α2 := M.read left_val in
                    let* α3 := M.read right_val in
                    let* α4 :=
                      M.call_closure
                        α0
                        [ α1; α2; α3; Value.StructTuple "core::option::Option::None" [] ] in
                    let* α0 := M.alloc α4 in
                    let* α1 := M.read α0 in
                    let* α2 := M.never_to_any α1 in
                    M.alloc α2;
                  fun γ => M.alloc (Value.Tuple [])
                ]
          ] in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_ensure_from_wallet :
    M.IsAssociatedFunction Self "ensure_from_wallet" ensure_from_wallet.
  
  (*
      fn ensure_no_owner(&self, owner: &AccountId) {
          assert!(!self.is_owner.contains(owner));
      }
  *)
  Definition ensure_no_owner (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; owner ] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply
                      (Ty.path "multisig::Mapping")
                      [ Ty.path "multisig::AccountId"; Ty.tuple [] ]
                      [])
                    "contains"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read owner in
                let* α3 :=
                  M.call_closure
                    α0
                    [ M.get_struct_record_field α1 "multisig::Multisig" "is_owner"; α2 ] in
                let* α4 := M.alloc (UnOp.Pure.not (UnOp.Pure.not α3)) in
                M.pure (M.use α4) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
              let* α1 := M.read (mk_str "assertion failed: !self.is_owner.contains(owner)") in
              let* α2 := M.call_closure α0 [ α1 ] in
              let* α3 := M.never_to_any α2 in
              M.alloc α3;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_ensure_no_owner :
    M.IsAssociatedFunction Self "ensure_no_owner" ensure_no_owner.
  
  (*
      pub fn add_owner(&mut self, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_no_owner(&new_owner);
          ensure_requirement_is_valid(self.owners.len() as u32 + 1, self.requirement);
          self.is_owner.insert(new_owner, ());
          self.owners.push(new_owner);
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition add_owner (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; new_owner ] =>
      let* self := M.alloc self in
      let* new_owner := M.alloc new_owner in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_from_wallet" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_no_owner" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1; new_owner ] in
        M.alloc α2 in
      let* _ :=
        let* α0 := M.get_function "multisig::ensure_requirement_is_valid" [] [] in
        let* α1 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
              [])
            "len"
            []
            [] in
        let* α2 := M.read self in
        let* α3 :=
          M.call_closure α1 [ M.get_struct_record_field α2 "multisig::Multisig" "owners" ] in
        let* α4 := BinOp.Panic.add (M.rust_cast α3) (Value.Integer Integer.U32 1) in
        let* α5 := M.read self in
        let* α6 := M.read (M.get_struct_record_field α5 "multisig::Multisig" "requirement") in
        let* α7 := M.call_closure α0 [ α4; α6 ] in
        M.alloc α7 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [ Ty.path "multisig::AccountId"; Ty.tuple [] ]
              [])
            "insert"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.read new_owner in
        let* α3 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "multisig::Multisig" "is_owner"; α2; Value.Tuple [] ] in
        M.alloc α3 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
              [])
            "push"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.read new_owner in
        let* α3 :=
          M.call_closure α0 [ M.get_struct_record_field α1 "multisig::Multisig" "owners"; α2 ] in
        M.alloc α3 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Env") "emit_event" [] [] in
        let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read new_owner in
        let* α6 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "multisig::Event::OwnerAddition"
                [ Value.StructRecord "multisig::OwnerAddition" [ ("owner", α5) ] ]
            ] in
        M.alloc α6 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_add_owner : M.IsAssociatedFunction Self "add_owner" add_owner.
  
  (*
      fn owner_index(&self, owner: &AccountId) -> u32 {
          self.owners.iter().position(|x| *x == *owner).expect(
              "This is only called after it was already verified that the id is
                 actually an owner.",
          ) as u32
      }
  *)
  Definition owner_index (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; owner ] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* α0 :=
        M.get_associated_function
          (Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ] [])
          "expect"
          []
          [ Value.Bool true ] in
      let* α1 :=
        M.get_trait_method
          "core::iter::traits::iterator::Iterator"
          (Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.path "multisig::AccountId" ] [])
          []
          []
          "position"
          [
            Ty.function
              [ Ty.tuple [ Ty.apply (Ty.path "&") [ Ty.path "multisig::AccountId" ] [] ] ]
              (Ty.path "bool")
          ]
          [] in
      let* α2 :=
        M.get_associated_function
          (Ty.apply (Ty.path "slice") [ Ty.path "multisig::AccountId" ] [])
          "iter"
          []
          [] in
      let* α3 :=
        M.get_trait_method
          "core::ops::deref::Deref"
          (Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
            [])
          []
          []
          "deref"
          []
          [] in
      let* α4 := M.read self in
      let* α5 := M.call_closure α3 [ M.get_struct_record_field α4 "multisig::Multisig" "owners" ] in
      let* α6 := M.call_closure α2 [ α5 ] in
      let* α7 := M.alloc α6 in
      let* α8 :=
        M.call_closure
          α1
          [
            α7;
            M.closure
              (fun γ =>
                match γ with
                | [ α0 ] =>
                  let* α0 := M.alloc α0 in
                  M.match_operator
                    α0
                    [
                      fun γ =>
                        let* x := M.copy γ in
                        let* α0 :=
                          M.get_trait_method
                            "core::cmp::PartialEq"
                            (Ty.path "multisig::AccountId")
                            [ Ty.path "multisig::AccountId" ]
                            [ Value.Bool true ]
                            "eq"
                            []
                            [] in
                        let* α1 := M.read x in
                        let* α2 := M.read owner in
                        M.call_closure α0 [ α1; α2 ]
                    ]
                | _ => M.impossible
                end)
          ] in
      let* α9 :=
        M.read
          (mk_str
            "This is only called after it was already verified that the id is
               actually an owner.") in
      let* α10 := M.call_closure α0 [ α8; α9 ] in
      M.pure (M.rust_cast α10)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_owner_index : M.IsAssociatedFunction Self "owner_index" owner_index.
  
  (*
      fn clean_owner_confirmations(&mut self, owner: &AccountId) {
          for trans_id in &self.transaction_list.transactions {
              let key = ( *trans_id, *owner);
              if self.confirmations.contains(&key) {
                  self.confirmations.remove(key);
                  let mut count = self.confirmation_count.get(trans_id).unwrap_or(0 as u32);
                  count -= 1;
                  self.confirmation_count.insert( *trans_id, count);
              }
          }
      }
  *)
  Definition clean_owner_confirmations (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; owner ] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* α0 :=
        M.get_trait_method
          "core::iter::traits::collect::IntoIterator"
          (Ty.apply
            (Ty.path "&")
            [
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ]
                []
            ]
            [])
          []
          []
          "into_iter"
          []
          [] in
      let* α1 := M.read self in
      let* α2 :=
        M.call_closure
          α0
          [
            M.get_struct_record_field
              (M.get_struct_record_field α1 "multisig::Multisig" "transaction_list")
              "multisig::Transactions"
              "transactions"
          ] in
      let* α3 := M.alloc α2 in
      let* α4 :=
        M.match_operator
          α3
          [
            fun γ =>
              let* iter := M.copy γ in
              M.loop
                (let* _ :=
                  let* α0 :=
                    M.get_trait_method
                      "core::iter::traits::iterator::Iterator"
                      (Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.path "u32" ] [])
                      []
                      []
                      "next"
                      []
                      [] in
                  let* α1 := M.call_closure α0 [ iter ] in
                  let* α2 := M.alloc α1 in
                  M.match_operator
                    α2
                    [
                      fun γ =>
                        let* α0 := M.break in
                        let* α1 := M.read α0 in
                        let* α2 := M.never_to_any α1 in
                        M.alloc α2;
                      fun γ =>
                        let* γ0_0 :=
                          M.get_struct_tuple_field_or_break_match
                            γ
                            "core::option::Option::Some"
                            0 in
                        let* trans_id := M.copy γ0_0 in
                        let* key :=
                          let* α0 := M.read trans_id in
                          let* α1 := M.read α0 in
                          let* α2 := M.read owner in
                          let* α3 := M.read α2 in
                          M.alloc (Value.Tuple [ α1; α3 ]) in
                        let* α0 := M.alloc (Value.Tuple []) in
                        M.match_operator
                          α0
                          [
                            fun γ =>
                              let* γ :=
                                let* α0 :=
                                  M.get_associated_function
                                    (Ty.apply
                                      (Ty.path "multisig::Mapping")
                                      [
                                        Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ];
                                        Ty.tuple []
                                      ]
                                      [])
                                    "contains"
                                    []
                                    [] in
                                let* α1 := M.read self in
                                let* α2 :=
                                  M.call_closure
                                    α0
                                    [
                                      M.get_struct_record_field
                                        α1
                                        "multisig::Multisig"
                                        "confirmations";
                                      key
                                    ] in
                                let* α3 := M.alloc α2 in
                                M.pure (M.use α3) in
                              let* _ :=
                                let* α0 := M.read γ in
                                M.is_constant_or_break_match α0 (Value.Bool true) in
                              let* _ :=
                                let* α0 :=
                                  M.get_associated_function
                                    (Ty.apply
                                      (Ty.path "multisig::Mapping")
                                      [
                                        Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ];
                                        Ty.tuple []
                                      ]
                                      [])
                                    "remove"
                                    []
                                    [] in
                                let* α1 := M.read self in
                                let* α2 := M.read key in
                                let* α3 :=
                                  M.call_closure
                                    α0
                                    [
                                      M.get_struct_record_field
                                        α1
                                        "multisig::Multisig"
                                        "confirmations";
                                      α2
                                    ] in
                                M.alloc α3 in
                              let* count :=
                                let* α0 :=
                                  M.get_associated_function
                                    (Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ] [])
                                    "unwrap_or"
                                    []
                                    [] in
                                let* α1 :=
                                  M.get_associated_function
                                    (Ty.apply
                                      (Ty.path "multisig::Mapping")
                                      [ Ty.path "u32"; Ty.path "u32" ]
                                      [])
                                    "get"
                                    []
                                    [] in
                                let* α2 := M.read self in
                                let* α3 := M.read trans_id in
                                let* α4 :=
                                  M.call_closure
                                    α1
                                    [
                                      M.get_struct_record_field
                                        α2
                                        "multisig::Multisig"
                                        "confirmation_count";
                                      α3
                                    ] in
                                let* α5 := M.alloc (Value.Integer Integer.U32 0) in
                                let* α6 := M.read (M.use α5) in
                                let* α7 := M.call_closure α0 [ α4; α6 ] in
                                M.alloc α7 in
                              let* _ :=
                                let β := count in
                                let* α0 := M.read β in
                                let* α1 := BinOp.Panic.sub α0 (Value.Integer Integer.U32 1) in
                                M.assign β α1 in
                              let* _ :=
                                let* α0 :=
                                  M.get_associated_function
                                    (Ty.apply
                                      (Ty.path "multisig::Mapping")
                                      [ Ty.path "u32"; Ty.path "u32" ]
                                      [])
                                    "insert"
                                    []
                                    [] in
                                let* α1 := M.read self in
                                let* α2 := M.read trans_id in
                                let* α3 := M.read α2 in
                                let* α4 := M.read count in
                                let* α5 :=
                                  M.call_closure
                                    α0
                                    [
                                      M.get_struct_record_field
                                        α1
                                        "multisig::Multisig"
                                        "confirmation_count";
                                      α3;
                                      α4
                                    ] in
                                M.alloc α5 in
                              M.alloc (Value.Tuple []);
                            fun γ => M.alloc (Value.Tuple [])
                          ]
                    ] in
                M.alloc (Value.Tuple []))
          ] in
      M.read (M.use α4)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_clean_owner_confirmations :
    M.IsAssociatedFunction Self "clean_owner_confirmations" clean_owner_confirmations.
  
  (*
      pub fn remove_owner(&mut self, owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&owner);
          let len = self.owners.len() as u32 - 1;
          let requirement = u32::min(len, self.requirement);
          ensure_requirement_is_valid(len, requirement);
          let owner_index = self.owner_index(&owner) as usize;
          self.owners.swap_remove(owner_index);
          self.is_owner.remove(owner);
          self.requirement = requirement;
          self.clean_owner_confirmations(&owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner }));
      }
  *)
  Definition remove_owner (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; owner ] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_from_wallet" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Multisig") "ensure_owner" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1; owner ] in
        M.alloc α2 in
      let* len :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
              [])
            "len"
            []
            [] in
        let* α1 := M.read self in
        let* α2 :=
          M.call_closure α0 [ M.get_struct_record_field α1 "multisig::Multisig" "owners" ] in
        let* α3 := BinOp.Panic.sub (M.rust_cast α2) (Value.Integer Integer.U32 1) in
        M.alloc α3 in
      let* requirement :=
        let* α0 := M.get_trait_method "core::cmp::Ord" (Ty.path "u32") [] [] "min" [] [] in
        let* α1 := M.read len in
        let* α2 := M.read self in
        let* α3 := M.read (M.get_struct_record_field α2 "multisig::Multisig" "requirement") in
        let* α4 := M.call_closure α0 [ α1; α3 ] in
        M.alloc α4 in
      let* _ :=
        let* α0 := M.get_function "multisig::ensure_requirement_is_valid" [] [] in
        let* α1 := M.read len in
        let* α2 := M.read requirement in
        let* α3 := M.call_closure α0 [ α1; α2 ] in
        M.alloc α3 in
      let* owner_index :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Multisig") "owner_index" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1; owner ] in
        M.alloc (M.rust_cast α2) in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
              [])
            "swap_remove"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.read owner_index in
        let* α3 :=
          M.call_closure α0 [ M.get_struct_record_field α1 "multisig::Multisig" "owners"; α2 ] in
        M.alloc α3 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [ Ty.path "multisig::AccountId"; Ty.tuple [] ]
              [])
            "remove"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.read owner in
        let* α3 :=
          M.call_closure α0 [ M.get_struct_record_field α1 "multisig::Multisig" "is_owner"; α2 ] in
        M.alloc α3 in
      let* _ :=
        let* α0 := M.read self in
        let* α1 := M.read requirement in
        M.assign (M.get_struct_record_field α0 "multisig::Multisig" "requirement") α1 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.path "multisig::Multisig")
            "clean_owner_confirmations"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1; owner ] in
        M.alloc α2 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Env") "emit_event" [] [] in
        let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read owner in
        let* α6 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "multisig::Event::OwnerRemoval"
                [ Value.StructRecord "multisig::OwnerRemoval" [ ("owner", α5) ] ]
            ] in
        M.alloc α6 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_remove_owner : M.IsAssociatedFunction Self "remove_owner" remove_owner.
  
  (*
      pub fn replace_owner(&mut self, old_owner: AccountId, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&old_owner);
          self.ensure_no_owner(&new_owner);
          let owner_index = self.owner_index(&old_owner);
          self.owners[owner_index as usize] = new_owner;
          self.is_owner.remove(old_owner);
          self.is_owner.insert(new_owner, ());
          self.clean_owner_confirmations(&old_owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner: old_owner }));
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition replace_owner (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; old_owner; new_owner ] =>
      let* self := M.alloc self in
      let* old_owner := M.alloc old_owner in
      let* new_owner := M.alloc new_owner in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_from_wallet" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Multisig") "ensure_owner" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1; old_owner ] in
        M.alloc α2 in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_no_owner" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1; new_owner ] in
        M.alloc α2 in
      let* owner_index :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Multisig") "owner_index" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1; old_owner ] in
        M.alloc α2 in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "core::ops::index::IndexMut"
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
              [])
            [ Ty.path "usize" ]
            []
            "index_mut"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.read owner_index in
        let* α3 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "multisig::Multisig" "owners"; M.rust_cast α2 ] in
        let* α4 := M.read new_owner in
        M.assign α3 α4 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [ Ty.path "multisig::AccountId"; Ty.tuple [] ]
              [])
            "remove"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.read old_owner in
        let* α3 :=
          M.call_closure α0 [ M.get_struct_record_field α1 "multisig::Multisig" "is_owner"; α2 ] in
        M.alloc α3 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [ Ty.path "multisig::AccountId"; Ty.tuple [] ]
              [])
            "insert"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.read new_owner in
        let* α3 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "multisig::Multisig" "is_owner"; α2; Value.Tuple [] ] in
        M.alloc α3 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.path "multisig::Multisig")
            "clean_owner_confirmations"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1; old_owner ] in
        M.alloc α2 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Env") "emit_event" [] [] in
        let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read old_owner in
        let* α6 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "multisig::Event::OwnerRemoval"
                [ Value.StructRecord "multisig::OwnerRemoval" [ ("owner", α5) ] ]
            ] in
        M.alloc α6 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Env") "emit_event" [] [] in
        let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read new_owner in
        let* α6 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "multisig::Event::OwnerAddition"
                [ Value.StructRecord "multisig::OwnerAddition" [ ("owner", α5) ] ]
            ] in
        M.alloc α6 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_replace_owner :
    M.IsAssociatedFunction Self "replace_owner" replace_owner.
  
  (*
      pub fn change_requirement(&mut self, new_requirement: u32) {
          self.ensure_from_wallet();
          ensure_requirement_is_valid(self.owners.len() as u32, new_requirement);
          self.requirement = new_requirement;
          self.env()
              .emit_event(Event::RequirementChange(RequirementChange {
                  new_requirement,
              }));
      }
  *)
  Definition change_requirement (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; new_requirement ] =>
      let* self := M.alloc self in
      let* new_requirement := M.alloc new_requirement in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_from_wallet" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* _ :=
        let* α0 := M.get_function "multisig::ensure_requirement_is_valid" [] [] in
        let* α1 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
              [])
            "len"
            []
            [] in
        let* α2 := M.read self in
        let* α3 :=
          M.call_closure α1 [ M.get_struct_record_field α2 "multisig::Multisig" "owners" ] in
        let* α4 := M.read new_requirement in
        let* α5 := M.call_closure α0 [ M.rust_cast α3; α4 ] in
        M.alloc α5 in
      let* _ :=
        let* α0 := M.read self in
        let* α1 := M.read new_requirement in
        M.assign (M.get_struct_record_field α0 "multisig::Multisig" "requirement") α1 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Env") "emit_event" [] [] in
        let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read new_requirement in
        let* α6 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "multisig::Event::RequirementChange"
                [ Value.StructRecord "multisig::RequirementChange" [ ("new_requirement", α5) ] ]
            ] in
        M.alloc α6 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_change_requirement :
    M.IsAssociatedFunction Self "change_requirement" change_requirement.
  
  (*
      fn confirm_by_caller(
          &mut self,
          confirmer: AccountId,
          transaction: TransactionId,
      ) -> ConfirmationStatus {
          let mut count = self
              .confirmation_count
              .get(&transaction)
              .unwrap_or(0 as u32);
          let key = (transaction, confirmer);
          let new_confirmation = !self.confirmations.contains(&key);
          if new_confirmation {
              count += 1;
              self.confirmations.insert(key, ());
              self.confirmation_count.insert(transaction, count);
          }
          let status = {
              if count >= self.requirement {
                  ConfirmationStatus::Confirmed
              } else {
                  ConfirmationStatus::ConfirmationsNeeded(self.requirement - count)
              }
          };
          if new_confirmation {
              self.env().emit_event(Event::Confirmation(Confirmation {
                  transaction,
                  from: confirmer,
                  status,
              }));
          }
          status
      }
  *)
  Definition confirm_by_caller (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; confirmer; transaction ] =>
      let* self := M.alloc self in
      let* confirmer := M.alloc confirmer in
      let* transaction := M.alloc transaction in
      let* count :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ] [])
            "unwrap_or"
            []
            [] in
        let* α1 :=
          M.get_associated_function
            (Ty.apply (Ty.path "multisig::Mapping") [ Ty.path "u32"; Ty.path "u32" ] [])
            "get"
            []
            [] in
        let* α2 := M.read self in
        let* α3 :=
          M.call_closure
            α1
            [ M.get_struct_record_field α2 "multisig::Multisig" "confirmation_count"; transaction
            ] in
        let* α4 := M.alloc (Value.Integer Integer.U32 0) in
        let* α5 := M.read (M.use α4) in
        let* α6 := M.call_closure α0 [ α3; α5 ] in
        M.alloc α6 in
      let* key :=
        let* α0 := M.read transaction in
        let* α1 := M.read confirmer in
        M.alloc (Value.Tuple [ α0; α1 ]) in
      let* new_confirmation :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [ Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ]; Ty.tuple [] ]
              [])
            "contains"
            []
            [] in
        let* α1 := M.read self in
        let* α2 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "multisig::Multisig" "confirmations"; key ] in
        M.alloc (UnOp.Pure.not α2) in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let γ := M.use new_confirmation in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* _ :=
                let β := count in
                let* α0 := M.read β in
                let* α1 := BinOp.Panic.add α0 (Value.Integer Integer.U32 1) in
                M.assign β α1 in
              let* _ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply
                      (Ty.path "multisig::Mapping")
                      [ Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ]; Ty.tuple [] ]
                      [])
                    "insert"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read key in
                let* α3 :=
                  M.call_closure
                    α0
                    [
                      M.get_struct_record_field α1 "multisig::Multisig" "confirmations";
                      α2;
                      Value.Tuple []
                    ] in
                M.alloc α3 in
              let* _ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "multisig::Mapping") [ Ty.path "u32"; Ty.path "u32" ] [])
                    "insert"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read transaction in
                let* α3 := M.read count in
                let* α4 :=
                  M.call_closure
                    α0
                    [ M.get_struct_record_field α1 "multisig::Multisig" "confirmation_count"; α2; α3
                    ] in
                M.alloc α4 in
              M.alloc (Value.Tuple []);
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* status :=
        let* α0 := M.alloc (Value.Tuple []) in
        let* α1 :=
          M.match_operator
            α0
            [
              fun γ =>
                let* γ :=
                  let* α0 := M.read count in
                  let* α1 := M.read self in
                  let* α2 :=
                    M.read (M.get_struct_record_field α1 "multisig::Multisig" "requirement") in
                  let* α3 := M.alloc (BinOp.Pure.ge α0 α2) in
                  M.pure (M.use α3) in
                let* _ :=
                  let* α0 := M.read γ in
                  M.is_constant_or_break_match α0 (Value.Bool true) in
                M.alloc (Value.StructTuple "multisig::ConfirmationStatus::Confirmed" []);
              fun γ =>
                let* α0 := M.read self in
                let* α1 :=
                  M.read (M.get_struct_record_field α0 "multisig::Multisig" "requirement") in
                let* α2 := M.read count in
                let* α3 := BinOp.Panic.sub α1 α2 in
                M.alloc
                  (Value.StructTuple "multisig::ConfirmationStatus::ConfirmationsNeeded" [ α3 ])
            ] in
        M.copy α1 in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let γ := M.use new_confirmation in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* _ :=
                let* α0 := M.get_associated_function (Ty.path "multisig::Env") "emit_event" [] [] in
                let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
                let* α2 := M.read self in
                let* α3 := M.call_closure α1 [ α2 ] in
                let* α4 := M.alloc α3 in
                let* α5 := M.read transaction in
                let* α6 := M.read confirmer in
                let* α7 := M.read status in
                let* α8 :=
                  M.call_closure
                    α0
                    [
                      α4;
                      Value.StructTuple
                        "multisig::Event::Confirmation"
                        [
                          Value.StructRecord
                            "multisig::Confirmation"
                            [ ("transaction", α5); ("from", α6); ("status", α7) ]
                        ]
                    ] in
                M.alloc α8 in
              M.alloc (Value.Tuple []);
            fun γ => M.alloc (Value.Tuple [])
          ] in
      M.read status
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_confirm_by_caller :
    M.IsAssociatedFunction Self "confirm_by_caller" confirm_by_caller.
  
  (*
      pub fn submit_transaction(
          &mut self,
          transaction: Transaction,
      ) -> (TransactionId, ConfirmationStatus) {
          self.ensure_caller_is_owner();
          let trans_id = self.transaction_list.next_id;
          self.transaction_list.next_id = trans_id
              .checked_add(1 as u32)
              .expect("Transaction ids exhausted.");
          self.transactions.insert(trans_id, transaction);
          self.transaction_list.transactions.push(trans_id);
          self.env().emit_event(Event::Submission(Submission {
              transaction: trans_id,
          }));
          (
              trans_id,
              self.confirm_by_caller(self.env().caller(), trans_id),
          )
      }
  *)
  Definition submit_transaction (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; transaction ] =>
      let* self := M.alloc self in
      let* transaction := M.alloc transaction in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_caller_is_owner" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* trans_id :=
        let* α0 := M.read self in
        M.copy
          (M.get_struct_record_field
            (M.get_struct_record_field α0 "multisig::Multisig" "transaction_list")
            "multisig::Transactions"
            "next_id") in
      let* _ :=
        let* α0 := M.read self in
        let* α1 :=
          M.get_associated_function
            (Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ] [])
            "expect"
            []
            [ Value.Bool true ] in
        let* α2 := M.get_associated_function (Ty.path "u32") "checked_add" [] [ Value.Bool true ] in
        let* α3 := M.read trans_id in
        let* α4 := M.alloc (Value.Integer Integer.U32 1) in
        let* α5 := M.read (M.use α4) in
        let* α6 := M.call_closure α2 [ α3; α5 ] in
        let* α7 := M.read (mk_str "Transaction ids exhausted.") in
        let* α8 := M.call_closure α1 [ α6; α7 ] in
        M.assign
          (M.get_struct_record_field
            (M.get_struct_record_field α0 "multisig::Multisig" "transaction_list")
            "multisig::Transactions"
            "next_id")
          α8 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [ Ty.path "u32"; Ty.path "multisig::Transaction" ]
              [])
            "insert"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.read trans_id in
        let* α3 := M.read transaction in
        let* α4 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "multisig::Multisig" "transactions"; α2; α3 ] in
        M.alloc α4 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ]
              [])
            "push"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.read trans_id in
        let* α3 :=
          M.call_closure
            α0
            [
              M.get_struct_record_field
                (M.get_struct_record_field α1 "multisig::Multisig" "transaction_list")
                "multisig::Transactions"
                "transactions";
              α2
            ] in
        M.alloc α3 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Env") "emit_event" [] [] in
        let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read trans_id in
        let* α6 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "multisig::Event::Submission"
                [ Value.StructRecord "multisig::Submission" [ ("transaction", α5) ] ]
            ] in
        M.alloc α6 in
      let* α0 := M.read trans_id in
      let* α1 :=
        M.get_associated_function (Ty.path "multisig::Multisig") "confirm_by_caller" [] [] in
      let* α2 := M.read self in
      let* α3 := M.get_associated_function (Ty.path "multisig::Env") "caller" [] [] in
      let* α4 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
      let* α5 := M.read self in
      let* α6 := M.call_closure α4 [ α5 ] in
      let* α7 := M.alloc α6 in
      let* α8 := M.call_closure α3 [ α7 ] in
      let* α9 := M.read trans_id in
      let* α10 := M.call_closure α1 [ α2; α8; α9 ] in
      let* α0 := M.alloc (Value.Tuple [ α0; α10 ]) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_submit_transaction :
    M.IsAssociatedFunction Self "submit_transaction" submit_transaction.
  
  (*
      fn take_transaction(&mut self, trans_id: TransactionId) -> Option<Transaction> {
          let transaction = self.transactions.get(&trans_id);
          if transaction.is_some() {
              self.transactions.remove(trans_id);
              let pos = self
                  .transaction_list
                  .transactions
                  .iter()
                  .position(|t| t == &trans_id)
                  .expect("The transaction exists hence it must also be in the list.");
              self.transaction_list.transactions.swap_remove(pos);
              for owner in self.owners.iter() {
                  self.confirmations.remove((trans_id, *owner));
              }
              self.confirmation_count.remove(trans_id);
          }
          transaction
      }
  *)
  Definition take_transaction (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* transaction :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [ Ty.path "u32"; Ty.path "multisig::Transaction" ]
              [])
            "get"
            []
            [] in
        let* α1 := M.read self in
        let* α2 :=
          M.call_closure
            α0
            [ M.get_struct_record_field α1 "multisig::Multisig" "transactions"; trans_id ] in
        M.alloc α2 in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "multisig::Transaction" ]
                      [])
                    "is_some"
                    []
                    [ Value.Bool true ] in
                let* α1 := M.call_closure α0 [ transaction ] in
                let* α2 := M.alloc α1 in
                M.pure (M.use α2) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* _ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply
                      (Ty.path "multisig::Mapping")
                      [ Ty.path "u32"; Ty.path "multisig::Transaction" ]
                      [])
                    "remove"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read trans_id in
                let* α3 :=
                  M.call_closure
                    α0
                    [ M.get_struct_record_field α1 "multisig::Multisig" "transactions"; α2 ] in
                M.alloc α3 in
              let* pos :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ] [])
                    "expect"
                    []
                    [ Value.Bool true ] in
                let* α1 :=
                  M.get_trait_method
                    "core::iter::traits::iterator::Iterator"
                    (Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.path "u32" ] [])
                    []
                    []
                    "position"
                    [
                      Ty.function
                        [ Ty.tuple [ Ty.apply (Ty.path "&") [ Ty.path "u32" ] [] ] ]
                        (Ty.path "bool")
                    ]
                    [] in
                let* α2 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "slice") [ Ty.path "u32" ] [])
                    "iter"
                    []
                    [] in
                let* α3 :=
                  M.get_trait_method
                    "core::ops::deref::Deref"
                    (Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ]
                      [])
                    []
                    []
                    "deref"
                    []
                    [] in
                let* α4 := M.read self in
                let* α5 :=
                  M.call_closure
                    α3
                    [
                      M.get_struct_record_field
                        (M.get_struct_record_field α4 "multisig::Multisig" "transaction_list")
                        "multisig::Transactions"
                        "transactions"
                    ] in
                let* α6 := M.call_closure α2 [ α5 ] in
                let* α7 := M.alloc α6 in
                let* α8 :=
                  M.call_closure
                    α1
                    [
                      α7;
                      M.closure
                        (fun γ =>
                          match γ with
                          | [ α0 ] =>
                            let* α0 := M.alloc α0 in
                            M.match_operator
                              α0
                              [
                                fun γ =>
                                  let* t := M.copy γ in
                                  let* α0 :=
                                    M.get_trait_method
                                      "core::cmp::PartialEq"
                                      (Ty.apply (Ty.path "&") [ Ty.path "u32" ] [])
                                      [ Ty.apply (Ty.path "&") [ Ty.path "u32" ] [] ]
                                      [ Value.Bool true ]
                                      "eq"
                                      []
                                      [] in
                                  let* α1 := M.alloc trans_id in
                                  M.call_closure α0 [ t; α1 ]
                              ]
                          | _ => M.impossible
                          end)
                    ] in
                let* α9 :=
                  M.read (mk_str "The transaction exists hence it must also be in the list.") in
                let* α10 := M.call_closure α0 [ α8; α9 ] in
                M.alloc α10 in
              let* _ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u32"; Ty.path "alloc::alloc::Global" ]
                      [])
                    "swap_remove"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read pos in
                let* α3 :=
                  M.call_closure
                    α0
                    [
                      M.get_struct_record_field
                        (M.get_struct_record_field α1 "multisig::Multisig" "transaction_list")
                        "multisig::Transactions"
                        "transactions";
                      α2
                    ] in
                M.alloc α3 in
              let* _ :=
                let* α0 :=
                  M.get_trait_method
                    "core::iter::traits::collect::IntoIterator"
                    (Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      [ Ty.path "multisig::AccountId" ]
                      [])
                    []
                    []
                    "into_iter"
                    []
                    [] in
                let* α1 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "slice") [ Ty.path "multisig::AccountId" ] [])
                    "iter"
                    []
                    [] in
                let* α2 :=
                  M.get_trait_method
                    "core::ops::deref::Deref"
                    (Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "multisig::AccountId"; Ty.path "alloc::alloc::Global" ]
                      [])
                    []
                    []
                    "deref"
                    []
                    [] in
                let* α3 := M.read self in
                let* α4 :=
                  M.call_closure
                    α2
                    [ M.get_struct_record_field α3 "multisig::Multisig" "owners" ] in
                let* α5 := M.call_closure α1 [ α4 ] in
                let* α6 := M.call_closure α0 [ α5 ] in
                let* α7 := M.alloc α6 in
                let* α8 :=
                  M.match_operator
                    α7
                    [
                      fun γ =>
                        let* iter := M.copy γ in
                        M.loop
                          (let* _ :=
                            let* α0 :=
                              M.get_trait_method
                                "core::iter::traits::iterator::Iterator"
                                (Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  [ Ty.path "multisig::AccountId" ]
                                  [])
                                []
                                []
                                "next"
                                []
                                [] in
                            let* α1 := M.call_closure α0 [ iter ] in
                            let* α2 := M.alloc α1 in
                            M.match_operator
                              α2
                              [
                                fun γ =>
                                  let* α0 := M.break in
                                  let* α1 := M.read α0 in
                                  let* α2 := M.never_to_any α1 in
                                  M.alloc α2;
                                fun γ =>
                                  let* γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match
                                      γ
                                      "core::option::Option::Some"
                                      0 in
                                  let* owner := M.copy γ0_0 in
                                  let* _ :=
                                    let* α0 :=
                                      M.get_associated_function
                                        (Ty.apply
                                          (Ty.path "multisig::Mapping")
                                          [
                                            Ty.tuple
                                              [ Ty.path "u32"; Ty.path "multisig::AccountId" ];
                                            Ty.tuple []
                                          ]
                                          [])
                                        "remove"
                                        []
                                        [] in
                                    let* α1 := M.read self in
                                    let* α2 := M.read trans_id in
                                    let* α3 := M.read owner in
                                    let* α4 := M.read α3 in
                                    let* α5 :=
                                      M.call_closure
                                        α0
                                        [
                                          M.get_struct_record_field
                                            α1
                                            "multisig::Multisig"
                                            "confirmations";
                                          Value.Tuple [ α2; α4 ]
                                        ] in
                                    M.alloc α5 in
                                  M.alloc (Value.Tuple [])
                              ] in
                          M.alloc (Value.Tuple []))
                    ] in
                M.pure (M.use α8) in
              let* _ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "multisig::Mapping") [ Ty.path "u32"; Ty.path "u32" ] [])
                    "remove"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read trans_id in
                let* α3 :=
                  M.call_closure
                    α0
                    [ M.get_struct_record_field α1 "multisig::Multisig" "confirmation_count"; α2
                    ] in
                M.alloc α3 in
              M.alloc (Value.Tuple []);
            fun γ => M.alloc (Value.Tuple [])
          ] in
      M.read transaction
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_take_transaction :
    M.IsAssociatedFunction Self "take_transaction" take_transaction.
  
  (*
      pub fn cancel_transaction(&mut self, trans_id: TransactionId) {
          self.ensure_from_wallet();
          if self.take_transaction(trans_id).is_some() {
              self.env().emit_event(Event::Cancellation(Cancellation {
                  transaction: trans_id,
              }));
          }
      }
  *)
  Definition cancel_transaction (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_from_wallet" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* α0 := M.alloc (Value.Tuple []) in
      let* α0 :=
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "multisig::Transaction" ]
                      [])
                    "is_some"
                    []
                    [ Value.Bool true ] in
                let* α1 :=
                  M.get_associated_function
                    (Ty.path "multisig::Multisig")
                    "take_transaction"
                    []
                    [] in
                let* α2 := M.read self in
                let* α3 := M.read trans_id in
                let* α4 := M.call_closure α1 [ α2; α3 ] in
                let* α5 := M.alloc α4 in
                let* α6 := M.call_closure α0 [ α5 ] in
                let* α7 := M.alloc α6 in
                M.pure (M.use α7) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* _ :=
                let* α0 := M.get_associated_function (Ty.path "multisig::Env") "emit_event" [] [] in
                let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
                let* α2 := M.read self in
                let* α3 := M.call_closure α1 [ α2 ] in
                let* α4 := M.alloc α3 in
                let* α5 := M.read trans_id in
                let* α6 :=
                  M.call_closure
                    α0
                    [
                      α4;
                      Value.StructTuple
                        "multisig::Event::Cancellation"
                        [ Value.StructRecord "multisig::Cancellation" [ ("transaction", α5) ] ]
                    ] in
                M.alloc α6 in
              M.alloc (Value.Tuple []);
            fun γ => M.alloc (Value.Tuple [])
          ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_cancel_transaction :
    M.IsAssociatedFunction Self "cancel_transaction" cancel_transaction.
  
  (*
      pub fn confirm_transaction(&mut self, trans_id: TransactionId) -> ConfirmationStatus {
          self.ensure_caller_is_owner();
          self.ensure_transaction_exists(trans_id);
          self.confirm_by_caller(self.env().caller(), trans_id)
      }
  *)
  Definition confirm_transaction (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_caller_is_owner" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.path "multisig::Multisig")
            "ensure_transaction_exists"
            []
            [] in
        let* α1 := M.read self in
        let* α2 := M.read trans_id in
        let* α3 := M.call_closure α0 [ α1; α2 ] in
        M.alloc α3 in
      let* α0 :=
        M.get_associated_function (Ty.path "multisig::Multisig") "confirm_by_caller" [] [] in
      let* α1 := M.read self in
      let* α2 := M.get_associated_function (Ty.path "multisig::Env") "caller" [] [] in
      let* α3 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
      let* α4 := M.read self in
      let* α5 := M.call_closure α3 [ α4 ] in
      let* α6 := M.alloc α5 in
      let* α7 := M.call_closure α2 [ α6 ] in
      let* α8 := M.read trans_id in
      let* α9 := M.call_closure α0 [ α1; α7; α8 ] in
      let* α0 := M.alloc α9 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_confirm_transaction :
    M.IsAssociatedFunction Self "confirm_transaction" confirm_transaction.
  
  (*
      pub fn revoke_confirmation(&mut self, trans_id: TransactionId) {
          self.ensure_caller_is_owner();
          let caller = self.env().caller();
          if self.confirmations.contains(&(trans_id, caller)) {
              self.confirmations.remove((trans_id, caller));
              let mut confirmation_count = self
                  .confirmation_count
                  .get(&trans_id)
                  .expect("There is a entry in `self.confirmations`. Hence a count must exit.");
              // Will not underflow as there is at least one confirmation
              confirmation_count -= 1;
              self.confirmation_count.insert(trans_id, confirmation_count);
              self.env().emit_event(Event::Revocation(Revocation {
                  transaction: trans_id,
                  from: caller,
              }));
          }
      }
  *)
  Definition revoke_confirmation (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_caller_is_owner" [] [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* caller :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Env") "caller" [] [] in
        let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.call_closure α0 [ α4 ] in
        M.alloc α5 in
      let* α0 := M.alloc (Value.Tuple []) in
      let* α0 :=
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply
                      (Ty.path "multisig::Mapping")
                      [ Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ]; Ty.tuple [] ]
                      [])
                    "contains"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read trans_id in
                let* α3 := M.read caller in
                let* α4 := M.alloc (Value.Tuple [ α2; α3 ]) in
                let* α5 :=
                  M.call_closure
                    α0
                    [ M.get_struct_record_field α1 "multisig::Multisig" "confirmations"; α4 ] in
                let* α6 := M.alloc α5 in
                M.pure (M.use α6) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* _ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply
                      (Ty.path "multisig::Mapping")
                      [ Ty.tuple [ Ty.path "u32"; Ty.path "multisig::AccountId" ]; Ty.tuple [] ]
                      [])
                    "remove"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read trans_id in
                let* α3 := M.read caller in
                let* α4 :=
                  M.call_closure
                    α0
                    [
                      M.get_struct_record_field α1 "multisig::Multisig" "confirmations";
                      Value.Tuple [ α2; α3 ]
                    ] in
                M.alloc α4 in
              let* confirmation_count :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ] [])
                    "expect"
                    []
                    [ Value.Bool true ] in
                let* α1 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "multisig::Mapping") [ Ty.path "u32"; Ty.path "u32" ] [])
                    "get"
                    []
                    [] in
                let* α2 := M.read self in
                let* α3 :=
                  M.call_closure
                    α1
                    [
                      M.get_struct_record_field α2 "multisig::Multisig" "confirmation_count";
                      trans_id
                    ] in
                let* α4 :=
                  M.read
                    (mk_str "There is a entry in `self.confirmations`. Hence a count must exit.") in
                let* α5 := M.call_closure α0 [ α3; α4 ] in
                M.alloc α5 in
              let* _ :=
                let β := confirmation_count in
                let* α0 := M.read β in
                let* α1 := BinOp.Panic.sub α0 (Value.Integer Integer.U32 1) in
                M.assign β α1 in
              let* _ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "multisig::Mapping") [ Ty.path "u32"; Ty.path "u32" ] [])
                    "insert"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read trans_id in
                let* α3 := M.read confirmation_count in
                let* α4 :=
                  M.call_closure
                    α0
                    [ M.get_struct_record_field α1 "multisig::Multisig" "confirmation_count"; α2; α3
                    ] in
                M.alloc α4 in
              let* _ :=
                let* α0 := M.get_associated_function (Ty.path "multisig::Env") "emit_event" [] [] in
                let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
                let* α2 := M.read self in
                let* α3 := M.call_closure α1 [ α2 ] in
                let* α4 := M.alloc α3 in
                let* α5 := M.read trans_id in
                let* α6 := M.read caller in
                let* α7 :=
                  M.call_closure
                    α0
                    [
                      α4;
                      Value.StructTuple
                        "multisig::Event::Revocation"
                        [
                          Value.StructRecord
                            "multisig::Revocation"
                            [ ("transaction", α5); ("from", α6) ]
                        ]
                    ] in
                M.alloc α7 in
              M.alloc (Value.Tuple []);
            fun γ => M.alloc (Value.Tuple [])
          ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_revoke_confirmation :
    M.IsAssociatedFunction Self "revoke_confirmation" revoke_confirmation.
  
  (*
      pub fn invoke_transaction(&mut self, trans_id: TransactionId) -> Result<(), Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          assert!(self.env().transferred_value() == t.transferred_value);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<()>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(_)) => Ok(()),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.map(|_| None),
          }));
          result
      }
  *)
  Definition invoke_transaction (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; trans_id ] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "ensure_confirmed" [] [] in
        let* α1 := M.read self in
        let* α2 := M.read trans_id in
        let* α3 := M.call_closure α0 [ α1; α2 ] in
        M.alloc α3 in
      let* t :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "core::option::Option") [ Ty.path "multisig::Transaction" ] [])
            "expect"
            []
            [ Value.Bool true ] in
        let* α1 :=
          M.get_associated_function (Ty.path "multisig::Multisig") "take_transaction" [] [] in
        let* α2 := M.read self in
        let* α3 := M.read trans_id in
        let* α4 := M.call_closure α1 [ α2; α3 ] in
        let* α5 := M.get_constant "multisig::WRONG_TRANSACTION_ID" in
        let* α6 := M.read α5 in
        let* α7 := M.call_closure α0 [ α4; α6 ] in
        M.alloc α7 in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function (Ty.path "multisig::Env") "transferred_value" [] [] in
                let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
                let* α2 := M.read self in
                let* α3 := M.call_closure α1 [ α2 ] in
                let* α4 := M.alloc α3 in
                let* α5 := M.call_closure α0 [ α4 ] in
                let* α6 :=
                  M.read
                    (M.get_struct_record_field t "multisig::Transaction" "transferred_value") in
                let* α7 := M.alloc (UnOp.Pure.not (BinOp.Pure.eq α5 α6)) in
                M.pure (M.use α7) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
              let* α1 :=
                M.read
                  (mk_str
                    "assertion failed: self.env().transferred_value() == t.transferred_value") in
              let* α2 := M.call_closure α0 [ α1 ] in
              let* α3 := M.never_to_any α2 in
              M.alloc α3;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* result :=
        let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
        let* α1 := M.read (mk_str "not yet implemented") in
        let* α2 := M.call_closure α0 [ α1 ] in
        let* α3 := M.never_to_any α2 in
        M.alloc α3 in
      let* result :=
        let* α0 :=
          M.match_operator
            result
            [
              fun γ =>
                let* γ0_0 :=
                  M.get_struct_tuple_field_or_break_match γ "core::result::Result::Ok" 0 in
                let* γ1_0 :=
                  M.get_struct_tuple_field_or_break_match γ0_0 "core::result::Result::Ok" 0 in
                M.alloc (Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]);
              fun γ =>
                M.alloc
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "multisig::Error::TransactionFailed" [] ])
            ] in
        M.copy α0 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "multisig::Env") "emit_event" [] [] in
        let* α1 := M.get_associated_function (Ty.path "multisig::Multisig") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read trans_id in
        let* α6 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "multisig::Error" ]
              [])
            "map"
            [
              Ty.apply
                (Ty.path "core::option::Option")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                    []
                ]
                [];
              Ty.function
                [ Ty.tuple [ Ty.tuple [] ] ]
                (Ty.apply
                  (Ty.path "core::option::Option")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      []
                  ]
                  [])
            ]
            [] in
        let* α7 := M.read result in
        let* α8 :=
          M.call_closure
            α6
            [
              α7;
              M.closure
                (fun γ =>
                  match γ with
                  | [ α0 ] =>
                    let* α0 := M.alloc α0 in
                    M.match_operator
                      α0
                      [ fun γ => M.pure (Value.StructTuple "core::option::Option::None" []) ]
                  | _ => M.impossible
                  end)
            ] in
        let* α9 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "multisig::Event::Execution"
                [ Value.StructRecord "multisig::Execution" [ ("transaction", α5); ("result", α8) ] ]
            ] in
        M.alloc α9 in
      M.read result
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_invoke_transaction :
    M.IsAssociatedFunction Self "invoke_transaction" invoke_transaction.
  
  (*
      pub fn eval_transaction(&mut self, trans_id: TransactionId) -> Result<Vec<u8>, Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<Vec<u8>>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(v)) => Ok(v),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.clone().map(Some),
          }));
          result
      }
  *)
  Parameter eval_transaction : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom AssociatedFunction_eval_transaction :
    M.IsAssociatedFunction Self "eval_transaction" eval_transaction.
End Impl_multisig_Multisig.
