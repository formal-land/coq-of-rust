(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Struct AccountId *)

Module Impl_core_default_Default_for_payment_channel_AccountId.
  (*
  Default
  *)
  Definition default (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [] =>
      let* Î±0 :=
        M.get_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "u128" ] in
      let* Î±1 := M.call Î±0 [] in
      M.pure (Value.StructTuple "payment_channel::AccountId" [ Î±1 ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      (* Self *) (Ty.path "payment_channel::AccountId")
      []
      [ ("default", InstanceField.Method default) ]
      [].
End Impl_core_default_Default_for_payment_channel_AccountId.

Module Impl_core_clone_Clone_for_payment_channel_AccountId.
  (*
  Clone
  *)
  Definition clone (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 :=
        match_operator
          Value.DeclaredButUndefined
          [ fun Î³ => (M.read self) : Ty.path "payment_channel::AccountId" ] in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      (* Self *) (Ty.path "payment_channel::AccountId")
      []
      [ ("clone", InstanceField.Method clone) ]
      [].
End Impl_core_clone_Clone_for_payment_channel_AccountId.

Module Impl_core_marker_Copy_for_payment_channel_AccountId.
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::Copy"
      (* Self *) (Ty.path "payment_channel::AccountId")
      []
      []
      [].
End Impl_core_marker_Copy_for_payment_channel_AccountId.

Module Impl_core_marker_StructuralPartialEq_for_payment_channel_AccountId.
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      (* Self *) (Ty.path "payment_channel::AccountId")
      []
      []
      [].
End Impl_core_marker_StructuralPartialEq_for_payment_channel_AccountId.

Module Impl_core_cmp_PartialEq_for_payment_channel_AccountId.
  (*
  PartialEq
  *)
  Definition eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Î±0 := M.var "BinOp::Pure::eq" in
      let* Î±1 := M.var "payment_channel::AccountId::Get_0" in
      let* Î±2 := M.read self in
      let* Î±3 := M.read (Î±1 Î±2) in
      let* Î±4 := M.var "payment_channel::AccountId::Get_0" in
      let* Î±5 := M.read other in
      let* Î±6 := M.read (Î±4 Î±5) in
      M.pure (Î±0 Î±3 Î±6)
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      (* Self *) (Ty.path "payment_channel::AccountId")
      []
      [ ("eq", InstanceField.Method eq) ]
      [].
End Impl_core_cmp_PartialEq_for_payment_channel_AccountId.

Module Impl_core_marker_StructuralEq_for_payment_channel_AccountId.
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralEq"
      (* Self *) (Ty.path "payment_channel::AccountId")
      []
      []
      [].
End Impl_core_marker_StructuralEq_for_payment_channel_AccountId.

Module Impl_core_cmp_Eq_for_payment_channel_AccountId.
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq
      (ðœ : list Ty.t)
      (Î± : list Value.t)
      : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 :=
        match_operator
          Value.DeclaredButUndefined
          [ fun Î³ => (M.alloc tt) : Ty.path "unit" ] in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Eq"
      (* Self *) (Ty.path "payment_channel::AccountId")
      []
      [
        ("assert_receiver_is_total_eq",
          InstanceField.Method assert_receiver_is_total_eq)
      ]
      [].
End Impl_core_cmp_Eq_for_payment_channel_AccountId.

Module Impl_core_convert_From_array_u8_for_payment_channel_AccountId.
  (*
      fn from(value: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Definition from (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ value ] =>
      let* value := M.alloc value in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      (* Self *) (Ty.path "payment_channel::AccountId")
      [ (* T *) Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
      [ ("from", InstanceField.Method from) ]
      [].
End Impl_core_convert_From_array_u8_for_payment_channel_AccountId.

Axiom Balance : (Ty.path "payment_channel::Balance") = (Ty.path "u128").

Axiom Timestamp : (Ty.path "payment_channel::Timestamp") = (Ty.path "u64").

(* Struct Env *)

(* Struct PaymentChannel *)

(* Enum Error *)

Module Impl_core_marker_StructuralPartialEq_for_payment_channel_Error.
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      (* Self *) (Ty.path "payment_channel::Error")
      []
      []
      [].
End Impl_core_marker_StructuralPartialEq_for_payment_channel_Error.

Module Impl_core_cmp_PartialEq_for_payment_channel_Error.
  (*
  PartialEq
  *)
  Definition eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* __self_tag :=
        let* Î±0 := M.var "core::intrinsics::discriminant_value" in
        let* Î±1 := M.read self in
        let* Î±2 := M.call Î±0 [ Î±1 ] in
        M.alloc Î±2 in
      let* __arg1_tag :=
        let* Î±0 := M.var "core::intrinsics::discriminant_value" in
        let* Î±1 := M.read other in
        let* Î±2 := M.call Î±0 [ Î±1 ] in
        M.alloc Î±2 in
      let* Î±0 := M.var "BinOp::Pure::eq" in
      let* Î±1 := M.read __self_tag in
      let* Î±2 := M.read __arg1_tag in
      let* Î±0 := M.alloc (Î±0 Î±1 Î±2) in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      (* Self *) (Ty.path "payment_channel::Error")
      []
      [ ("eq", InstanceField.Method eq) ]
      [].
End Impl_core_cmp_PartialEq_for_payment_channel_Error.

Module Impl_core_marker_StructuralEq_for_payment_channel_Error.
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralEq"
      (* Self *) (Ty.path "payment_channel::Error")
      []
      []
      [].
End Impl_core_marker_StructuralEq_for_payment_channel_Error.

Module Impl_core_cmp_Eq_for_payment_channel_Error.
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq
      (ðœ : list Ty.t)
      (Î± : list Value.t)
      : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      M.pure tt
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Eq"
      (* Self *) (Ty.path "payment_channel::Error")
      []
      [
        ("assert_receiver_is_total_eq",
          InstanceField.Method assert_receiver_is_total_eq)
      ]
      [].
End Impl_core_cmp_Eq_for_payment_channel_Error.

Axiom Result :
  forall (T : Ty.t),
  (Ty.path "payment_channel::Result") =
    (Ty.apply
      (Ty.path "core::result::Result")
      [ T; Ty.path "payment_channel::Error" ]).

(* Struct SenderCloseStarted *)

(* Enum Event *)

Module Impl_payment_channel_Env.
  Definition Self : Ty.t := Ty.path "payment_channel::Env".
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "payment_channel::Env::Get_caller" in
      let* Î±1 := M.read self in
      M.read (Î±0 Î±1)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_caller :
    M.IsAssociatedFunction Self "caller" caller [].
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; _event ] =>
      let* self := M.alloc self in
      let* _event := M.alloc _event in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_emit_event :
    M.IsAssociatedFunction Self "emit_event" emit_event [].
  
  (*
      fn terminate_contract(&self, sender: AccountId) {
          unimplemented!()
      }
  *)
  Definition terminate_contract (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; sender ] =>
      let* self := M.alloc self in
      let* sender := M.alloc sender in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_terminate_contract :
    M.IsAssociatedFunction Self "terminate_contract" terminate_contract [].
  
  (*
      fn transfer(&self, recipient: AccountId, amount: Balance) -> Result<()> {
          unimplemented!()
      }
  *)
  Definition transfer (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; recipient; amount ] =>
      let* self := M.alloc self in
      let* recipient := M.alloc recipient in
      let* amount := M.alloc amount in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_transfer :
    M.IsAssociatedFunction Self "transfer" transfer [].
  
  (*
      fn block_timestamp(&self) -> Timestamp {
          unimplemented!()
      }
  *)
  Definition block_timestamp (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_block_timestamp :
    M.IsAssociatedFunction Self "block_timestamp" block_timestamp [].
  
  (*
      fn balance(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition balance (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_balance :
    M.IsAssociatedFunction Self "balance" balance [].
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Definition account_id (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_account_id :
    M.IsAssociatedFunction Self "account_id" account_id [].
End Impl_payment_channel_Env.

(* Trait *)
Module HashOutput.
  
End HashOutput.

(* Trait *)
Module CryptoHash.
  
End CryptoHash.

(*
pub fn hash_encoded<H, T>(input: &T, output: &mut <H as HashOutput>::Type)
where
    H: CryptoHash,
{
    unimplemented!()
}
*)
Definition hash_encoded (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [ H; T ], [ input; output ] =>
    let* input := M.alloc input in
    let* output := M.alloc output in
    let* Î±0 := M.var "core::panicking::panic" in
    let* Î±1 := M.read (mk_str "not implemented") in
    let* Î±2 := M.call Î±0 [ Î±1 ] in
    never_to_any Î±2
  | _, _ => M.impossible
  end.

(*
pub fn ecdsa_recover(
    signature: &[u8; 65],
    message_hash: &[u8; 32],
    output: &mut [u8; 33],
) -> Result<()> {
    unimplemented!()
}
*)
Definition ecdsa_recover (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [], [ signature; message_hash; output ] =>
    let* signature := M.alloc signature in
    let* message_hash := M.alloc message_hash in
    let* output := M.alloc output in
    let* Î±0 := M.var "core::panicking::panic" in
    let* Î±1 := M.read (mk_str "not implemented") in
    let* Î±2 := M.call Î±0 [ Î±1 ] in
    never_to_any Î±2
  | _, _ => M.impossible
  end.

(* Enum Sha2x256 *)

(* Enum Keccak256 *)

(* Enum Blake2x256 *)

(* Enum Blake2x128 *)

Module Impl_payment_channel_HashOutput_for_payment_channel_Sha2x256.
  (*
      type Type = [u8; 32];
  *)
  Definition Type_ : Set := Ty.apply (Ty.path "array") [ Ty.path "u8" ].
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::HashOutput"
      (* Self *) (Ty.path "payment_channel::Sha2x256")
      []
      [ ("Type_", TODO) ]
      [].
End Impl_payment_channel_HashOutput_for_payment_channel_Sha2x256.

Module Impl_payment_channel_HashOutput_for_payment_channel_Keccak256.
  (*
      type Type = [u8; 32];
  *)
  Definition Type_ : Set := Ty.apply (Ty.path "array") [ Ty.path "u8" ].
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::HashOutput"
      (* Self *) (Ty.path "payment_channel::Keccak256")
      []
      [ ("Type_", TODO) ]
      [].
End Impl_payment_channel_HashOutput_for_payment_channel_Keccak256.

Module Impl_payment_channel_HashOutput_for_payment_channel_Blake2x256.
  (*
      type Type = [u8; 32];
  *)
  Definition Type_ : Set := Ty.apply (Ty.path "array") [ Ty.path "u8" ].
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::HashOutput"
      (* Self *) (Ty.path "payment_channel::Blake2x256")
      []
      [ ("Type_", TODO) ]
      [].
End Impl_payment_channel_HashOutput_for_payment_channel_Blake2x256.

Module Impl_payment_channel_HashOutput_for_payment_channel_Blake2x128.
  (*
      type Type = [u8; 16];
  *)
  Definition Type_ : Set := Ty.apply (Ty.path "array") [ Ty.path "u8" ].
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::HashOutput"
      (* Self *) (Ty.path "payment_channel::Blake2x128")
      []
      [ ("Type_", TODO) ]
      [].
End Impl_payment_channel_HashOutput_for_payment_channel_Blake2x128.

Module Impl_payment_channel_CryptoHash_for_payment_channel_Sha2x256.
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ input; output ] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::CryptoHash"
      (* Self *) (Ty.path "payment_channel::Sha2x256")
      []
      [ ("hash", InstanceField.Method hash) ]
      [].
End Impl_payment_channel_CryptoHash_for_payment_channel_Sha2x256.

Module Impl_payment_channel_CryptoHash_for_payment_channel_Keccak256.
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ input; output ] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::CryptoHash"
      (* Self *) (Ty.path "payment_channel::Keccak256")
      []
      [ ("hash", InstanceField.Method hash) ]
      [].
End Impl_payment_channel_CryptoHash_for_payment_channel_Keccak256.

Module Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x256.
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ input; output ] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::CryptoHash"
      (* Self *) (Ty.path "payment_channel::Blake2x256")
      []
      [ ("hash", InstanceField.Method hash) ]
      [].
End Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x256.

Module Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x128.
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ input; output ] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::CryptoHash"
      (* Self *) (Ty.path "payment_channel::Blake2x128")
      []
      [ ("hash", InstanceField.Method hash) ]
      [].
End Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x128.

Module Impl_payment_channel_PaymentChannel.
  Definition Self : Ty.t := Ty.path "payment_channel::PaymentChannel".
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [] =>
      let* Î±0 := M.var "core::panicking::panic" in
      let* Î±1 := M.read (mk_str "not implemented") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      never_to_any Î±2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_init_env :
    M.IsAssociatedFunction Self "init_env" init_env [].
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      M.call (Ty.path "payment_channel::PaymentChannel")::["init_env"] []
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_env : M.IsAssociatedFunction Self "env" env [].
  
  (*
      fn is_signature_valid(&self, amount: Balance, signature: [u8; 65]) -> bool {
          let encodable = (self.env().account_id(), amount);
          let mut message = <Sha2x256 as HashOutput>::Type::default();
          hash_encoded::<Sha2x256, _>(&encodable, &mut message);
  
          let mut pub_key = [0; 33];
          ecdsa_recover(&signature, &message, &mut pub_key)
              .unwrap_or_else(|err| panic!("recover failed: {err:?}"));
          let mut signature_account_id = [0; 32];
          <Blake2x256 as CryptoHash>::hash(&pub_key, &mut signature_account_id);
  
          self.recipient == signature_account_id.into()
      }
  *)
  Definition is_signature_valid (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; amount; signature ] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let* encodable :=
        let* Î±0 := M.read self in
        let* Î±1 :=
          M.call (Ty.path "payment_channel::PaymentChannel")::["env"] [ Î±0 ] in
        let* Î±2 := M.alloc Î±1 in
        let* Î±3 :=
          M.call (Ty.path "payment_channel::Env")::["account_id"] [ Î±2 ] in
        let* Î±4 := M.read amount in
        M.alloc (Î±3, Î±4) in
      let* message :=
        let* Î±0 :=
          M.get_method
            "core::default::Default"
            "default"
            [ (* Self *) Ty.apply (Ty.path "array") [ Ty.path "u8" ] ] in
        let* Î±1 := M.call Î±0 [] in
        M.alloc Î±1 in
      let* _ :=
        let* Î±0 := M.var "payment_channel::hash_encoded" in
        let* Î±1 := M.call Î±0 [ encodable; message ] in
        M.alloc Î±1 in
      let* pub_key := M.alloc (repeat ((Integer.of_Z 0) : Ty.path "u8") 33) in
      let* _ :=
        let* Î±0 := M.var "payment_channel::ecdsa_recover" in
        let* Î±1 := M.call Î±0 [ signature; message; pub_key ] in
        let* Î±2 :=
          M.call
            (Ty.apply
                (Ty.path "core::result::Result")
                [ Ty.tuple []; Ty.path "payment_channel::Error"
                ])::["unwrap_or_else"]
            [
              Î±1;
              fun (Î±0 : Ty.path "payment_channel::Error") =>
                (let* Î±0 := M.alloc Î±0 in
                match_operator
                  Î±0
                  [
                    fun Î³ =>
                      (let* err := M.copy Î³ in
                      let* Î±0 := M.var "std::panicking::begin_panic" in
                      let* Î±1 := M.read (mk_str "recover failed: {err:?}") in
                      let* Î±2 := M.call Î±0 [ Î±1 ] in
                      never_to_any Î±2) :
                      _
                  ]) :
                _
            ] in
        M.alloc Î±2 in
      let* signature_account_id :=
        M.alloc (repeat ((Integer.of_Z 0) : Ty.path "u8") 32) in
      let* _ :=
        let* Î±0 :=
          M.get_method
            "payment_channel::CryptoHash"
            "hash"
            [ (* Self *) Ty.path "payment_channel::Blake2x256" ] in
        let* Î±1 :=
          M.call
            Î±0
            [ pointer_coercion "Unsize" pub_key; signature_account_id ] in
        M.alloc Î±1 in
      let* Î±0 :=
        M.get_method
          "core::cmp::PartialEq"
          "eq"
          [
            (* Self *) Ty.path "payment_channel::AccountId";
            (* Rhs *) Ty.path "payment_channel::AccountId"
          ] in
      let* Î±1 := M.var "payment_channel::PaymentChannel::Get_recipient" in
      let* Î±2 := M.read self in
      let* Î±3 :=
        M.get_method
          "core::convert::Into"
          "into"
          [
            (* Self *) Ty.apply (Ty.path "array") [ Ty.path "u8" ];
            (* T *) Ty.path "payment_channel::AccountId"
          ] in
      let* Î±4 := M.read signature_account_id in
      let* Î±5 := M.call Î±3 [ Î±4 ] in
      let* Î±6 := M.alloc Î±5 in
      let* Î±7 := M.call Î±0 [ Î±1 Î±2; Î±6 ] in
      let* Î±0 := M.alloc Î±7 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_is_signature_valid :
    M.IsAssociatedFunction Self "is_signature_valid" is_signature_valid [].
  
  (*
      pub fn new(recipient: AccountId, close_duration: Timestamp) -> Self {
          Self {
              sender: Self::init_env().caller(),
              recipient,
              expiration: None,
              withdrawn: 0,
              close_duration,
          }
      }
  *)
  Definition new (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ recipient; close_duration ] =>
      let* recipient := M.alloc recipient in
      let* close_duration := M.alloc close_duration in
      let* Î±0 :=
        M.call (Ty.path "payment_channel::PaymentChannel")::["init_env"] [] in
      let* Î±1 := M.alloc Î±0 in
      let* Î±2 := M.call (Ty.path "payment_channel::Env")::["caller"] [ Î±1 ] in
      let* Î±3 := M.read recipient in
      let* Î±4 := M.read close_duration in
      M.pure
        (Value.StructRecord
          "payment_channel::PaymentChannel"
          [
            ("sender", Î±2);
            ("recipient", Î±3);
            ("expiration", core.option.Option.None);
            ("withdrawn", (Integer.of_Z 0) : Ty.path "u128");
            ("close_duration", Î±4)
          ])
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new [].
  
  (*
      fn close_inner(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {
          if self.env().caller() != self.recipient {
              return Err(Error::CallerIsNotRecipient);
          }
  
          if amount < self.withdrawn {
              return Err(Error::AmountIsLessThanWithdrawn);
          }
  
          // Signature validation
          if !self.is_signature_valid(amount, signature) {
              return Err(Error::InvalidSignature);
          }
  
          self.env()
              .transfer(self.recipient, amount - self.withdrawn)
              .map_err(|_| Error::TransferFailed)?;
  
          Ok(())
      }
  *)
  Definition close_inner (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; amount; signature ] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]) in
      M.catch_return
        (let* _ :=
          let* Î±0 :=
            M.get_method
              "core::cmp::PartialEq"
              "ne"
              [
                (* Self *) Ty.path "payment_channel::AccountId";
                (* Rhs *) Ty.path "payment_channel::AccountId"
              ] in
          let* Î±1 := M.read self in
          let* Î±2 :=
            M.call
              (Ty.path "payment_channel::PaymentChannel")::["env"]
              [ Î±1 ] in
          let* Î±3 := M.alloc Î±2 in
          let* Î±4 :=
            M.call (Ty.path "payment_channel::Env")::["caller"] [ Î±3 ] in
          let* Î±5 := M.alloc Î±4 in
          let* Î±6 := M.var "payment_channel::PaymentChannel::Get_recipient" in
          let* Î±7 := M.read self in
          let* Î±8 := M.call Î±0 [ Î±5; Î±6 Î±7 ] in
          let* Î±9 := M.alloc Î±8 in
          let* Î±10 := M.read (use Î±9) in
          if Î±10 then
            let* Î±0 :=
              return_
                (Value.StructTuple
                  "core::result::Result::Err"
                  [ payment_channel.Error.CallerIsNotRecipient ]) in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2
          else
            M.alloc tt in
        let* _ :=
          let* Î±0 := M.var "BinOp::Pure::lt" in
          let* Î±1 := M.read amount in
          let* Î±2 := M.var "payment_channel::PaymentChannel::Get_withdrawn" in
          let* Î±3 := M.read self in
          let* Î±4 := M.read (Î±2 Î±3) in
          let* Î±5 := M.alloc (Î±0 Î±1 Î±4) in
          let* Î±6 := M.read (use Î±5) in
          if Î±6 then
            let* Î±0 :=
              return_
                (Value.StructTuple
                  "core::result::Result::Err"
                  [ payment_channel.Error.AmountIsLessThanWithdrawn ]) in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2
          else
            M.alloc tt in
        let* _ :=
          let* Î±0 := M.var "UnOp::not" in
          let* Î±1 := M.read self in
          let* Î±2 := M.read amount in
          let* Î±3 := M.read signature in
          let* Î±4 :=
            M.call
              (Ty.path
                  "payment_channel::PaymentChannel")::["is_signature_valid"]
              [ Î±1; Î±2; Î±3 ] in
          let* Î±5 := M.alloc (Î±0 Î±4) in
          let* Î±6 := M.read (use Î±5) in
          if Î±6 then
            let* Î±0 :=
              return_
                (Value.StructTuple
                  "core::result::Result::Err"
                  [ payment_channel.Error.InvalidSignature ]) in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2
          else
            M.alloc tt in
        let* _ :=
          let* Î±0 :=
            M.get_method
              "core::ops::try_trait::Try"
              "branch"
              [
                (* Self *)
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.tuple []; Ty.path "payment_channel::Error" ]
              ] in
          let* Î±1 := M.read self in
          let* Î±2 :=
            M.call
              (Ty.path "payment_channel::PaymentChannel")::["env"]
              [ Î±1 ] in
          let* Î±3 := M.alloc Î±2 in
          let* Î±4 := M.var "payment_channel::PaymentChannel::Get_recipient" in
          let* Î±5 := M.read self in
          let* Î±6 := M.read (Î±4 Î±5) in
          let* Î±7 := M.var "BinOp::Panic::sub" in
          let* Î±8 := M.read amount in
          let* Î±9 := M.var "payment_channel::PaymentChannel::Get_withdrawn" in
          let* Î±10 := M.read self in
          let* Î±11 := M.read (Î±9 Î±10) in
          let* Î±12 := Î±7 Î±8 Î±11 in
          let* Î±13 :=
            M.call
              (Ty.path "payment_channel::Env")::["transfer"]
              [ Î±3; Î±6; Î±12 ] in
          let* Î±14 :=
            M.call
              (Ty.apply
                  (Ty.path "core::result::Result")
                  [ Ty.tuple []; Ty.path "payment_channel::Error"
                  ])::["map_err"]
              [
                Î±13;
                fun (Î±0 : Ty.path "payment_channel::Error") =>
                  (let* Î±0 := M.alloc Î±0 in
                  match_operator
                    Î±0
                    [ fun Î³ => (M.pure payment_channel.Error.TransferFailed) : _
                    ]) :
                  _
              ] in
          let* Î±15 := M.call Î±0 [ Î±14 ] in
          let* Î±16 := M.alloc Î±15 in
          match_operator
            Î±16
            [
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let* Î³0_0 :=
                    let* Î±0 :=
                      M.var
                        "core::ops::control_flow::ControlFlow::Get_Break_0" in
                    M.pure (Î±0 Î³) in
                  let* residual := M.copy Î³0_0 in
                  let* Î±0 :=
                    M.get_method
                      "core::ops::try_trait::FromResidual"
                      "from_residual"
                      [
                        (* Self *)
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "payment_channel::Error" ];
                        (* R *)
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.path "core::convert::Infallible";
                              Ty.path "payment_channel::Error"
                            ]
                      ] in
                  let* Î±1 := M.read residual in
                  let* Î±2 := M.call Î±0 [ Î±1 ] in
                  let* Î±3 := return_ Î±2 in
                  let* Î±4 := M.read Î±3 in
                  let* Î±5 := never_to_any Î±4 in
                  M.alloc Î±5
                | _ => M.break_match 
                end) :
                Ty.tuple [];
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let* Î³0_0 :=
                    let* Î±0 :=
                      M.var
                        "core::ops::control_flow::ControlFlow::Get_Continue_0" in
                    M.pure (Î±0 Î³) in
                  let* val := M.copy Î³0_0 in
                  M.pure val
                | _ => M.break_match 
                end) :
                Ty.tuple []
            ] in
        let* Î±0 :=
          M.alloc (Value.StructTuple "core::result::Result::Ok" [ tt ]) in
        M.read Î±0)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_close_inner :
    M.IsAssociatedFunction Self "close_inner" close_inner [].
  
  (*
      pub fn close(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {
          self.close_inner(amount, signature)?;
          self.env().terminate_contract(self.sender);
  
          Ok(())
      }
  *)
  Definition close (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; amount; signature ] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]) in
      M.catch_return
        (let* _ :=
          let* Î±0 :=
            M.get_method
              "core::ops::try_trait::Try"
              "branch"
              [
                (* Self *)
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.tuple []; Ty.path "payment_channel::Error" ]
              ] in
          let* Î±1 := M.read self in
          let* Î±2 := M.read amount in
          let* Î±3 := M.read signature in
          let* Î±4 :=
            M.call
              (Ty.path "payment_channel::PaymentChannel")::["close_inner"]
              [ Î±1; Î±2; Î±3 ] in
          let* Î±5 := M.call Î±0 [ Î±4 ] in
          let* Î±6 := M.alloc Î±5 in
          match_operator
            Î±6
            [
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let* Î³0_0 :=
                    let* Î±0 :=
                      M.var
                        "core::ops::control_flow::ControlFlow::Get_Break_0" in
                    M.pure (Î±0 Î³) in
                  let* residual := M.copy Î³0_0 in
                  let* Î±0 :=
                    M.get_method
                      "core::ops::try_trait::FromResidual"
                      "from_residual"
                      [
                        (* Self *)
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "payment_channel::Error" ];
                        (* R *)
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.path "core::convert::Infallible";
                              Ty.path "payment_channel::Error"
                            ]
                      ] in
                  let* Î±1 := M.read residual in
                  let* Î±2 := M.call Î±0 [ Î±1 ] in
                  let* Î±3 := return_ Î±2 in
                  let* Î±4 := M.read Î±3 in
                  let* Î±5 := never_to_any Î±4 in
                  M.alloc Î±5
                | _ => M.break_match 
                end) :
                Ty.tuple [];
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let* Î³0_0 :=
                    let* Î±0 :=
                      M.var
                        "core::ops::control_flow::ControlFlow::Get_Continue_0" in
                    M.pure (Î±0 Î³) in
                  let* val := M.copy Î³0_0 in
                  M.pure val
                | _ => M.break_match 
                end) :
                Ty.tuple []
            ] in
        let* _ :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              (Ty.path "payment_channel::PaymentChannel")::["env"]
              [ Î±0 ] in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.var "payment_channel::PaymentChannel::Get_sender" in
          let* Î±4 := M.read self in
          let* Î±5 := M.read (Î±3 Î±4) in
          let* Î±6 :=
            M.call
              (Ty.path "payment_channel::Env")::["terminate_contract"]
              [ Î±2; Î±5 ] in
          M.alloc Î±6 in
        let* Î±0 :=
          M.alloc (Value.StructTuple "core::result::Result::Ok" [ tt ]) in
        M.read Î±0)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_close : M.IsAssociatedFunction Self "close" close [].
  
  (*
      pub fn start_sender_close(&mut self) -> Result<()> {
          if self.env().caller() != self.sender {
              return Err(Error::CallerIsNotSender);
          }
  
          let now = self.env().block_timestamp();
          let expiration = now + self.close_duration;
  
          self.env()
              .emit_event(Event::SenderCloseStarted(SenderCloseStarted {
                  expiration,
                  close_duration: self.close_duration,
              }));
  
          self.expiration = Some(expiration);
  
          Ok(())
      }
  *)
  Definition start_sender_close (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]) in
      M.catch_return
        (let* _ :=
          let* Î±0 :=
            M.get_method
              "core::cmp::PartialEq"
              "ne"
              [
                (* Self *) Ty.path "payment_channel::AccountId";
                (* Rhs *) Ty.path "payment_channel::AccountId"
              ] in
          let* Î±1 := M.read self in
          let* Î±2 :=
            M.call
              (Ty.path "payment_channel::PaymentChannel")::["env"]
              [ Î±1 ] in
          let* Î±3 := M.alloc Î±2 in
          let* Î±4 :=
            M.call (Ty.path "payment_channel::Env")::["caller"] [ Î±3 ] in
          let* Î±5 := M.alloc Î±4 in
          let* Î±6 := M.var "payment_channel::PaymentChannel::Get_sender" in
          let* Î±7 := M.read self in
          let* Î±8 := M.call Î±0 [ Î±5; Î±6 Î±7 ] in
          let* Î±9 := M.alloc Î±8 in
          let* Î±10 := M.read (use Î±9) in
          if Î±10 then
            let* Î±0 :=
              return_
                (Value.StructTuple
                  "core::result::Result::Err"
                  [ payment_channel.Error.CallerIsNotSender ]) in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2
          else
            M.alloc tt in
        let* now :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              (Ty.path "payment_channel::PaymentChannel")::["env"]
              [ Î±0 ] in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 :=
            M.call
              (Ty.path "payment_channel::Env")::["block_timestamp"]
              [ Î±2 ] in
          M.alloc Î±3 in
        let* expiration :=
          let* Î±0 := M.var "BinOp::Panic::add" in
          let* Î±1 := M.read now in
          let* Î±2 :=
            M.var "payment_channel::PaymentChannel::Get_close_duration" in
          let* Î±3 := M.read self in
          let* Î±4 := M.read (Î±2 Î±3) in
          let* Î±5 := Î±0 Î±1 Î±4 in
          M.alloc Î±5 in
        let* _ :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call
              (Ty.path "payment_channel::PaymentChannel")::["env"]
              [ Î±0 ] in
          let* Î±2 := M.alloc Î±1 in
          let* Î±3 := M.read expiration in
          let* Î±4 :=
            M.var "payment_channel::PaymentChannel::Get_close_duration" in
          let* Î±5 := M.read self in
          let* Î±6 := M.read (Î±4 Î±5) in
          let* Î±7 :=
            M.call
              (Ty.path "payment_channel::Env")::["emit_event"]
              [
                Î±2;
                Value.StructTuple
                  "payment_channel::Event::SenderCloseStarted"
                  [
                    Value.StructRecord
                      "payment_channel::SenderCloseStarted"
                      [ ("expiration", Î±3); ("close_duration", Î±6) ]
                  ]
              ] in
          M.alloc Î±7 in
        let* _ :=
          let* Î±0 := M.var "payment_channel::PaymentChannel::Get_expiration" in
          let* Î±1 := M.read self in
          let* Î±2 := M.read expiration in
          assign
            (Î±0 Î±1)
            (Value.StructTuple "core::option::Option::Some" [ Î±2 ]) in
        let* Î±0 :=
          M.alloc (Value.StructTuple "core::result::Result::Ok" [ tt ]) in
        M.read Î±0)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_start_sender_close :
    M.IsAssociatedFunction Self "start_sender_close" start_sender_close [].
  
  (*
      pub fn claim_timeout(&mut self) -> Result<()> {
          match self.expiration {
              Some(expiration) => {
                  // expiration is set. Check if it's reached and if so, release the
                  // funds and terminate the contract.
                  let now = self.env().block_timestamp();
                  if now < expiration {
                      return Err(Error::NotYetExpired);
                  }
  
                  self.env().terminate_contract(self.sender);
  
                  Ok(())
              }
  
              None => Err(Error::NotYetExpired),
          }
      }
  *)
  Definition claim_timeout (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]) in
      M.catch_return
        (let* Î±0 := M.var "payment_channel::PaymentChannel::Get_expiration" in
        let* Î±1 := M.read self in
        let* Î±2 :=
          match_operator
            (Î±0 Î±1)
            [
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.option.Option.Some _ =>
                  let* Î³0_0 :=
                    let* Î±0 := M.var "core::option::Option::Get_Some_0" in
                    M.pure (Î±0 Î³) in
                  let* expiration := M.copy Î³0_0 in
                  let* now :=
                    let* Î±0 := M.read self in
                    let* Î±1 :=
                      M.call
                        (Ty.path "payment_channel::PaymentChannel")::["env"]
                        [ Î±0 ] in
                    let* Î±2 := M.alloc Î±1 in
                    let* Î±3 :=
                      M.call
                        (Ty.path "payment_channel::Env")::["block_timestamp"]
                        [ Î±2 ] in
                    M.alloc Î±3 in
                  let* _ :=
                    let* Î±0 := M.var "BinOp::Pure::lt" in
                    let* Î±1 := M.read now in
                    let* Î±2 := M.read expiration in
                    let* Î±3 := M.alloc (Î±0 Î±1 Î±2) in
                    let* Î±4 := M.read (use Î±3) in
                    if Î±4 then
                      let* Î±0 :=
                        return_
                          (Value.StructTuple
                            "core::result::Result::Err"
                            [ payment_channel.Error.NotYetExpired ]) in
                      let* Î±1 := M.read Î±0 in
                      let* Î±2 := never_to_any Î±1 in
                      M.alloc Î±2
                    else
                      M.alloc tt in
                  let* _ :=
                    let* Î±0 := M.read self in
                    let* Î±1 :=
                      M.call
                        (Ty.path "payment_channel::PaymentChannel")::["env"]
                        [ Î±0 ] in
                    let* Î±2 := M.alloc Î±1 in
                    let* Î±3 :=
                      M.var "payment_channel::PaymentChannel::Get_sender" in
                    let* Î±4 := M.read self in
                    let* Î±5 := M.read (Î±3 Î±4) in
                    let* Î±6 :=
                      M.call
                        (Ty.path "payment_channel::Env")::["terminate_contract"]
                        [ Î±2; Î±5 ] in
                    M.alloc Î±6 in
                  M.alloc (Value.StructTuple "core::result::Result::Ok" [ tt ])
                | _ => M.break_match 
                end) :
                Ty.apply
                  (Ty.path "core::result::Result")
                  [ Ty.tuple []; Ty.path "payment_channel::Error" ];
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.option.Option.None =>
                  M.alloc
                    (Value.StructTuple
                      "core::result::Result::Err"
                      [ payment_channel.Error.NotYetExpired ])
                | _ => M.break_match 
                end) :
                Ty.apply
                  (Ty.path "core::result::Result")
                  [ Ty.tuple []; Ty.path "payment_channel::Error" ]
            ] in
        M.read Î±2)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_claim_timeout :
    M.IsAssociatedFunction Self "claim_timeout" claim_timeout [].
  
  (*
      pub fn withdraw(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {
          if self.env().caller() != self.recipient {
              return Err(Error::CallerIsNotRecipient);
          }
  
          // Signature validation
          if !self.is_signature_valid(amount, signature) {
              return Err(Error::InvalidSignature);
          }
  
          // Make sure there's something to withdraw (guards against underflow)
          if amount < self.withdrawn {
              return Err(Error::AmountIsLessThanWithdrawn);
          }
  
          let amount_to_withdraw = amount - self.withdrawn;
          self.withdrawn += amount_to_withdraw;
  
          self.env()
              .transfer(self.recipient, amount_to_withdraw)
              .map_err(|_| Error::TransferFailed)?;
  
          Ok(())
      }
  *)
  Definition withdraw (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; amount; signature ] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]) in
      M.catch_return
        (let* _ :=
          let* Î±0 :=
            M.get_method
              "core::cmp::PartialEq"
              "ne"
              [
                (* Self *) Ty.path "payment_channel::AccountId";
                (* Rhs *) Ty.path "payment_channel::AccountId"
              ] in
          let* Î±1 := M.read self in
          let* Î±2 :=
            M.call
              (Ty.path "payment_channel::PaymentChannel")::["env"]
              [ Î±1 ] in
          let* Î±3 := M.alloc Î±2 in
          let* Î±4 :=
            M.call (Ty.path "payment_channel::Env")::["caller"] [ Î±3 ] in
          let* Î±5 := M.alloc Î±4 in
          let* Î±6 := M.var "payment_channel::PaymentChannel::Get_recipient" in
          let* Î±7 := M.read self in
          let* Î±8 := M.call Î±0 [ Î±5; Î±6 Î±7 ] in
          let* Î±9 := M.alloc Î±8 in
          let* Î±10 := M.read (use Î±9) in
          if Î±10 then
            let* Î±0 :=
              return_
                (Value.StructTuple
                  "core::result::Result::Err"
                  [ payment_channel.Error.CallerIsNotRecipient ]) in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2
          else
            M.alloc tt in
        let* _ :=
          let* Î±0 := M.var "UnOp::not" in
          let* Î±1 := M.read self in
          let* Î±2 := M.read amount in
          let* Î±3 := M.read signature in
          let* Î±4 :=
            M.call
              (Ty.path
                  "payment_channel::PaymentChannel")::["is_signature_valid"]
              [ Î±1; Î±2; Î±3 ] in
          let* Î±5 := M.alloc (Î±0 Î±4) in
          let* Î±6 := M.read (use Î±5) in
          if Î±6 then
            let* Î±0 :=
              return_
                (Value.StructTuple
                  "core::result::Result::Err"
                  [ payment_channel.Error.InvalidSignature ]) in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2
          else
            M.alloc tt in
        let* _ :=
          let* Î±0 := M.var "BinOp::Pure::lt" in
          let* Î±1 := M.read amount in
          let* Î±2 := M.var "payment_channel::PaymentChannel::Get_withdrawn" in
          let* Î±3 := M.read self in
          let* Î±4 := M.read (Î±2 Î±3) in
          let* Î±5 := M.alloc (Î±0 Î±1 Î±4) in
          let* Î±6 := M.read (use Î±5) in
          if Î±6 then
            let* Î±0 :=
              return_
                (Value.StructTuple
                  "core::result::Result::Err"
                  [ payment_channel.Error.AmountIsLessThanWithdrawn ]) in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2
          else
            M.alloc tt in
        let* amount_to_withdraw :=
          let* Î±0 := M.var "BinOp::Panic::sub" in
          let* Î±1 := M.read amount in
          let* Î±2 := M.var "payment_channel::PaymentChannel::Get_withdrawn" in
          let* Î±3 := M.read self in
          let* Î±4 := M.read (Î±2 Î±3) in
          let* Î±5 := Î±0 Î±1 Î±4 in
          M.alloc Î±5 in
        let* _ :=
          let* Î² :=
            let* Î±0 := M.var "payment_channel::PaymentChannel::Get_withdrawn" in
            let* Î±1 := M.read self in
            M.pure (Î±0 Î±1) in
          let* Î±0 := M.var "assign" in
          let* Î±1 := M.var "BinOp::Panic::add" in
          let* Î±2 := M.read Î² in
          let* Î±3 := M.read amount_to_withdraw in
          let* Î±4 := Î±1 Î±2 Î±3 in
          Î±0 Î² Î±4 in
        let* _ :=
          let* Î±0 :=
            M.get_method
              "core::ops::try_trait::Try"
              "branch"
              [
                (* Self *)
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.tuple []; Ty.path "payment_channel::Error" ]
              ] in
          let* Î±1 := M.read self in
          let* Î±2 :=
            M.call
              (Ty.path "payment_channel::PaymentChannel")::["env"]
              [ Î±1 ] in
          let* Î±3 := M.alloc Î±2 in
          let* Î±4 := M.var "payment_channel::PaymentChannel::Get_recipient" in
          let* Î±5 := M.read self in
          let* Î±6 := M.read (Î±4 Î±5) in
          let* Î±7 := M.read amount_to_withdraw in
          let* Î±8 :=
            M.call
              (Ty.path "payment_channel::Env")::["transfer"]
              [ Î±3; Î±6; Î±7 ] in
          let* Î±9 :=
            M.call
              (Ty.apply
                  (Ty.path "core::result::Result")
                  [ Ty.tuple []; Ty.path "payment_channel::Error"
                  ])::["map_err"]
              [
                Î±8;
                fun (Î±0 : Ty.path "payment_channel::Error") =>
                  (let* Î±0 := M.alloc Î±0 in
                  match_operator
                    Î±0
                    [ fun Î³ => (M.pure payment_channel.Error.TransferFailed) : _
                    ]) :
                  _
              ] in
          let* Î±10 := M.call Î±0 [ Î±9 ] in
          let* Î±11 := M.alloc Î±10 in
          match_operator
            Î±11
            [
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let* Î³0_0 :=
                    let* Î±0 :=
                      M.var
                        "core::ops::control_flow::ControlFlow::Get_Break_0" in
                    M.pure (Î±0 Î³) in
                  let* residual := M.copy Î³0_0 in
                  let* Î±0 :=
                    M.get_method
                      "core::ops::try_trait::FromResidual"
                      "from_residual"
                      [
                        (* Self *)
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "payment_channel::Error" ];
                        (* R *)
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.path "core::convert::Infallible";
                              Ty.path "payment_channel::Error"
                            ]
                      ] in
                  let* Î±1 := M.read residual in
                  let* Î±2 := M.call Î±0 [ Î±1 ] in
                  let* Î±3 := return_ Î±2 in
                  let* Î±4 := M.read Î±3 in
                  let* Î±5 := never_to_any Î±4 in
                  M.alloc Î±5
                | _ => M.break_match 
                end) :
                Ty.tuple [];
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let* Î³0_0 :=
                    let* Î±0 :=
                      M.var
                        "core::ops::control_flow::ControlFlow::Get_Continue_0" in
                    M.pure (Î±0 Î³) in
                  let* val := M.copy Î³0_0 in
                  M.pure val
                | _ => M.break_match 
                end) :
                Ty.tuple []
            ] in
        let* Î±0 :=
          M.alloc (Value.StructTuple "core::result::Result::Ok" [ tt ]) in
        M.read Î±0)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_withdraw :
    M.IsAssociatedFunction Self "withdraw" withdraw [].
  
  (*
      pub fn get_sender(&self) -> AccountId {
          self.sender
      }
  *)
  Definition get_sender (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "payment_channel::PaymentChannel::Get_sender" in
      let* Î±1 := M.read self in
      M.read (Î±0 Î±1)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_sender :
    M.IsAssociatedFunction Self "get_sender" get_sender [].
  
  (*
      pub fn get_recipient(&self) -> AccountId {
          self.recipient
      }
  *)
  Definition get_recipient (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "payment_channel::PaymentChannel::Get_recipient" in
      let* Î±1 := M.read self in
      M.read (Î±0 Î±1)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_recipient :
    M.IsAssociatedFunction Self "get_recipient" get_recipient [].
  
  (*
      pub fn get_expiration(&self) -> Option<Timestamp> {
          self.expiration
      }
  *)
  Definition get_expiration (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "payment_channel::PaymentChannel::Get_expiration" in
      let* Î±1 := M.read self in
      M.read (Î±0 Î±1)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_expiration :
    M.IsAssociatedFunction Self "get_expiration" get_expiration [].
  
  (*
      pub fn get_withdrawn(&self) -> Balance {
          self.withdrawn
      }
  *)
  Definition get_withdrawn (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "payment_channel::PaymentChannel::Get_withdrawn" in
      let* Î±1 := M.read self in
      M.read (Î±0 Î±1)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_withdrawn :
    M.IsAssociatedFunction Self "get_withdrawn" get_withdrawn [].
  
  (*
      pub fn get_close_duration(&self) -> Timestamp {
          self.close_duration
      }
  *)
  Definition get_close_duration (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "payment_channel::PaymentChannel::Get_close_duration" in
      let* Î±1 := M.read self in
      M.read (Î±0 Î±1)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_close_duration :
    M.IsAssociatedFunction Self "get_close_duration" get_close_duration [].
  
  (*
      pub fn get_balance(&self) -> Balance {
          self.env().balance()
      }
  *)
  Definition get_balance (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.read self in
      let* Î±1 :=
        M.call (Ty.path "payment_channel::PaymentChannel")::["env"] [ Î±0 ] in
      let* Î±2 := M.alloc Î±1 in
      M.call (Ty.path "payment_channel::Env")::["balance"] [ Î±2 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_balance :
    M.IsAssociatedFunction Self "get_balance" get_balance [].
End Impl_payment_channel_PaymentChannel.
