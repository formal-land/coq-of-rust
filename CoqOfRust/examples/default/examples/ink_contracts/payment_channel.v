(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.



Module  Impl_core_default_Default_for_payment_channel_AccountId.
Section Impl_core_default_Default_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::AccountId") [].
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self := Ty.path "u128")
            (Trait := ‚Ñê))) in
      let* Œ±1 := M.call Œ±0 in
      M.pure (payment_channel.AccountId.Build_t Œ±1)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_default : Instance.t := {
    Notations.double_colon := default;
  }.
  
  Definition ‚Ñê : Instance.t := [("default", default)].
End Impl_core_default_Default_for_payment_channel_AccountId.
End Impl_core_default_Default_for_payment_channel_AccountId.

Module  Impl_core_clone_Clone_for_payment_channel_AccountId.
Section Impl_core_clone_Clone_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::AccountId") [].
  
  (*
  Clone
  *)
  Definition clone (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [Ty.path "u128"]))
          [
            fun Œ≥ =>
              (let* Œ±0 := M.read self in
              M.pure (deref Œ±0)) :
              Ty.apply (Ty.path "payment_channel::AccountId") []
          ] in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_clone : Instance.t := {
    Notations.double_colon := clone;
  }.
  
  Definition ‚Ñê : Instance.t := [("clone", clone); ("clone_from", clone_from)].
End Impl_core_clone_Clone_for_payment_channel_AccountId.
End Impl_core_clone_Clone_for_payment_channel_AccountId.

Module  Impl_core_marker_Copy_for_payment_channel_AccountId.
Section Impl_core_marker_Copy_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::AccountId") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_Copy_for_payment_channel_AccountId.
End Impl_core_marker_Copy_for_payment_channel_AccountId.

Module  Impl_core_marker_StructuralPartialEq_for_payment_channel_AccountId.
Section Impl_core_marker_StructuralPartialEq_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::AccountId") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralPartialEq_for_payment_channel_AccountId.
End Impl_core_marker_StructuralPartialEq_for_payment_channel_AccountId.

Module  Impl_core_cmp_PartialEq_for_payment_channel_AccountId.
Section Impl_core_cmp_PartialEq_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::AccountId") [].
  
  (*
  PartialEq
  *)
  Definition eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 := M.read self in
      let* Œ±1 :=
        M.read ((M.var "payment_channel::AccountId::Get_0") (deref Œ±0)) in
      let* Œ±2 := M.read other in
      let* Œ±3 :=
        M.read ((M.var "payment_channel::AccountId::Get_0") (deref Œ±2)) in
      M.pure ((M.var "BinOp::Pure::eq") Œ±1 Œ±3)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_eq : Instance.t := {
    Notations.double_colon := eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("eq", eq); ("ne", ne)].
End Impl_core_cmp_PartialEq_for_payment_channel_AccountId.
End Impl_core_cmp_PartialEq_for_payment_channel_AccountId.

Module  Impl_core_marker_StructuralEq_for_payment_channel_AccountId.
Section Impl_core_marker_StructuralEq_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::AccountId") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralEq_for_payment_channel_AccountId.
End Impl_core_marker_StructuralEq_for_payment_channel_AccountId.

Module  Impl_core_cmp_Eq_for_payment_channel_AccountId.
Section Impl_core_cmp_Eq_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::AccountId") [].
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq
      (ùúè : list Ty.t)
      (Œ± : list Value.t)
      : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply (Ty.path "core::cmp::AssertParamIsEq") [Ty.path "u128"]))
          [ fun Œ≥ => (M.alloc tt) : Ty.path "unit" ] in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_assert_receiver_is_total_eq : Instance.t := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("assert_receiver_is_total_eq",
      assert_receiver_is_total_eq)].
End Impl_core_cmp_Eq_for_payment_channel_AccountId.
End Impl_core_cmp_Eq_for_payment_channel_AccountId.

Module  Impl_core_convert_From_array_u8_for_payment_channel_AccountId.
Section Impl_core_convert_From_array_u8_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::AccountId") [].
  
  (*
      fn from(value: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Definition from (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [value] =>
      let* value := M.alloc value in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_from : Instance.t := {
    Notations.double_colon := from;
  }.
  
  Definition ‚Ñê : Instance.t := [("from", from)].
End Impl_core_convert_From_array_u8_for_payment_channel_AccountId.
End Impl_core_convert_From_array_u8_for_payment_channel_AccountId.

Axiom Balance : Ty.path "u128".

Axiom Timestamp : Ty.path "u64".







Module  Impl_core_marker_StructuralPartialEq_for_payment_channel_Error.
Section Impl_core_marker_StructuralPartialEq_for_payment_channel_Error.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Error") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralPartialEq_for_payment_channel_Error.
End Impl_core_marker_StructuralPartialEq_for_payment_channel_Error.

Module  Impl_core_cmp_PartialEq_for_payment_channel_Error.
Section Impl_core_cmp_PartialEq_for_payment_channel_Error.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Error") [].
  
  (*
  PartialEq
  *)
  Definition eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* __self_tag :=
        let* Œ±0 := M.read self in
        let* Œ±1 := M.call ((M.var "core::intrinsics::discriminant_value") Œ±0) in
        M.alloc Œ±1 in
      let* __arg1_tag :=
        let* Œ±0 := M.read other in
        let* Œ±1 := M.call ((M.var "core::intrinsics::discriminant_value") Œ±0) in
        M.alloc Œ±1 in
      let* Œ±0 := M.read __self_tag in
      let* Œ±1 := M.read __arg1_tag in
      let* Œ±0 := M.alloc ((M.var "BinOp::Pure::eq") Œ±0 Œ±1) in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_eq : Instance.t := {
    Notations.double_colon := eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("eq", eq); ("ne", ne)].
End Impl_core_cmp_PartialEq_for_payment_channel_Error.
End Impl_core_cmp_PartialEq_for_payment_channel_Error.

Module  Impl_core_marker_StructuralEq_for_payment_channel_Error.
Section Impl_core_marker_StructuralEq_for_payment_channel_Error.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Error") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralEq_for_payment_channel_Error.
End Impl_core_marker_StructuralEq_for_payment_channel_Error.

Module  Impl_core_cmp_Eq_for_payment_channel_Error.
Section Impl_core_cmp_Eq_for_payment_channel_Error.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Error") [].
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq
      (ùúè : list Ty.t)
      (Œ± : list Value.t)
      : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      M.pure tt
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_assert_receiver_is_total_eq : Instance.t := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("assert_receiver_is_total_eq",
      assert_receiver_is_total_eq)].
End Impl_core_cmp_Eq_for_payment_channel_Error.
End Impl_core_cmp_Eq_for_payment_channel_Error.

Axiom Result :
    fun T =>
      Ty.apply
        (Ty.path "core::result::Result")
        [T; Ty.apply (Ty.path "payment_channel::Error") []].





Module  Impl_payment_channel_Env.
Section Impl_payment_channel_Env.
  Definition Self : Set := Ty.apply (Ty.path "payment_channel::Env") [].
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      M.read ((M.var "payment_channel::Env::Get_caller") (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_caller : Instance.t := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; _event] =>
      let* self := M.alloc self in
      let* _event := M.alloc _event in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_emit_event : Instance.t := {
    Notations.double_colon := emit_event;
  }.
  
  (*
      fn terminate_contract(&self, sender: AccountId) {
          unimplemented!()
      }
  *)
  Definition terminate_contract (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; sender] =>
      let* self := M.alloc self in
      let* sender := M.alloc sender in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_terminate_contract : Instance.t := {
    Notations.double_colon := terminate_contract;
  }.
  
  (*
      fn transfer(&self, recipient: AccountId, amount: Balance) -> Result<()> {
          unimplemented!()
      }
  *)
  Definition transfer (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; recipient; amount] =>
      let* self := M.alloc self in
      let* recipient := M.alloc recipient in
      let* amount := M.alloc amount in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_transfer : Instance.t := {
    Notations.double_colon := transfer;
  }.
  
  (*
      fn block_timestamp(&self) -> Timestamp {
          unimplemented!()
      }
  *)
  Definition block_timestamp (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_block_timestamp : Instance.t := {
    Notations.double_colon := block_timestamp;
  }.
  
  (*
      fn balance(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition balance (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_balance : Instance.t := {
    Notations.double_colon := balance;
  }.
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Definition account_id (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_account_id : Instance.t := {
    Notations.double_colon := account_id;
  }.
End Impl_payment_channel_Env.
End Impl_payment_channel_Env.

Module  HashOutput.
Section HashOutput.
  Class Trait (Self : Set) : Type := {
    Type_ : Set;
    ‚Ñí_0 :: core.default.Default.Trait Type_;
  }.
  
  Definition Method_Type_ `(Trait) : Instance.t := {
    Notations.double_colon_type := Type_;
  }.
End HashOutput.
End HashOutput.

Module  CryptoHash.
Section CryptoHash.
  Class Trait (Self : Set) : Type := {
    hash :
      Ty.function
        [Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "slice") [Ty.path "u8"]];
          Ty.apply (Ty.path "mut_ref") [_]]
        (Ty.path "unit");
  }.
  
End CryptoHash.
End CryptoHash.

(*
pub fn hash_encoded<H, T>(input: &T, output: &mut <H as HashOutput>::Type)
where
    H: CryptoHash,
{
    unimplemented!()
}
*)
Definition hash_encoded (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [H; T], [input; output] =>
    let* input := M.alloc input in
    let* output := M.alloc output in
    let* Œ±0 := M.read (mk_str "not implemented") in
    let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
    never_to_any Œ±1
  | _, _ => M.impossible
  end.

(*
pub fn ecdsa_recover(
    signature: &[u8; 65],
    message_hash: &[u8; 32],
    output: &mut [u8; 33],
) -> Result<()> {
    unimplemented!()
}
*)
Definition ecdsa_recover (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [signature; message_hash; output] =>
    let* signature := M.alloc signature in
    let* message_hash := M.alloc message_hash in
    let* output := M.alloc output in
    let* Œ±0 := M.read (mk_str "not implemented") in
    let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
    never_to_any Œ±1
  | _, _ => M.impossible
  end.









Module  Impl_payment_channel_HashOutput_for_payment_channel_Sha2x256.
Section Impl_payment_channel_HashOutput_for_payment_channel_Sha2x256.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Sha2x256") [].
  
  (*
      type Type = [u8; 32];
  *)
  Definition Type_ : Set := Ty.apply (Ty.path "array") [Ty.path "u8"].
  
  Definition ‚Ñê : Instance.t := [("Type_", Type_)].
End Impl_payment_channel_HashOutput_for_payment_channel_Sha2x256.
End Impl_payment_channel_HashOutput_for_payment_channel_Sha2x256.

Module  Impl_payment_channel_HashOutput_for_payment_channel_Keccak256.
Section Impl_payment_channel_HashOutput_for_payment_channel_Keccak256.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Keccak256") [].
  
  (*
      type Type = [u8; 32];
  *)
  Definition Type_ : Set := Ty.apply (Ty.path "array") [Ty.path "u8"].
  
  Definition ‚Ñê : Instance.t := [("Type_", Type_)].
End Impl_payment_channel_HashOutput_for_payment_channel_Keccak256.
End Impl_payment_channel_HashOutput_for_payment_channel_Keccak256.

Module  Impl_payment_channel_HashOutput_for_payment_channel_Blake2x256.
Section Impl_payment_channel_HashOutput_for_payment_channel_Blake2x256.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Blake2x256") [].
  
  (*
      type Type = [u8; 32];
  *)
  Definition Type_ : Set := Ty.apply (Ty.path "array") [Ty.path "u8"].
  
  Definition ‚Ñê : Instance.t := [("Type_", Type_)].
End Impl_payment_channel_HashOutput_for_payment_channel_Blake2x256.
End Impl_payment_channel_HashOutput_for_payment_channel_Blake2x256.

Module  Impl_payment_channel_HashOutput_for_payment_channel_Blake2x128.
Section Impl_payment_channel_HashOutput_for_payment_channel_Blake2x128.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Blake2x128") [].
  
  (*
      type Type = [u8; 16];
  *)
  Definition Type_ : Set := Ty.apply (Ty.path "array") [Ty.path "u8"].
  
  Definition ‚Ñê : Instance.t := [("Type_", Type_)].
End Impl_payment_channel_HashOutput_for_payment_channel_Blake2x128.
End Impl_payment_channel_HashOutput_for_payment_channel_Blake2x128.

Module  Impl_payment_channel_CryptoHash_for_payment_channel_Sha2x256.
Section Impl_payment_channel_CryptoHash_for_payment_channel_Sha2x256.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Sha2x256") [].
  
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [input; output] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_hash : Instance.t := {
    Notations.double_colon := hash;
  }.
  
  Definition ‚Ñê : Instance.t := [("hash", hash)].
End Impl_payment_channel_CryptoHash_for_payment_channel_Sha2x256.
End Impl_payment_channel_CryptoHash_for_payment_channel_Sha2x256.

Module  Impl_payment_channel_CryptoHash_for_payment_channel_Keccak256.
Section Impl_payment_channel_CryptoHash_for_payment_channel_Keccak256.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Keccak256") [].
  
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [input; output] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_hash : Instance.t := {
    Notations.double_colon := hash;
  }.
  
  Definition ‚Ñê : Instance.t := [("hash", hash)].
End Impl_payment_channel_CryptoHash_for_payment_channel_Keccak256.
End Impl_payment_channel_CryptoHash_for_payment_channel_Keccak256.

Module  Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x256.
Section Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x256.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Blake2x256") [].
  
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [input; output] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_hash : Instance.t := {
    Notations.double_colon := hash;
  }.
  
  Definition ‚Ñê : Instance.t := [("hash", hash)].
End Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x256.
End Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x256.

Module  Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x128.
Section Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x128.
  Definition Self : Ty.t := Ty.apply (Ty.path "payment_channel::Blake2x128") [].
  
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [input; output] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_hash : Instance.t := {
    Notations.double_colon := hash;
  }.
  
  Definition ‚Ñê : Instance.t := [("hash", hash)].
End Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x128.
End Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x128.

Module  Impl_payment_channel_PaymentChannel.
Section Impl_payment_channel_PaymentChannel.
  Definition Self : Set :=
    Ty.apply (Ty.path "payment_channel::PaymentChannel") [].
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 := M.read (mk_str "not implemented") in
      let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_init_env : Instance.t := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      M.call
        (Ty.apply (Ty.path "payment_channel::PaymentChannel") [])::["init_env"]
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_env : Instance.t := {
    Notations.double_colon := env;
  }.
  
  (*
      fn is_signature_valid(&self, amount: Balance, signature: [u8; 65]) -> bool {
          let encodable = (self.env().account_id(), amount);
          let mut message = <Sha2x256 as HashOutput>::Type::default();
          hash_encoded::<Sha2x256, _>(&encodable, &mut message);
  
          let mut pub_key = [0; 33];
          ecdsa_recover(&signature, &message, &mut pub_key)
              .unwrap_or_else(|err| panic!("recover failed: {err:?}"));
          let mut signature_account_id = [0; 32];
          <Blake2x256 as CryptoHash>::hash(&pub_key, &mut signature_account_id);
  
          self.recipient == signature_account_id.into()
      }
  *)
  Definition is_signature_valid (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; amount; signature] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let* encodable :=
        let* Œ±0 := M.read self in
        let* Œ±1 :=
          M.call
            ((Ty.apply (Ty.path "payment_channel::PaymentChannel") [])::["env"]
              Œ±0) in
        let* Œ±2 := M.alloc Œ±1 in
        let* Œ±3 :=
          M.call
            ((Ty.apply (Ty.path "payment_channel::Env") [])::["account_id"]
              (borrow Œ±2)) in
        let* Œ±4 := M.read amount in
        M.alloc (Œ±3, Œ±4) in
      let* message :=
        let* Œ±0 :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.default.Default.default
              (Self := Ty.apply (Ty.path "array") [Ty.path "u8"])
              (Trait := ‚Ñê))) in
        let* Œ±1 := M.call Œ±0 in
        M.alloc Œ±1 in
      let* _ :=
        let* Œ±0 :=
          M.call
            ((M.var "payment_channel::hash_encoded")
              (borrow encodable)
              (borrow_mut message)) in
        M.alloc Œ±0 in
      let* pub_key := M.alloc (repeat ((Integer.of_Z 0) : Ty.path "u8") 33) in
      let* _ :=
        let* Œ±0 :=
          M.call
            ((M.var "payment_channel::ecdsa_recover")
              (borrow signature)
              (borrow message)
              (borrow_mut pub_key)) in
        let* Œ±1 :=
          M.call
            ((Ty.apply
                  (Ty.path "core::result::Result")
                  [Ty.tuple;
                    Ty.apply
                      (Ty.path "payment_channel::Error")
                      []])::["unwrap_or_else"]
              Œ±0
              (fun (Œ±0 : Ty.apply (Ty.path "payment_channel::Error") []) =>
                (let* Œ±0 := M.alloc Œ±0 in
                match_operator
                  Œ±0
                  [
                    fun Œ≥ =>
                      (let* err := M.copy Œ≥ in
                      let* Œ±0 := M.read (mk_str "recover failed: {err:?}") in
                      let* Œ±1 :=
                        M.call ((M.var "std::panicking::begin_panic") Œ±0) in
                      never_to_any Œ±1) :
                      Ty.tuple
                  ]) :
                Ty.tuple)) in
        M.alloc Œ±1 in
      let* signature_account_id :=
        M.alloc (repeat ((Integer.of_Z 0) : Ty.path "u8") 32) in
      let* _ :=
        let* Œ±0 :=
          ltac:(M.get_method (fun ‚Ñê =>
            payment_channel.CryptoHash.hash
              (Self := Ty.apply (Ty.path "payment_channel::Blake2x256") [])
              (Trait := ‚Ñê))) in
        let* Œ±1 :=
          M.call
            (Œ±0
              (pointer_coercion "Unsize" (borrow pub_key))
              (borrow_mut signature_account_id)) in
        M.alloc Œ±1 in
      let* Œ±0 :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.cmp.PartialEq.eq
            (Self := Ty.apply (Ty.path "payment_channel::AccountId") [])
            (Rhs := Ty.apply (Ty.path "payment_channel::AccountId") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 := M.read self in
      let* Œ±2 :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.Into.into
            (Self := Ty.apply (Ty.path "array") [Ty.path "u8"])
            (T := Ty.apply (Ty.path "payment_channel::AccountId") [])
            (Trait := ‚Ñê))) in
      let* Œ±3 := M.read signature_account_id in
      let* Œ±4 := M.call (Œ±2 Œ±3) in
      let* Œ±5 := M.alloc Œ±4 in
      let* Œ±6 :=
        M.call
          (Œ±0
            (borrow
              ((M.var "payment_channel::PaymentChannel::Get_recipient")
                (deref Œ±1)))
            (borrow Œ±5)) in
      let* Œ±0 := M.alloc Œ±6 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_is_signature_valid : Instance.t := {
    Notations.double_colon := is_signature_valid;
  }.
  
  (*
      pub fn new(recipient: AccountId, close_duration: Timestamp) -> Self {
          Self {
              sender: Self::init_env().caller(),
              recipient,
              expiration: None,
              withdrawn: 0,
              close_duration,
          }
      }
  *)
  Definition new (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [recipient; close_duration] =>
      let* recipient := M.alloc recipient in
      let* close_duration := M.alloc close_duration in
      let* Œ±0 :=
        M.call
          (Ty.apply
              (Ty.path "payment_channel::PaymentChannel")
              [])::["init_env"] in
      let* Œ±1 := M.alloc Œ±0 in
      let* Œ±2 :=
        M.call
          ((Ty.apply (Ty.path "payment_channel::Env") [])::["caller"]
            (borrow Œ±1)) in
      let* Œ±3 := M.read recipient in
      let* Œ±4 := M.read close_duration in
      M.pure
        {|
          payment_channel.PaymentChannel.sender := Œ±2;
          payment_channel.PaymentChannel.recipient := Œ±3;
          payment_channel.PaymentChannel.expiration := core.option.Option.None;
          payment_channel.PaymentChannel.withdrawn :=
            (Integer.of_Z 0) : Ty.path "u128";
          payment_channel.PaymentChannel.close_duration := Œ±4;
        |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_new : Instance.t := {
    Notations.double_colon := new;
  }.
  
  (*
      fn close_inner(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {
          if self.env().caller() != self.recipient {
              return Err(Error::CallerIsNotRecipient);
          }
  
          if amount < self.withdrawn {
              return Err(Error::AmountIsLessThanWithdrawn);
          }
  
          // Signature validation
          if !self.is_signature_valid(amount, signature) {
              return Err(Error::InvalidSignature);
          }
  
          self.env()
              .transfer(self.recipient, amount - self.withdrawn)
              .map_err(|_| Error::TransferFailed)?;
  
          Ok(())
      }
  *)
  Definition close_inner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; amount; signature] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple; Ty.apply (Ty.path "payment_channel::Error") []]) in
      M.catch_return
        (let* _ :=
          let* Œ±0 :=
            ltac:(M.get_method (fun ‚Ñê =>
              core.cmp.PartialEq.ne
                (Self := Ty.apply (Ty.path "payment_channel::AccountId") [])
                (Rhs := Ty.apply (Ty.path "payment_channel::AccountId") [])
                (Trait := ‚Ñê))) in
          let* Œ±1 := M.read self in
          let* Œ±2 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["env"]
                (borrow (deref Œ±1))) in
          let* Œ±3 := M.alloc Œ±2 in
          let* Œ±4 :=
            M.call
              ((Ty.apply (Ty.path "payment_channel::Env") [])::["caller"]
                (borrow Œ±3)) in
          let* Œ±5 := M.alloc Œ±4 in
          let* Œ±6 := M.read self in
          let* Œ±7 :=
            M.call
              (Œ±0
                (borrow Œ±5)
                (borrow
                  ((M.var "payment_channel::PaymentChannel::Get_recipient")
                    (deref Œ±6)))) in
          let* Œ±8 := M.alloc Œ±7 in
          let* Œ±9 := M.read (use Œ±8) in
          if Œ±9 then
            let* Œ±0 :=
              return_
                (core.result.Result.Err
                  payment_channel.Error.CallerIsNotRecipient) in
            let* Œ±1 := M.read Œ±0 in
            let* Œ±2 := never_to_any Œ±1 in
            M.alloc Œ±2
          else
            M.alloc tt in
        let* _ :=
          let* Œ±0 := M.read amount in
          let* Œ±1 := M.read self in
          let* Œ±2 :=
            M.read
              ((M.var "payment_channel::PaymentChannel::Get_withdrawn")
                (deref Œ±1)) in
          let* Œ±3 := M.alloc ((M.var "BinOp::Pure::lt") Œ±0 Œ±2) in
          let* Œ±4 := M.read (use Œ±3) in
          if Œ±4 then
            let* Œ±0 :=
              return_
                (core.result.Result.Err
                  payment_channel.Error.AmountIsLessThanWithdrawn) in
            let* Œ±1 := M.read Œ±0 in
            let* Œ±2 := never_to_any Œ±1 in
            M.alloc Œ±2
          else
            M.alloc tt in
        let* _ :=
          let* Œ±0 := M.read self in
          let* Œ±1 := M.read amount in
          let* Œ±2 := M.read signature in
          let* Œ±3 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["is_signature_valid"]
                (borrow (deref Œ±0))
                Œ±1
                Œ±2) in
          let* Œ±4 := M.alloc ((M.var "UnOp::not") Œ±3) in
          let* Œ±5 := M.read (use Œ±4) in
          if Œ±5 then
            let* Œ±0 :=
              return_
                (core.result.Result.Err
                  payment_channel.Error.InvalidSignature) in
            let* Œ±1 := M.read Œ±0 in
            let* Œ±2 := never_to_any Œ±1 in
            M.alloc Œ±2
          else
            M.alloc tt in
        let* _ :=
          let* Œ±0 :=
            ltac:(M.get_method (fun ‚Ñê =>
              core.ops.try_trait.Try.branch
                (Self :=
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [Ty.tuple; Ty.apply (Ty.path "payment_channel::Error") []])
                (Trait := ‚Ñê))) in
          let* Œ±1 := M.read self in
          let* Œ±2 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["env"]
                (borrow (deref Œ±1))) in
          let* Œ±3 := M.alloc Œ±2 in
          let* Œ±4 := M.read self in
          let* Œ±5 :=
            M.read
              ((M.var "payment_channel::PaymentChannel::Get_recipient")
                (deref Œ±4)) in
          let* Œ±6 := M.read amount in
          let* Œ±7 := M.read self in
          let* Œ±8 :=
            M.read
              ((M.var "payment_channel::PaymentChannel::Get_withdrawn")
                (deref Œ±7)) in
          let* Œ±9 := (M.var "BinOp::Panic::sub") Œ±6 Œ±8 in
          let* Œ±10 :=
            M.call
              ((Ty.apply (Ty.path "payment_channel::Env") [])::["transfer"]
                (borrow Œ±3)
                Œ±5
                Œ±9) in
          let* Œ±11 :=
            M.call
              ((Ty.apply
                    (Ty.path "core::result::Result")
                    [Ty.tuple;
                      Ty.apply
                        (Ty.path "payment_channel::Error")
                        []])::["map_err"]
                Œ±10
                (fun (Œ±0 : Ty.apply (Ty.path "payment_channel::Error") []) =>
                  (let* Œ±0 := M.alloc Œ±0 in
                  match_operator
                    Œ±0
                    [
                      fun Œ≥ =>
                        (M.pure payment_channel.Error.TransferFailed) :
                        Ty.apply (Ty.path "payment_channel::Error") []
                    ]) :
                  Ty.apply (Ty.path "payment_channel::Error") [])) in
          let* Œ±12 := M.call (Œ±0 Œ±11) in
          let* Œ±13 := M.alloc Œ±12 in
          match_operator
            Œ±13
            [
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let Œ≥0_0 :=
                    (M.var "core::ops::control_flow::ControlFlow::Get_Break_0")
                      Œ≥ in
                  let* residual := M.copy Œ≥0_0 in
                  let* Œ±0 :=
                    ltac:(M.get_method (fun ‚Ñê =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [Ty.tuple;
                              Ty.apply (Ty.path "payment_channel::Error") []])
                        (R :=
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [Ty.apply (Ty.path "core::convert::Infallible") [];
                              Ty.apply (Ty.path "payment_channel::Error") []])
                        (Trait := ‚Ñê))) in
                  let* Œ±1 := M.read residual in
                  let* Œ±2 := M.call (Œ±0 Œ±1) in
                  let* Œ±3 := return_ Œ±2 in
                  let* Œ±4 := M.read Œ±3 in
                  let* Œ±5 := never_to_any Œ±4 in
                  M.alloc Œ±5
                | _ => M.break_match
                end) :
                Ty.tuple;
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let Œ≥0_0 :=
                    (M.var
                        "core::ops::control_flow::ControlFlow::Get_Continue_0")
                      Œ≥ in
                  let* val := M.copy Œ≥0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                Ty.tuple
            ] in
        let* Œ±0 := M.alloc (core.result.Result.Ok tt) in
        M.read Œ±0)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_close_inner : Instance.t := {
    Notations.double_colon := close_inner;
  }.
  
  (*
      pub fn close(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {
          self.close_inner(amount, signature)?;
          self.env().terminate_contract(self.sender);
  
          Ok(())
      }
  *)
  Definition close (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; amount; signature] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple; Ty.apply (Ty.path "payment_channel::Error") []]) in
      M.catch_return
        (let* _ :=
          let* Œ±0 :=
            ltac:(M.get_method (fun ‚Ñê =>
              core.ops.try_trait.Try.branch
                (Self :=
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [Ty.tuple; Ty.apply (Ty.path "payment_channel::Error") []])
                (Trait := ‚Ñê))) in
          let* Œ±1 := M.read self in
          let* Œ±2 := M.read amount in
          let* Œ±3 := M.read signature in
          let* Œ±4 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["close_inner"]
                Œ±1
                Œ±2
                Œ±3) in
          let* Œ±5 := M.call (Œ±0 Œ±4) in
          let* Œ±6 := M.alloc Œ±5 in
          match_operator
            Œ±6
            [
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let Œ≥0_0 :=
                    (M.var "core::ops::control_flow::ControlFlow::Get_Break_0")
                      Œ≥ in
                  let* residual := M.copy Œ≥0_0 in
                  let* Œ±0 :=
                    ltac:(M.get_method (fun ‚Ñê =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [Ty.tuple;
                              Ty.apply (Ty.path "payment_channel::Error") []])
                        (R :=
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [Ty.apply (Ty.path "core::convert::Infallible") [];
                              Ty.apply (Ty.path "payment_channel::Error") []])
                        (Trait := ‚Ñê))) in
                  let* Œ±1 := M.read residual in
                  let* Œ±2 := M.call (Œ±0 Œ±1) in
                  let* Œ±3 := return_ Œ±2 in
                  let* Œ±4 := M.read Œ±3 in
                  let* Œ±5 := never_to_any Œ±4 in
                  M.alloc Œ±5
                | _ => M.break_match
                end) :
                Ty.tuple;
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let Œ≥0_0 :=
                    (M.var
                        "core::ops::control_flow::ControlFlow::Get_Continue_0")
                      Œ≥ in
                  let* val := M.copy Œ≥0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                Ty.tuple
            ] in
        let* _ :=
          let* Œ±0 := M.read self in
          let* Œ±1 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["env"]
                (borrow (deref Œ±0))) in
          let* Œ±2 := M.alloc Œ±1 in
          let* Œ±3 := M.read self in
          let* Œ±4 :=
            M.read
              ((M.var "payment_channel::PaymentChannel::Get_sender")
                (deref Œ±3)) in
          let* Œ±5 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::Env")
                    [])::["terminate_contract"]
                (borrow Œ±2)
                Œ±4) in
          M.alloc Œ±5 in
        let* Œ±0 := M.alloc (core.result.Result.Ok tt) in
        M.read Œ±0)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_close : Instance.t := {
    Notations.double_colon := close;
  }.
  
  (*
      pub fn start_sender_close(&mut self) -> Result<()> {
          if self.env().caller() != self.sender {
              return Err(Error::CallerIsNotSender);
          }
  
          let now = self.env().block_timestamp();
          let expiration = now + self.close_duration;
  
          self.env()
              .emit_event(Event::SenderCloseStarted(SenderCloseStarted {
                  expiration,
                  close_duration: self.close_duration,
              }));
  
          self.expiration = Some(expiration);
  
          Ok(())
      }
  *)
  Definition start_sender_close (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple; Ty.apply (Ty.path "payment_channel::Error") []]) in
      M.catch_return
        (let* _ :=
          let* Œ±0 :=
            ltac:(M.get_method (fun ‚Ñê =>
              core.cmp.PartialEq.ne
                (Self := Ty.apply (Ty.path "payment_channel::AccountId") [])
                (Rhs := Ty.apply (Ty.path "payment_channel::AccountId") [])
                (Trait := ‚Ñê))) in
          let* Œ±1 := M.read self in
          let* Œ±2 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["env"]
                (borrow (deref Œ±1))) in
          let* Œ±3 := M.alloc Œ±2 in
          let* Œ±4 :=
            M.call
              ((Ty.apply (Ty.path "payment_channel::Env") [])::["caller"]
                (borrow Œ±3)) in
          let* Œ±5 := M.alloc Œ±4 in
          let* Œ±6 := M.read self in
          let* Œ±7 :=
            M.call
              (Œ±0
                (borrow Œ±5)
                (borrow
                  ((M.var "payment_channel::PaymentChannel::Get_sender")
                    (deref Œ±6)))) in
          let* Œ±8 := M.alloc Œ±7 in
          let* Œ±9 := M.read (use Œ±8) in
          if Œ±9 then
            let* Œ±0 :=
              return_
                (core.result.Result.Err
                  payment_channel.Error.CallerIsNotSender) in
            let* Œ±1 := M.read Œ±0 in
            let* Œ±2 := never_to_any Œ±1 in
            M.alloc Œ±2
          else
            M.alloc tt in
        let* now :=
          let* Œ±0 := M.read self in
          let* Œ±1 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["env"]
                (borrow (deref Œ±0))) in
          let* Œ±2 := M.alloc Œ±1 in
          let* Œ±3 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::Env")
                    [])::["block_timestamp"]
                (borrow Œ±2)) in
          M.alloc Œ±3 in
        let* expiration :=
          let* Œ±0 := M.read now in
          let* Œ±1 := M.read self in
          let* Œ±2 :=
            M.read
              ((M.var "payment_channel::PaymentChannel::Get_close_duration")
                (deref Œ±1)) in
          let* Œ±3 := (M.var "BinOp::Panic::add") Œ±0 Œ±2 in
          M.alloc Œ±3 in
        let* _ :=
          let* Œ±0 := M.read self in
          let* Œ±1 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["env"]
                (borrow (deref Œ±0))) in
          let* Œ±2 := M.alloc Œ±1 in
          let* Œ±3 := M.read expiration in
          let* Œ±4 := M.read self in
          let* Œ±5 :=
            M.read
              ((M.var "payment_channel::PaymentChannel::Get_close_duration")
                (deref Œ±4)) in
          let* Œ±6 :=
            M.call
              ((Ty.apply (Ty.path "payment_channel::Env") [])::["emit_event"]
                (borrow Œ±2)
                (payment_channel.Event.SenderCloseStarted
                  {|
                    payment_channel.SenderCloseStarted.expiration := Œ±3;
                    payment_channel.SenderCloseStarted.close_duration := Œ±5;
                  |})) in
          M.alloc Œ±6 in
        let* _ :=
          let* Œ±0 := M.read self in
          let* Œ±1 := M.read expiration in
          assign
            ((M.var "payment_channel::PaymentChannel::Get_expiration")
              (deref Œ±0))
            (core.option.Option.Some Œ±1) in
        let* Œ±0 := M.alloc (core.result.Result.Ok tt) in
        M.read Œ±0)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_start_sender_close : Instance.t := {
    Notations.double_colon := start_sender_close;
  }.
  
  (*
      pub fn claim_timeout(&mut self) -> Result<()> {
          match self.expiration {
              Some(expiration) => {
                  // expiration is set. Check if it's reached and if so, release the
                  // funds and terminate the contract.
                  let now = self.env().block_timestamp();
                  if now < expiration {
                      return Err(Error::NotYetExpired);
                  }
  
                  self.env().terminate_contract(self.sender);
  
                  Ok(())
              }
  
              None => Err(Error::NotYetExpired),
          }
      }
  *)
  Definition claim_timeout (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple; Ty.apply (Ty.path "payment_channel::Error") []]) in
      M.catch_return
        (let* Œ±0 := M.read self in
        let* Œ±1 :=
          match_operator
            ((M.var "payment_channel::PaymentChannel::Get_expiration")
              (deref Œ±0))
            [
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | core.option.Option.Some _ =>
                  let Œ≥0_0 := (M.var "core::option::Option::Get_Some_0") Œ≥ in
                  let* expiration := M.copy Œ≥0_0 in
                  let* now :=
                    let* Œ±0 := M.read self in
                    let* Œ±1 :=
                      M.call
                        ((Ty.apply
                              (Ty.path "payment_channel::PaymentChannel")
                              [])::["env"]
                          (borrow (deref Œ±0))) in
                    let* Œ±2 := M.alloc Œ±1 in
                    let* Œ±3 :=
                      M.call
                        ((Ty.apply
                              (Ty.path "payment_channel::Env")
                              [])::["block_timestamp"]
                          (borrow Œ±2)) in
                    M.alloc Œ±3 in
                  let* _ :=
                    let* Œ±0 := M.read now in
                    let* Œ±1 := M.read expiration in
                    let* Œ±2 := M.alloc ((M.var "BinOp::Pure::lt") Œ±0 Œ±1) in
                    let* Œ±3 := M.read (use Œ±2) in
                    if Œ±3 then
                      let* Œ±0 :=
                        return_
                          (core.result.Result.Err
                            payment_channel.Error.NotYetExpired) in
                      let* Œ±1 := M.read Œ±0 in
                      let* Œ±2 := never_to_any Œ±1 in
                      M.alloc Œ±2
                    else
                      M.alloc tt in
                  let* _ :=
                    let* Œ±0 := M.read self in
                    let* Œ±1 :=
                      M.call
                        ((Ty.apply
                              (Ty.path "payment_channel::PaymentChannel")
                              [])::["env"]
                          (borrow (deref Œ±0))) in
                    let* Œ±2 := M.alloc Œ±1 in
                    let* Œ±3 := M.read self in
                    let* Œ±4 :=
                      M.read
                        ((M.var "payment_channel::PaymentChannel::Get_sender")
                          (deref Œ±3)) in
                    let* Œ±5 :=
                      M.call
                        ((Ty.apply
                              (Ty.path "payment_channel::Env")
                              [])::["terminate_contract"]
                          (borrow Œ±2)
                          Œ±4) in
                    M.alloc Œ±5 in
                  M.alloc (core.result.Result.Ok tt)
                | _ => M.break_match
                end) :
                Ty.apply
                  (Ty.path "core::result::Result")
                  [Ty.tuple; Ty.apply (Ty.path "payment_channel::Error") []];
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | core.option.Option.None =>
                  M.alloc
                    (core.result.Result.Err payment_channel.Error.NotYetExpired)
                | _ => M.break_match
                end) :
                Ty.apply
                  (Ty.path "core::result::Result")
                  [Ty.tuple; Ty.apply (Ty.path "payment_channel::Error") []]
            ] in
        M.read Œ±1)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_claim_timeout : Instance.t := {
    Notations.double_colon := claim_timeout;
  }.
  
  (*
      pub fn withdraw(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {
          if self.env().caller() != self.recipient {
              return Err(Error::CallerIsNotRecipient);
          }
  
          // Signature validation
          if !self.is_signature_valid(amount, signature) {
              return Err(Error::InvalidSignature);
          }
  
          // Make sure there's something to withdraw (guards against underflow)
          if amount < self.withdrawn {
              return Err(Error::AmountIsLessThanWithdrawn);
          }
  
          let amount_to_withdraw = amount - self.withdrawn;
          self.withdrawn += amount_to_withdraw;
  
          self.env()
              .transfer(self.recipient, amount_to_withdraw)
              .map_err(|_| Error::TransferFailed)?;
  
          Ok(())
      }
  *)
  Definition withdraw (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; amount; signature] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple; Ty.apply (Ty.path "payment_channel::Error") []]) in
      M.catch_return
        (let* _ :=
          let* Œ±0 :=
            ltac:(M.get_method (fun ‚Ñê =>
              core.cmp.PartialEq.ne
                (Self := Ty.apply (Ty.path "payment_channel::AccountId") [])
                (Rhs := Ty.apply (Ty.path "payment_channel::AccountId") [])
                (Trait := ‚Ñê))) in
          let* Œ±1 := M.read self in
          let* Œ±2 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["env"]
                (borrow (deref Œ±1))) in
          let* Œ±3 := M.alloc Œ±2 in
          let* Œ±4 :=
            M.call
              ((Ty.apply (Ty.path "payment_channel::Env") [])::["caller"]
                (borrow Œ±3)) in
          let* Œ±5 := M.alloc Œ±4 in
          let* Œ±6 := M.read self in
          let* Œ±7 :=
            M.call
              (Œ±0
                (borrow Œ±5)
                (borrow
                  ((M.var "payment_channel::PaymentChannel::Get_recipient")
                    (deref Œ±6)))) in
          let* Œ±8 := M.alloc Œ±7 in
          let* Œ±9 := M.read (use Œ±8) in
          if Œ±9 then
            let* Œ±0 :=
              return_
                (core.result.Result.Err
                  payment_channel.Error.CallerIsNotRecipient) in
            let* Œ±1 := M.read Œ±0 in
            let* Œ±2 := never_to_any Œ±1 in
            M.alloc Œ±2
          else
            M.alloc tt in
        let* _ :=
          let* Œ±0 := M.read self in
          let* Œ±1 := M.read amount in
          let* Œ±2 := M.read signature in
          let* Œ±3 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["is_signature_valid"]
                (borrow (deref Œ±0))
                Œ±1
                Œ±2) in
          let* Œ±4 := M.alloc ((M.var "UnOp::not") Œ±3) in
          let* Œ±5 := M.read (use Œ±4) in
          if Œ±5 then
            let* Œ±0 :=
              return_
                (core.result.Result.Err
                  payment_channel.Error.InvalidSignature) in
            let* Œ±1 := M.read Œ±0 in
            let* Œ±2 := never_to_any Œ±1 in
            M.alloc Œ±2
          else
            M.alloc tt in
        let* _ :=
          let* Œ±0 := M.read amount in
          let* Œ±1 := M.read self in
          let* Œ±2 :=
            M.read
              ((M.var "payment_channel::PaymentChannel::Get_withdrawn")
                (deref Œ±1)) in
          let* Œ±3 := M.alloc ((M.var "BinOp::Pure::lt") Œ±0 Œ±2) in
          let* Œ±4 := M.read (use Œ±3) in
          if Œ±4 then
            let* Œ±0 :=
              return_
                (core.result.Result.Err
                  payment_channel.Error.AmountIsLessThanWithdrawn) in
            let* Œ±1 := M.read Œ±0 in
            let* Œ±2 := never_to_any Œ±1 in
            M.alloc Œ±2
          else
            M.alloc tt in
        let* amount_to_withdraw :=
          let* Œ±0 := M.read amount in
          let* Œ±1 := M.read self in
          let* Œ±2 :=
            M.read
              ((M.var "payment_channel::PaymentChannel::Get_withdrawn")
                (deref Œ±1)) in
          let* Œ±3 := (M.var "BinOp::Panic::sub") Œ±0 Œ±2 in
          M.alloc Œ±3 in
        let* _ :=
          let* Œ≤ :=
            let* Œ±0 := M.read self in
            M.pure
              ((M.var "payment_channel::PaymentChannel::Get_withdrawn")
                (deref Œ±0)) in
          let* Œ±0 := M.read Œ≤ in
          let* Œ±1 := M.read amount_to_withdraw in
          let* Œ±2 := (M.var "BinOp::Panic::add") Œ±0 Œ±1 in
          (M.var "assign") Œ≤ Œ±2 in
        let* _ :=
          let* Œ±0 :=
            ltac:(M.get_method (fun ‚Ñê =>
              core.ops.try_trait.Try.branch
                (Self :=
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [Ty.tuple; Ty.apply (Ty.path "payment_channel::Error") []])
                (Trait := ‚Ñê))) in
          let* Œ±1 := M.read self in
          let* Œ±2 :=
            M.call
              ((Ty.apply
                    (Ty.path "payment_channel::PaymentChannel")
                    [])::["env"]
                (borrow (deref Œ±1))) in
          let* Œ±3 := M.alloc Œ±2 in
          let* Œ±4 := M.read self in
          let* Œ±5 :=
            M.read
              ((M.var "payment_channel::PaymentChannel::Get_recipient")
                (deref Œ±4)) in
          let* Œ±6 := M.read amount_to_withdraw in
          let* Œ±7 :=
            M.call
              ((Ty.apply (Ty.path "payment_channel::Env") [])::["transfer"]
                (borrow Œ±3)
                Œ±5
                Œ±6) in
          let* Œ±8 :=
            M.call
              ((Ty.apply
                    (Ty.path "core::result::Result")
                    [Ty.tuple;
                      Ty.apply
                        (Ty.path "payment_channel::Error")
                        []])::["map_err"]
                Œ±7
                (fun (Œ±0 : Ty.apply (Ty.path "payment_channel::Error") []) =>
                  (let* Œ±0 := M.alloc Œ±0 in
                  match_operator
                    Œ±0
                    [
                      fun Œ≥ =>
                        (M.pure payment_channel.Error.TransferFailed) :
                        Ty.apply (Ty.path "payment_channel::Error") []
                    ]) :
                  Ty.apply (Ty.path "payment_channel::Error") [])) in
          let* Œ±9 := M.call (Œ±0 Œ±8) in
          let* Œ±10 := M.alloc Œ±9 in
          match_operator
            Œ±10
            [
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let Œ≥0_0 :=
                    (M.var "core::ops::control_flow::ControlFlow::Get_Break_0")
                      Œ≥ in
                  let* residual := M.copy Œ≥0_0 in
                  let* Œ±0 :=
                    ltac:(M.get_method (fun ‚Ñê =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [Ty.tuple;
                              Ty.apply (Ty.path "payment_channel::Error") []])
                        (R :=
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [Ty.apply (Ty.path "core::convert::Infallible") [];
                              Ty.apply (Ty.path "payment_channel::Error") []])
                        (Trait := ‚Ñê))) in
                  let* Œ±1 := M.read residual in
                  let* Œ±2 := M.call (Œ±0 Œ±1) in
                  let* Œ±3 := return_ Œ±2 in
                  let* Œ±4 := M.read Œ±3 in
                  let* Œ±5 := never_to_any Œ±4 in
                  M.alloc Œ±5
                | _ => M.break_match
                end) :
                Ty.tuple;
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let Œ≥0_0 :=
                    (M.var
                        "core::ops::control_flow::ControlFlow::Get_Continue_0")
                      Œ≥ in
                  let* val := M.copy Œ≥0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                Ty.tuple
            ] in
        let* Œ±0 := M.alloc (core.result.Result.Ok tt) in
        M.read Œ±0)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_withdraw : Instance.t := {
    Notations.double_colon := withdraw;
  }.
  
  (*
      pub fn get_sender(&self) -> AccountId {
          self.sender
      }
  *)
  Definition get_sender (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      M.read ((M.var "payment_channel::PaymentChannel::Get_sender") (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_get_sender : Instance.t := {
    Notations.double_colon := get_sender;
  }.
  
  (*
      pub fn get_recipient(&self) -> AccountId {
          self.recipient
      }
  *)
  Definition get_recipient (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      M.read
        ((M.var "payment_channel::PaymentChannel::Get_recipient") (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_get_recipient : Instance.t := {
    Notations.double_colon := get_recipient;
  }.
  
  (*
      pub fn get_expiration(&self) -> Option<Timestamp> {
          self.expiration
      }
  *)
  Definition get_expiration (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      M.read
        ((M.var "payment_channel::PaymentChannel::Get_expiration") (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_get_expiration : Instance.t := {
    Notations.double_colon := get_expiration;
  }.
  
  (*
      pub fn get_withdrawn(&self) -> Balance {
          self.withdrawn
      }
  *)
  Definition get_withdrawn (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      M.read
        ((M.var "payment_channel::PaymentChannel::Get_withdrawn") (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_get_withdrawn : Instance.t := {
    Notations.double_colon := get_withdrawn;
  }.
  
  (*
      pub fn get_close_duration(&self) -> Timestamp {
          self.close_duration
      }
  *)
  Definition get_close_duration (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      M.read
        ((M.var "payment_channel::PaymentChannel::Get_close_duration")
          (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_get_close_duration : Instance.t := {
    Notations.double_colon := get_close_duration;
  }.
  
  (*
      pub fn get_balance(&self) -> Balance {
          self.env().balance()
      }
  *)
  Definition get_balance (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      let* Œ±1 :=
        M.call
          ((Ty.apply (Ty.path "payment_channel::PaymentChannel") [])::["env"]
            Œ±0) in
      let* Œ±2 := M.alloc Œ±1 in
      M.call
        ((Ty.apply (Ty.path "payment_channel::Env") [])::["balance"]
          (borrow Œ±2))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_get_balance : Instance.t := {
    Notations.double_colon := get_balance;
  }.
End Impl_payment_channel_PaymentChannel.
End Impl_payment_channel_PaymentChannel.
