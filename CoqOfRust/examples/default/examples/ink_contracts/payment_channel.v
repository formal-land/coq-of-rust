(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* StructTuple
  {
    name := "AccountId";
    ty_params := [];
    fields := [ Ty.path "u128" ];
  } *)

Module Impl_core_default_Default_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.path "payment_channel::AccountId".
  
  (*
  Default
  *)
  Definition default (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* α0 :=
        M.get_trait_method "core::default::Default" (Ty.path "u128") [] [] "default" [] [] in
      let* α1 := M.call_closure α0 [] in
      M.pure (Value.StructTuple "payment_channel::AccountId" [ α1 ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_payment_channel_AccountId.

Module Impl_core_clone_Clone_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.path "payment_channel::AccountId".
  
  (*
  Clone
  *)
  Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.match_operator Value.DeclaredButUndefined [ fun γ => M.read self ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_payment_channel_AccountId.

Module Impl_core_marker_Copy_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.path "payment_channel::AccountId".
  
  Axiom Implements :
    M.IsTraitInstance "core::marker::Copy" Self (* Trait polymorphic types *) [] (* Instance *) [].
End Impl_core_marker_Copy_for_payment_channel_AccountId.

Module Impl_core_marker_StructuralPartialEq_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.path "payment_channel::AccountId".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_payment_channel_AccountId.

Module Impl_core_cmp_PartialEq_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.path "payment_channel::AccountId".
  
  (*
  PartialEq
  *)
  Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 := M.read self in
      let* α1 := M.read (M.get_struct_tuple_field α0 "payment_channel::AccountId" 0) in
      let* α2 := M.read other in
      let* α3 := M.read (M.get_struct_tuple_field α2 "payment_channel::AccountId" 0) in
      M.pure (BinOp.Pure.eq α1 α3)
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_for_payment_channel_AccountId.

Module Impl_core_marker_StructuralEq_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.path "payment_channel::AccountId".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralEq_for_payment_channel_AccountId.

Module Impl_core_cmp_Eq_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.path "payment_channel::AccountId".
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 :=
        M.match_operator Value.DeclaredButUndefined [ fun γ => M.alloc (Value.Tuple []) ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Eq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
End Impl_core_cmp_Eq_for_payment_channel_AccountId.

Module Impl_core_convert_From_array_u8_32_for_payment_channel_AccountId.
  Definition Self : Ty.t := Ty.path "payment_channel::AccountId".
  
  (*
      fn from(value: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Definition from (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ value ] =>
      let* value := M.alloc value in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      Self
      (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "array") [ Ty.path "u8" ] [ Value.Integer Integer.Usize 32 ] ]
      (* Instance *) [ ("from", InstanceField.Method from) ].
End Impl_core_convert_From_array_u8_32_for_payment_channel_AccountId.

Axiom Balance : (Ty.path "payment_channel::Balance") = (Ty.path "u128").

Axiom Timestamp : (Ty.path "payment_channel::Timestamp") = (Ty.path "u64").

(* StructRecord
  {
    name := "Env";
    ty_params := [];
    fields := [ ("caller", Ty.path "payment_channel::AccountId") ];
  } *)

(* StructRecord
  {
    name := "PaymentChannel";
    ty_params := [];
    fields :=
      [
        ("sender", Ty.path "payment_channel::AccountId");
        ("recipient", Ty.path "payment_channel::AccountId");
        ("expiration", Ty.apply (Ty.path "core::option::Option") [ Ty.path "u64" ] []);
        ("withdrawn", Ty.path "u128");
        ("close_duration", Ty.path "u64")
      ];
  } *)

(* Enum Error *)
(* {
  ty_params := [];
  variants :=
    [
      {
        name := "CallerIsNotSender";
        item := StructTuple [];
        discriminant := None;
      };
      {
        name := "CallerIsNotRecipient";
        item := StructTuple [];
        discriminant := None;
      };
      {
        name := "AmountIsLessThanWithdrawn";
        item := StructTuple [];
        discriminant := None;
      };
      {
        name := "TransferFailed";
        item := StructTuple [];
        discriminant := None;
      };
      {
        name := "NotYetExpired";
        item := StructTuple [];
        discriminant := None;
      };
      {
        name := "InvalidSignature";
        item := StructTuple [];
        discriminant := None;
      }
    ];
} *)

Module Impl_core_marker_StructuralPartialEq_for_payment_channel_Error.
  Definition Self : Ty.t := Ty.path "payment_channel::Error".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_payment_channel_Error.

Module Impl_core_cmp_PartialEq_for_payment_channel_Error.
  Definition Self : Ty.t := Ty.path "payment_channel::Error".
  
  (*
  PartialEq
  *)
  Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* __self_tag :=
        let* α0 :=
          M.get_function
            "core::intrinsics::discriminant_value"
            [ Ty.path "payment_channel::Error" ]
            [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* __arg1_tag :=
        let* α0 :=
          M.get_function
            "core::intrinsics::discriminant_value"
            [ Ty.path "payment_channel::Error" ]
            [] in
        let* α1 := M.read other in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* α0 := M.read __self_tag in
      let* α1 := M.read __arg1_tag in
      let* α0 := M.alloc (BinOp.Pure.eq α0 α1) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_for_payment_channel_Error.

Module Impl_core_marker_StructuralEq_for_payment_channel_Error.
  Definition Self : Ty.t := Ty.path "payment_channel::Error".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_StructuralEq_for_payment_channel_Error.

Module Impl_core_cmp_Eq_for_payment_channel_Error.
  Definition Self : Ty.t := Ty.path "payment_channel::Error".
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      M.pure (Value.Tuple [])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Eq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
End Impl_core_cmp_Eq_for_payment_channel_Error.

Axiom Result :
  forall (T : Ty.t),
  (Ty.apply (Ty.path "payment_channel::Result") [ T ] []) =
    (Ty.apply (Ty.path "core::result::Result") [ T; Ty.path "payment_channel::Error" ] []).

(* StructRecord
  {
    name := "SenderCloseStarted";
    ty_params := [];
    fields := [ ("expiration", Ty.path "u64"); ("close_duration", Ty.path "u64") ];
  } *)

(* Enum Event *)
(* {
  ty_params := [];
  variants :=
    [
      {
        name := "SenderCloseStarted";
        item := StructTuple [ Ty.path "payment_channel::SenderCloseStarted" ];
        discriminant := None;
      }
    ];
} *)

Module Impl_payment_channel_Env.
  Definition Self : Ty.t := Ty.path "payment_channel::Env".
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read (M.get_struct_record_field α0 "payment_channel::Env" "caller")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_caller : M.IsAssociatedFunction Self "caller" caller.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; _event ] =>
      let* self := M.alloc self in
      let* _event := M.alloc _event in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_emit_event : M.IsAssociatedFunction Self "emit_event" emit_event.
  
  (*
      fn terminate_contract(&self, sender: AccountId) {
          unimplemented!()
      }
  *)
  Definition terminate_contract (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; sender ] =>
      let* self := M.alloc self in
      let* sender := M.alloc sender in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_terminate_contract :
    M.IsAssociatedFunction Self "terminate_contract" terminate_contract.
  
  (*
      fn transfer(&self, recipient: AccountId, amount: Balance) -> Result<()> {
          unimplemented!()
      }
  *)
  Definition transfer (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; recipient; amount ] =>
      let* self := M.alloc self in
      let* recipient := M.alloc recipient in
      let* amount := M.alloc amount in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_transfer : M.IsAssociatedFunction Self "transfer" transfer.
  
  (*
      fn block_timestamp(&self) -> Timestamp {
          unimplemented!()
      }
  *)
  Definition block_timestamp (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_block_timestamp :
    M.IsAssociatedFunction Self "block_timestamp" block_timestamp.
  
  (*
      fn balance(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition balance (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_balance : M.IsAssociatedFunction Self "balance" balance.
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Definition account_id (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_account_id : M.IsAssociatedFunction Self "account_id" account_id.
End Impl_payment_channel_Env.

(* Trait *)
(* Empty module 'HashOutput' *)

(* Trait *)
(* Empty module 'CryptoHash' *)

(*
pub fn hash_encoded<H, T>(input: &T, output: &mut <H as HashOutput>::Type)
where
    H: CryptoHash,
{
    unimplemented!()
}
*)
Definition hash_encoded (τ : list Ty.t) (α : list Value.t) : M :=
  match τ, α with
  | [ H; T ], [ input; output ] =>
    let* input := M.alloc input in
    let* output := M.alloc output in
    let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
    let* α1 := M.read (mk_str "not implemented") in
    let* α2 := M.call_closure α0 [ α1 ] in
    M.never_to_any α2
  | _, _ => M.impossible
  end.

(*
pub fn ecdsa_recover(
    signature: &[u8; 65],
    message_hash: &[u8; 32],
    output: &mut [u8; 33],
) -> Result<()> {
    unimplemented!()
}
*)
Definition ecdsa_recover (τ : list Ty.t) (α : list Value.t) : M :=
  match τ, α with
  | [], [ signature; message_hash; output ] =>
    let* signature := M.alloc signature in
    let* message_hash := M.alloc message_hash in
    let* output := M.alloc output in
    let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
    let* α1 := M.read (mk_str "not implemented") in
    let* α2 := M.call_closure α0 [ α1 ] in
    M.never_to_any α2
  | _, _ => M.impossible
  end.

(* Enum Sha2x256 *)
(* {
  ty_params := [];
  variants := [];
} *)

(* Enum Keccak256 *)
(* {
  ty_params := [];
  variants := [];
} *)

(* Enum Blake2x256 *)
(* {
  ty_params := [];
  variants := [];
} *)

(* Enum Blake2x128 *)
(* {
  ty_params := [];
  variants := [];
} *)

Module Impl_payment_channel_HashOutput_for_payment_channel_Sha2x256.
  Definition Self : Ty.t := Ty.path "payment_channel::Sha2x256".
  
  (*
      type Type = [u8; 32];
  *)
  Definition _Type_ : Ty.t :=
    Ty.apply (Ty.path "array") [ Ty.path "u8" ] [ Value.Integer Integer.Usize 32 ].
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::HashOutput"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("Type_", InstanceField.Ty _Type_) ].
End Impl_payment_channel_HashOutput_for_payment_channel_Sha2x256.

Module Impl_payment_channel_HashOutput_for_payment_channel_Keccak256.
  Definition Self : Ty.t := Ty.path "payment_channel::Keccak256".
  
  (*
      type Type = [u8; 32];
  *)
  Definition _Type_ : Ty.t :=
    Ty.apply (Ty.path "array") [ Ty.path "u8" ] [ Value.Integer Integer.Usize 32 ].
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::HashOutput"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("Type_", InstanceField.Ty _Type_) ].
End Impl_payment_channel_HashOutput_for_payment_channel_Keccak256.

Module Impl_payment_channel_HashOutput_for_payment_channel_Blake2x256.
  Definition Self : Ty.t := Ty.path "payment_channel::Blake2x256".
  
  (*
      type Type = [u8; 32];
  *)
  Definition _Type_ : Ty.t :=
    Ty.apply (Ty.path "array") [ Ty.path "u8" ] [ Value.Integer Integer.Usize 32 ].
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::HashOutput"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("Type_", InstanceField.Ty _Type_) ].
End Impl_payment_channel_HashOutput_for_payment_channel_Blake2x256.

Module Impl_payment_channel_HashOutput_for_payment_channel_Blake2x128.
  Definition Self : Ty.t := Ty.path "payment_channel::Blake2x128".
  
  (*
      type Type = [u8; 16];
  *)
  Definition _Type_ : Ty.t :=
    Ty.apply (Ty.path "array") [ Ty.path "u8" ] [ Value.Integer Integer.Usize 16 ].
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::HashOutput"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("Type_", InstanceField.Ty _Type_) ].
End Impl_payment_channel_HashOutput_for_payment_channel_Blake2x128.

Module Impl_payment_channel_CryptoHash_for_payment_channel_Sha2x256.
  Definition Self : Ty.t := Ty.path "payment_channel::Sha2x256".
  
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ input; output ] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::CryptoHash"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("hash", InstanceField.Method hash) ].
End Impl_payment_channel_CryptoHash_for_payment_channel_Sha2x256.

Module Impl_payment_channel_CryptoHash_for_payment_channel_Keccak256.
  Definition Self : Ty.t := Ty.path "payment_channel::Keccak256".
  
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ input; output ] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::CryptoHash"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("hash", InstanceField.Method hash) ].
End Impl_payment_channel_CryptoHash_for_payment_channel_Keccak256.

Module Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x256.
  Definition Self : Ty.t := Ty.path "payment_channel::Blake2x256".
  
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ input; output ] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::CryptoHash"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("hash", InstanceField.Method hash) ].
End Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x256.

Module Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x128.
  Definition Self : Ty.t := Ty.path "payment_channel::Blake2x128".
  
  (*
      fn hash(input: &[u8], output: &mut <Self as HashOutput>::Type) {
          unimplemented!()
      }
  *)
  Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ input; output ] =>
      let* input := M.alloc input in
      let* output := M.alloc output in
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "payment_channel::CryptoHash"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("hash", InstanceField.Method hash) ].
End Impl_payment_channel_CryptoHash_for_payment_channel_Blake2x128.

Module Impl_payment_channel_PaymentChannel.
  Definition Self : Ty.t := Ty.path "payment_channel::PaymentChannel".
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* α0 := M.get_function "core::panicking::panic" [] [ Value.Bool true ] in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_init_env : M.IsAssociatedFunction Self "init_env" init_env.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 :=
        M.get_associated_function (Ty.path "payment_channel::PaymentChannel") "init_env" [] [] in
      M.call_closure α0 []
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_env : M.IsAssociatedFunction Self "env" env.
  
  (*
      fn is_signature_valid(&self, amount: Balance, signature: [u8; 65]) -> bool {
          let encodable = (self.env().account_id(), amount);
          let mut message = <Sha2x256 as HashOutput>::Type::default();
          hash_encoded::<Sha2x256, _>(&encodable, &mut message);
  
          let mut pub_key = [0; 33];
          ecdsa_recover(&signature, &message, &mut pub_key)
              .unwrap_or_else(|err| panic!("recover failed: {err:?}"));
          let mut signature_account_id = [0; 32];
          <Blake2x256 as CryptoHash>::hash(&pub_key, &mut signature_account_id);
  
          self.recipient == signature_account_id.into()
      }
  *)
  Definition is_signature_valid (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; amount; signature ] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let* encodable :=
        let* α0 := M.get_associated_function (Ty.path "payment_channel::Env") "account_id" [] [] in
        let* α1 :=
          M.get_associated_function (Ty.path "payment_channel::PaymentChannel") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.call_closure α0 [ α4 ] in
        let* α6 := M.read amount in
        M.alloc (Value.Tuple [ α5; α6 ]) in
      let* message :=
        let* α0 :=
          M.get_trait_method
            "core::default::Default"
            (Ty.apply (Ty.path "array") [ Ty.path "u8" ] [ Value.Integer Integer.Usize 32 ])
            []
            []
            "default"
            []
            [] in
        let* α1 := M.call_closure α0 [] in
        M.alloc α1 in
      let* _ :=
        let* α0 :=
          M.get_function
            "payment_channel::hash_encoded"
            [
              Ty.path "payment_channel::Sha2x256";
              Ty.tuple [ Ty.path "payment_channel::AccountId"; Ty.path "u128" ]
            ]
            [] in
        let* α1 := M.call_closure α0 [ encodable; message ] in
        M.alloc α1 in
      let* pub_key := M.alloc (repeat (Value.Integer Integer.U8 0) 33) in
      let* _ :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]
              [])
            "unwrap_or_else"
            [ Ty.function [ Ty.tuple [ Ty.path "payment_channel::Error" ] ] (Ty.tuple []) ]
            [] in
        let* α1 := M.get_function "payment_channel::ecdsa_recover" [] [] in
        let* α2 := M.call_closure α1 [ signature; message; pub_key ] in
        let* α3 :=
          M.call_closure
            α0
            [
              α2;
              M.closure
                (fun γ =>
                  match γ with
                  | [ α0 ] =>
                    let* α0 := M.alloc α0 in
                    M.match_operator
                      α0
                      [
                        fun γ =>
                          let* err := M.copy γ in
                          let* α0 :=
                            M.get_function
                              "std::panicking::begin_panic"
                              [ Ty.apply (Ty.path "&") [ Ty.path "str" ] [] ]
                              [] in
                          let* α1 := M.read (mk_str "recover failed: {err:?}") in
                          let* α2 := M.call_closure α0 [ α1 ] in
                          M.never_to_any α2
                      ]
                  | _ => M.impossible
                  end)
            ] in
        M.alloc α3 in
      let* signature_account_id := M.alloc (repeat (Value.Integer Integer.U8 0) 32) in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "payment_channel::CryptoHash"
            (Ty.path "payment_channel::Blake2x256")
            []
            []
            "hash"
            []
            [] in
        let* α1 := (* Unsize *) M.pure (M.pointer_coercion pub_key) in
        let* α2 := M.call_closure α0 [ α1; signature_account_id ] in
        M.alloc α2 in
      let* α0 :=
        M.get_trait_method
          "core::cmp::PartialEq"
          (Ty.path "payment_channel::AccountId")
          [ Ty.path "payment_channel::AccountId" ]
          [ Value.Bool true ]
          "eq"
          []
          [] in
      let* α1 := M.read self in
      let* α2 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.apply (Ty.path "array") [ Ty.path "u8" ] [ Value.Integer Integer.Usize 32 ])
          [ Ty.path "payment_channel::AccountId" ]
          []
          "into"
          []
          [] in
      let* α3 := M.read signature_account_id in
      let* α4 := M.call_closure α2 [ α3 ] in
      let* α5 := M.alloc α4 in
      let* α6 :=
        M.call_closure
          α0
          [ M.get_struct_record_field α1 "payment_channel::PaymentChannel" "recipient"; α5 ] in
      let* α0 := M.alloc α6 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_is_signature_valid :
    M.IsAssociatedFunction Self "is_signature_valid" is_signature_valid.
  
  (*
      pub fn new(recipient: AccountId, close_duration: Timestamp) -> Self {
          Self {
              sender: Self::init_env().caller(),
              recipient,
              expiration: None,
              withdrawn: 0,
              close_duration,
          }
      }
  *)
  Definition new (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ recipient; close_duration ] =>
      let* recipient := M.alloc recipient in
      let* close_duration := M.alloc close_duration in
      let* α0 := M.get_associated_function (Ty.path "payment_channel::Env") "caller" [] [] in
      let* α1 :=
        M.get_associated_function (Ty.path "payment_channel::PaymentChannel") "init_env" [] [] in
      let* α2 := M.call_closure α1 [] in
      let* α3 := M.alloc α2 in
      let* α4 := M.call_closure α0 [ α3 ] in
      let* α5 := M.read recipient in
      let* α6 := M.read close_duration in
      M.pure
        (Value.StructRecord
          "payment_channel::PaymentChannel"
          [
            ("sender", α4);
            ("recipient", α5);
            ("expiration", Value.StructTuple "core::option::Option::None" []);
            ("withdrawn", Value.Integer Integer.U128 0);
            ("close_duration", α6)
          ])
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
  
  (*
      fn close_inner(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {
          if self.env().caller() != self.recipient {
              return Err(Error::CallerIsNotRecipient);
          }
  
          if amount < self.withdrawn {
              return Err(Error::AmountIsLessThanWithdrawn);
          }
  
          // Signature validation
          if !self.is_signature_valid(amount, signature) {
              return Err(Error::InvalidSignature);
          }
  
          self.env()
              .transfer(self.recipient, amount - self.withdrawn)
              .map_err(|_| Error::TransferFailed)?;
  
          Ok(())
      }
  *)
  Definition close_inner (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; amount; signature ] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_trait_method
                    "core::cmp::PartialEq"
                    (Ty.path "payment_channel::AccountId")
                    [ Ty.path "payment_channel::AccountId" ]
                    [ Value.Bool true ]
                    "ne"
                    []
                    [] in
                let* α1 :=
                  M.get_associated_function (Ty.path "payment_channel::Env") "caller" [] [] in
                let* α2 :=
                  M.get_associated_function
                    (Ty.path "payment_channel::PaymentChannel")
                    "env"
                    []
                    [] in
                let* α3 := M.read self in
                let* α4 := M.call_closure α2 [ α3 ] in
                let* α5 := M.alloc α4 in
                let* α6 := M.call_closure α1 [ α5 ] in
                let* α7 := M.alloc α6 in
                let* α8 := M.read self in
                let* α9 :=
                  M.call_closure
                    α0
                    [ α7; M.get_struct_record_field α8 "payment_channel::PaymentChannel" "recipient"
                    ] in
                let* α10 := M.alloc α9 in
                M.pure (M.use α10) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.return_
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "payment_channel::Error::CallerIsNotRecipient" [] ]) in
              let* α1 := M.read α0 in
              let* α2 := M.never_to_any α1 in
              M.alloc α2;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 := M.read amount in
                let* α1 := M.read self in
                let* α2 :=
                  M.read
                    (M.get_struct_record_field α1 "payment_channel::PaymentChannel" "withdrawn") in
                let* α3 := M.alloc (BinOp.Pure.lt α0 α2) in
                M.pure (M.use α3) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.return_
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "payment_channel::Error::AmountIsLessThanWithdrawn" [] ]) in
              let* α1 := M.read α0 in
              let* α2 := M.never_to_any α1 in
              M.alloc α2;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.path "payment_channel::PaymentChannel")
                    "is_signature_valid"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read amount in
                let* α3 := M.read signature in
                let* α4 := M.call_closure α0 [ α1; α2; α3 ] in
                let* α5 := M.alloc (UnOp.Pure.not α4) in
                M.pure (M.use α5) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.return_
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "payment_channel::Error::InvalidSignature" [] ]) in
              let* α1 := M.read α0 in
              let* α2 := M.never_to_any α1 in
              M.alloc α2;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "core::ops::try_trait::Try"
            (Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]
              [])
            []
            []
            "branch"
            []
            [] in
        let* α1 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]
              [])
            "map_err"
            [
              Ty.path "payment_channel::Error";
              Ty.function
                [ Ty.tuple [ Ty.path "payment_channel::Error" ] ]
                (Ty.path "payment_channel::Error")
            ]
            [] in
        let* α2 := M.get_associated_function (Ty.path "payment_channel::Env") "transfer" [] [] in
        let* α3 :=
          M.get_associated_function (Ty.path "payment_channel::PaymentChannel") "env" [] [] in
        let* α4 := M.read self in
        let* α5 := M.call_closure α3 [ α4 ] in
        let* α6 := M.alloc α5 in
        let* α7 := M.read self in
        let* α8 :=
          M.read (M.get_struct_record_field α7 "payment_channel::PaymentChannel" "recipient") in
        let* α9 := M.read amount in
        let* α10 := M.read self in
        let* α11 :=
          M.read (M.get_struct_record_field α10 "payment_channel::PaymentChannel" "withdrawn") in
        let* α12 := BinOp.Panic.sub α9 α11 in
        let* α13 := M.call_closure α2 [ α6; α8; α12 ] in
        let* α14 :=
          M.call_closure
            α1
            [
              α13;
              M.closure
                (fun γ =>
                  match γ with
                  | [ α0 ] =>
                    let* α0 := M.alloc α0 in
                    M.match_operator
                      α0
                      [
                        fun γ =>
                          M.pure (Value.StructTuple "payment_channel::Error::TransferFailed" [])
                      ]
                  | _ => M.impossible
                  end)
            ] in
        let* α15 := M.call_closure α0 [ α14 ] in
        let* α16 := M.alloc α15 in
        M.match_operator
          α16
          [
            fun γ =>
              let* γ0_0 :=
                M.get_struct_tuple_field_or_break_match
                  γ
                  "core::ops::control_flow::ControlFlow::Break"
                  0 in
              let* residual := M.copy γ0_0 in
              let* α0 :=
                M.get_trait_method
                  "core::ops::try_trait::FromResidual"
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.tuple []; Ty.path "payment_channel::Error" ]
                    [])
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.path "core::convert::Infallible"; Ty.path "payment_channel::Error" ]
                      []
                  ]
                  []
                  "from_residual"
                  []
                  [] in
              let* α1 := M.read residual in
              let* α2 := M.call_closure α0 [ α1 ] in
              let* α3 := M.return_ α2 in
              let* α4 := M.read α3 in
              let* α5 := M.never_to_any α4 in
              M.alloc α5;
            fun γ =>
              let* γ0_0 :=
                M.get_struct_tuple_field_or_break_match
                  γ
                  "core::ops::control_flow::ControlFlow::Continue"
                  0 in
              let* val := M.copy γ0_0 in
              M.pure val
          ] in
      let* α0 := M.alloc (Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_close_inner : M.IsAssociatedFunction Self "close_inner" close_inner.
  
  (*
      pub fn close(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {
          self.close_inner(amount, signature)?;
          self.env().terminate_contract(self.sender);
  
          Ok(())
      }
  *)
  Definition close (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; amount; signature ] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "core::ops::try_trait::Try"
            (Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]
              [])
            []
            []
            "branch"
            []
            [] in
        let* α1 :=
          M.get_associated_function
            (Ty.path "payment_channel::PaymentChannel")
            "close_inner"
            []
            [] in
        let* α2 := M.read self in
        let* α3 := M.read amount in
        let* α4 := M.read signature in
        let* α5 := M.call_closure α1 [ α2; α3; α4 ] in
        let* α6 := M.call_closure α0 [ α5 ] in
        let* α7 := M.alloc α6 in
        M.match_operator
          α7
          [
            fun γ =>
              let* γ0_0 :=
                M.get_struct_tuple_field_or_break_match
                  γ
                  "core::ops::control_flow::ControlFlow::Break"
                  0 in
              let* residual := M.copy γ0_0 in
              let* α0 :=
                M.get_trait_method
                  "core::ops::try_trait::FromResidual"
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.tuple []; Ty.path "payment_channel::Error" ]
                    [])
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.path "core::convert::Infallible"; Ty.path "payment_channel::Error" ]
                      []
                  ]
                  []
                  "from_residual"
                  []
                  [] in
              let* α1 := M.read residual in
              let* α2 := M.call_closure α0 [ α1 ] in
              let* α3 := M.return_ α2 in
              let* α4 := M.read α3 in
              let* α5 := M.never_to_any α4 in
              M.alloc α5;
            fun γ =>
              let* γ0_0 :=
                M.get_struct_tuple_field_or_break_match
                  γ
                  "core::ops::control_flow::ControlFlow::Continue"
                  0 in
              let* val := M.copy γ0_0 in
              M.pure val
          ] in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "payment_channel::Env") "terminate_contract" [] [] in
        let* α1 :=
          M.get_associated_function (Ty.path "payment_channel::PaymentChannel") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read self in
        let* α6 :=
          M.read (M.get_struct_record_field α5 "payment_channel::PaymentChannel" "sender") in
        let* α7 := M.call_closure α0 [ α4; α6 ] in
        M.alloc α7 in
      let* α0 := M.alloc (Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_close : M.IsAssociatedFunction Self "close" close.
  
  (*
      pub fn start_sender_close(&mut self) -> Result<()> {
          if self.env().caller() != self.sender {
              return Err(Error::CallerIsNotSender);
          }
  
          let now = self.env().block_timestamp();
          let expiration = now + self.close_duration;
  
          self.env()
              .emit_event(Event::SenderCloseStarted(SenderCloseStarted {
                  expiration,
                  close_duration: self.close_duration,
              }));
  
          self.expiration = Some(expiration);
  
          Ok(())
      }
  *)
  Definition start_sender_close (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_trait_method
                    "core::cmp::PartialEq"
                    (Ty.path "payment_channel::AccountId")
                    [ Ty.path "payment_channel::AccountId" ]
                    [ Value.Bool true ]
                    "ne"
                    []
                    [] in
                let* α1 :=
                  M.get_associated_function (Ty.path "payment_channel::Env") "caller" [] [] in
                let* α2 :=
                  M.get_associated_function
                    (Ty.path "payment_channel::PaymentChannel")
                    "env"
                    []
                    [] in
                let* α3 := M.read self in
                let* α4 := M.call_closure α2 [ α3 ] in
                let* α5 := M.alloc α4 in
                let* α6 := M.call_closure α1 [ α5 ] in
                let* α7 := M.alloc α6 in
                let* α8 := M.read self in
                let* α9 :=
                  M.call_closure
                    α0
                    [ α7; M.get_struct_record_field α8 "payment_channel::PaymentChannel" "sender"
                    ] in
                let* α10 := M.alloc α9 in
                M.pure (M.use α10) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.return_
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "payment_channel::Error::CallerIsNotSender" [] ]) in
              let* α1 := M.read α0 in
              let* α2 := M.never_to_any α1 in
              M.alloc α2;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* now :=
        let* α0 :=
          M.get_associated_function (Ty.path "payment_channel::Env") "block_timestamp" [] [] in
        let* α1 :=
          M.get_associated_function (Ty.path "payment_channel::PaymentChannel") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.call_closure α0 [ α4 ] in
        M.alloc α5 in
      let* expiration :=
        let* α0 := M.read now in
        let* α1 := M.read self in
        let* α2 :=
          M.read
            (M.get_struct_record_field α1 "payment_channel::PaymentChannel" "close_duration") in
        let* α3 := BinOp.Panic.add α0 α2 in
        M.alloc α3 in
      let* _ :=
        let* α0 := M.get_associated_function (Ty.path "payment_channel::Env") "emit_event" [] [] in
        let* α1 :=
          M.get_associated_function (Ty.path "payment_channel::PaymentChannel") "env" [] [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.alloc α3 in
        let* α5 := M.read expiration in
        let* α6 := M.read self in
        let* α7 :=
          M.read
            (M.get_struct_record_field α6 "payment_channel::PaymentChannel" "close_duration") in
        let* α8 :=
          M.call_closure
            α0
            [
              α4;
              Value.StructTuple
                "payment_channel::Event::SenderCloseStarted"
                [
                  Value.StructRecord
                    "payment_channel::SenderCloseStarted"
                    [ ("expiration", α5); ("close_duration", α7) ]
                ]
            ] in
        M.alloc α8 in
      let* _ :=
        let* α0 := M.read self in
        let* α1 := M.read expiration in
        M.assign
          (M.get_struct_record_field α0 "payment_channel::PaymentChannel" "expiration")
          (Value.StructTuple "core::option::Option::Some" [ α1 ]) in
      let* α0 := M.alloc (Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_start_sender_close :
    M.IsAssociatedFunction Self "start_sender_close" start_sender_close.
  
  (*
      pub fn claim_timeout(&mut self) -> Result<()> {
          match self.expiration {
              Some(expiration) => {
                  // expiration is set. Check if it's reached and if so, release the
                  // funds and terminate the contract.
                  let now = self.env().block_timestamp();
                  if now < expiration {
                      return Err(Error::NotYetExpired);
                  }
  
                  self.env().terminate_contract(self.sender);
  
                  Ok(())
              }
  
              None => Err(Error::NotYetExpired),
          }
      }
  *)
  Definition claim_timeout (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      let* α1 :=
        M.match_operator
          (M.get_struct_record_field α0 "payment_channel::PaymentChannel" "expiration")
          [
            fun γ =>
              let* γ0_0 :=
                M.get_struct_tuple_field_or_break_match γ "core::option::Option::Some" 0 in
              let* expiration := M.copy γ0_0 in
              let* now :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.path "payment_channel::Env")
                    "block_timestamp"
                    []
                    [] in
                let* α1 :=
                  M.get_associated_function
                    (Ty.path "payment_channel::PaymentChannel")
                    "env"
                    []
                    [] in
                let* α2 := M.read self in
                let* α3 := M.call_closure α1 [ α2 ] in
                let* α4 := M.alloc α3 in
                let* α5 := M.call_closure α0 [ α4 ] in
                M.alloc α5 in
              let* _ :=
                let* α0 := M.alloc (Value.Tuple []) in
                M.match_operator
                  α0
                  [
                    fun γ =>
                      let* γ :=
                        let* α0 := M.read now in
                        let* α1 := M.read expiration in
                        let* α2 := M.alloc (BinOp.Pure.lt α0 α1) in
                        M.pure (M.use α2) in
                      let* _ :=
                        let* α0 := M.read γ in
                        M.is_constant_or_break_match α0 (Value.Bool true) in
                      let* α0 :=
                        M.return_
                          (Value.StructTuple
                            "core::result::Result::Err"
                            [ Value.StructTuple "payment_channel::Error::NotYetExpired" [] ]) in
                      let* α1 := M.read α0 in
                      let* α2 := M.never_to_any α1 in
                      M.alloc α2;
                    fun γ => M.alloc (Value.Tuple [])
                  ] in
              let* _ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.path "payment_channel::Env")
                    "terminate_contract"
                    []
                    [] in
                let* α1 :=
                  M.get_associated_function
                    (Ty.path "payment_channel::PaymentChannel")
                    "env"
                    []
                    [] in
                let* α2 := M.read self in
                let* α3 := M.call_closure α1 [ α2 ] in
                let* α4 := M.alloc α3 in
                let* α5 := M.read self in
                let* α6 :=
                  M.read
                    (M.get_struct_record_field α5 "payment_channel::PaymentChannel" "sender") in
                let* α7 := M.call_closure α0 [ α4; α6 ] in
                M.alloc α7 in
              M.alloc (Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]);
            fun γ =>
              M.alloc
                (Value.StructTuple
                  "core::result::Result::Err"
                  [ Value.StructTuple "payment_channel::Error::NotYetExpired" [] ])
          ] in
      M.read α1
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_claim_timeout :
    M.IsAssociatedFunction Self "claim_timeout" claim_timeout.
  
  (*
      pub fn withdraw(&mut self, amount: Balance, signature: [u8; 65]) -> Result<()> {
          if self.env().caller() != self.recipient {
              return Err(Error::CallerIsNotRecipient);
          }
  
          // Signature validation
          if !self.is_signature_valid(amount, signature) {
              return Err(Error::InvalidSignature);
          }
  
          // Make sure there's something to withdraw (guards against underflow)
          if amount < self.withdrawn {
              return Err(Error::AmountIsLessThanWithdrawn);
          }
  
          let amount_to_withdraw = amount - self.withdrawn;
          self.withdrawn += amount_to_withdraw;
  
          self.env()
              .transfer(self.recipient, amount_to_withdraw)
              .map_err(|_| Error::TransferFailed)?;
  
          Ok(())
      }
  *)
  Definition withdraw (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; amount; signature ] =>
      let* self := M.alloc self in
      let* amount := M.alloc amount in
      let* signature := M.alloc signature in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_trait_method
                    "core::cmp::PartialEq"
                    (Ty.path "payment_channel::AccountId")
                    [ Ty.path "payment_channel::AccountId" ]
                    [ Value.Bool true ]
                    "ne"
                    []
                    [] in
                let* α1 :=
                  M.get_associated_function (Ty.path "payment_channel::Env") "caller" [] [] in
                let* α2 :=
                  M.get_associated_function
                    (Ty.path "payment_channel::PaymentChannel")
                    "env"
                    []
                    [] in
                let* α3 := M.read self in
                let* α4 := M.call_closure α2 [ α3 ] in
                let* α5 := M.alloc α4 in
                let* α6 := M.call_closure α1 [ α5 ] in
                let* α7 := M.alloc α6 in
                let* α8 := M.read self in
                let* α9 :=
                  M.call_closure
                    α0
                    [ α7; M.get_struct_record_field α8 "payment_channel::PaymentChannel" "recipient"
                    ] in
                let* α10 := M.alloc α9 in
                M.pure (M.use α10) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.return_
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "payment_channel::Error::CallerIsNotRecipient" [] ]) in
              let* α1 := M.read α0 in
              let* α2 := M.never_to_any α1 in
              M.alloc α2;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.path "payment_channel::PaymentChannel")
                    "is_signature_valid"
                    []
                    [] in
                let* α1 := M.read self in
                let* α2 := M.read amount in
                let* α3 := M.read signature in
                let* α4 := M.call_closure α0 [ α1; α2; α3 ] in
                let* α5 := M.alloc (UnOp.Pure.not α4) in
                M.pure (M.use α5) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.return_
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "payment_channel::Error::InvalidSignature" [] ]) in
              let* α1 := M.read α0 in
              let* α2 := M.never_to_any α1 in
              M.alloc α2;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 := M.read amount in
                let* α1 := M.read self in
                let* α2 :=
                  M.read
                    (M.get_struct_record_field α1 "payment_channel::PaymentChannel" "withdrawn") in
                let* α3 := M.alloc (BinOp.Pure.lt α0 α2) in
                M.pure (M.use α3) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.return_
                  (Value.StructTuple
                    "core::result::Result::Err"
                    [ Value.StructTuple "payment_channel::Error::AmountIsLessThanWithdrawn" [] ]) in
              let* α1 := M.read α0 in
              let* α2 := M.never_to_any α1 in
              M.alloc α2;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* amount_to_withdraw :=
        let* α0 := M.read amount in
        let* α1 := M.read self in
        let* α2 :=
          M.read (M.get_struct_record_field α1 "payment_channel::PaymentChannel" "withdrawn") in
        let* α3 := BinOp.Panic.sub α0 α2 in
        M.alloc α3 in
      let* _ :=
        let* β :=
          let* α0 := M.read self in
          M.pure (M.get_struct_record_field α0 "payment_channel::PaymentChannel" "withdrawn") in
        let* α0 := M.read β in
        let* α1 := M.read amount_to_withdraw in
        let* α2 := BinOp.Panic.add α0 α1 in
        M.assign β α2 in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "core::ops::try_trait::Try"
            (Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]
              [])
            []
            []
            "branch"
            []
            [] in
        let* α1 :=
          M.get_associated_function
            (Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.path "payment_channel::Error" ]
              [])
            "map_err"
            [
              Ty.path "payment_channel::Error";
              Ty.function
                [ Ty.tuple [ Ty.path "payment_channel::Error" ] ]
                (Ty.path "payment_channel::Error")
            ]
            [] in
        let* α2 := M.get_associated_function (Ty.path "payment_channel::Env") "transfer" [] [] in
        let* α3 :=
          M.get_associated_function (Ty.path "payment_channel::PaymentChannel") "env" [] [] in
        let* α4 := M.read self in
        let* α5 := M.call_closure α3 [ α4 ] in
        let* α6 := M.alloc α5 in
        let* α7 := M.read self in
        let* α8 :=
          M.read (M.get_struct_record_field α7 "payment_channel::PaymentChannel" "recipient") in
        let* α9 := M.read amount_to_withdraw in
        let* α10 := M.call_closure α2 [ α6; α8; α9 ] in
        let* α11 :=
          M.call_closure
            α1
            [
              α10;
              M.closure
                (fun γ =>
                  match γ with
                  | [ α0 ] =>
                    let* α0 := M.alloc α0 in
                    M.match_operator
                      α0
                      [
                        fun γ =>
                          M.pure (Value.StructTuple "payment_channel::Error::TransferFailed" [])
                      ]
                  | _ => M.impossible
                  end)
            ] in
        let* α12 := M.call_closure α0 [ α11 ] in
        let* α13 := M.alloc α12 in
        M.match_operator
          α13
          [
            fun γ =>
              let* γ0_0 :=
                M.get_struct_tuple_field_or_break_match
                  γ
                  "core::ops::control_flow::ControlFlow::Break"
                  0 in
              let* residual := M.copy γ0_0 in
              let* α0 :=
                M.get_trait_method
                  "core::ops::try_trait::FromResidual"
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.tuple []; Ty.path "payment_channel::Error" ]
                    [])
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.path "core::convert::Infallible"; Ty.path "payment_channel::Error" ]
                      []
                  ]
                  []
                  "from_residual"
                  []
                  [] in
              let* α1 := M.read residual in
              let* α2 := M.call_closure α0 [ α1 ] in
              let* α3 := M.return_ α2 in
              let* α4 := M.read α3 in
              let* α5 := M.never_to_any α4 in
              M.alloc α5;
            fun γ =>
              let* γ0_0 :=
                M.get_struct_tuple_field_or_break_match
                  γ
                  "core::ops::control_flow::ControlFlow::Continue"
                  0 in
              let* val := M.copy γ0_0 in
              M.pure val
          ] in
      let* α0 := M.alloc (Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_withdraw : M.IsAssociatedFunction Self "withdraw" withdraw.
  
  (*
      pub fn get_sender(&self) -> AccountId {
          self.sender
      }
  *)
  Definition get_sender (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read (M.get_struct_record_field α0 "payment_channel::PaymentChannel" "sender")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_sender : M.IsAssociatedFunction Self "get_sender" get_sender.
  
  (*
      pub fn get_recipient(&self) -> AccountId {
          self.recipient
      }
  *)
  Definition get_recipient (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read (M.get_struct_record_field α0 "payment_channel::PaymentChannel" "recipient")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_recipient :
    M.IsAssociatedFunction Self "get_recipient" get_recipient.
  
  (*
      pub fn get_expiration(&self) -> Option<Timestamp> {
          self.expiration
      }
  *)
  Definition get_expiration (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read (M.get_struct_record_field α0 "payment_channel::PaymentChannel" "expiration")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_expiration :
    M.IsAssociatedFunction Self "get_expiration" get_expiration.
  
  (*
      pub fn get_withdrawn(&self) -> Balance {
          self.withdrawn
      }
  *)
  Definition get_withdrawn (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read (M.get_struct_record_field α0 "payment_channel::PaymentChannel" "withdrawn")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_withdrawn :
    M.IsAssociatedFunction Self "get_withdrawn" get_withdrawn.
  
  (*
      pub fn get_close_duration(&self) -> Timestamp {
          self.close_duration
      }
  *)
  Definition get_close_duration (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read (M.get_struct_record_field α0 "payment_channel::PaymentChannel" "close_duration")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_close_duration :
    M.IsAssociatedFunction Self "get_close_duration" get_close_duration.
  
  (*
      pub fn get_balance(&self) -> Balance {
          self.env().balance()
      }
  *)
  Definition get_balance (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.get_associated_function (Ty.path "payment_channel::Env") "balance" [] [] in
      let* α1 :=
        M.get_associated_function (Ty.path "payment_channel::PaymentChannel") "env" [] [] in
      let* α2 := M.read self in
      let* α3 := M.call_closure α1 [ α2 ] in
      let* α4 := M.alloc α3 in
      M.call_closure α0 [ α4 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_get_balance : M.IsAssociatedFunction Self "get_balance" get_balance.
End Impl_payment_channel_PaymentChannel.
