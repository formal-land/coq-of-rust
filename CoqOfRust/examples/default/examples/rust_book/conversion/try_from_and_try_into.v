(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  EvenNumber.
Section EvenNumber.
  Record t : Set := {
    x0 : i32.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End EvenNumber.
End EvenNumber.

Module  Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.
  Definition Self : Set := try_from_and_try_into.EvenNumber.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let f := M.alloc (| f |) in
      M.call (|(core.fmt.Formatter.t::["debug_tuple_field1_finish"]
        (M.read (| f |))
        (M.read (| mk_str "EvenNumber" |))
        (pointer_coercion
          "Unsize"
          (borrow
            (M.alloc (|
              borrow
                (try_from_and_try_into.EvenNumber.Get_0
                  (deref (M.read (| self |))))
            |)))))
      |)
    ) : ltac:(core.fmt.Result))).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.

Module  Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.
  Definition Self : Set := try_from_and_try_into.EvenNumber.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.

Module  Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.
  Definition Self : Set := try_from_and_try_into.EvenNumber.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref try_from_and_try_into.EvenNumber.t)
      : M bool.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let other := M.alloc (| other |) in
      BinOp.Pure.eq
        (M.read (|
          try_from_and_try_into.EvenNumber.Get_0 (deref (M.read (| self |)))
        |))
        (M.read (|
          try_from_and_try_into.EvenNumber.Get_0 (deref (M.read (| other |)))
        |))
    ) : bool.t)).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.

Module  Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.
  Definition Self : Set := try_from_and_try_into.EvenNumber.t.
  
  (*
      type Error = ();
  *)
  Definition Error : Set := unit.
  
  (*
      fn try_from(value: i32) -> Result<Self, Self::Error> {
          if value % 2 == 0 {
              Ok(EvenNumber(value))
          } else {
              Err(())
          }
      }
  *)
  Definition try_from (value : i32.t) : M (core.result.Result.t Self Error) :=
    ltac:(M.monadic ((
      let value := M.alloc (| value |) in
      M.read (|
        if
          M.read (|
            use
              (M.alloc (|
                BinOp.Pure.eq
                  (BinOp.Panic.rem (|
                    M.read (| value |),
                    (Integer.of_Z 2) : i32.t
                  |))
                  ((Integer.of_Z 0) : i32.t)
              |))
          |)
        then
          M.alloc (|
            core.result.Result.Ok
              (try_from_and_try_into.EvenNumber.Build_t (M.read (| value |)))
          |)
        else
          M.alloc (| core.result.Result.Err tt |)
      |)
    ) : core.result.Result.t Self Error)).
  
  Global Instance AssociatedFunction_try_from :
    Notations.DoubleColon Self "try_from" := {
    Notations.double_colon := try_from;
  }.
  
  Global Instance ℐ : core.convert.TryFrom.Trait Self (T := i32.t) := {
    core.convert.TryFrom.Error := Error;
    core.convert.TryFrom.try_from := try_from;
  }.
End Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.

(*
fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result<EvenNumber, ()> = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result<EvenNumber, ()> = 5i32.try_into();
    assert_eq!(result, Err(()));
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic ((
    M.read (|
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.convert.TryFrom.try_from
                          (Self := try_from_and_try_into.EvenNumber.t)
                          (T := i32.t)
                          (Trait := ℐ)))
                      ((Integer.of_Z 8) : i32.t))
                    |)
                  |)),
                borrow
                  (M.alloc (|
                    core.result.Result.Ok
                      (try_from_and_try_into.EvenNumber.Build_t
                        ((Integer.of_Z 8) : i32.t))
                  |)))
            |))
            [
              fun
                  (γ :
                    M.Val
                      ((ref
                        (core.result.Result.t
                          try_from_and_try_into.EvenNumber.t
                          unit))
                      *
                      (ref
                        (core.result.Result.t
                          try_from_and_try_into.EvenNumber.t
                          unit)))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.cmp.PartialEq.eq
                                  (Self :=
                                    core.result.Result.t
                                      try_from_and_try_into.EvenNumber.t
                                      unit)
                                  (Rhs :=
                                    core.result.Result.t
                                      try_from_and_try_into.EvenNumber.t
                                      unit)
                                  (Trait := ℐ)))
                              (M.read (| left_val |))
                              (M.read (| right_val |)))
                            |))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.convert.TryFrom.try_from
                          (Self := try_from_and_try_into.EvenNumber.t)
                          (T := i32.t)
                          (Trait := ℐ)))
                      ((Integer.of_Z 5) : i32.t))
                    |)
                  |)),
                borrow (M.alloc (| core.result.Result.Err tt |)))
            |))
            [
              fun
                  (γ :
                    M.Val
                      ((ref
                        (core.result.Result.t
                          try_from_and_try_into.EvenNumber.t
                          unit))
                      *
                      (ref
                        (core.result.Result.t
                          try_from_and_try_into.EvenNumber.t
                          unit)))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.cmp.PartialEq.eq
                                  (Self :=
                                    core.result.Result.t
                                      try_from_and_try_into.EvenNumber.t
                                      unit)
                                  (Rhs :=
                                    core.result.Result.t
                                      try_from_and_try_into.EvenNumber.t
                                      unit)
                                  (Trait := ℐ)))
                              (M.read (| left_val |))
                              (M.read (| right_val |)))
                            |))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      let result :
          M.Val
            (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
        M.alloc (|
          M.call (|(ltac:(M.get_method (fun ℐ =>
              core.convert.TryInto.try_into
                (Self := i32.t)
                (T := try_from_and_try_into.EvenNumber.t)
                (Trait := ℐ)))
            ((Integer.of_Z 8) : i32.t))
          |)
        |) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow result,
                borrow
                  (M.alloc (|
                    core.result.Result.Ok
                      (try_from_and_try_into.EvenNumber.Build_t
                        ((Integer.of_Z 8) : i32.t))
                  |)))
            |))
            [
              fun
                  (γ :
                    M.Val
                      ((ref
                        (core.result.Result.t
                          try_from_and_try_into.EvenNumber.t
                          unit))
                      *
                      (ref
                        (core.result.Result.t
                          try_from_and_try_into.EvenNumber.t
                          unit)))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.cmp.PartialEq.eq
                                  (Self :=
                                    core.result.Result.t
                                      try_from_and_try_into.EvenNumber.t
                                      unit)
                                  (Rhs :=
                                    core.result.Result.t
                                      try_from_and_try_into.EvenNumber.t
                                      unit)
                                  (Trait := ℐ)))
                              (M.read (| left_val |))
                              (M.read (| right_val |)))
                            |))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      let result :
          M.Val
            (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
        M.alloc (|
          M.call (|(ltac:(M.get_method (fun ℐ =>
              core.convert.TryInto.try_into
                (Self := i32.t)
                (T := try_from_and_try_into.EvenNumber.t)
                (Trait := ℐ)))
            ((Integer.of_Z 5) : i32.t))
          |)
        |) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow result, borrow (M.alloc (| core.result.Result.Err tt |)))
            |))
            [
              fun
                  (γ :
                    M.Val
                      ((ref
                        (core.result.Result.t
                          try_from_and_try_into.EvenNumber.t
                          unit))
                      *
                      (ref
                        (core.result.Result.t
                          try_from_and_try_into.EvenNumber.t
                          unit)))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.cmp.PartialEq.eq
                                  (Self :=
                                    core.result.Result.t
                                      try_from_and_try_into.EvenNumber.t
                                      unit)
                                  (Rhs :=
                                    core.result.Result.t
                                      try_from_and_try_into.EvenNumber.t
                                      unit)
                                  (Trait := ℐ)))
                              (M.read (| left_val |))
                              (M.read (| right_val |)))
                            |))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      M.alloc (| tt |)
    |)
  ) : unit)).
