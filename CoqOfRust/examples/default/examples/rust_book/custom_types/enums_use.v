(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
Enum Status
{
  const_params := [];
  ty_params := [];
  variants :=
    [
      {
        name := "Rich";
        item := StructTuple [];
      };
      {
        name := "Poor";
        item := StructTuple [];
      }
    ];
}
*)

Axiom IsDiscriminant_Status_Rich : M.IsDiscriminant "enums_use::Status::Rich" 0.
Axiom IsDiscriminant_Status_Poor : M.IsDiscriminant "enums_use::Status::Poor" 1.

(*
Enum Work
{
  const_params := [];
  ty_params := [];
  variants :=
    [
      {
        name := "Civilian";
        item := StructTuple [];
      };
      {
        name := "Soldier";
        item := StructTuple [];
      }
    ];
}
*)

Axiom IsDiscriminant_Work_Civilian : M.IsDiscriminant "enums_use::Work::Civilian" 0.
Axiom IsDiscriminant_Work_Soldier : M.IsDiscriminant "enums_use::Work::Soldier" 1.

(*
fn main() {
    // Equivalent to `Status::Poor`.
    let status = Poor;
    // Equivalent to `Work::Civilian`.
    let work = Civilian;

    match status {
        // Note the lack of scoping because of the explicit `use` above.
        Rich => println!("The rich have lots of money!"),
        Poor => println!("The poor have no money..."),
    }

    match work {
        // Note again the lack of scoping.
        Civilian => println!("Civilians work!"),
        Soldier => println!("Soldiers fight!"),
    }
}
*)
Definition main (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [] =>
    ltac:(M.monadic
      (M.read (|
        let~ status : Ty.path "enums_use::Status" :=
          M.alloc (| Value.StructTuple "enums_use::Status::Poor" [] |) in
        let~ work : Ty.path "enums_use::Work" :=
          M.alloc (| Value.StructTuple "enums_use::Work::Civilian" [] |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            status,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "enums_use::Status::Rich" |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "std::io::stdio::_print", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ M.read (| Value.String "The rich have lots of money!
" |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "enums_use::Status::Poor" |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "std::io::stdio::_print", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ M.read (| Value.String "The poor have no money...
" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        M.match_operator (|
          work,
          [
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "enums_use::Work::Civilian" |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "std::io::stdio::_print", [], [] |),
                      [
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_const",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Value.Array [ M.read (| Value.String "Civilians work!
" |) ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)));
            fun γ =>
              ltac:(M.monadic
                (let _ := M.is_struct_tuple (| γ, "enums_use::Work::Soldier" |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "std::io::stdio::_print", [], [] |),
                      [
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_const",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Value.Array [ M.read (| Value.String "Soldiers fight!
" |) ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)))
          ]
        |)
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Axiom Function_main : M.IsFunction "enums_use::main" main.
Smpl Add apply Function_main : is_function.
