(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Person.
Section Person.
  Record t : Set := {
    name : alloc.string.String.t;
    age : u8.t;
  }.
  
  Definition Get_name :=
    Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
  Definition Get_age :=
    Ref.map (fun α => Some α.(age)) (fun β α => Some (α <| age := β |>)).
End Person.
End Person.

Module  Impl_core_fmt_Debug_for_structures_Person_t.
Section Impl_core_fmt_Debug_for_structures_Person_t.
  Definition Self : Set := structures.Person.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let f := M.alloc (| f |) in
      M.call (|(core.fmt.Formatter.t::["debug_struct_field2_finish"]
        (M.read (| f |))
        (M.read (| mk_str "Person" |))
        (M.read (| mk_str "name" |))
        (pointer_coercion
          "Unsize"
          (borrow (structures.Person.Get_name (deref (M.read (| self |))))))
        (M.read (| mk_str "age" |))
        (pointer_coercion
          "Unsize"
          (borrow
            (M.alloc (|
              borrow (structures.Person.Get_age (deref (M.read (| self |))))
            |)))))
      |)
    )).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_structures_Person_t.
End Impl_core_fmt_Debug_for_structures_Person_t.

Module  Unit.
Section Unit.
  Inductive t : Set := Build.
End Unit.
End Unit.

Module  Pair.
Section Pair.
  Record t : Set := {
    x0 : i32.t;
    x1 : f32.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
  Definition Get_1 :=
    Ref.map (fun α => Some α.(x1)) (fun β α => Some (α <| x1 := β |>)).
End Pair.
End Pair.

Module  Point.
Section Point.
  Record t : Set := {
    x : f32.t;
    y : f32.t;
  }.
  
  Definition Get_x :=
    Ref.map (fun α => Some α.(x)) (fun β α => Some (α <| x := β |>)).
  Definition Get_y :=
    Ref.map (fun α => Some α.(y)) (fun β α => Some (α <| y := β |>)).
End Point.
End Point.

Module  Rectangle.
Section Rectangle.
  Record t : Set := {
    top_left : structures.Point.t;
    bottom_right : structures.Point.t;
  }.
  
  Definition Get_top_left :=
    Ref.map
      (fun α => Some α.(top_left))
      (fun β α => Some (α <| top_left := β |>)).
  Definition Get_bottom_right :=
    Ref.map
      (fun α => Some α.(bottom_right))
      (fun β α => Some (α <| bottom_right := β |>)).
End Rectangle.
End Rectangle.

(*
fn main() {
    // Create struct with field init shorthand
    let name = String::from("Peter");
    let age = 27;
    let peter = Person { name, age };

    // Print debug struct
    println!("{:?}", peter);

    // Instantiate a `Point`
    let point: Point = Point { x: 10.3, y: 0.4 };

    // Access the fields of the point
    println!("point coordinates: ({}, {})", point.x, point.y);

    // Make a new point by using struct update syntax to use the fields of our
    // other one
    let bottom_right = Point { x: 5.2, ..point };

    // `bottom_right.y` will be the same as `point.y` because we used that field
    // from `point`
    println!("second point: ({}, {})", bottom_right.x, bottom_right.y);

    // Destructure the point using a `let` binding
    let Point {
        x: left_edge,
        y: top_edge,
    } = point;

    let _rectangle = Rectangle {
        // struct instantiation is an expression too
        top_left: Point {
            x: left_edge,
            y: top_edge,
        },
        bottom_right: bottom_right,
    };

    // Instantiate a unit struct
    let _unit = Unit;

    // Instantiate a tuple struct
    let pair = Pair(1, 0.1);

    // Access the fields of a tuple struct
    println!("pair contains {:?} and {:?}", pair.0, pair.1);

    // Destructure a tuple struct
    let Pair(integer, decimal) = pair;

    println!("pair contains {:?} and {:?}", integer, decimal);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic (
    M.read (|
      let name : M.Val alloc.string.String.t :=
        M.alloc (|
          M.call (|(ltac:(M.get_method (fun ℐ =>
              core.convert.From.from
                (Self := alloc.string.String.t)
                (T := ref str.t)
                (Trait := ℐ)))
            (M.read (| mk_str "Peter" |)))
          |)
        |) in
      let age : M.Val u8.t := M.alloc (| (Integer.of_Z 27) : u8.t |) in
      let peter : M.Val structures.Person.t :=
        M.alloc (|
          {|
            structures.Person.name := M.read (| name |);
            structures.Person.age := M.read (| age |);
          |}
        |) in
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [ M.read (| mk_str "" |); M.read (| mk_str "
" |) ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                          (borrow peter))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      let point : M.Val structures.Point.t :=
        M.alloc (|
          {|
            structures.Point.x := M.read (| UnsupportedLiteral : M.Val f32.t |);
            structures.Point.y := M.read (| UnsupportedLiteral : M.Val f32.t |);
          |}
        |) in
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.read (| mk_str "point coordinates: (" |);
                        M.read (| mk_str ", " |);
                        M.read (| mk_str ")
" |)
                      ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow (structures.Point.Get_x point)))
                        |);
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow (structures.Point.Get_y point)))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      let bottom_right : M.Val structures.Point.t :=
        M.alloc (|
          (M.read (| point |))
            <| structures.Point.x :=
              M.read (| UnsupportedLiteral : M.Val f32.t |)
            |>
        |) in
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.read (| mk_str "second point: (" |);
                        M.read (| mk_str ", " |);
                        M.read (| mk_str ")
" |)
                      ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow (structures.Point.Get_x bottom_right)))
                        |);
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow (structures.Point.Get_y bottom_right)))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      ltac:
        (M.monadic_match_operator
          point
          [
            fun (γ : M.Val structures.Point.t) =>
              match M.read (| γ |) with
              | {| structures.Point.x := _; structures.Point.y := _; |} =>
                let γ0_0 := structures.Point.Get_x γ in
                let γ0_1 := structures.Point.Get_y γ in
                let left_edge := M.copy (| γ0_0 |) in
                let top_edge := M.copy (| γ0_1 |) in
                let _rectangle : M.Val structures.Rectangle.t :=
                  M.alloc (|
                    {|
                      structures.Rectangle.top_left :=
                        {|
                          structures.Point.x := M.read (| left_edge |);
                          structures.Point.y := M.read (| top_edge |);
                        |};
                      structures.Rectangle.bottom_right :=
                        M.read (| bottom_right |);
                    |}
                  |) in
                let _unit : M.Val structures.Unit.t :=
                  M.alloc (| structures.Unit.Build |) in
                let pair : M.Val structures.Pair.t :=
                  M.alloc (|
                    structures.Pair.Build_t
                      ((Integer.of_Z 1) : i32.t)
                      (M.read (| UnsupportedLiteral : M.Val f32.t |))
                  |) in
                let _ : M.Val unit :=
                  let _ : M.Val unit :=
                    M.alloc (|
                      M.call (|(std.io.stdio._print
                        (M.call (|(core.fmt.Arguments.t::["new_v1"]
                          (pointer_coercion
                            "Unsize"
                            (borrow
                              (M.alloc (|
                                [
                                  M.read (| mk_str "pair contains " |);
                                  M.read (| mk_str " and " |);
                                  M.read (| mk_str "
" |)
                                ]
                              |))))
                          (pointer_coercion
                            "Unsize"
                            (borrow
                              (M.alloc (|
                                [
                                  M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                                    (borrow (structures.Pair.Get_0 pair)))
                                  |);
                                  M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                                    (borrow (structures.Pair.Get_1 pair)))
                                  |)
                                ]
                              |)))))
                        |)))
                      |)
                    |) in
                  M.alloc (| tt |) in
                ltac:
                  (M.monadic_match_operator
                    pair
                    [
                      fun (γ : M.Val structures.Pair.t) =>
                        match M.read (| γ |) with
                        | structures.Pair.Build_t _ _ =>
                          let γ0_0 := structures.Pair.Get_0 γ in
                          let γ0_1 := structures.Pair.Get_1 γ in
                          let integer := M.copy (| γ0_0 |) in
                          let decimal := M.copy (| γ0_1 |) in
                          let _ : M.Val unit :=
                            let _ : M.Val unit :=
                              M.alloc (|
                                M.call (|(std.io.stdio._print
                                  (M.call (|(core.fmt.Arguments.t::["new_v1"]
                                    (pointer_coercion
                                      "Unsize"
                                      (borrow
                                        (M.alloc (|
                                          [
                                            M.read (| mk_str "pair contains "
                                            |);
                                            M.read (| mk_str " and " |);
                                            M.read (| mk_str "
" |)
                                          ]
                                        |))))
                                    (pointer_coercion
                                      "Unsize"
                                      (borrow
                                        (M.alloc (|
                                          [
                                            M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                                              (borrow integer))
                                            |);
                                            M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                                              (borrow decimal))
                                            |)
                                          ]
                                        |)))))
                                  |)))
                                |)
                              |) in
                            M.alloc (| tt |) in
                          M.alloc (| tt |)
                        end :
                        M.Val unit
                    ])
              end :
              M.Val unit
          ])
    |)
  )).
