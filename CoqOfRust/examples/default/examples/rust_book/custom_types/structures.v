(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Enum Person *)

Module Impl_core_fmt_Debug_for_structures_Person.
  Definition Self : Ty.t := Ty.path "structures::Person".
  
  (*
  Debug
  *)
  Definition fmt (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Î±0 := M.read f in
      let* Î±1 := M.read (mk_str "Person") in
      let* Î±2 := M.read (mk_str "name") in
      let* Î±3 := M.read self in
      let* Î±4 := M.read (mk_str "age") in
      let* Î±5 := M.read self in
      let* Î±6 :=
        M.alloc (borrow ((M.var "structures::Person::Get_age") (deref Î±5))) in
      M.call
        (Ty.path "core::fmt::Formatter")::["debug_struct_field2_finish"]
        [
          Î±0;
          Î±1;
          Î±2;
          pointer_coercion
            "Unsize"
            (borrow ((M.var "structures::Person::Get_name") (deref Î±3)));
          Î±4;
          pointer_coercion "Unsize" (borrow Î±6)
        ]
    | _, _ => M.impossible
    end.
  
  Definition â„ : Instance.t := [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_structures_Person.

(* Struct Unit *)

(* Struct Pair *)

(* Enum Point *)

(* Enum Rectangle *)

(*
fn main() {
    // Create struct with field init shorthand
    let name = String::from("Peter");
    let age = 27;
    let peter = Person { name, age };

    // Print debug struct
    println!("{:?}", peter);

    // Instantiate a `Point`
    let point: Point = Point { x: 10.3, y: 0.4 };

    // Access the fields of the point
    println!("point coordinates: ({}, {})", point.x, point.y);

    // Make a new point by using struct update syntax to use the fields of our
    // other one
    let bottom_right = Point { x: 5.2, ..point };

    // `bottom_right.y` will be the same as `point.y` because we used that field
    // from `point`
    println!("second point: ({}, {})", bottom_right.x, bottom_right.y);

    // Destructure the point using a `let` binding
    let Point {
        x: left_edge,
        y: top_edge,
    } = point;

    let _rectangle = Rectangle {
        // struct instantiation is an expression too
        top_left: Point {
            x: left_edge,
            y: top_edge,
        },
        bottom_right: bottom_right,
    };

    // Instantiate a unit struct
    let _unit = Unit;

    // Instantiate a tuple struct
    let pair = Pair(1, 0.1);

    // Access the fields of a tuple struct
    println!("pair contains {:?} and {:?}", pair.0, pair.1);

    // Destructure a tuple struct
    let Pair(integer, decimal) = pair;

    println!("pair contains {:?} and {:?}", integer, decimal);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [], [] =>
    let* name :=
      let* Î±0 :=
        M.get_method
          "core::convert::From"
          "from"
          [
            (* Self *) Ty.path "alloc::string::String";
            (* T *) Ty.apply (Ty.path "ref") [ Ty.path "str" ]
          ] in
      let* Î±1 := M.read (mk_str "Peter") in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      M.alloc Î±2 in
    let* age := M.alloc ((Integer.of_Z 27) : Ty.path "u8") in
    let* peter :=
      let* Î±0 := M.read name in
      let* Î±1 := M.read age in
      M.alloc
        (Value.StructRecord
          "structures::Person"
          [ ("name", Î±0); ("age", Î±1) ]) in
    let* _ :=
      let* _ :=
        let* Î±0 := M.read (mk_str "") in
        let* Î±1 := M.read (mk_str "
") in
        let* Î±2 := M.alloc [ Î±0; Î±1 ] in
        let* Î±3 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_debug"]
            [ borrow peter ] in
        let* Î±4 := M.alloc [ Î±3 ] in
        let* Î±5 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±2);
              pointer_coercion "Unsize" (borrow Î±4)
            ] in
        let* Î±6 := M.call (M.var "std::io::stdio::_print") [ Î±5 ] in
        M.alloc Î±6 in
      M.alloc tt in
    let* point :=
      let* Î±0 := M.read (UnsupportedLiteral : Ty.path "f32") in
      let* Î±1 := M.read (UnsupportedLiteral : Ty.path "f32") in
      M.alloc
        (Value.StructRecord "structures::Point" [ ("x", Î±0); ("y", Î±1) ]) in
    let* _ :=
      let* _ :=
        let* Î±0 := M.read (mk_str "point coordinates: (") in
        let* Î±1 := M.read (mk_str ", ") in
        let* Î±2 := M.read (mk_str ")
") in
        let* Î±3 := M.alloc [ Î±0; Î±1; Î±2 ] in
        let* Î±4 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow ((M.var "structures::Point::Get_x") point) ] in
        let* Î±5 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow ((M.var "structures::Point::Get_y") point) ] in
        let* Î±6 := M.alloc [ Î±4; Î±5 ] in
        let* Î±7 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±3);
              pointer_coercion "Unsize" (borrow Î±6)
            ] in
        let* Î±8 := M.call (M.var "std::io::stdio::_print") [ Î±7 ] in
        M.alloc Î±8 in
      M.alloc tt in
    let* bottom_right :=
      let* Î±0 := M.read (UnsupportedLiteral : Ty.path "f32") in
      let* Î±1 := M.read point in
      M.alloc (Î±1 <| structures.Point.x := Î±0 |>) in
    let* _ :=
      let* _ :=
        let* Î±0 := M.read (mk_str "second point: (") in
        let* Î±1 := M.read (mk_str ", ") in
        let* Î±2 := M.read (mk_str ")
") in
        let* Î±3 := M.alloc [ Î±0; Î±1; Î±2 ] in
        let* Î±4 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow ((M.var "structures::Point::Get_x") bottom_right) ] in
        let* Î±5 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow ((M.var "structures::Point::Get_y") bottom_right) ] in
        let* Î±6 := M.alloc [ Î±4; Î±5 ] in
        let* Î±7 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±3);
              pointer_coercion "Unsize" (borrow Î±6)
            ] in
        let* Î±8 := M.call (M.var "std::io::stdio::_print") [ Î±7 ] in
        M.alloc Î±8 in
      M.alloc tt in
    let* Î±0 :=
      match_operator
        point
        [
          fun Î³ =>
            (let* Î±0 := M.read Î³ in
            match Î±0 with
            | {| structures.Point.x := _; structures.Point.y := _; |} =>
              let Î³0_0 := (M.var "structures::Point::Get_x") Î³ in
              let Î³0_1 := (M.var "structures::Point::Get_y") Î³ in
              let* left_edge := M.copy Î³0_0 in
              let* top_edge := M.copy Î³0_1 in
              let* _rectangle :=
                let* Î±0 := M.read left_edge in
                let* Î±1 := M.read top_edge in
                let* Î±2 := M.read bottom_right in
                M.alloc
                  (Value.StructRecord
                    "structures::Rectangle"
                    [
                      ("top_left",
                        Value.StructRecord
                          "structures::Point"
                          [ ("x", Î±0); ("y", Î±1) ]);
                      ("bottom_right", Î±2)
                    ]) in
              let* _unit := M.alloc structures.Unit.Build in
              let* pair :=
                let* Î±0 := M.read (UnsupportedLiteral : Ty.path "f32") in
                M.alloc
                  (structures.Pair.Build_t
                    ((Integer.of_Z 1) : Ty.path "i32")
                    Î±0) in
              let* _ :=
                let* _ :=
                  let* Î±0 := M.read (mk_str "pair contains ") in
                  let* Î±1 := M.read (mk_str " and ") in
                  let* Î±2 := M.read (mk_str "
") in
                  let* Î±3 := M.alloc [ Î±0; Î±1; Î±2 ] in
                  let* Î±4 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ borrow ((M.var "structures::Pair::Get_0") pair) ] in
                  let* Î±5 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ borrow ((M.var "structures::Pair::Get_1") pair) ] in
                  let* Î±6 := M.alloc [ Î±4; Î±5 ] in
                  let* Î±7 :=
                    M.call
                      (Ty.path "core::fmt::Arguments")::["new_v1"]
                      [
                        pointer_coercion "Unsize" (borrow Î±3);
                        pointer_coercion "Unsize" (borrow Î±6)
                      ] in
                  let* Î±8 := M.call (M.var "std::io::stdio::_print") [ Î±7 ] in
                  M.alloc Î±8 in
                M.alloc tt in
              match_operator
                pair
                [
                  fun Î³ =>
                    (let* Î±0 := M.read Î³ in
                    match Î±0 with
                    | structures.Pair.Build_t _ _ =>
                      let Î³0_0 := (M.var "structures::Pair::Get_0") Î³ in
                      let Î³0_1 := (M.var "structures::Pair::Get_1") Î³ in
                      let* integer := M.copy Î³0_0 in
                      let* decimal := M.copy Î³0_1 in
                      let* _ :=
                        let* _ :=
                          let* Î±0 := M.read (mk_str "pair contains ") in
                          let* Î±1 := M.read (mk_str " and ") in
                          let* Î±2 := M.read (mk_str "
") in
                          let* Î±3 := M.alloc [ Î±0; Î±1; Î±2 ] in
                          let* Î±4 :=
                            M.call
                              (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                              [ borrow integer ] in
                          let* Î±5 :=
                            M.call
                              (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                              [ borrow decimal ] in
                          let* Î±6 := M.alloc [ Î±4; Î±5 ] in
                          let* Î±7 :=
                            M.call
                              (Ty.path "core::fmt::Arguments")::["new_v1"]
                              [
                                pointer_coercion "Unsize" (borrow Î±3);
                                pointer_coercion "Unsize" (borrow Î±6)
                              ] in
                          let* Î±8 :=
                            M.call (M.var "std::io::stdio::_print") [ Î±7 ] in
                          M.alloc Î±8 in
                        M.alloc tt in
                      M.alloc tt
                    end) :
                    Ty.path "unit"
                ]
            end) :
            Ty.path "unit"
        ] in
    M.read Î±0
  | _, _ => M.impossible
  end.
