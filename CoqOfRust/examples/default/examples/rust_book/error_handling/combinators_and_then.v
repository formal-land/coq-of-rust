(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
Enum Food
{
  const_params := [];
  ty_params := [];
  variants :=
    [
      {
        name := "CordonBleu";
        item := StructTuple [];
      };
      {
        name := "Steak";
        item := StructTuple [];
      };
      {
        name := "Sushi";
        item := StructTuple [];
      }
    ];
}
*)

Axiom IsDiscriminant_Food_CordonBleu : M.IsDiscriminant "combinators_and_then::Food::CordonBleu" 0.
Axiom IsDiscriminant_Food_Steak : M.IsDiscriminant "combinators_and_then::Food::Steak" 1.
Axiom IsDiscriminant_Food_Sushi : M.IsDiscriminant "combinators_and_then::Food::Sushi" 2.

Module Impl_core_fmt_Debug_for_combinators_and_then_Food.
  Definition Self : Ty.t := Ty.path "combinators_and_then::Food".
  
  (* Debug *)
  Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "combinators_and_then::Food" ], self |) in
        let f := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
        M.call_closure (|
          Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.path "core::fmt::Error" ],
          M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
          [
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
            M.match_operator (|
              Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let _ := M.is_struct_tuple (| γ, "combinators_and_then::Food::CordonBleu" |) in
                    M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CordonBleu" |) |) |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let _ := M.is_struct_tuple (| γ, "combinators_and_then::Food::Steak" |) in
                    M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Steak" |) |) |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let _ := M.is_struct_tuple (| γ, "combinators_and_then::Food::Sushi" |) in
                    M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Sushi" |) |) |)))
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_combinators_and_then_Food.

(*
Enum Day
{
  const_params := [];
  ty_params := [];
  variants :=
    [
      {
        name := "Monday";
        item := StructTuple [];
      };
      {
        name := "Tuesday";
        item := StructTuple [];
      };
      {
        name := "Wednesday";
        item := StructTuple [];
      }
    ];
}
*)

Axiom IsDiscriminant_Day_Monday : M.IsDiscriminant "combinators_and_then::Day::Monday" 0.
Axiom IsDiscriminant_Day_Tuesday : M.IsDiscriminant "combinators_and_then::Day::Tuesday" 1.
Axiom IsDiscriminant_Day_Wednesday : M.IsDiscriminant "combinators_and_then::Day::Wednesday" 2.

Module Impl_core_fmt_Debug_for_combinators_and_then_Day.
  Definition Self : Ty.t := Ty.path "combinators_and_then::Day".
  
  (* Debug *)
  Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; f ] =>
      ltac:(M.monadic
        (let self :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "combinators_and_then::Day" ], self |) in
        let f := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
        M.call_closure (|
          Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.path "core::fmt::Error" ],
          M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
          [
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
            M.match_operator (|
              Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let _ := M.is_struct_tuple (| γ, "combinators_and_then::Day::Monday" |) in
                    M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Monday" |) |) |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let _ := M.is_struct_tuple (| γ, "combinators_and_then::Day::Tuesday" |) in
                    M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Tuesday" |) |) |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let _ := M.is_struct_tuple (| γ, "combinators_and_then::Day::Wednesday" |) in
                    M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Wednesday" |) |) |)))
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_combinators_and_then_Day.

(*
fn have_ingredients(food: Food) -> Option<Food> {
    match food {
        Food::Sushi => None,
        _ => Some(food),
    }
}
*)
Definition have_ingredients (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ food ] =>
    ltac:(M.monadic
      (let food := M.alloc (| Ty.path "combinators_and_then::Food", food |) in
      M.match_operator (|
        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "combinators_and_then::Food" ],
        food,
        [
          fun γ =>
            ltac:(M.monadic
              (let _ := M.is_struct_tuple (| γ, "combinators_and_then::Food::Sushi" |) in
              Value.StructTuple
                "core::option::Option::None"
                []
                [ Ty.path "combinators_and_then::Food" ]
                []));
          fun γ =>
            ltac:(M.monadic
              (Value.StructTuple
                "core::option::Option::Some"
                []
                [ Ty.path "combinators_and_then::Food" ]
                [ M.read (| food |) ]))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_have_ingredients :
  M.IsFunction.C "combinators_and_then::have_ingredients" have_ingredients.
Admitted.
Global Typeclasses Opaque have_ingredients.

(*
fn have_recipe(food: Food) -> Option<Food> {
    match food {
        Food::CordonBleu => None,
        _ => Some(food),
    }
}
*)
Definition have_recipe (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ food ] =>
    ltac:(M.monadic
      (let food := M.alloc (| Ty.path "combinators_and_then::Food", food |) in
      M.match_operator (|
        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "combinators_and_then::Food" ],
        food,
        [
          fun γ =>
            ltac:(M.monadic
              (let _ := M.is_struct_tuple (| γ, "combinators_and_then::Food::CordonBleu" |) in
              Value.StructTuple
                "core::option::Option::None"
                []
                [ Ty.path "combinators_and_then::Food" ]
                []));
          fun γ =>
            ltac:(M.monadic
              (Value.StructTuple
                "core::option::Option::Some"
                []
                [ Ty.path "combinators_and_then::Food" ]
                [ M.read (| food |) ]))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_have_recipe :
  M.IsFunction.C "combinators_and_then::have_recipe" have_recipe.
Admitted.
Global Typeclasses Opaque have_recipe.

(*
fn cookable_v1(food: Food) -> Option<Food> {
    match have_recipe(food) {
        None => None,
        Some(food) => match have_ingredients(food) {
            None => None,
            Some(food) => Some(food),
        },
    }
}
*)
Definition cookable_v1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ food ] =>
    ltac:(M.monadic
      (let food := M.alloc (| Ty.path "combinators_and_then::Food", food |) in
      M.match_operator (|
        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "combinators_and_then::Food" ],
        M.alloc (|
          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "combinators_and_then::Food" ],
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "combinators_and_then::Food" ],
            M.get_function (| "combinators_and_then::have_recipe", [], [] |),
            [ M.read (| food |) ]
          |)
        |),
        [
          fun γ =>
            ltac:(M.monadic
              (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
              Value.StructTuple
                "core::option::Option::None"
                []
                [ Ty.path "combinators_and_then::Food" ]
                []));
          fun γ =>
            ltac:(M.monadic
              (let γ0_0 :=
                M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
              let food := M.copy (| Ty.path "combinators_and_then::Food", γ0_0 |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "combinators_and_then::Food" ],
                M.alloc (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "combinators_and_then::Food" ],
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.path "combinators_and_then::Food" ],
                    M.get_function (| "combinators_and_then::have_ingredients", [], [] |),
                    [ M.read (| food |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      Value.StructTuple
                        "core::option::Option::None"
                        []
                        [ Ty.path "combinators_and_then::Food" ]
                        []));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let food := M.copy (| Ty.path "combinators_and_then::Food", γ0_0 |) in
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [ Ty.path "combinators_and_then::Food" ]
                        [ M.read (| food |) ]))
                ]
              |)))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_cookable_v1 :
  M.IsFunction.C "combinators_and_then::cookable_v1" cookable_v1.
Admitted.
Global Typeclasses Opaque cookable_v1.

(*
fn cookable_v2(food: Food) -> Option<Food> {
    have_recipe(food).and_then(have_ingredients)
}
*)
Definition cookable_v2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ food ] =>
    ltac:(M.monadic
      (let food := M.alloc (| Ty.path "combinators_and_then::Food", food |) in
      M.call_closure (|
        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "combinators_and_then::Food" ],
        M.get_associated_function (|
          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "combinators_and_then::Food" ],
          "and_then",
          [],
          [
            Ty.path "combinators_and_then::Food";
            Ty.function
              [ Ty.path "combinators_and_then::Food" ]
              (Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "combinators_and_then::Food" ])
          ]
        |),
        [
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "combinators_and_then::Food" ],
            M.get_function (| "combinators_and_then::have_recipe", [], [] |),
            [ M.read (| food |) ]
          |);
          M.get_function (| "combinators_and_then::have_ingredients", [], [] |)
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_cookable_v2 :
  M.IsFunction.C "combinators_and_then::cookable_v2" cookable_v2.
Admitted.
Global Typeclasses Opaque cookable_v2.

(*
fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) => println!("Yay! On {:?} we get to eat {:?}.", day, food),
        None => println!("Oh no. We don't get to eat on {:?}?", day),
    }
}
*)
Definition eat (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ food; day ] =>
    ltac:(M.monadic
      (let food := M.alloc (| Ty.path "combinators_and_then::Food", food |) in
      let day := M.alloc (| Ty.path "combinators_and_then::Day", day |) in
      M.match_operator (|
        Ty.tuple [],
        M.alloc (|
          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "combinators_and_then::Food" ],
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "combinators_and_then::Food" ],
            M.get_function (| "combinators_and_then::cookable_v2", [], [] |),
            [ M.read (| food |) ]
          |)
        |),
        [
          fun γ =>
            ltac:(M.monadic
              (let γ0_0 :=
                M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
              let food := M.copy (| Ty.path "combinators_and_then::Food", γ0_0 |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "std::io::stdio::_print", [], [] |),
                    [
                      M.call_closure (|
                        Ty.path "core::fmt::Arguments",
                        M.get_associated_function (|
                          Ty.path "core::fmt::Arguments",
                          "new_v1",
                          [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 2 ],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 3 ]
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                  Value.Array
                                    [
                                      mk_str (| "Yay! On " |);
                                      mk_str (| " we get to eat " |);
                                      mk_str (| ".
" |)
                                    ]
                                |)
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 2 ]
                                    [ Ty.path "core::fmt::rt::Argument" ],
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        Ty.path "core::fmt::rt::Argument",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_debug",
                                          [],
                                          [ Ty.path "combinators_and_then::Day" ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.borrow (| Pointer.Kind.Ref, day |) |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "core::fmt::rt::Argument",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_debug",
                                          [],
                                          [ Ty.path "combinators_and_then::Food" ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.borrow (| Pointer.Kind.Ref, food |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                  |) in
                M.alloc (| Ty.tuple [], Value.Tuple [] |)
              |)));
          fun γ =>
            ltac:(M.monadic
              (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "std::io::stdio::_print", [], [] |),
                    [
                      M.call_closure (|
                        Ty.path "core::fmt::Arguments",
                        M.get_associated_function (|
                          Ty.path "core::fmt::Arguments",
                          "new_v1",
                          [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 2 ]
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                  Value.Array
                                    [
                                      mk_str (| "Oh no. We don't get to eat on " |);
                                      mk_str (| "?
" |)
                                    ]
                                |)
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 1 ]
                                    [ Ty.path "core::fmt::rt::Argument" ],
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        Ty.path "core::fmt::rt::Argument",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_debug",
                                          [],
                                          [ Ty.path "combinators_and_then::Day" ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.borrow (| Pointer.Kind.Ref, day |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                  |) in
                M.alloc (| Ty.tuple [], Value.Tuple [] |)
              |)))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_eat : M.IsFunction.C "combinators_and_then::eat" eat.
Admitted.
Global Typeclasses Opaque eat.

(*
fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
*)
Definition main (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [] =>
    ltac:(M.monadic
      (M.match_operator (|
        Ty.tuple [],
        M.alloc (|
          Ty.tuple
            [
              Ty.path "combinators_and_then::Food";
              Ty.path "combinators_and_then::Food";
              Ty.path "combinators_and_then::Food"
            ],
          Value.Tuple
            [
              Value.StructTuple "combinators_and_then::Food::CordonBleu" [] [] [];
              Value.StructTuple "combinators_and_then::Food::Steak" [] [] [];
              Value.StructTuple "combinators_and_then::Food::Sushi" [] [] []
            ]
        |),
        [
          fun γ =>
            ltac:(M.monadic
              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
              let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
              let cordon_bleu := M.copy (| Ty.path "combinators_and_then::Food", γ0_0 |) in
              let steak := M.copy (| Ty.path "combinators_and_then::Food", γ0_1 |) in
              let sushi := M.copy (| Ty.path "combinators_and_then::Food", γ0_2 |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "combinators_and_then::eat", [], [] |),
                    [
                      M.read (| cordon_bleu |);
                      Value.StructTuple "combinators_and_then::Day::Monday" [] [] []
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "combinators_and_then::eat", [], [] |),
                    [
                      M.read (| steak |);
                      Value.StructTuple "combinators_and_then::Day::Tuesday" [] [] []
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "combinators_and_then::eat", [], [] |),
                    [
                      M.read (| sushi |);
                      Value.StructTuple "combinators_and_then::Day::Wednesday" [] [] []
                    ]
                  |) in
                M.alloc (| Ty.tuple [], Value.Tuple [] |)
              |)))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_main : M.IsFunction.C "combinators_and_then::main" main.
Admitted.
Global Typeclasses Opaque main.
