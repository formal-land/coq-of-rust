(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module Food.
  Inductive t : Set :=
  | Apple
  | Carrot
  | Potato.
End Food.

Module  Impl_core_fmt_Debug_for_combinators_map_Food_t.
Section Impl_core_fmt_Debug_for_combinators_map_Food_t.
  Definition Self : Set := combinators_map.Food.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let f := M.alloc (| f |) in
      M.call (|(core.fmt.Formatter.t::["write_str"]
        (M.read (| f |))
        (M.read (|
          ltac:
            (M.monadic_match_operator
              self
              [
                fun (γ : M.Val (ref combinators_map.Food.t)) =>
                  (let γ := deref (M.read (| γ |)) in
                  match M.read (| γ |) with
                  | combinators_map.Food.Apple =>
                    M.alloc (| M.read (| mk_str "Apple" |) |)
                  | _ => M.break_match(||)
                  end) :
                  M.Val (ref str.t);
                fun (γ : M.Val (ref combinators_map.Food.t)) =>
                  (let γ := deref (M.read (| γ |)) in
                  match M.read (| γ |) with
                  | combinators_map.Food.Carrot =>
                    M.alloc (| M.read (| mk_str "Carrot" |) |)
                  | _ => M.break_match(||)
                  end) :
                  M.Val (ref str.t);
                fun (γ : M.Val (ref combinators_map.Food.t)) =>
                  (let γ := deref (M.read (| γ |)) in
                  match M.read (| γ |) with
                  | combinators_map.Food.Potato =>
                    M.alloc (| M.read (| mk_str "Potato" |) |)
                  | _ => M.break_match(||)
                  end) :
                  M.Val (ref str.t)
              ])
        |)))
      |)
    )).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_combinators_map_Food_t.
End Impl_core_fmt_Debug_for_combinators_map_Food_t.

Module  Peeled.
Section Peeled.
  Record t : Set := {
    x0 : combinators_map.Food.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Peeled.
End Peeled.

Module  Impl_core_fmt_Debug_for_combinators_map_Peeled_t.
Section Impl_core_fmt_Debug_for_combinators_map_Peeled_t.
  Definition Self : Set := combinators_map.Peeled.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let f := M.alloc (| f |) in
      M.call (|(core.fmt.Formatter.t::["debug_tuple_field1_finish"]
        (M.read (| f |))
        (M.read (| mk_str "Peeled" |))
        (pointer_coercion
          "Unsize"
          (borrow
            (M.alloc (|
              borrow (combinators_map.Peeled.Get_0 (deref (M.read (| self |))))
            |)))))
      |)
    )).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_combinators_map_Peeled_t.
End Impl_core_fmt_Debug_for_combinators_map_Peeled_t.

Module  Chopped.
Section Chopped.
  Record t : Set := {
    x0 : combinators_map.Food.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Chopped.
End Chopped.

Module  Impl_core_fmt_Debug_for_combinators_map_Chopped_t.
Section Impl_core_fmt_Debug_for_combinators_map_Chopped_t.
  Definition Self : Set := combinators_map.Chopped.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let f := M.alloc (| f |) in
      M.call (|(core.fmt.Formatter.t::["debug_tuple_field1_finish"]
        (M.read (| f |))
        (M.read (| mk_str "Chopped" |))
        (pointer_coercion
          "Unsize"
          (borrow
            (M.alloc (|
              borrow (combinators_map.Chopped.Get_0 (deref (M.read (| self |))))
            |)))))
      |)
    )).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_combinators_map_Chopped_t.
End Impl_core_fmt_Debug_for_combinators_map_Chopped_t.

Module  Cooked.
Section Cooked.
  Record t : Set := {
    x0 : combinators_map.Food.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Cooked.
End Cooked.

Module  Impl_core_fmt_Debug_for_combinators_map_Cooked_t.
Section Impl_core_fmt_Debug_for_combinators_map_Cooked_t.
  Definition Self : Set := combinators_map.Cooked.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let f := M.alloc (| f |) in
      M.call (|(core.fmt.Formatter.t::["debug_tuple_field1_finish"]
        (M.read (| f |))
        (M.read (| mk_str "Cooked" |))
        (pointer_coercion
          "Unsize"
          (borrow
            (M.alloc (|
              borrow (combinators_map.Cooked.Get_0 (deref (M.read (| self |))))
            |)))))
      |)
    )).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_combinators_map_Cooked_t.
End Impl_core_fmt_Debug_for_combinators_map_Cooked_t.

(*
fn peel(food: Option<Food>) -> Option<Peeled> {
    match food {
        Some(food) => Some(Peeled(food)),
        None => None,
    }
}
*)
Definition peel
    (food : core.option.Option.t combinators_map.Food.t)
    : M (core.option.Option.t combinators_map.Peeled.t) :=
  ltac:(M.monadic (
    let food := M.alloc (| food |) in
    M.read (|
      ltac:
        (M.monadic_match_operator
          food
          [
            fun (γ : M.Val (core.option.Option.t combinators_map.Food.t)) =>
              match M.read (| γ |) with
              | core.option.Option.Some _ =>
                let γ0_0 := core.option.Option.Get_Some_0 γ in
                let food := M.copy (| γ0_0 |) in
                M.alloc (|
                  core.option.Option.Some
                    (combinators_map.Peeled.Build_t (M.read (| food |)))
                |)
              | _ => M.break_match(||)
              end :
              M.Val (core.option.Option.t combinators_map.Peeled.t);
            fun (γ : M.Val (core.option.Option.t combinators_map.Food.t)) =>
              match M.read (| γ |) with
              | core.option.Option.None => M.alloc (| core.option.Option.None |)
              | _ => M.break_match(||)
              end :
              M.Val (core.option.Option.t combinators_map.Peeled.t)
          ])
    |)
  )).

(*
fn chop(peeled: Option<Peeled>) -> Option<Chopped> {
    match peeled {
        Some(Peeled(food)) => Some(Chopped(food)),
        None => None,
    }
}
*)
Definition chop
    (peeled : core.option.Option.t combinators_map.Peeled.t)
    : M (core.option.Option.t combinators_map.Chopped.t) :=
  ltac:(M.monadic (
    let peeled := M.alloc (| peeled |) in
    M.read (|
      ltac:
        (M.monadic_match_operator
          peeled
          [
            fun (γ : M.Val (core.option.Option.t combinators_map.Peeled.t)) =>
              match M.read (| γ |) with
              | core.option.Option.Some _ =>
                let γ0_0 := core.option.Option.Get_Some_0 γ in
                match M.read (| γ0_0 |) with
                | combinators_map.Peeled.Build_t _ =>
                  let γ1_0 := combinators_map.Peeled.Get_0 γ0_0 in
                  let food := M.copy (| γ1_0 |) in
                  M.alloc (|
                    core.option.Option.Some
                      (combinators_map.Chopped.Build_t (M.read (| food |)))
                  |)
                end
              | _ => M.break_match(||)
              end :
              M.Val (core.option.Option.t combinators_map.Chopped.t);
            fun (γ : M.Val (core.option.Option.t combinators_map.Peeled.t)) =>
              match M.read (| γ |) with
              | core.option.Option.None => M.alloc (| core.option.Option.None |)
              | _ => M.break_match(||)
              end :
              M.Val (core.option.Option.t combinators_map.Chopped.t)
          ])
    |)
  )).

(*
fn cook(chopped: Option<Chopped>) -> Option<Cooked> {
    chopped.map(|Chopped(food)| Cooked(food))
}
*)
Definition cook
    (chopped : core.option.Option.t combinators_map.Chopped.t)
    : M (core.option.Option.t combinators_map.Cooked.t) :=
  ltac:(M.monadic (
    let chopped := M.alloc (| chopped |) in
    M.call (|((core.option.Option.t combinators_map.Chopped.t)::["map"]
      (M.read (| chopped |))
      (fun (α0 : combinators_map.Chopped.t) =>
        (ltac:
          (M.monadic_match_operator
            (M.alloc (| α0 |))
            [
              fun γ =>
                match M.read (| γ |) with
                | combinators_map.Chopped.Build_t _ =>
                  let γ0_0 := combinators_map.Chopped.Get_0 γ in
                  let food := M.copy (| γ0_0 |) in
                  combinators_map.Cooked.Build_t (M.read (| food |))
                end :
                combinators_map.Cooked.t
            ])) :
        combinators_map.Cooked.t))
    |)
  )).

(*
fn process(food: Option<Food>) -> Option<Cooked> {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}
*)
Definition process
    (food : core.option.Option.t combinators_map.Food.t)
    : M (core.option.Option.t combinators_map.Cooked.t) :=
  ltac:(M.monadic (
    let food := M.alloc (| food |) in
    M.call (|((core.option.Option.t combinators_map.Chopped.t)::["map"]
      (M.call (|((core.option.Option.t combinators_map.Peeled.t)::["map"]
        (M.call (|((core.option.Option.t combinators_map.Food.t)::["map"]
          (M.read (| food |))
          (fun (α0 : combinators_map.Food.t) =>
            (ltac:
              (M.monadic_match_operator
                (M.alloc (| α0 |))
                [
                  fun γ =>
                    (let f := M.copy (| γ |) in
                    combinators_map.Peeled.Build_t (M.read (| f |))) :
                    combinators_map.Peeled.t
                ])) :
            combinators_map.Peeled.t))
        |))
        (fun (α0 : combinators_map.Peeled.t) =>
          (ltac:
            (M.monadic_match_operator
              (M.alloc (| α0 |))
              [
                fun γ =>
                  match M.read (| γ |) with
                  | combinators_map.Peeled.Build_t _ =>
                    let γ0_0 := combinators_map.Peeled.Get_0 γ in
                    let f := M.copy (| γ0_0 |) in
                    combinators_map.Chopped.Build_t (M.read (| f |))
                  end :
                  combinators_map.Chopped.t
              ])) :
          combinators_map.Chopped.t))
      |))
      (fun (α0 : combinators_map.Chopped.t) =>
        (ltac:
          (M.monadic_match_operator
            (M.alloc (| α0 |))
            [
              fun γ =>
                match M.read (| γ |) with
                | combinators_map.Chopped.Build_t _ =>
                  let γ0_0 := combinators_map.Chopped.Get_0 γ in
                  let f := M.copy (| γ0_0 |) in
                  combinators_map.Cooked.Build_t (M.read (| f |))
                end :
                combinators_map.Cooked.t
            ])) :
        combinators_map.Cooked.t))
    |)
  )).

(*
fn eat(food: Option<Cooked>) {
    match food {
        Some(food) => println!("Mmm. I love {:?}", food),
        None => println!("Oh no! It wasn't edible."),
    }
}
*)
Definition eat
    (food : core.option.Option.t combinators_map.Cooked.t)
    : M unit :=
  ltac:(M.monadic (
    let food := M.alloc (| food |) in
    M.read (|
      ltac:
        (M.monadic_match_operator
          food
          [
            fun (γ : M.Val (core.option.Option.t combinators_map.Cooked.t)) =>
              match M.read (| γ |) with
              | core.option.Option.Some _ =>
                let γ0_0 := core.option.Option.Get_Some_0 γ in
                let food := M.copy (| γ0_0 |) in
                let _ : M.Val unit :=
                  M.alloc (|
                    M.call (|(std.io.stdio._print
                      (M.call (|(core.fmt.Arguments.t::["new_v1"]
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.read (| mk_str "Mmm. I love " |);
                                M.read (| mk_str "
" |)
                              ]
                            |))))
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                                  (borrow food))
                                |)
                              ]
                            |)))))
                      |)))
                    |)
                  |) in
                M.alloc (| tt |)
              | _ => M.break_match(||)
              end :
              M.Val unit;
            fun (γ : M.Val (core.option.Option.t combinators_map.Cooked.t)) =>
              match M.read (| γ |) with
              | core.option.Option.None =>
                let _ : M.Val unit :=
                  M.alloc (|
                    M.call (|(std.io.stdio._print
                      (M.call (|(core.fmt.Arguments.t::["new_const"]
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [ M.read (| mk_str "Oh no! It wasn't edible.
" |)
                              ]
                            |)))))
                      |)))
                    |)
                  |) in
                M.alloc (| tt |)
              | _ => M.break_match(||)
              end :
              M.Val unit
          ])
    |)
  )).

(*
fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // Let's try the simpler looking `process()` now.
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic (
    M.read (|
      let apple : M.Val (core.option.Option.t combinators_map.Food.t) :=
        M.alloc (| core.option.Option.Some combinators_map.Food.Apple |) in
      let carrot : M.Val (core.option.Option.t combinators_map.Food.t) :=
        M.alloc (| core.option.Option.Some combinators_map.Food.Carrot |) in
      let potato : M.Val (core.option.Option.t combinators_map.Food.t) :=
        M.alloc (| core.option.Option.None |) in
      let cooked_apple :
          M.Val (core.option.Option.t combinators_map.Cooked.t) :=
        M.alloc (|
          M.call (|(combinators_map.cook
            (M.call (|(combinators_map.chop
              (M.call (|(combinators_map.peel (M.read (| apple |))) |)))
            |)))
          |)
        |) in
      let cooked_carrot :
          M.Val (core.option.Option.t combinators_map.Cooked.t) :=
        M.alloc (|
          M.call (|(combinators_map.cook
            (M.call (|(combinators_map.chop
              (M.call (|(combinators_map.peel (M.read (| carrot |))) |)))
            |)))
          |)
        |) in
      let cooked_potato :
          M.Val (core.option.Option.t combinators_map.Cooked.t) :=
        M.alloc (| M.call (|(combinators_map.process (M.read (| potato |))) |)
        |) in
      let _ : M.Val unit :=
        M.alloc (| M.call (|(combinators_map.eat (M.read (| cooked_apple |))) |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(combinators_map.eat (M.read (| cooked_carrot |))) |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(combinators_map.eat (M.read (| cooked_potato |))) |)
        |) in
      M.alloc (| tt |)
    |)
  )).
