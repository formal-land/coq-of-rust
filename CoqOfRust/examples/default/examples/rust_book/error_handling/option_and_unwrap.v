(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn give_adult(drink: Option<&str>) {
    // Specify a course of action for each case.
    match drink {
        Some("lemonade") => println!("Yuck! Too sugary."),
        Some(inner) => println!("{}? How nice.", inner),
        None => println!("No drink? Oh well."),
    }
}
*)
Definition give_adult (drink : core.option.Option.t (ref str.t)) : M unit :=
  ltac:(M.monadic ((
    let drink := M.alloc (| drink |) in
    M.read (|
      ltac:
        (M.monadic_match_operator
          drink
          [
            fun (γ : M.Val (core.option.Option.t (ref str.t))) =>
              match M.read (| γ |) with
              | core.option.Option.Some _ =>
                let γ0_0 := core.option.Option.Get_Some_0 γ in
                let _ : M.Val unit :=
                  M.alloc (|
                    M.call (|(std.io.stdio._print
                      (M.call (|(core.fmt.Arguments.t::["new_const"]
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [ M.read (| mk_str "Yuck! Too sugary.
" |) ]
                            |)))))
                      |)))
                    |)
                  |) in
                M.alloc (| tt |)
              | _ => M.break_match(||)
              end :
              M.Val unit;
            fun (γ : M.Val (core.option.Option.t (ref str.t))) =>
              match M.read (| γ |) with
              | core.option.Option.Some _ =>
                let γ0_0 := core.option.Option.Get_Some_0 γ in
                let inner := M.copy (| γ0_0 |) in
                let _ : M.Val unit :=
                  M.alloc (|
                    M.call (|(std.io.stdio._print
                      (M.call (|(core.fmt.Arguments.t::["new_v1"]
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.read (| mk_str "" |);
                                M.read (| mk_str "? How nice.
" |)
                              ]
                            |))))
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                  (borrow inner))
                                |)
                              ]
                            |)))))
                      |)))
                    |)
                  |) in
                M.alloc (| tt |)
              | _ => M.break_match(||)
              end :
              M.Val unit;
            fun (γ : M.Val (core.option.Option.t (ref str.t))) =>
              match M.read (| γ |) with
              | core.option.Option.None =>
                let _ : M.Val unit :=
                  M.alloc (|
                    M.call (|(std.io.stdio._print
                      (M.call (|(core.fmt.Arguments.t::["new_const"]
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [ M.read (| mk_str "No drink? Oh well.
" |) ]
                            |)))))
                      |)))
                    |)
                  |) in
                M.alloc (| tt |)
              | _ => M.break_match(||)
              end :
              M.Val unit
          ])
    |)
  ) : unit)).

(*
fn drink(drink: Option<&str>) {
    // `unwrap` returns a `panic` when it receives a `None`.
    let inside = drink.unwrap();
    if inside == "lemonade" {
        panic!("AAAaaaaa!!!!");
    }

    println!("I love {}s!!!!!", inside);
}
*)
Definition drink (drink : core.option.Option.t (ref str.t)) : M unit :=
  ltac:(M.monadic ((
    let drink := M.alloc (| drink |) in
    M.read (|
      let inside : M.Val (ref str.t) :=
        M.alloc (|
          M.call (|((core.option.Option.t (ref str.t))::["unwrap"]
            (M.read (| drink |)))
          |)
        |) in
      let _ : M.Val unit :=
        if
          M.read (|
            use
              (M.alloc (|
                M.call (|(ltac:(M.get_method (fun ℐ =>
                    core.cmp.PartialEq.eq
                      (Self := ref str.t)
                      (Rhs := ref str.t)
                      (Trait := ℐ)))
                  (borrow inside)
                  (borrow (mk_str "lemonade")))
                |)
              |))
          |)
        then
          M.alloc (|
            (never_to_any (B := unit)) (|
              M.call (|(std.panicking.begin_panic
                (M.read (| mk_str "AAAaaaaa!!!!" |)))
              |)
            |)
          |)
        else
          M.alloc (| tt |) in
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.read (| mk_str "I love " |);
                        M.read (| mk_str "s!!!!!
" |)
                      ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow inside))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      M.alloc (| tt |)
    |)
  ) : unit)).

(*
fn main() {
    let water = Some("water");
    let lemonade = Some("lemonade");
    let void = None;

    give_adult(water);
    give_adult(lemonade);
    give_adult(void);

    let coffee = Some("coffee");
    let nothing = None;

    drink(coffee);
    drink(nothing);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic ((
    M.read (|
      let water : M.Val (core.option.Option.t (ref str.t)) :=
        M.alloc (| core.option.Option.Some (M.read (| mk_str "water" |)) |) in
      let lemonade : M.Val (core.option.Option.t (ref str.t)) :=
        M.alloc (| core.option.Option.Some (M.read (| mk_str "lemonade" |))
        |) in
      let void : M.Val (core.option.Option.t (ref str.t)) :=
        M.alloc (| core.option.Option.None |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(option_and_unwrap.give_adult (M.read (| water |))) |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(option_and_unwrap.give_adult (M.read (| lemonade |))) |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(option_and_unwrap.give_adult (M.read (| void |))) |)
        |) in
      let coffee : M.Val (core.option.Option.t (ref str.t)) :=
        M.alloc (| core.option.Option.Some (M.read (| mk_str "coffee" |)) |) in
      let nothing : M.Val (core.option.Option.t (ref str.t)) :=
        M.alloc (| core.option.Option.None |) in
      let _ : M.Val unit :=
        M.alloc (| M.call (|(option_and_unwrap.drink (M.read (| coffee |))) |)
        |) in
      let _ : M.Val unit :=
        M.alloc (| M.call (|(option_and_unwrap.drink (M.read (| nothing |))) |)
        |) in
      M.alloc (| tt |)
    |)
  ) : unit)).
