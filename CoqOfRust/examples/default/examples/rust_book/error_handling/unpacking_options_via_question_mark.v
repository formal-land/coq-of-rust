(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.



Module  Impl_core_clone_Clone_for_unpacking_options_via_question_mark_PhoneNumber.
Section Impl_core_clone_Clone_for_unpacking_options_via_question_mark_PhoneNumber.
  Definition Self : Ty.t :=
    Ty.apply (Ty.path "unpacking_options_via_question_mark::PhoneNumber") [].
  
  (*
  Clone
  *)
  Definition clone (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Î±0 :
          Ty.apply
            (Ty.path "unpacking_options_via_question_mark::PhoneNumber")
            [] :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [Ty.apply (Ty.path "core::option::Option") [Ty.path "u8"]]))
          [
            fun Î³ =>
              (match_operator
                (DeclaredButUndefinedVariable
                  (A :=
                    Ty.apply
                      (Ty.path "core::clone::AssertParamIsClone")
                      [Ty.path "u32"]))
                [
                  fun Î³ =>
                    (let* Î±0 :
                        Ty.apply
                          (Ty.path "ref")
                          [Ty.apply
                              (Ty.path
                                "unpacking_options_via_question_mark::PhoneNumber")
                              []] :=
                      M.read self in
                    M.pure (deref Î±0)) :
                    Ty.apply
                      (Ty.path
                        "unpacking_options_via_question_mark::PhoneNumber")
                      []
                ]) :
              Ty.apply
                (Ty.path "unpacking_options_via_question_mark::PhoneNumber")
                []
          ] in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_clone : Instance.t := {
    Notations.double_colon := clone;
  }.
  
  Definition â„ : Instance.t := [("clone", clone); ("clone_from", clone_from)].
End Impl_core_clone_Clone_for_unpacking_options_via_question_mark_PhoneNumber.
End Impl_core_clone_Clone_for_unpacking_options_via_question_mark_PhoneNumber.

Module  Impl_core_marker_Copy_for_unpacking_options_via_question_mark_PhoneNumber.
Section Impl_core_marker_Copy_for_unpacking_options_via_question_mark_PhoneNumber.
  Definition Self : Ty.t :=
    Ty.apply (Ty.path "unpacking_options_via_question_mark::PhoneNumber") [].
  
  Definition â„ : Instance.t := [].
End Impl_core_marker_Copy_for_unpacking_options_via_question_mark_PhoneNumber.
End Impl_core_marker_Copy_for_unpacking_options_via_question_mark_PhoneNumber.



Module  Impl_core_clone_Clone_for_unpacking_options_via_question_mark_Job.
Section Impl_core_clone_Clone_for_unpacking_options_via_question_mark_Job.
  Definition Self : Ty.t :=
    Ty.apply (Ty.path "unpacking_options_via_question_mark::Job") [].
  
  (*
  Clone
  *)
  Definition clone (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Î±0 :
          Ty.apply (Ty.path "unpacking_options_via_question_mark::Job") [] :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [Ty.apply
                    (Ty.path "core::option::Option")
                    [Ty.apply
                        (Ty.path
                          "unpacking_options_via_question_mark::PhoneNumber")
                        []]]))
          [
            fun Î³ =>
              (let* Î±0 :
                  Ty.apply
                    (Ty.path "ref")
                    [Ty.apply
                        (Ty.path "unpacking_options_via_question_mark::Job")
                        []] :=
                M.read self in
              M.pure (deref Î±0)) :
              Ty.apply (Ty.path "unpacking_options_via_question_mark::Job") []
          ] in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_clone : Instance.t := {
    Notations.double_colon := clone;
  }.
  
  Definition â„ : Instance.t := [("clone", clone); ("clone_from", clone_from)].
End Impl_core_clone_Clone_for_unpacking_options_via_question_mark_Job.
End Impl_core_clone_Clone_for_unpacking_options_via_question_mark_Job.

Module  Impl_core_marker_Copy_for_unpacking_options_via_question_mark_Job.
Section Impl_core_marker_Copy_for_unpacking_options_via_question_mark_Job.
  Definition Self : Ty.t :=
    Ty.apply (Ty.path "unpacking_options_via_question_mark::Job") [].
  
  Definition â„ : Instance.t := [].
End Impl_core_marker_Copy_for_unpacking_options_via_question_mark_Job.
End Impl_core_marker_Copy_for_unpacking_options_via_question_mark_Job.



Module  Impl_unpacking_options_via_question_mark_Person.
Section Impl_unpacking_options_via_question_mark_Person.
  Definition Self : Set :=
    Ty.apply (Ty.path "unpacking_options_via_question_mark::Person") [].
  
  (*
      fn work_phone_area_code(&self) -> Option<u8> {
          // This would need many nested `match` statements without the `?` operator.
          // It would take a lot more code - try writing it yourself and see which
          // is easier.
          self.job?.phone_number?.area_code
      }
  *)
  Definition work_phone_area_code (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      let return_ :=
        M.return_
          (R := Ty.apply (Ty.path "core::option::Option") [Ty.path "u8"]) in
      M.catch_return
        (let* Î±0 :
            Ty.function
              [Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply
                      (Ty.path
                        "unpacking_options_via_question_mark::PhoneNumber")
                      []]]
              (Ty.apply
                (Ty.path "core::ops::control_flow::ControlFlow")
                [_; _]) :=
          ltac:(M.get_method (fun â„ =>
            core.ops.try_trait.Try.branch
              (Self :=
                Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply
                      (Ty.path
                        "unpacking_options_via_question_mark::PhoneNumber")
                      []])
              (Trait := â„))) in
        let* Î±1 :
            Ty.function
              [Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply
                      (Ty.path "unpacking_options_via_question_mark::Job")
                      []]]
              (Ty.apply
                (Ty.path "core::ops::control_flow::ControlFlow")
                [_; _]) :=
          ltac:(M.get_method (fun â„ =>
            core.ops.try_trait.Try.branch
              (Self :=
                Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply
                      (Ty.path "unpacking_options_via_question_mark::Job")
                      []])
              (Trait := â„))) in
        let* Î±2 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply
                  (Ty.path "unpacking_options_via_question_mark::Person")
                  []] :=
          M.read self in
        let* Î±3 :
            Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply
                  (Ty.path "unpacking_options_via_question_mark::Job")
                  []] :=
          M.read
            (unpacking_options_via_question_mark.Person.Get_job (deref Î±2)) in
        let* Î±4 :
            Ty.apply
              (Ty.path "core::ops::control_flow::ControlFlow")
              [Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply (Ty.path "core::convert::Infallible") []];
                Ty.apply
                  (Ty.path "unpacking_options_via_question_mark::Job")
                  []] :=
          M.call (Î±1 Î±3) in
        let* Î±5 :
            Ty.apply
              (Ty.path "core::ops::control_flow::ControlFlow")
              [Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply (Ty.path "core::convert::Infallible") []];
                Ty.apply
                  (Ty.path "unpacking_options_via_question_mark::Job")
                  []] :=
          M.alloc Î±4 in
        let* Î±6 :
            Ty.apply (Ty.path "unpacking_options_via_question_mark::Job") [] :=
          match_operator
            Î±5
            [
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let Î³0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 Î³ in
                  let* residual := M.copy Î³0_0 in
                  let* Î±0 :
                      Ty.function
                        [Ty.apply
                            (Ty.path "core::option::Option")
                            [Ty.apply (Ty.path "core::convert::Infallible") []]]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [Ty.path "u8"]) :=
                    ltac:(M.get_method (fun â„ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          Ty.apply
                            (Ty.path "core::option::Option")
                            [Ty.path "u8"])
                        (R :=
                          Ty.apply
                            (Ty.path "core::option::Option")
                            [Ty.apply (Ty.path "core::convert::Infallible") []])
                        (Trait := â„))) in
                  let* Î±1 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.apply (Ty.path "core::convert::Infallible") []] :=
                    M.read residual in
                  let* Î±2 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.path "u8"] :=
                    M.call (Î±0 Î±1) in
                  let* Î±3 : Ty.path "never" := return_ Î±2 in
                  let* Î±4 : Ty.path "never" := M.read Î±3 in
                  let* Î±5 :
                      Ty.apply
                        (Ty.path "unpacking_options_via_question_mark::Job")
                        [] :=
                    never_to_any Î±4 in
                  M.alloc Î±5
                | _ => M.break_match
                end) :
                Ty.apply
                  (Ty.path "unpacking_options_via_question_mark::Job")
                  [];
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let Î³0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 Î³ in
                  let* val := M.copy Î³0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                Ty.apply (Ty.path "unpacking_options_via_question_mark::Job") []
            ] in
        let* Î±7 :
            Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply
                  (Ty.path "unpacking_options_via_question_mark::PhoneNumber")
                  []] :=
          M.read
            (unpacking_options_via_question_mark.Job.Get_phone_number Î±6) in
        let* Î±8 :
            Ty.apply
              (Ty.path "core::ops::control_flow::ControlFlow")
              [Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply (Ty.path "core::convert::Infallible") []];
                Ty.apply
                  (Ty.path "unpacking_options_via_question_mark::PhoneNumber")
                  []] :=
          M.call (Î±0 Î±7) in
        let* Î±9 :
            Ty.apply
              (Ty.path "core::ops::control_flow::ControlFlow")
              [Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply (Ty.path "core::convert::Infallible") []];
                Ty.apply
                  (Ty.path "unpacking_options_via_question_mark::PhoneNumber")
                  []] :=
          M.alloc Î±8 in
        let* Î±10 :
            Ty.apply
              (Ty.path "unpacking_options_via_question_mark::PhoneNumber")
              [] :=
          match_operator
            Î±9
            [
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let Î³0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 Î³ in
                  let* residual := M.copy Î³0_0 in
                  let* Î±0 :
                      Ty.function
                        [Ty.apply
                            (Ty.path "core::option::Option")
                            [Ty.apply (Ty.path "core::convert::Infallible") []]]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [Ty.path "u8"]) :=
                    ltac:(M.get_method (fun â„ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          Ty.apply
                            (Ty.path "core::option::Option")
                            [Ty.path "u8"])
                        (R :=
                          Ty.apply
                            (Ty.path "core::option::Option")
                            [Ty.apply (Ty.path "core::convert::Infallible") []])
                        (Trait := â„))) in
                  let* Î±1 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.apply (Ty.path "core::convert::Infallible") []] :=
                    M.read residual in
                  let* Î±2 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.path "u8"] :=
                    M.call (Î±0 Î±1) in
                  let* Î±3 : Ty.path "never" := return_ Î±2 in
                  let* Î±4 : Ty.path "never" := M.read Î±3 in
                  let* Î±5 :
                      Ty.apply
                        (Ty.path
                          "unpacking_options_via_question_mark::PhoneNumber")
                        [] :=
                    never_to_any Î±4 in
                  M.alloc Î±5
                | _ => M.break_match
                end) :
                Ty.apply
                  (Ty.path "unpacking_options_via_question_mark::PhoneNumber")
                  [];
              fun Î³ =>
                (let* Î±0 := M.read Î³ in
                match Î±0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let Î³0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 Î³ in
                  let* val := M.copy Î³0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                Ty.apply
                  (Ty.path "unpacking_options_via_question_mark::PhoneNumber")
                  []
            ] in
        M.read
          (unpacking_options_via_question_mark.PhoneNumber.Get_area_code Î±10))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_work_phone_area_code : Instance.t := {
    Notations.double_colon := work_phone_area_code;
  }.
End Impl_unpacking_options_via_question_mark_Person.
End Impl_unpacking_options_via_question_mark_Person.

(*
fn main() {
    let p = Person {
        job: Some(Job {
            phone_number: Some(PhoneNumber {
                area_code: Some(61),
                number: 439222222,
            }),
        }),
    };

    assert_eq!(p.work_phone_area_code(), Some(61));
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [], [] =>
    let* p :
        Ty.apply (Ty.path "unpacking_options_via_question_mark::Person") [] :=
      M.alloc
        {|
          unpacking_options_via_question_mark.Person.job :=
            core.option.Option.Some
              {|
                unpacking_options_via_question_mark.Job.phone_number :=
                  core.option.Option.Some
                    {|
                      unpacking_options_via_question_mark.PhoneNumber.area_code :=
                        core.option.Option.Some
                          ((Integer.of_Z 61) : Ty.path "u8");
                      unpacking_options_via_question_mark.PhoneNumber.number :=
                        (Integer.of_Z 439222222) : Ty.path "u32";
                    |};
              |};
        |} in
    let* _ : Ty.tuple :=
      let* Î±0 : Ty.apply (Ty.path "core::option::Option") [Ty.path "u8"] :=
        M.call
          ((Ty.apply
                (Ty.path "unpacking_options_via_question_mark::Person")
                [])::["work_phone_area_code"]
            (borrow p)) in
      let* Î±1 : Ty.apply (Ty.path "core::option::Option") [Ty.path "u8"] :=
        M.alloc Î±0 in
      let* Î±2 : Ty.apply (Ty.path "core::option::Option") [Ty.path "u8"] :=
        M.alloc (core.option.Option.Some ((Integer.of_Z 61) : Ty.path "u8")) in
      let* Î±3 :
          Ty.tuple
            (Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "core::option::Option") [Ty.path "u8"]])
            (Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "core::option::Option") [Ty.path "u8"]]) :=
        M.alloc (borrow Î±1, borrow Î±2) in
      match_operator
        Î±3
        [
          fun Î³ =>
            (let* Î±0 := M.read Î³ in
            match Î±0 with
            | (_, _) =>
              let Î³0_0 := Tuple.Access.left Î³ in
              let Î³0_1 := Tuple.Access.right Î³ in
              let* left_val := M.copy Î³0_0 in
              let* right_val := M.copy Î³0_1 in
              let* Î±0 :
                  Ty.function
                    [Ty.apply
                        (Ty.path "ref")
                        [Ty.apply
                            (Ty.path "core::option::Option")
                            [Ty.path "u8"]];
                      Ty.apply
                        (Ty.path "ref")
                        [Ty.apply
                            (Ty.path "core::option::Option")
                            [Ty.path "u8"]]]
                    (Ty.path "bool") :=
                ltac:(M.get_method (fun â„ =>
                  core.cmp.PartialEq.eq
                    (Self :=
                      Ty.apply (Ty.path "core::option::Option") [Ty.path "u8"])
                    (Rhs :=
                      Ty.apply (Ty.path "core::option::Option") [Ty.path "u8"])
                    (Trait := â„))) in
              let* Î±1 :
                  Ty.apply
                    (Ty.path "ref")
                    [Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.path "u8"]] :=
                M.read left_val in
              let* Î±2 :
                  Ty.apply
                    (Ty.path "ref")
                    [Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.path "u8"]] :=
                M.read right_val in
              let* Î±3 : Ty.path "bool" := M.call (Î±0 Î±1 Î±2) in
              let* Î±4 : Ty.path "bool" := M.alloc (UnOp.not Î±3) in
              let* Î±5 : Ty.path "bool" := M.read (use Î±4) in
              if Î±5 then
                let* kind :
                    Ty.apply (Ty.path "core::panicking::AssertKind") [] :=
                  M.alloc core.panicking.AssertKind.Eq in
                let* Î±0 : Ty.apply (Ty.path "core::panicking::AssertKind") [] :=
                  M.read kind in
                let* Î±1 :
                    Ty.apply
                      (Ty.path "ref")
                      [Ty.apply
                          (Ty.path "core::option::Option")
                          [Ty.path "u8"]] :=
                  M.read left_val in
                let* Î±2 :
                    Ty.apply
                      (Ty.path "ref")
                      [Ty.apply
                          (Ty.path "core::option::Option")
                          [Ty.path "u8"]] :=
                  M.read right_val in
                let* Î±3 : Ty.path "never" :=
                  M.call
                    (core.panicking.assert_failed
                      Î±0
                      Î±1
                      Î±2
                      core.option.Option.None) in
                let* Î±0 : Ty.path "never" := M.alloc Î±3 in
                let* Î±1 : Ty.path "never" := M.read Î±0 in
                let* Î±2 : Ty.tuple := never_to_any Î±1 in
                M.alloc Î±2
              else
                M.alloc tt
            end) :
            Ty.tuple
        ] in
    let* Î±0 : Ty.path "unit" := M.alloc tt in
    M.read Î±0
  | _, _ => M.impossible
  end.
