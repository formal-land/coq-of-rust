(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module Foo.
  Inductive t : Set :=
  | Bar.
End Foo.

(*
fn main() {
    let a = Foo::Bar;

    // Variable a matches Foo::Bar
    if let Foo::Bar = a {
        // ^-- this causes a compile-time error. Use `if let` instead.
        println!("a is foobar");
    }
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic ((
    M.read (|
      let a : M.Val if_let_challenge.Foo.t :=
        M.alloc (| if_let_challenge.Foo.Bar |) in
      ltac:
        (M.monadic_match_operator
          a
          [
            fun (γ : M.Val if_let_challenge.Foo.t) =>
              match M.read (| γ |) with
              | if_let_challenge.Foo.Bar =>
                let _ : M.Val unit :=
                  let _ : M.Val unit :=
                    M.alloc (|
                      M.call (|(std.io.stdio._print
                        (M.call (|(core.fmt.Arguments.t::["new_const"]
                          (pointer_coercion
                            "Unsize"
                            (borrow
                              (M.alloc (| [ M.read (| mk_str "a is foobar
" |) ]
                              |)))))
                        |)))
                      |)
                    |) in
                  M.alloc (| tt |) in
                M.alloc (| tt |)
              end :
              M.Val unit;
            fun (γ : M.Val if_let_challenge.Foo.t) =>
              (M.alloc (| tt |)) : M.Val unit
          ])
    |)
  ) : unit)).
