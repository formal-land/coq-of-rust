(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn main() {
    // Try changing the values in the array, or make it a slice!
    let array = [1, -2, 6];

    match array {
        // Binds the second and the third elements to the respective variables
        [0, second, third] => println!("array[0] = 0, array[1] = {}, array[2] = {}", second, third),

        // Single values can be ignored with _
        [1, _, third] => println!(
            "array[0] = 1, array[2] = {} and array[1] was ignored",
            third
        ),

        // You can also bind some and ignore the rest
        [-1, second, ..] => println!(
            "array[0] = -1, array[1] = {} and all the other ones were ignored",
            second
        ),
        // The code below would not compile
        // [-1, second] => ...

        // Or store them in another array/slice (the type depends on
        // that of the value that is being matched against)
        [3, second, tail @ ..] => println!(
            "array[0] = 3, array[1] = {} and the other elements were {:?}",
            second, tail
        ),

        // Combining these patterns, we can, for example, bind the first and
        // last values, and store the rest of them in a single array
        [first, middle @ .., last] => println!(
            "array[0] = {}, middle = {:?}, array[2] = {}",
            first, middle, last
        ),
    }
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic (
    M.read (|
      let array_ : M.Val (array i32.t) :=
        M.alloc (|
          [
            (Integer.of_Z 1) : i32.t;
            (Integer.of_Z (-2)) : i32.t;
            (Integer.of_Z 6) : i32.t
          ]
        |) in
      ltac:
        (M.monadic_match_operator
          array_
          [
            fun (γ : M.Val (array i32.t)) =>
              match M.read (| γ |) with
              | [_; _; _] =>
                let γ0_0 := [0] γ in
                let γ0_1 := [1] γ in
                let γ0_2 := [2] γ in
                let second := M.copy (| γ0_1 |) in
                let third := M.copy (| γ0_2 |) in
                let _ : M.Val unit :=
                  M.alloc (|
                    M.call (|(std.io.stdio._print
                      (M.call (|(core.fmt.Arguments.t::["new_v1"]
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.read (| mk_str "array[0] = 0, array[1] = " |);
                                M.read (| mk_str ", array[2] = " |);
                                M.read (| mk_str "
" |)
                              ]
                            |))))
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                  (borrow second))
                                |);
                                M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                  (borrow third))
                                |)
                              ]
                            |)))))
                      |)))
                    |)
                  |) in
                M.alloc (| tt |)
              | _ => M.break_match(||)
              end :
              M.Val unit;
            fun (γ : M.Val (array i32.t)) =>
              match M.read (| γ |) with
              | [_; _; _] =>
                let γ0_0 := [0] γ in
                let γ0_1 := [1] γ in
                let γ0_2 := [2] γ in
                let third := M.copy (| γ0_2 |) in
                let _ : M.Val unit :=
                  M.alloc (|
                    M.call (|(std.io.stdio._print
                      (M.call (|(core.fmt.Arguments.t::["new_v1"]
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.read (| mk_str "array[0] = 1, array[2] = " |);
                                M.read (| mk_str " and array[1] was ignored
" |)
                              ]
                            |))))
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                  (borrow third))
                                |)
                              ]
                            |)))))
                      |)))
                    |)
                  |) in
                M.alloc (| tt |)
              | _ => M.break_match(||)
              end :
              M.Val unit;
            fun (γ : M.Val (array i32.t)) =>
              match M.read (| γ |) with
              | (_:: _:: _) =>
                let γ0_0 := [0] γ in
                let γ0_1 := [1] γ in
                let γ0_slice := [2].slice γ in
                let second := M.copy (| γ0_1 |) in
                let _ : M.Val unit :=
                  M.alloc (|
                    M.call (|(std.io.stdio._print
                      (M.call (|(core.fmt.Arguments.t::["new_v1"]
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.read (| mk_str "array[0] = -1, array[1] = "
                                |);
                                M.read (|
                                  mk_str " and all the other ones were ignored
"
                                |)
                              ]
                            |))))
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                  (borrow second))
                                |)
                              ]
                            |)))))
                      |)))
                    |)
                  |) in
                M.alloc (| tt |)
              | _ => M.break_match(||)
              end :
              M.Val unit;
            fun (γ : M.Val (array i32.t)) =>
              match M.read (| γ |) with
              | (_:: _:: _) =>
                let γ0_0 := [0] γ in
                let γ0_1 := [1] γ in
                let γ0_slice := [2].slice γ in
                let second := M.copy (| γ0_1 |) in
                let tail := M.copy (| γ0_slice |) in
                let _ : M.Val unit :=
                  M.alloc (|
                    M.call (|(std.io.stdio._print
                      (M.call (|(core.fmt.Arguments.t::["new_v1"]
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.read (| mk_str "array[0] = 3, array[1] = " |);
                                M.read (| mk_str " and the other elements were "
                                |);
                                M.read (| mk_str "
" |)
                              ]
                            |))))
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                  (borrow second))
                                |);
                                M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                                  (borrow tail))
                                |)
                              ]
                            |)))))
                      |)))
                    |)
                  |) in
                M.alloc (| tt |)
              | _ => M.break_match(||)
              end :
              M.Val unit;
            fun (γ : M.Val (array i32.t)) =>
              (let _ : M.Val unit :=
                M.alloc (|
                  M.call (|(std.io.stdio._print
                    (M.call (|(core.fmt.Arguments.t::["new_v1"]
                      (pointer_coercion
                        "Unsize"
                        (borrow
                          (M.alloc (|
                            [
                              M.read (| mk_str "array[0] = " |);
                              M.read (| mk_str ", middle = " |);
                              M.read (| mk_str ", array[2] = " |);
                              M.read (| mk_str "
" |)
                            ]
                          |))))
                      (pointer_coercion
                        "Unsize"
                        (borrow
                          (M.alloc (|
                            [
                              M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                (borrow first))
                              |);
                              M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                                (borrow middle))
                              |);
                              M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                (borrow last))
                              |)
                            ]
                          |)))))
                    |)))
                  |)
                |) in
              M.alloc (| tt |)) :
              M.Val unit
          ])
    |)
  )).
