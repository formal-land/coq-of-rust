(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.



Module  Impl_associated_functions_and_methods_Point.
Section Impl_associated_functions_and_methods_Point.
  Definition Self : Set :=
    Ty.apply (Ty.path "associated_functions_and_methods::Point") [].
  
  (*
      fn origin() -> Point {
          Point { y: 0.0, x: 1.0 }
      }
  *)
  Definition origin (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [] =>
      let* Î±0 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* Î±1 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      M.pure
        {|
          associated_functions_and_methods.Point.y := Î±0;
          associated_functions_and_methods.Point.x := Î±1;
        |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_origin : Instance.t := {
    Notations.double_colon := origin;
  }.
  
  (*
      fn new(x: f64, y: f64) -> Point {
          Point { x: x, y: y }
      }
  *)
  Definition new (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [x; y] =>
      let* x := M.alloc x in
      let* y := M.alloc y in
      let* Î±0 : Ty.path "f64" := M.read x in
      let* Î±1 : Ty.path "f64" := M.read y in
      M.pure
        {|
          associated_functions_and_methods.Point.x := Î±0;
          associated_functions_and_methods.Point.y := Î±1;
        |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_new : Instance.t := {
    Notations.double_colon := new;
  }.
End Impl_associated_functions_and_methods_Point.
End Impl_associated_functions_and_methods_Point.



Module  Impl_associated_functions_and_methods_Rectangle.
Section Impl_associated_functions_and_methods_Rectangle.
  Definition Self : Set :=
    Ty.apply (Ty.path "associated_functions_and_methods::Rectangle") [].
  
  (*
      fn get_p1(&self) -> Point {
          self.p1
      }
  *)
  Definition get_p1 (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Î±0 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply
                (Ty.path "associated_functions_and_methods::Rectangle")
                []] :=
        M.read self in
      M.read (associated_functions_and_methods.Rectangle.Get_p1 (deref Î±0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_get_p1 : Instance.t := {
    Notations.double_colon := get_p1;
  }.
  
  (*
      fn area(&self) -> f64 {
          // `self` gives access to the struct fields via the dot operator
          let Point { x: x1, y: y1 } = self.p1;
          let Point { x: x2, y: y2 } = self.p2;
  
          // `abs` is a `f64` method that returns the absolute value of the
          // caller
          ((x1 - x2) * (y1 - y2)).abs()
      }
  *)
  Definition area (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Î±0 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply
                (Ty.path "associated_functions_and_methods::Rectangle")
                []] :=
        M.read self in
      let* Î±1 : Ty.path "f64" :=
        match_operator
          (associated_functions_and_methods.Rectangle.Get_p1 (deref Î±0))
          [
            fun Î³ =>
              (let* Î±0 := M.read Î³ in
              match Î±0 with
              |
                  {|
                    associated_functions_and_methods.Point.x := _;
                    associated_functions_and_methods.Point.y := _;
                  |}
                  =>
                let Î³0_0 := associated_functions_and_methods.Point.Get_x Î³ in
                let Î³0_1 := associated_functions_and_methods.Point.Get_y Î³ in
                let* x1 := M.copy Î³0_0 in
                let* y1 := M.copy Î³0_1 in
                let* Î±0 :
                    Ty.apply
                      (Ty.path "ref")
                      [Ty.apply
                          (Ty.path
                            "associated_functions_and_methods::Rectangle")
                          []] :=
                  M.read self in
                match_operator
                  (associated_functions_and_methods.Rectangle.Get_p2 (deref Î±0))
                  [
                    fun Î³ =>
                      (let* Î±0 := M.read Î³ in
                      match Î±0 with
                      |
                          {|
                            associated_functions_and_methods.Point.x := _;
                            associated_functions_and_methods.Point.y := _;
                          |}
                          =>
                        let Î³0_0 :=
                          associated_functions_and_methods.Point.Get_x Î³ in
                        let Î³0_1 :=
                          associated_functions_and_methods.Point.Get_y Î³ in
                        let* x2 := M.copy Î³0_0 in
                        let* y2 := M.copy Î³0_1 in
                        let* Î±0 : Ty.path "f64" := M.read x1 in
                        let* Î±1 : Ty.path "f64" := M.read x2 in
                        let* Î±2 : Ty.path "f64" := BinOp.Panic.sub Î±0 Î±1 in
                        let* Î±3 : Ty.path "f64" := M.read y1 in
                        let* Î±4 : Ty.path "f64" := M.read y2 in
                        let* Î±5 : Ty.path "f64" := BinOp.Panic.sub Î±3 Î±4 in
                        let* Î±6 : Ty.path "f64" := BinOp.Panic.mul Î±2 Î±5 in
                        let* Î±7 : Ty.path "f64" :=
                          M.call ((Ty.path "f64")::["abs"] Î±6) in
                        M.alloc Î±7
                      end) :
                      Ty.path "f64"
                  ]
              end) :
              Ty.path "f64"
          ] in
      M.read Î±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_area : Instance.t := {
    Notations.double_colon := area;
  }.
  
  (*
      fn perimeter(&self) -> f64 {
          let Point { x: x1, y: y1 } = self.p1;
          let Point { x: x2, y: y2 } = self.p2;
  
          2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
      }
  *)
  Definition perimeter (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Î±0 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply
                (Ty.path "associated_functions_and_methods::Rectangle")
                []] :=
        M.read self in
      let* Î±1 : Ty.path "f64" :=
        match_operator
          (associated_functions_and_methods.Rectangle.Get_p1 (deref Î±0))
          [
            fun Î³ =>
              (let* Î±0 := M.read Î³ in
              match Î±0 with
              |
                  {|
                    associated_functions_and_methods.Point.x := _;
                    associated_functions_and_methods.Point.y := _;
                  |}
                  =>
                let Î³0_0 := associated_functions_and_methods.Point.Get_x Î³ in
                let Î³0_1 := associated_functions_and_methods.Point.Get_y Î³ in
                let* x1 := M.copy Î³0_0 in
                let* y1 := M.copy Î³0_1 in
                let* Î±0 :
                    Ty.apply
                      (Ty.path "ref")
                      [Ty.apply
                          (Ty.path
                            "associated_functions_and_methods::Rectangle")
                          []] :=
                  M.read self in
                match_operator
                  (associated_functions_and_methods.Rectangle.Get_p2 (deref Î±0))
                  [
                    fun Î³ =>
                      (let* Î±0 := M.read Î³ in
                      match Î±0 with
                      |
                          {|
                            associated_functions_and_methods.Point.x := _;
                            associated_functions_and_methods.Point.y := _;
                          |}
                          =>
                        let Î³0_0 :=
                          associated_functions_and_methods.Point.Get_x Î³ in
                        let Î³0_1 :=
                          associated_functions_and_methods.Point.Get_y Î³ in
                        let* x2 := M.copy Î³0_0 in
                        let* y2 := M.copy Î³0_1 in
                        let* Î±0 : Ty.path "f64" :=
                          M.read (UnsupportedLiteral : Ty.path "f64") in
                        let* Î±1 : Ty.path "f64" := M.read x1 in
                        let* Î±2 : Ty.path "f64" := M.read x2 in
                        let* Î±3 : Ty.path "f64" := BinOp.Panic.sub Î±1 Î±2 in
                        let* Î±4 : Ty.path "f64" :=
                          M.call ((Ty.path "f64")::["abs"] Î±3) in
                        let* Î±5 : Ty.path "f64" := M.read y1 in
                        let* Î±6 : Ty.path "f64" := M.read y2 in
                        let* Î±7 : Ty.path "f64" := BinOp.Panic.sub Î±5 Î±6 in
                        let* Î±8 : Ty.path "f64" :=
                          M.call ((Ty.path "f64")::["abs"] Î±7) in
                        let* Î±9 : Ty.path "f64" := BinOp.Panic.add Î±4 Î±8 in
                        let* Î±10 : Ty.path "f64" := BinOp.Panic.mul Î±0 Î±9 in
                        M.alloc Î±10
                      end) :
                      Ty.path "f64"
                  ]
              end) :
              Ty.path "f64"
          ] in
      M.read Î±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_perimeter : Instance.t := {
    Notations.double_colon := perimeter;
  }.
  
  (*
      fn translate(&mut self, x: f64, y: f64) {
          self.p1.x += x;
          self.p2.x += x;
  
          self.p1.y += y;
          self.p2.y += y;
      }
  *)
  Definition translate (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self; x; y] =>
      let* self := M.alloc self in
      let* x := M.alloc x in
      let* y := M.alloc y in
      let* _ : Ty.tuple :=
        let* Î² : Ty.path "f64" :=
          let* Î±0 :
              Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply
                    (Ty.path "associated_functions_and_methods::Rectangle")
                    []] :=
            M.read self in
          M.pure
            (associated_functions_and_methods.Point.Get_x
              (associated_functions_and_methods.Rectangle.Get_p1 (deref Î±0))) in
        let* Î±0 := M.read Î² in
        let* Î±1 : Ty.path "f64" := M.read x in
        let* Î±2 := BinOp.Panic.add Î±0 Î±1 in
        assign Î² Î±2 in
      let* _ : Ty.tuple :=
        let* Î² : Ty.path "f64" :=
          let* Î±0 :
              Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply
                    (Ty.path "associated_functions_and_methods::Rectangle")
                    []] :=
            M.read self in
          M.pure
            (associated_functions_and_methods.Point.Get_x
              (associated_functions_and_methods.Rectangle.Get_p2 (deref Î±0))) in
        let* Î±0 := M.read Î² in
        let* Î±1 : Ty.path "f64" := M.read x in
        let* Î±2 := BinOp.Panic.add Î±0 Î±1 in
        assign Î² Î±2 in
      let* _ : Ty.tuple :=
        let* Î² : Ty.path "f64" :=
          let* Î±0 :
              Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply
                    (Ty.path "associated_functions_and_methods::Rectangle")
                    []] :=
            M.read self in
          M.pure
            (associated_functions_and_methods.Point.Get_y
              (associated_functions_and_methods.Rectangle.Get_p1 (deref Î±0))) in
        let* Î±0 := M.read Î² in
        let* Î±1 : Ty.path "f64" := M.read y in
        let* Î±2 := BinOp.Panic.add Î±0 Î±1 in
        assign Î² Î±2 in
      let* _ : Ty.tuple :=
        let* Î² : Ty.path "f64" :=
          let* Î±0 :
              Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply
                    (Ty.path "associated_functions_and_methods::Rectangle")
                    []] :=
            M.read self in
          M.pure
            (associated_functions_and_methods.Point.Get_y
              (associated_functions_and_methods.Rectangle.Get_p2 (deref Î±0))) in
        let* Î±0 := M.read Î² in
        let* Î±1 : Ty.path "f64" := M.read y in
        let* Î±2 := BinOp.Panic.add Î±0 Î±1 in
        assign Î² Î±2 in
      let* Î±0 : Ty.path "unit" := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_translate : Instance.t := {
    Notations.double_colon := translate;
  }.
End Impl_associated_functions_and_methods_Rectangle.
End Impl_associated_functions_and_methods_Rectangle.



Module  Impl_associated_functions_and_methods_Pair.
Section Impl_associated_functions_and_methods_Pair.
  Definition Self : Set :=
    Ty.apply (Ty.path "associated_functions_and_methods::Pair") [].
  
  (*
      fn destroy(self) {
          // Destructure `self`
          let Pair(first, second) = self;
  
          println!("Destroying Pair({}, {})", first, second);
  
          // `first` and `second` go out of scope and get freed
      }
  *)
  Definition destroy (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Î±0 : Ty.tuple :=
        match_operator
          self
          [
            fun Î³ =>
              (let* Î±0 := M.read Î³ in
              match Î±0 with
              | associated_functions_and_methods.Pair.Build_t _ _ =>
                let Î³0_0 := associated_functions_and_methods.Pair.Get_0 Î³ in
                let Î³0_1 := associated_functions_and_methods.Pair.Get_1 Î³ in
                let* first := M.copy Î³0_0 in
                let* second := M.copy Î³0_1 in
                let* _ : Ty.tuple :=
                  let* _ : Ty.tuple :=
                    let* Î±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                      M.read (mk_str "Destroying Pair(") in
                    let* Î±1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                      M.read (mk_str ", ") in
                    let* Î±2 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                      M.read (mk_str ")
") in
                    let* Î±3 :
                        Ty.apply
                          (Ty.path "array")
                          [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
                      M.alloc [ Î±0; Î±1; Î±2 ] in
                    let* Î±4 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
                      M.call
                        ((Ty.apply
                              (Ty.path "core::fmt::rt::Argument")
                              [])::["new_display"]
                          (borrow first)) in
                    let* Î±5 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
                      M.call
                        ((Ty.apply
                              (Ty.path "core::fmt::rt::Argument")
                              [])::["new_display"]
                          (borrow second)) in
                    let* Î±6 :
                        Ty.apply
                          (Ty.path "array")
                          [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
                      M.alloc [ Î±4; Î±5 ] in
                    let* Î±7 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
                      M.call
                        ((Ty.apply
                              (Ty.path "core::fmt::Arguments")
                              [])::["new_v1"]
                          (pointer_coercion "Unsize" (borrow Î±3))
                          (pointer_coercion "Unsize" (borrow Î±6))) in
                    let* Î±8 : Ty.tuple := M.call (std.io.stdio._print Î±7) in
                    M.alloc Î±8 in
                  M.alloc tt in
                M.alloc tt
              end) :
              Ty.path "unit"
          ] in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_destroy : Instance.t := {
    Notations.double_colon := destroy;
  }.
End Impl_associated_functions_and_methods_Pair.
End Impl_associated_functions_and_methods_Pair.

(*
fn main() {
    let rectangle = Rectangle {
        // Associated functions are called using double colons
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Methods are called using the dot operator
    // Note that the first argument `&self` is implicitly passed, i.e.
    // `rectangle.perimeter()` === `Rectangle::perimeter(&rectangle)`
    println!("Rectangle perimeter: {}", rectangle.perimeter());
    println!("Rectangle area: {}", rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Error! `rectangle` is immutable, but this method requires a mutable
    // object
    //rectangle.translate(1.0, 0.0);
    // TODO ^ Try uncommenting this line

    // Okay! Mutable objects can call mutable methods
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Error! Previous `destroy` call "consumed" `pair`
    //pair.destroy();
    // TODO ^ Try uncommenting this line
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [], [] =>
    let* rectangle :
        Ty.apply (Ty.path "associated_functions_and_methods::Rectangle") [] :=
      let* Î±0 :
          Ty.apply (Ty.path "associated_functions_and_methods::Point") [] :=
        M.call
          (Ty.apply
              (Ty.path "associated_functions_and_methods::Point")
              [])::["origin"] in
      let* Î±1 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* Î±2 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* Î±3 :
          Ty.apply (Ty.path "associated_functions_and_methods::Point") [] :=
        M.call
          ((Ty.apply
                (Ty.path "associated_functions_and_methods::Point")
                [])::["new"]
            Î±1
            Î±2) in
      M.alloc
        {|
          associated_functions_and_methods.Rectangle.p1 := Î±0;
          associated_functions_and_methods.Rectangle.p2 := Î±3;
        |} in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* Î±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "Rectangle perimeter: ") in
        let* Î±1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "
") in
        let* Î±2 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ Î±0; Î±1 ] in
        let* Î±3 : Ty.path "f64" :=
          M.call
            ((Ty.apply
                  (Ty.path "associated_functions_and_methods::Rectangle")
                  [])::["perimeter"]
              (borrow rectangle)) in
        let* Î±4 : Ty.path "f64" := M.alloc Î±3 in
        let* Î±5 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_display"]
              (borrow Î±4)) in
        let* Î±6 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
          M.alloc [ Î±5 ] in
        let* Î±7 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
              (pointer_coercion "Unsize" (borrow Î±2))
              (pointer_coercion "Unsize" (borrow Î±6))) in
        let* Î±8 : Ty.tuple := M.call (std.io.stdio._print Î±7) in
        M.alloc Î±8 in
      M.alloc tt in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* Î±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "Rectangle area: ") in
        let* Î±1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "
") in
        let* Î±2 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ Î±0; Î±1 ] in
        let* Î±3 : Ty.path "f64" :=
          M.call
            ((Ty.apply
                  (Ty.path "associated_functions_and_methods::Rectangle")
                  [])::["area"]
              (borrow rectangle)) in
        let* Î±4 : Ty.path "f64" := M.alloc Î±3 in
        let* Î±5 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_display"]
              (borrow Î±4)) in
        let* Î±6 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
          M.alloc [ Î±5 ] in
        let* Î±7 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
              (pointer_coercion "Unsize" (borrow Î±2))
              (pointer_coercion "Unsize" (borrow Î±6))) in
        let* Î±8 : Ty.tuple := M.call (std.io.stdio._print Î±7) in
        M.alloc Î±8 in
      M.alloc tt in
    let* square :
        Ty.apply (Ty.path "associated_functions_and_methods::Rectangle") [] :=
      let* Î±0 :
          Ty.apply (Ty.path "associated_functions_and_methods::Point") [] :=
        M.call
          (Ty.apply
              (Ty.path "associated_functions_and_methods::Point")
              [])::["origin"] in
      let* Î±1 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* Î±2 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* Î±3 :
          Ty.apply (Ty.path "associated_functions_and_methods::Point") [] :=
        M.call
          ((Ty.apply
                (Ty.path "associated_functions_and_methods::Point")
                [])::["new"]
            Î±1
            Î±2) in
      M.alloc
        {|
          associated_functions_and_methods.Rectangle.p1 := Î±0;
          associated_functions_and_methods.Rectangle.p2 := Î±3;
        |} in
    let* _ : Ty.tuple :=
      let* Î±0 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* Î±1 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* Î±2 : Ty.tuple :=
        M.call
          ((Ty.apply
                (Ty.path "associated_functions_and_methods::Rectangle")
                [])::["translate"]
            (borrow_mut square)
            Î±0
            Î±1) in
      M.alloc Î±2 in
    let* pair :
        Ty.apply (Ty.path "associated_functions_and_methods::Pair") [] :=
      let* Î±0 :
          Ty.apply
            (Ty.path "alloc::boxed::Box")
            [Ty.path "i32"; Ty.apply (Ty.path "alloc::alloc::Global") []] :=
        M.call
          ((Ty.apply
                (Ty.path "alloc::boxed::Box")
                [Ty.path "i32";
                  Ty.apply (Ty.path "alloc::alloc::Global") []])::["new"]
            ((Integer.of_Z 1) : Ty.path "i32")) in
      let* Î±1 :
          Ty.apply
            (Ty.path "alloc::boxed::Box")
            [Ty.path "i32"; Ty.apply (Ty.path "alloc::alloc::Global") []] :=
        M.call
          ((Ty.apply
                (Ty.path "alloc::boxed::Box")
                [Ty.path "i32";
                  Ty.apply (Ty.path "alloc::alloc::Global") []])::["new"]
            ((Integer.of_Z 2) : Ty.path "i32")) in
      M.alloc (associated_functions_and_methods.Pair.Build_t Î±0 Î±1) in
    let* _ : Ty.tuple :=
      let* Î±0 :
          Ty.apply (Ty.path "associated_functions_and_methods::Pair") [] :=
        M.read pair in
      let* Î±1 : Ty.tuple :=
        M.call
          ((Ty.apply
                (Ty.path "associated_functions_and_methods::Pair")
                [])::["destroy"]
            Î±0) in
      M.alloc Î±1 in
    let* Î±0 : Ty.path "unit" := M.alloc tt in
    M.read Î±0
  | _, _ => M.impossible
  end.
