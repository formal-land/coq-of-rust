(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn call_me<F: Fn()>(f: F) {
    f();
}
*)
Definition call_me {F : Set} (f : F) : M unit :=
  ltac:(M.monadic ((
    let f := M.alloc (| f |) in
    M.read (|
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(ltac:(M.get_method (fun ℐ =>
              core.ops.function.Fn.call
                (Self := F)
                (Args := unit)
                (Trait := ℐ)))
            (borrow f)
            tt)
          |)
        |) in
      M.alloc (| tt |)
    |)
  ) : unit)).

(*
fn function() {
    println!("I'm a function!");
}
*)
Definition function : M unit :=
  ltac:(M.monadic ((
    M.read (|
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_const"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (| [ M.read (| mk_str "I'm a function!
" |) ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      M.alloc (| tt |)
    |)
  ) : unit)).

(*
fn main() {
    // Define a closure satisfying the `Fn` bound
    let closure = || println!("I'm a closure!");

    call_me(closure);
    call_me(function);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic ((
    M.read (|
      let closure : M.Val (unit -> unit) :=
        M.alloc (|
          fun (α0 : unit) =>
            (ltac:
              (M.monadic_match_operator
                (M.alloc (| α0 |))
                [
                  fun γ =>
                    (M.read (|
                      let _ : M.Val unit :=
                        M.alloc (|
                          M.call (|(std.io.stdio._print
                            (M.call (|(core.fmt.Arguments.t::["new_const"]
                              (pointer_coercion
                                "Unsize"
                                (borrow
                                  (M.alloc (|
                                    [ M.read (| mk_str "I'm a closure!
" |) ]
                                  |)))))
                            |)))
                          |)
                        |) in
                      M.alloc (| tt |)
                    |)) :
                    unit
                ])) :
            unit
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(functions_closures_input_functions.call_me
            (M.read (| closure |)))
          |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(functions_closures_input_functions.call_me
            functions_closures_input_functions.function)
          |)
        |) in
      M.alloc (| tt |)
    |)
  ) : unit)).
