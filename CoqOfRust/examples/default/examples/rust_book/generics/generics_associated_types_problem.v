(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Struct Container *)

(* Trait *)
Module Contains.
  
End Contains.

Module Impl_generics_associated_types_problem_Contains_i32_i32_for_generics_associated_types_problem_Container.
  Definition Self : Ty.t :=
    Ty.path "generics_associated_types_problem::Container".
  
  (*
      fn contains(&self, number_1: &i32, number_2: &i32) -> bool {
          (&self.0 == number_1) && (&self.1 == number_2)
      }
  *)
  Definition contains (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self; number_1; number_2 ] =>
      let* self := M.alloc self in
      let* number_1 := M.alloc number_1 in
      let* number_2 := M.alloc number_2 in
      let* Œ±0 :=
        M.get_method
          "core::cmp::PartialEq"
          "eq"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "i32" ];
            (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "i32" ]
          ] in
      let* Œ±1 := M.read self in
      let* Œ±2 :=
        M.alloc
          (borrow
            ((M.var "generics_associated_types_problem::Container::Get_0")
              (deref Œ±1))) in
      let* Œ±3 := M.call Œ±0 [ borrow Œ±2; borrow number_1 ] in
      let* Œ±4 :=
        M.get_method
          "core::cmp::PartialEq"
          "eq"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "i32" ];
            (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "i32" ]
          ] in
      let* Œ±5 := M.read self in
      let* Œ±6 :=
        M.alloc
          (borrow
            ((M.var "generics_associated_types_problem::Container::Get_1")
              (deref Œ±5))) in
      let* Œ±7 := M.call Œ±4 [ borrow Œ±6; borrow number_2 ] in
      M.pure ((M.var "BinOp::Pure::and") Œ±3 Œ±7)
    | _, _ => M.impossible
    end.
  
  (*
      fn first(&self) -> i32 {
          self.0
      }
  *)
  Definition first (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      M.read
        ((M.var "generics_associated_types_problem::Container::Get_0")
          (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  (*
      fn last(&self) -> i32 {
          self.1
      }
  *)
  Definition last (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* Œ±0 := M.read self in
      M.read
        ((M.var "generics_associated_types_problem::Container::Get_1")
          (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t :=
    [
      ("contains", InstanceField.Method contains);
      ("first", InstanceField.Method first);
      ("last", InstanceField.Method last)
    ].
End Impl_generics_associated_types_problem_Contains_i32_i32_for_generics_associated_types_problem_Container.

(*
fn difference<A, B, C>(container: &C) -> i32
where
    C: Contains<A, B>,
{
    container.last() - container.first()
}
*)
Definition difference (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [ A; B; C ], [ container ] =>
    let* container := M.alloc container in
    let* Œ±0 :=
      M.get_method
        "generics_associated_types_problem::Contains"
        "last"
        [ (* Self *) C; (* A *) A; (* B *) B ] in
    let* Œ±1 := M.read container in
    let* Œ±2 := M.call Œ±0 [ Œ±1 ] in
    let* Œ±3 :=
      M.get_method
        "generics_associated_types_problem::Contains"
        "first"
        [ (* Self *) C; (* A *) A; (* B *) B ] in
    let* Œ±4 := M.read container in
    let* Œ±5 := M.call Œ±3 [ Œ±4 ] in
    (M.var "BinOp::Panic::sub") Œ±2 Œ±5
  | _, _ => M.impossible
  end.

(*
fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(
        "Does container contain {} and {}: {}",
        &number_1,
        &number_2,
        container.contains(&number_1, &number_2)
    );
    println!("First number: {}", container.first());
    println!("Last number: {}", container.last());

    println!("The difference is: {}", difference(&container));
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [] =>
    let* number_1 := M.alloc ((Integer.of_Z 3) : Ty.path "i32") in
    let* number_2 := M.alloc ((Integer.of_Z 10) : Ty.path "i32") in
    let* container :=
      let* Œ±0 := M.read number_1 in
      let* Œ±1 := M.read number_2 in
      M.alloc (generics_associated_types_problem.Container.Build_t Œ±0 Œ±1) in
    let* _ :=
      let* _ :=
        let* Œ±0 := M.read (mk_str "Does container contain ") in
        let* Œ±1 := M.read (mk_str " and ") in
        let* Œ±2 := M.read (mk_str ": ") in
        let* Œ±3 := M.read (mk_str "
") in
        let* Œ±4 := M.alloc [ Œ±0; Œ±1; Œ±2; Œ±3 ] in
        let* Œ±5 := M.alloc (borrow number_1) in
        let* Œ±6 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow Œ±5 ] in
        let* Œ±7 := M.alloc (borrow number_2) in
        let* Œ±8 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow Œ±7 ] in
        let* Œ±9 :=
          M.get_method
            "generics_associated_types_problem::Contains"
            "contains"
            [
              (* Self *) Ty.path "generics_associated_types_problem::Container";
              (* A *) Ty.path "i32";
              (* B *) Ty.path "i32"
            ] in
        let* Œ±10 :=
          M.call Œ±9 [ borrow container; borrow number_1; borrow number_2 ] in
        let* Œ±11 := M.alloc Œ±10 in
        let* Œ±12 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow Œ±11 ] in
        let* Œ±13 := M.alloc [ Œ±6; Œ±8; Œ±12 ] in
        let* Œ±14 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Œ±4);
              pointer_coercion "Unsize" (borrow Œ±13)
            ] in
        let* Œ±15 := M.call (M.var "std::io::stdio::_print") [ Œ±14 ] in
        M.alloc Œ±15 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* Œ±0 := M.read (mk_str "First number: ") in
        let* Œ±1 := M.read (mk_str "
") in
        let* Œ±2 := M.alloc [ Œ±0; Œ±1 ] in
        let* Œ±3 :=
          M.get_method
            "generics_associated_types_problem::Contains"
            "first"
            [
              (* Self *) Ty.path "generics_associated_types_problem::Container";
              (* A *) Ty.path "i32";
              (* B *) Ty.path "i32"
            ] in
        let* Œ±4 := M.call Œ±3 [ borrow container ] in
        let* Œ±5 := M.alloc Œ±4 in
        let* Œ±6 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow Œ±5 ] in
        let* Œ±7 := M.alloc [ Œ±6 ] in
        let* Œ±8 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Œ±2);
              pointer_coercion "Unsize" (borrow Œ±7)
            ] in
        let* Œ±9 := M.call (M.var "std::io::stdio::_print") [ Œ±8 ] in
        M.alloc Œ±9 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* Œ±0 := M.read (mk_str "Last number: ") in
        let* Œ±1 := M.read (mk_str "
") in
        let* Œ±2 := M.alloc [ Œ±0; Œ±1 ] in
        let* Œ±3 :=
          M.get_method
            "generics_associated_types_problem::Contains"
            "last"
            [
              (* Self *) Ty.path "generics_associated_types_problem::Container";
              (* A *) Ty.path "i32";
              (* B *) Ty.path "i32"
            ] in
        let* Œ±4 := M.call Œ±3 [ borrow container ] in
        let* Œ±5 := M.alloc Œ±4 in
        let* Œ±6 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow Œ±5 ] in
        let* Œ±7 := M.alloc [ Œ±6 ] in
        let* Œ±8 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Œ±2);
              pointer_coercion "Unsize" (borrow Œ±7)
            ] in
        let* Œ±9 := M.call (M.var "std::io::stdio::_print") [ Œ±8 ] in
        M.alloc Œ±9 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* Œ±0 := M.read (mk_str "The difference is: ") in
        let* Œ±1 := M.read (mk_str "
") in
        let* Œ±2 := M.alloc [ Œ±0; Œ±1 ] in
        let* Œ±3 :=
          M.call
            (M.var "generics_associated_types_problem::difference")
            [ borrow container ] in
        let* Œ±4 := M.alloc Œ±3 in
        let* Œ±5 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow Œ±4 ] in
        let* Œ±6 := M.alloc [ Œ±5 ] in
        let* Œ±7 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Œ±2);
              pointer_coercion "Unsize" (borrow Œ±6)
            ] in
        let* Œ±8 := M.call (M.var "std::io::stdio::_print") [ Œ±7 ] in
        M.alloc Œ±8 in
      M.alloc tt in
    let* Œ±0 := M.alloc tt in
    M.read Œ±0
  | _, _ => M.impossible
  end.
