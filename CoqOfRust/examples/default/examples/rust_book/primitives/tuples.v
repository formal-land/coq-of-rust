(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn reverse(pair: (i32, bool)) -> (bool, i32) {
    // `let` can be used to bind the members of a tuple to variables
    let (int_param, bool_param) = pair;

    (bool_param, int_param)
}
*)
Definition reverse (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [], [ pair ] =>
    let* pair := M.alloc pair in
    let* Î±0 :=
      match_operator
        pair
        [
          fun Î³ =>
            (let* Î±0 := M.read Î³ in
            match Î±0 with
            | (_, _) =>
              let Î³0_0 := Tuple.Access.left Î³ in
              let Î³0_1 := Tuple.Access.right Î³ in
              let* int_param := M.copy Î³0_0 in
              let* bool_param := M.copy Î³0_1 in
              let* Î±0 := M.read bool_param in
              let* Î±1 := M.read int_param in
              M.alloc (Î±0, Î±1)
            end) :
            Ty.tuple [ Ty.path "bool"; Ty.path "i32" ]
        ] in
    M.read Î±0
  | _, _ => M.impossible
  end.

(* Struct Matrix *)

Module Impl_core_fmt_Debug_for_tuples_Matrix.
  (*
  Debug
  *)
  Definition fmt (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Î±0 := M.read f in
      let* Î±1 := M.read (mk_str "Matrix") in
      let* Î±2 := M.var "tuples::Matrix::Get_0" in
      let* Î±3 := M.read self in
      let* Î±4 := M.var "tuples::Matrix::Get_1" in
      let* Î±5 := M.read self in
      let* Î±6 := M.var "tuples::Matrix::Get_2" in
      let* Î±7 := M.read self in
      let* Î±8 := M.var "tuples::Matrix::Get_3" in
      let* Î±9 := M.read self in
      let* Î±10 := M.alloc (borrow (Î±8 (deref Î±9))) in
      M.call
        (Ty.path "core::fmt::Formatter")::["debug_tuple_field4_finish"]
        [
          Î±0;
          Î±1;
          pointer_coercion "Unsize" (borrow (Î±2 (deref Î±3)));
          pointer_coercion "Unsize" (borrow (Î±4 (deref Î±5)));
          pointer_coercion "Unsize" (borrow (Î±6 (deref Î±7)));
          pointer_coercion "Unsize" (borrow Î±10)
        ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    let Self := Ty.path "tuples::Matrix" in
    M.IsTraitInstance
      "core::fmt::Debug"
      Self
      []
      [ ("fmt", InstanceField.Method fmt [ Self ]) ].
End Impl_core_fmt_Debug_for_tuples_Matrix.

(*
fn main() {
    // A tuple with a bunch of different types
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // Values can be extracted from the tuple using tuple indexing
    println!("long tuple first value: {}", long_tuple.0);
    println!("long tuple second value: {}", long_tuple.1);

    // Tuples can be tuple members
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // Tuples are printable
    println!("tuple of tuples: {:?}", tuple_of_tuples);
    
    // But long Tuples (more than 12 elements) cannot be printed
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!("too long tuple: {:?}", too_long_tuple);
    // TODO ^ Uncomment the above 2 lines to see the compiler error

    let pair = (1, true);
    println!("pair is {:?}", pair);

    println!("the reversed pair is {:?}", reverse(pair));

    // To create one element tuples, the comma is required to tell them apart
    // from a literal surrounded by parentheses
    println!("one element tuple: {:?}", (5u32,));
    println!("just an integer: {:?}", (5u32));

    //tuples can be destructured to create bindings
    let tuple = (1, "hello", 4.5, true);

    let (a, b, c, d) = tuple;
    println!("{:?}, {:?}, {:?}, {:?}", a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!("{:?}", matrix);

}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [], [] =>
    let* long_tuple :=
      let* Î±0 := M.read (UnsupportedLiteral : Ty.path "f32") in
      let* Î±1 := M.read (UnsupportedLiteral : Ty.path "f64") in
      M.alloc
        ((Integer.of_Z 1) : Ty.path "u8",
          (Integer.of_Z 2) : Ty.path "u16",
          (Integer.of_Z 3) : Ty.path "u32",
          (Integer.of_Z 4) : Ty.path "u64",
          (Integer.of_Z (-1)) : Ty.path "i8",
          (Integer.of_Z (-2)) : Ty.path "i16",
          (Integer.of_Z (-3)) : Ty.path "i32",
          (Integer.of_Z (-4)) : Ty.path "i64",
          Î±0,
          Î±1,
          "a"%char,
          true) in
    let* _ :=
      let* _ :=
        let* Î±0 := M.var "std::io::stdio::_print" in
        let* Î±1 := M.read (mk_str "long tuple first value: ") in
        let* Î±2 := M.read (mk_str "
") in
        let* Î±3 := M.alloc [ Î±1; Î±2 ] in
        let* Î±4 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow "Unknown Field" ] in
        let* Î±5 := M.alloc [ Î±4 ] in
        let* Î±6 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±3);
              pointer_coercion "Unsize" (borrow Î±5)
            ] in
        let* Î±7 := M.call Î±0 [ Î±6 ] in
        M.alloc Î±7 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* Î±0 := M.var "std::io::stdio::_print" in
        let* Î±1 := M.read (mk_str "long tuple second value: ") in
        let* Î±2 := M.read (mk_str "
") in
        let* Î±3 := M.alloc [ Î±1; Î±2 ] in
        let* Î±4 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ borrow "Unknown Field" ] in
        let* Î±5 := M.alloc [ Î±4 ] in
        let* Î±6 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±3);
              pointer_coercion "Unsize" (borrow Î±5)
            ] in
        let* Î±7 := M.call Î±0 [ Î±6 ] in
        M.alloc Î±7 in
      M.alloc tt in
    let* tuple_of_tuples :=
      M.alloc
        (((Integer.of_Z 1) : Ty.path "u8",
            (Integer.of_Z 2) : Ty.path "u16",
            (Integer.of_Z 2) : Ty.path "u32"),
          ((Integer.of_Z 4) : Ty.path "u64",
            (Integer.of_Z (-1)) : Ty.path "i8"),
          (Integer.of_Z (-2)) : Ty.path "i16") in
    let* _ :=
      let* _ :=
        let* Î±0 := M.var "std::io::stdio::_print" in
        let* Î±1 := M.read (mk_str "tuple of tuples: ") in
        let* Î±2 := M.read (mk_str "
") in
        let* Î±3 := M.alloc [ Î±1; Î±2 ] in
        let* Î±4 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_debug"]
            [ borrow tuple_of_tuples ] in
        let* Î±5 := M.alloc [ Î±4 ] in
        let* Î±6 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±3);
              pointer_coercion "Unsize" (borrow Î±5)
            ] in
        let* Î±7 := M.call Î±0 [ Î±6 ] in
        M.alloc Î±7 in
      M.alloc tt in
    let* pair := M.alloc ((Integer.of_Z 1) : Ty.path "i32", true) in
    let* _ :=
      let* _ :=
        let* Î±0 := M.var "std::io::stdio::_print" in
        let* Î±1 := M.read (mk_str "pair is ") in
        let* Î±2 := M.read (mk_str "
") in
        let* Î±3 := M.alloc [ Î±1; Î±2 ] in
        let* Î±4 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_debug"]
            [ borrow pair ] in
        let* Î±5 := M.alloc [ Î±4 ] in
        let* Î±6 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±3);
              pointer_coercion "Unsize" (borrow Î±5)
            ] in
        let* Î±7 := M.call Î±0 [ Î±6 ] in
        M.alloc Î±7 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* Î±0 := M.var "std::io::stdio::_print" in
        let* Î±1 := M.read (mk_str "the reversed pair is ") in
        let* Î±2 := M.read (mk_str "
") in
        let* Î±3 := M.alloc [ Î±1; Î±2 ] in
        let* Î±4 := M.var "tuples::reverse" in
        let* Î±5 := M.read pair in
        let* Î±6 := M.call Î±4 [ Î±5 ] in
        let* Î±7 := M.alloc Î±6 in
        let* Î±8 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_debug"]
            [ borrow Î±7 ] in
        let* Î±9 := M.alloc [ Î±8 ] in
        let* Î±10 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±3);
              pointer_coercion "Unsize" (borrow Î±9)
            ] in
        let* Î±11 := M.call Î±0 [ Î±10 ] in
        M.alloc Î±11 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* Î±0 := M.var "std::io::stdio::_print" in
        let* Î±1 := M.read (mk_str "one element tuple: ") in
        let* Î±2 := M.read (mk_str "
") in
        let* Î±3 := M.alloc [ Î±1; Î±2 ] in
        let* Î±4 := M.alloc ((Integer.of_Z 5) : Ty.path "u32") in
        let* Î±5 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_debug"]
            [ borrow Î±4 ] in
        let* Î±6 := M.alloc [ Î±5 ] in
        let* Î±7 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±3);
              pointer_coercion "Unsize" (borrow Î±6)
            ] in
        let* Î±8 := M.call Î±0 [ Î±7 ] in
        M.alloc Î±8 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* Î±0 := M.var "std::io::stdio::_print" in
        let* Î±1 := M.read (mk_str "just an integer: ") in
        let* Î±2 := M.read (mk_str "
") in
        let* Î±3 := M.alloc [ Î±1; Î±2 ] in
        let* Î±4 := M.alloc ((Integer.of_Z 5) : Ty.path "u32") in
        let* Î±5 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_debug"]
            [ borrow Î±4 ] in
        let* Î±6 := M.alloc [ Î±5 ] in
        let* Î±7 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±3);
              pointer_coercion "Unsize" (borrow Î±6)
            ] in
        let* Î±8 := M.call Î±0 [ Î±7 ] in
        M.alloc Î±8 in
      M.alloc tt in
    let* tuple :=
      let* Î±0 := M.read (mk_str "hello") in
      let* Î±1 := M.read (UnsupportedLiteral : Ty.path "f64") in
      M.alloc ((Integer.of_Z 1) : Ty.path "i32", Î±0, Î±1, true) in
    let* Î±0 :=
      match_operator
        tuple
        [
          fun Î³ =>
            (let* Î±0 := M.read Î³ in
            match Î±0 with
            | (_, _, _, _) =>
              let Î³0_0 :=
                Tuple.Access.left (Tuple.Access.left (Tuple.Access.left Î³)) in
              let Î³0_1 :=
                Tuple.Access.right (Tuple.Access.left (Tuple.Access.left Î³)) in
              let Î³0_2 := Tuple.Access.right (Tuple.Access.left Î³) in
              let Î³0_3 := Tuple.Access.right Î³ in
              let* a := M.copy Î³0_0 in
              let* b := M.copy Î³0_1 in
              let* c := M.copy Î³0_2 in
              let* d := M.copy Î³0_3 in
              let* _ :=
                let* _ :=
                  let* Î±0 := M.var "std::io::stdio::_print" in
                  let* Î±1 := M.read (mk_str "") in
                  let* Î±2 := M.read (mk_str ", ") in
                  let* Î±3 := M.read (mk_str ", ") in
                  let* Î±4 := M.read (mk_str ", ") in
                  let* Î±5 := M.read (mk_str "
") in
                  let* Î±6 := M.alloc [ Î±1; Î±2; Î±3; Î±4; Î±5 ] in
                  let* Î±7 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ borrow a ] in
                  let* Î±8 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ borrow b ] in
                  let* Î±9 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ borrow c ] in
                  let* Î±10 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ borrow d ] in
                  let* Î±11 := M.alloc [ Î±7; Î±8; Î±9; Î±10 ] in
                  let* Î±12 :=
                    M.call
                      (Ty.path "core::fmt::Arguments")::["new_v1"]
                      [
                        pointer_coercion "Unsize" (borrow Î±6);
                        pointer_coercion "Unsize" (borrow Î±11)
                      ] in
                  let* Î±13 := M.call Î±0 [ Î±12 ] in
                  M.alloc Î±13 in
                M.alloc tt in
              let* matrix :=
                let* Î±0 := M.read (UnsupportedLiteral : Ty.path "f32") in
                let* Î±1 := M.read (UnsupportedLiteral : Ty.path "f32") in
                let* Î±2 := M.read (UnsupportedLiteral : Ty.path "f32") in
                let* Î±3 := M.read (UnsupportedLiteral : Ty.path "f32") in
                M.alloc (tuples.Matrix.Build_t Î±0 Î±1 Î±2 Î±3) in
              let* _ :=
                let* _ :=
                  let* Î±0 := M.var "std::io::stdio::_print" in
                  let* Î±1 := M.read (mk_str "") in
                  let* Î±2 := M.read (mk_str "
") in
                  let* Î±3 := M.alloc [ Î±1; Î±2 ] in
                  let* Î±4 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ borrow matrix ] in
                  let* Î±5 := M.alloc [ Î±4 ] in
                  let* Î±6 :=
                    M.call
                      (Ty.path "core::fmt::Arguments")::["new_v1"]
                      [
                        pointer_coercion "Unsize" (borrow Î±3);
                        pointer_coercion "Unsize" (borrow Î±5)
                      ] in
                  let* Î±7 := M.call Î±0 [ Î±6 ] in
                  M.alloc Î±7 in
                M.alloc tt in
              M.alloc tt
            end) :
            Ty.path "unit"
        ] in
    M.read Î±0
  | _, _ => M.impossible
  end.
