(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Ref.
Section Ref.
  Context {T : Set}.
  
  Record t : Set := {
    x0 : ref T;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Ref.
End Ref.

Module  Impl_core_fmt_Debug_for_scoping_rules_lifetimes_bounds_Ref_t_T.
Section Impl_core_fmt_Debug_for_scoping_rules_lifetimes_bounds_Ref_t_T.
  Context {T : Set}.
  
  Definition Self : Set := scoping_rules_lifetimes_bounds.Ref.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      let f := M.alloc (| f |) in
      M.call (|(core.fmt.Formatter.t::["debug_tuple_field1_finish"]
        (M.read (| f |))
        (M.read (| mk_str "Ref" |))
        (pointer_coercion
          "Unsize"
          (borrow
            (M.alloc (|
              borrow
                (scoping_rules_lifetimes_bounds.Ref.Get_0
                  (deref (M.read (| self |))))
            |)))))
      |)
    ) : ltac:(core.fmt.Result))).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_scoping_rules_lifetimes_bounds_Ref_t_T.
End Impl_core_fmt_Debug_for_scoping_rules_lifetimes_bounds_Ref_t_T.

(*
fn print<T>(t: T)
where
    T: Debug,
{
    println!("`print`: t is {:?}", t);
}
*)
Definition print {T : Set} (t : T) : M unit :=
  ltac:(M.monadic ((
    let t := M.alloc (| t |) in
    M.read (|
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.read (| mk_str "`print`: t is " |);
                        M.read (| mk_str "
" |)
                      ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                          (borrow t))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      M.alloc (| tt |)
    |)
  ) : unit)).

(*
fn print_ref<'a, T>(t: &'a T)
where
    T: Debug + 'a,
{
    println!("`print_ref`: t is {:?}", t);
}
*)
Definition print_ref {T : Set} (t : ref T) : M unit :=
  ltac:(M.monadic ((
    let t := M.alloc (| t |) in
    M.read (|
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.read (| mk_str "`print_ref`: t is " |);
                        M.read (| mk_str "
" |)
                      ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                          (borrow t))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      M.alloc (| tt |)
    |)
  ) : unit)).

(*
fn main() {
    let x = 7;
    let ref_x = Ref(&x);

    print_ref(&ref_x);
    print(ref_x);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic ((
    M.read (|
      let x : M.Val i32.t := M.alloc (| (Integer.of_Z 7) : i32.t |) in
      let ref_x : M.Val (scoping_rules_lifetimes_bounds.Ref.t i32.t) :=
        M.alloc (| scoping_rules_lifetimes_bounds.Ref.Build_t (borrow x) |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(scoping_rules_lifetimes_bounds.print_ref (borrow ref_x)) |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(scoping_rules_lifetimes_bounds.print (M.read (| ref_x |)))
          |)
        |) in
      M.alloc (| tt |)
    |)
  ) : unit)).
