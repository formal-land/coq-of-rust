(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn print_one<'a>(x: &'a i32) {
    println!("`print_one`: x is {}", x);
}
*)
Definition print_one (x : ref i32.t) : M unit :=
  ltac:(M.monadic ((
    let x := M.alloc (| x |) in
    M.read (|
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.read (| mk_str "`print_one`: x is " |);
                        M.read (| mk_str "
" |)
                      ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow x))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      M.alloc (| tt |)
    |)
  ) : unit)).

(*
fn add_one<'a>(x: &'a mut i32) {
    *x += 1;
}
*)
Definition add_one (x : mut_ref i32.t) : M unit :=
  ltac:(M.monadic ((
    let x := M.alloc (| x |) in
    M.read (|
      let _ : M.Val unit :=
        let β : M.Val i32.t := deref (M.read (| x |)) in
        assign (|
          β,
          BinOp.Panic.add (| M.read (| β |), (Integer.of_Z 1) : i32.t |)
        |) in
      M.alloc (| tt |)
    |)
  ) : unit)).

(*
fn print_multi<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("`print_multi`: x is {}, y is {}", x, y);
}
*)
Definition print_multi (x : ref i32.t) (y : ref i32.t) : M unit :=
  ltac:(M.monadic ((
    let x := M.alloc (| x |) in
    let y := M.alloc (| y |) in
    M.read (|
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.read (| mk_str "`print_multi`: x is " |);
                        M.read (| mk_str ", y is " |);
                        M.read (| mk_str "
" |)
                      ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow x))
                        |);
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow y))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      M.alloc (| tt |)
    |)
  ) : unit)).

(*
fn pass_x<'a, 'b>(x: &'a i32, _: &'b i32) -> &'a i32 {
    x
}
*)
Definition pass_x (x : ref i32.t) (arg : ref i32.t) : M (ref i32.t) :=
  ltac:(M.monadic ((
    let x := M.alloc (| x |) in
    let arg := M.alloc (| arg |) in
    M.read (| x |)
  ) : ref i32.t)).

(*
fn main() {
    let x = 7;
    let y = 9;

    print_one(&x);
    print_multi(&x, &y);

    let z = pass_x(&x, &y);
    print_one(z);

    let mut t = 3;
    add_one(&mut t);
    print_one(&t);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic ((
    M.read (|
      let x : M.Val i32.t := M.alloc (| (Integer.of_Z 7) : i32.t |) in
      let y : M.Val i32.t := M.alloc (| (Integer.of_Z 9) : i32.t |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(scoping_rules_lifetimes_functions.print_one (borrow x)) |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(scoping_rules_lifetimes_functions.print_multi
            (borrow x)
            (borrow y))
          |)
        |) in
      let z : M.Val (ref i32.t) :=
        M.alloc (|
          M.call (|(scoping_rules_lifetimes_functions.pass_x
            (borrow x)
            (borrow y))
          |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(scoping_rules_lifetimes_functions.print_one
            (M.read (| z |)))
          |)
        |) in
      let t : M.Val i32.t := M.alloc (| (Integer.of_Z 3) : i32.t |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(scoping_rules_lifetimes_functions.add_one (borrow_mut t)) |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(scoping_rules_lifetimes_functions.print_one (borrow t)) |)
        |) in
      M.alloc (| tt |)
    |)
  ) : unit)).
