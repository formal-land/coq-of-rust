(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Owner.
Section Owner.
  Record t : Set := {
    x0 : i32.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Owner.
End Owner.

Module  Impl_scoping_rules_lifetimes_methods_Owner_t.
Section Impl_scoping_rules_lifetimes_methods_Owner_t.
  Definition Self : Set := scoping_rules_lifetimes_methods.Owner.t.
  
  (*
      fn add_one<'a>(&'a mut self) {
          self.0 += 1;
      }
  *)
  Definition add_one (self : mut_ref Self) : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        let _ : M.Val unit :=
          let β : M.Val i32.t :=
            scoping_rules_lifetimes_methods.Owner.Get_0
              (deref (M.read (| self |))) in
          assign (|
            β,
            BinOp.Panic.add (| M.read (| β |), (Integer.of_Z 1) : i32.t |)
          |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_add_one :
    Notations.DoubleColon Self "add_one" := {
    Notations.double_colon := add_one;
  }.
  
  (*
      fn print<'a>(&'a self) {
          println!("`print`: {}", self.0);
      }
  *)
  Definition print (self : ref Self) : M unit :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        let _ : M.Val unit :=
          let _ : M.Val unit :=
            M.alloc (|
              M.call (|(std.io.stdio._print
                (M.call (|(core.fmt.Arguments.t::["new_v1"]
                  (pointer_coercion
                    "Unsize"
                    (borrow
                      (M.alloc (|
                        [
                          M.read (| mk_str "`print`: " |);
                          M.read (| mk_str "
" |)
                        ]
                      |))))
                  (pointer_coercion
                    "Unsize"
                    (borrow
                      (M.alloc (|
                        [
                          M.call (|(core.fmt.rt.Argument.t::["new_display"]
                            (borrow
                              (scoping_rules_lifetimes_methods.Owner.Get_0
                                (deref (M.read (| self |))))))
                          |)
                        ]
                      |)))))
                |)))
              |)
            |) in
          M.alloc (| tt |) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  Global Instance AssociatedFunction_print :
    Notations.DoubleColon Self "print" := {
    Notations.double_colon := print;
  }.
End Impl_scoping_rules_lifetimes_methods_Owner_t.
End Impl_scoping_rules_lifetimes_methods_Owner_t.

(*
fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic ((
    M.read (|
      let owner : M.Val scoping_rules_lifetimes_methods.Owner.t :=
        M.alloc (|
          scoping_rules_lifetimes_methods.Owner.Build_t
            ((Integer.of_Z 18) : i32.t)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(scoping_rules_lifetimes_methods.Owner.t::["add_one"]
            (borrow_mut owner))
          |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(scoping_rules_lifetimes_methods.Owner.t::["print"]
            (borrow owner))
          |)
        |) in
      M.alloc (| tt |)
    |)
  ) : unit)).
