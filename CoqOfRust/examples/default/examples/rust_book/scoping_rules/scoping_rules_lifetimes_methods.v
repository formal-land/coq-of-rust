(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* StructTuple
  {
    name := "Owner";
    const_params := [];
    ty_params := [];
    fields := [ Ty.path "i32" ];
  } *)

Module Impl_scoping_rules_lifetimes_methods_Owner.
  Definition Self : Ty.t := Ty.path "scoping_rules_lifetimes_methods::Owner".
  
  (*
      fn add_one<'a>(&'a mut self) {
          self.0 += 1;
      }
  *)
  Definition add_one (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.read (|
          let~ _ :=
            let β :=
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "scoping_rules_lifetimes_methods::Owner",
                0
              |) in
            M.write (| β, BinOp.Wrap.add Integer.I32 (M.read (| β |)) (Value.Integer 1) |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_add_one : M.IsAssociatedFunction Self "add_one" add_one.
  
  (*
      fn print<'a>(&'a self) {
          println!("`print`: {}", self.0);
      }
  *)
  Definition print (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.read (|
          let~ _ :=
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "std::io::stdio::_print", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                      [
                        (* Unsize *)
                        M.pointer_coercion
                          (M.alloc (|
                            Value.Array
                              [ M.read (| Value.String "`print`: " |); M.read (| Value.String "
" |)
                              ]
                          |));
                        (* Unsize *)
                        M.pointer_coercion
                          (M.alloc (|
                            Value.Array
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_display",
                                    [ Ty.path "i32" ]
                                  |),
                                  [
                                    M.SubPointer.get_struct_tuple_field (|
                                      M.read (| self |),
                                      "scoping_rules_lifetimes_methods::Owner",
                                      0
                                    |)
                                  ]
                                |)
                              ]
                          |))
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_print : M.IsAssociatedFunction Self "print" print.
End Impl_scoping_rules_lifetimes_methods_Owner.

(*
fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}
*)
Definition main (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [] =>
    ltac:(M.monadic
      (M.read (|
        let~ owner :=
          M.alloc (|
            Value.StructTuple "scoping_rules_lifetimes_methods::Owner" [ Value.Integer 18 ]
          |) in
        let~ _ :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "scoping_rules_lifetimes_methods::Owner",
                "add_one",
                []
              |),
              [ owner ]
            |)
          |) in
        let~ _ :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "scoping_rules_lifetimes_methods::Owner",
                "print",
                []
              |),
              [ owner ]
            |)
          |) in
        M.alloc (| Value.Tuple [] |)
      |)))
  | _, _, _ => M.impossible
  end.

Axiom Function_main : M.IsFunction "scoping_rules_lifetimes_methods::main" main.
