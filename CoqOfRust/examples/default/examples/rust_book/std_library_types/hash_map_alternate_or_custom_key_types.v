(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Account.
Section Account.
  Record t : Set := {
    username : ref str.t;
    password : ref str.t;
  }.
  
  Definition Get_username :=
    Ref.map
      (fun α => Some α.(username))
      (fun β α => Some (α <| username := β |>)).
  Definition Get_password :=
    Ref.map
      (fun α => Some α.(password))
      (fun β α => Some (α <| password := β |>)).
End Account.
End Account.

Module  Impl_core_marker_StructuralPartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
Section Impl_core_marker_StructuralPartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
  Definition Self : Set := hash_map_alternate_or_custom_key_types.Account.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
End Impl_core_marker_StructuralPartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.

Module  Impl_core_cmp_PartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
Section Impl_core_cmp_PartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
  Definition Self : Set := hash_map_alternate_or_custom_key_types.Account.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref hash_map_alternate_or_custom_key_types.Account.t)
      : M bool.t :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let other := M.alloc (| other |) in
      BinOp.Pure.and
        (M.call (|(ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := ref str.t)
              (Rhs := ref str.t)
              (Trait := ℐ)))
          (borrow
            (hash_map_alternate_or_custom_key_types.Account.Get_username
              (deref (M.read (| self |)))))
          (borrow
            (hash_map_alternate_or_custom_key_types.Account.Get_username
              (deref (M.read (| other |))))))
        |))
        (M.call (|(ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := ref str.t)
              (Rhs := ref str.t)
              (Trait := ℐ)))
          (borrow
            (hash_map_alternate_or_custom_key_types.Account.Get_password
              (deref (M.read (| self |)))))
          (borrow
            (hash_map_alternate_or_custom_key_types.Account.Get_password
              (deref (M.read (| other |))))))
        |))
    )).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
End Impl_core_cmp_PartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.

Module  Impl_core_marker_StructuralEq_for_hash_map_alternate_or_custom_key_types_Account_t.
Section Impl_core_marker_StructuralEq_for_hash_map_alternate_or_custom_key_types_Account_t.
  Definition Self : Set := hash_map_alternate_or_custom_key_types.Account.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_hash_map_alternate_or_custom_key_types_Account_t.
End Impl_core_marker_StructuralEq_for_hash_map_alternate_or_custom_key_types_Account_t.

Module  Impl_core_cmp_Eq_for_hash_map_alternate_or_custom_key_types_Account_t.
Section Impl_core_cmp_Eq_for_hash_map_alternate_or_custom_key_types_Account_t.
  Definition Self : Set := hash_map_alternate_or_custom_key_types.Account.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      M.read (|
        ltac:
          (M.monadic_match_operator
            (DeclaredButUndefinedVariable
              (A := core.cmp.AssertParamIsEq.t (ref str.t)))
            [
              fun (γ : M.Val (core.cmp.AssertParamIsEq.t (ref str.t))) =>
                (ltac:
                  (M.monadic_match_operator
                    (DeclaredButUndefinedVariable
                      (A := core.cmp.AssertParamIsEq.t (ref str.t)))
                    [
                      fun
                          (γ :
                            M.Val (core.cmp.AssertParamIsEq.t (ref str.t))) =>
                        (M.alloc (| tt |)) : M.Val unit
                    ])) :
                M.Val unit
            ])
      |)
    )).
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_hash_map_alternate_or_custom_key_types_Account_t.
End Impl_core_cmp_Eq_for_hash_map_alternate_or_custom_key_types_Account_t.

Module  Impl_core_hash_Hash_for_hash_map_alternate_or_custom_key_types_Account_t.
Section Impl_core_hash_Hash_for_hash_map_alternate_or_custom_key_types_Account_t.
  Definition Self : Set := hash_map_alternate_or_custom_key_types.Account.t.
  
  (*
  Hash
  *)
  Definition hash
      {__H : Set}
      (self : ref Self)
      (state : mut_ref __H)
      : M unit :=
    ltac:(M.monadic (
      let self := M.alloc (| self |) in
      let state := M.alloc (| state |) in
      M.read (|
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(ltac:(M.get_method (fun ℐ =>
                core.hash.Hash.hash
                  (Self := ref str.t)
                  (H := __H)
                  (Trait := ℐ)))
              (borrow
                (hash_map_alternate_or_custom_key_types.Account.Get_username
                  (deref (M.read (| self |)))))
              (M.read (| state |)))
            |)
          |) in
        M.alloc (|
          M.call (|(ltac:(M.get_method (fun ℐ =>
              core.hash.Hash.hash (Self := ref str.t) (H := __H) (Trait := ℐ)))
            (borrow
              (hash_map_alternate_or_custom_key_types.Account.Get_password
                (deref (M.read (| self |)))))
            (M.read (| state |)))
          |)
        |)
      |)
    )).
  
  Global Instance AssociatedFunction_hash {__H : Set} :
    Notations.DoubleColon Self "hash" := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
    core.hash.Hash.hash {__H : Set} := hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_hash_map_alternate_or_custom_key_types_Account_t.
End Impl_core_hash_Hash_for_hash_map_alternate_or_custom_key_types_Account_t.

Module  AccountInfo.
Section AccountInfo.
  Record t : Set := {
    name : ref str.t;
    email : ref str.t;
  }.
  
  Definition Get_name :=
    Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>)).
  Definition Get_email :=
    Ref.map (fun α => Some α.(email)) (fun β α => Some (α <| email := β |>)).
End AccountInfo.
End AccountInfo.

Ltac Accounts :=
  exact
    (std.collections.hash.map.HashMap.t
      hash_map_alternate_or_custom_key_types.Account.t
      hash_map_alternate_or_custom_key_types.AccountInfo.t
      std.collections.hash.map.HashMap.Default.S).

(*
fn try_logon<'a>(accounts: &Accounts<'a>, username: &'a str, password: &'a str) {
    println!("Username: {}", username);
    println!("Password: {}", password);
    println!("Attempting logon...");

    let logon = Account { username, password };

    match accounts.get(&logon) {
        Some(account_info) => {
            println!("Successful logon!");
            println!("Name: {}", account_info.name);
            println!("Email: {}", account_info.email);
        }
        _ => println!("Login failed!"),
    }
}
*)
Definition try_logon
    (accounts : ref ltac:(hash_map_alternate_or_custom_key_types.Accounts))
    (username : ref str.t)
    (password : ref str.t)
    : M unit :=
  ltac:(M.monadic (
    let accounts := M.alloc (| accounts |) in
    let username := M.alloc (| username |) in
    let password := M.alloc (| password |) in
    M.read (|
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.read (| mk_str "Username: " |);
                        M.read (| mk_str "
" |)
                      ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow username))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.read (| mk_str "Password: " |);
                        M.read (| mk_str "
" |)
                      ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow password))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_const"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (| [ M.read (| mk_str "Attempting logon...
" |) ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      let logon : M.Val hash_map_alternate_or_custom_key_types.Account.t :=
        M.alloc (|
          {|
            hash_map_alternate_or_custom_key_types.Account.username :=
              M.read (| username |);
            hash_map_alternate_or_custom_key_types.Account.password :=
              M.read (| password |);
          |} : hash_map_alternate_or_custom_key_types.Account.t
        |) in
      ltac:
        (M.monadic_match_operator
          (M.alloc (|
            M.call (|((std.collections.hash.map.HashMap.t
                  hash_map_alternate_or_custom_key_types.Account.t
                  hash_map_alternate_or_custom_key_types.AccountInfo.t
                  std.hash.random.RandomState.t)::["get"]
              (M.read (| accounts |))
              (borrow logon))
            |)
          |))
          [
            fun
                (γ :
                  M.Val
                    (core.option.Option.t
                      (ref
                        hash_map_alternate_or_custom_key_types.AccountInfo.t))) =>
              match M.read (| γ |) with
              | core.option.Option.Some _ =>
                let γ0_0 := core.option.Option.Get_Some_0 γ in
                let account_info := M.copy (| γ0_0 |) in
                let _ : M.Val unit :=
                  let _ : M.Val unit :=
                    M.alloc (|
                      M.call (|(std.io.stdio._print
                        (M.call (|(core.fmt.Arguments.t::["new_const"]
                          (pointer_coercion
                            "Unsize"
                            (borrow
                              (M.alloc (|
                                [ M.read (| mk_str "Successful logon!
" |) ]
                              |)))))
                        |)))
                      |)
                    |) in
                  M.alloc (| tt |) in
                let _ : M.Val unit :=
                  let _ : M.Val unit :=
                    M.alloc (|
                      M.call (|(std.io.stdio._print
                        (M.call (|(core.fmt.Arguments.t::["new_v1"]
                          (pointer_coercion
                            "Unsize"
                            (borrow
                              (M.alloc (|
                                [
                                  M.read (| mk_str "Name: " |);
                                  M.read (| mk_str "
" |)
                                ]
                              |))))
                          (pointer_coercion
                            "Unsize"
                            (borrow
                              (M.alloc (|
                                [
                                  M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                    (borrow
                                      (hash_map_alternate_or_custom_key_types.AccountInfo.Get_name
                                        (deref (M.read (| account_info |))))))
                                  |)
                                ]
                              |)))))
                        |)))
                      |)
                    |) in
                  M.alloc (| tt |) in
                let _ : M.Val unit :=
                  let _ : M.Val unit :=
                    M.alloc (|
                      M.call (|(std.io.stdio._print
                        (M.call (|(core.fmt.Arguments.t::["new_v1"]
                          (pointer_coercion
                            "Unsize"
                            (borrow
                              (M.alloc (|
                                [
                                  M.read (| mk_str "Email: " |);
                                  M.read (| mk_str "
" |)
                                ]
                              |))))
                          (pointer_coercion
                            "Unsize"
                            (borrow
                              (M.alloc (|
                                [
                                  M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                    (borrow
                                      (hash_map_alternate_or_custom_key_types.AccountInfo.Get_email
                                        (deref (M.read (| account_info |))))))
                                  |)
                                ]
                              |)))))
                        |)))
                      |)
                    |) in
                  M.alloc (| tt |) in
                M.alloc (| tt |)
              | _ => M.break_match(||)
              end :
              M.Val unit;
            fun
                (γ :
                  M.Val
                    (core.option.Option.t
                      (ref
                        hash_map_alternate_or_custom_key_types.AccountInfo.t))) =>
              (let _ : M.Val unit :=
                M.alloc (|
                  M.call (|(std.io.stdio._print
                    (M.call (|(core.fmt.Arguments.t::["new_const"]
                      (pointer_coercion
                        "Unsize"
                        (borrow
                          (M.alloc (| [ M.read (| mk_str "Login failed!
" |) ]
                          |)))))
                    |)))
                  |)
                |) in
              M.alloc (| tt |)) :
              M.Val unit
          ])
    |)
  )).

(*
fn main() {
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: "j.everyman",
        password: "password123",
    };

    let account_info = AccountInfo {
        name: "John Everyman",
        email: "j.everyman@email.com",
    };

    accounts.insert(account, account_info);

    try_logon(&accounts, "j.everyman", "psasword123");

    try_logon(&accounts, "j.everyman", "password123");
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic (
    M.read (|
      let accounts :
          M.Val
            (std.collections.hash.map.HashMap.t
              hash_map_alternate_or_custom_key_types.Account.t
              hash_map_alternate_or_custom_key_types.AccountInfo.t
              std.hash.random.RandomState.t) :=
        M.alloc (|
          M.call (|(std.collections.hash.map.HashMap.t
              hash_map_alternate_or_custom_key_types.Account.t
              hash_map_alternate_or_custom_key_types.AccountInfo.t
              std.hash.random.RandomState.t)::["new"]
          |)
        |) in
      let account : M.Val hash_map_alternate_or_custom_key_types.Account.t :=
        M.alloc (|
          {|
            hash_map_alternate_or_custom_key_types.Account.username :=
              M.read (| mk_str "j.everyman" |);
            hash_map_alternate_or_custom_key_types.Account.password :=
              M.read (| mk_str "password123" |);
          |} : hash_map_alternate_or_custom_key_types.Account.t
        |) in
      let account_info :
          M.Val hash_map_alternate_or_custom_key_types.AccountInfo.t :=
        M.alloc (|
          {|
            hash_map_alternate_or_custom_key_types.AccountInfo.name :=
              M.read (| mk_str "John Everyman" |);
            hash_map_alternate_or_custom_key_types.AccountInfo.email :=
              M.read (| mk_str "j.everyman@email.com" |);
          |} : hash_map_alternate_or_custom_key_types.AccountInfo.t
        |) in
      let _ :
          M.Val
            (core.option.Option.t
              hash_map_alternate_or_custom_key_types.AccountInfo.t) :=
        M.alloc (|
          M.call (|((std.collections.hash.map.HashMap.t
                hash_map_alternate_or_custom_key_types.Account.t
                hash_map_alternate_or_custom_key_types.AccountInfo.t
                std.hash.random.RandomState.t)::["insert"]
            (borrow_mut accounts)
            (M.read (| account |))
            (M.read (| account_info |)))
          |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(hash_map_alternate_or_custom_key_types.try_logon
            (borrow accounts)
            (M.read (| mk_str "j.everyman" |))
            (M.read (| mk_str "psasword123" |)))
          |)
        |) in
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(hash_map_alternate_or_custom_key_types.try_logon
            (borrow accounts)
            (M.read (| mk_str "j.everyman" |))
            (M.read (| mk_str "password123" |)))
          |)
        |) in
      M.alloc (| tt |)
    |)
  )).
