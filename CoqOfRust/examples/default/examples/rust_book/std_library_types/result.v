(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module checked.
  Module MathError.
    Inductive t : Set :=
    | DivisionByZero
    | NonPositiveLogarithm
    | NegativeSquareRoot.
  End MathError.
  
  Module  Impl_core_fmt_Debug_for_result_checked_MathError_t.
  Section Impl_core_fmt_Debug_for_result_checked_MathError_t.
    Definition Self : Set := result.checked.MathError.t.
    
    (*
        Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      ltac:(M.monadic ((
        let self := M.alloc (| self |) in
        let f := M.alloc (| f |) in
        M.call (|(core.fmt.Formatter.t::["write_str"]
          (M.read (| f |))
          (M.read (|
            ltac:
              (M.monadic_match_operator
                self
                [
                  fun (γ : M.Val (ref result.checked.MathError.t)) =>
                    (let γ := deref (M.read (| γ |)) in
                    match M.read (| γ |) with
                    | result.checked.MathError.DivisionByZero =>
                      M.alloc (| M.read (| mk_str "DivisionByZero" |) |)
                    | _ => M.break_match(||)
                    end) :
                    M.Val (ref str.t);
                  fun (γ : M.Val (ref result.checked.MathError.t)) =>
                    (let γ := deref (M.read (| γ |)) in
                    match M.read (| γ |) with
                    | result.checked.MathError.NonPositiveLogarithm =>
                      M.alloc (| M.read (| mk_str "NonPositiveLogarithm" |) |)
                    | _ => M.break_match(||)
                    end) :
                    M.Val (ref str.t);
                  fun (γ : M.Val (ref result.checked.MathError.t)) =>
                    (let γ := deref (M.read (| γ |)) in
                    match M.read (| γ |) with
                    | result.checked.MathError.NegativeSquareRoot =>
                      M.alloc (| M.read (| mk_str "NegativeSquareRoot" |) |)
                    | _ => M.break_match(||)
                    end) :
                    M.Val (ref str.t)
                ])
          |)))
        |)
      ) : ltac:(core.fmt.Result))).
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_result_checked_MathError_t.
  End Impl_core_fmt_Debug_for_result_checked_MathError_t.
  
  Ltac MathResult :=
    exact (core.result.Result.t f64.t result.checked.MathError.t).
  
  (*
      pub fn div(x: f64, y: f64) -> MathResult {
          if y == 0.0 {
              // This operation would `fail`, instead let's return the reason of
              // the failure wrapped in `Err`
              Err(MathError::DivisionByZero)
          } else {
              // This operation is valid, return the result wrapped in `Ok`
              Ok(x / y)
          }
      }
  *)
  Definition div (x : f64.t) (y : f64.t) : M ltac:(result.checked.MathResult) :=
    ltac:(M.monadic ((
      let x := M.alloc (| x |) in
      let y := M.alloc (| y |) in
      M.read (|
        if
          M.read (|
            use
              (M.alloc (|
                BinOp.Pure.eq
                  (M.read (| y |))
                  (M.read (| UnsupportedLiteral : M.Val f64.t |))
              |))
          |)
        then
          M.alloc (|
            core.result.Result.Err result.checked.MathError.DivisionByZero
          |)
        else
          M.alloc (|
            core.result.Result.Ok
              (BinOp.Panic.div (| M.read (| x |), M.read (| y |) |))
          |)
      |)
    ) : ltac:(result.checked.MathResult))).
  
  (*
      pub fn sqrt(x: f64) -> MathResult {
          if x < 0.0 {
              Err(MathError::NegativeSquareRoot)
          } else {
              Ok(x.sqrt())
          }
      }
  *)
  Definition sqrt (x : f64.t) : M ltac:(result.checked.MathResult) :=
    ltac:(M.monadic ((
      let x := M.alloc (| x |) in
      M.read (|
        if
          M.read (|
            use
              (M.alloc (|
                BinOp.Pure.lt
                  (M.read (| x |))
                  (M.read (| UnsupportedLiteral : M.Val f64.t |))
              |))
          |)
        then
          M.alloc (|
            core.result.Result.Err result.checked.MathError.NegativeSquareRoot
          |)
        else
          M.alloc (|
            core.result.Result.Ok
              (M.call (|(f64.t::["sqrt"] (M.read (| x |))) |))
          |)
      |)
    ) : ltac:(result.checked.MathResult))).
  
  (*
      pub fn ln(x: f64) -> MathResult {
          if x <= 0.0 {
              Err(MathError::NonPositiveLogarithm)
          } else {
              Ok(x.ln())
          }
      }
  *)
  Definition ln (x : f64.t) : M ltac:(result.checked.MathResult) :=
    ltac:(M.monadic ((
      let x := M.alloc (| x |) in
      M.read (|
        if
          M.read (|
            use
              (M.alloc (|
                BinOp.Pure.le
                  (M.read (| x |))
                  (M.read (| UnsupportedLiteral : M.Val f64.t |))
              |))
          |)
        then
          M.alloc (|
            core.result.Result.Err result.checked.MathError.NonPositiveLogarithm
          |)
        else
          M.alloc (|
            core.result.Result.Ok (M.call (|(f64.t::["ln"] (M.read (| x |))) |))
          |)
      |)
    ) : ltac:(result.checked.MathResult))).
End checked.

(*
fn op(x: f64, y: f64) -> f64 {
    // This is a three level match pyramid!
    match checked::div(x, y) {
        Err(why) => panic!("{:?}", why),
        Ok(ratio) => match checked::ln(ratio) {
            Err(why) => panic!("{:?}", why),
            Ok(ln) => match checked::sqrt(ln) {
                Err(why) => panic!("{:?}", why),
                Ok(sqrt) => sqrt,
            },
        },
    }
}
*)
Definition op (x : f64.t) (y : f64.t) : M f64.t :=
  ltac:(M.monadic ((
    let x := M.alloc (| x |) in
    let y := M.alloc (| y |) in
    M.read (|
      ltac:
        (M.monadic_match_operator
          (M.alloc (|
            M.call (|(result.checked.div (M.read (| x |)) (M.read (| y |))) |)
          |))
          [
            fun
                (γ :
                  M.Val
                    (core.result.Result.t f64.t result.checked.MathError.t)) =>
              match M.read (| γ |) with
              | core.result.Result.Err _ =>
                let γ0_0 := core.result.Result.Get_Err_0 γ in
                let why := M.copy (| γ0_0 |) in
                M.alloc (|
                  (never_to_any (B := f64.t)) (|
                    M.call (|(core.panicking.panic_fmt
                      (M.call (|(core.fmt.Arguments.t::["new_v1"]
                        (pointer_coercion
                          "Unsize"
                          (borrow (M.alloc (| [ M.read (| mk_str "" |) ] |))))
                        (pointer_coercion
                          "Unsize"
                          (borrow
                            (M.alloc (|
                              [
                                M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                                  (borrow why))
                                |)
                              ]
                            |)))))
                      |)))
                    |)
                  |)
                |)
              | _ => M.break_match(||)
              end :
              M.Val f64.t;
            fun
                (γ :
                  M.Val
                    (core.result.Result.t f64.t result.checked.MathError.t)) =>
              match M.read (| γ |) with
              | core.result.Result.Ok _ =>
                let γ0_0 := core.result.Result.Get_Ok_0 γ in
                let ratio := M.copy (| γ0_0 |) in
                ltac:
                  (M.monadic_match_operator
                    (M.alloc (|
                      M.call (|(result.checked.ln (M.read (| ratio |))) |)
                    |))
                    [
                      fun
                          (γ :
                            M.Val
                              (core.result.Result.t
                                f64.t
                                result.checked.MathError.t)) =>
                        match M.read (| γ |) with
                        | core.result.Result.Err _ =>
                          let γ0_0 := core.result.Result.Get_Err_0 γ in
                          let why := M.copy (| γ0_0 |) in
                          M.alloc (|
                            (never_to_any (B := f64.t)) (|
                              M.call (|(core.panicking.panic_fmt
                                (M.call (|(core.fmt.Arguments.t::["new_v1"]
                                  (pointer_coercion
                                    "Unsize"
                                    (borrow
                                      (M.alloc (| [ M.read (| mk_str "" |) ]
                                      |))))
                                  (pointer_coercion
                                    "Unsize"
                                    (borrow
                                      (M.alloc (|
                                        [
                                          M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                                            (borrow why))
                                          |)
                                        ]
                                      |)))))
                                |)))
                              |)
                            |)
                          |)
                        | _ => M.break_match(||)
                        end :
                        M.Val f64.t;
                      fun
                          (γ :
                            M.Val
                              (core.result.Result.t
                                f64.t
                                result.checked.MathError.t)) =>
                        match M.read (| γ |) with
                        | core.result.Result.Ok _ =>
                          let γ0_0 := core.result.Result.Get_Ok_0 γ in
                          let ln := M.copy (| γ0_0 |) in
                          ltac:
                            (M.monadic_match_operator
                              (M.alloc (|
                                M.call (|(result.checked.sqrt (M.read (| ln |)))
                                |)
                              |))
                              [
                                fun
                                    (γ :
                                      M.Val
                                        (core.result.Result.t
                                          f64.t
                                          result.checked.MathError.t)) =>
                                  match M.read (| γ |) with
                                  | core.result.Result.Err _ =>
                                    let γ0_0 :=
                                      core.result.Result.Get_Err_0 γ in
                                    let why := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      (never_to_any (B := f64.t)) (|
                                        M.call (|(core.panicking.panic_fmt
                                          (M.call (|(core.fmt.Arguments.t::["new_v1"]
                                            (pointer_coercion
                                              "Unsize"
                                              (borrow
                                                (M.alloc (|
                                                  [ M.read (| mk_str "" |) ]
                                                |))))
                                            (pointer_coercion
                                              "Unsize"
                                              (borrow
                                                (M.alloc (|
                                                  [
                                                    M.call (|(core.fmt.rt.Argument.t::["new_debug"]
                                                      (borrow why))
                                                    |)
                                                  ]
                                                |)))))
                                          |)))
                                        |)
                                      |)
                                    |)
                                  | _ => M.break_match(||)
                                  end :
                                  M.Val f64.t;
                                fun
                                    (γ :
                                      M.Val
                                        (core.result.Result.t
                                          f64.t
                                          result.checked.MathError.t)) =>
                                  match M.read (| γ |) with
                                  | core.result.Result.Ok _ =>
                                    let γ0_0 := core.result.Result.Get_Ok_0 γ in
                                    let sqrt := M.copy (| γ0_0 |) in
                                    sqrt
                                  | _ => M.break_match(||)
                                  end :
                                  M.Val f64.t
                              ])
                        | _ => M.break_match(||)
                        end :
                        M.Val f64.t
                    ])
              | _ => M.break_match(||)
              end :
              M.Val f64.t
          ])
    |)
  ) : f64.t)).

(*
fn main() {
    // Will this fail?
    println!("{}", op(1.0, 10.0));
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic ((
    M.read (|
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_v1"]
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [ M.read (| mk_str "" |); M.read (| mk_str "
" |) ]
                    |))))
                (pointer_coercion
                  "Unsize"
                  (borrow
                    (M.alloc (|
                      [
                        M.call (|(core.fmt.rt.Argument.t::["new_display"]
                          (borrow
                            (M.alloc (|
                              M.call (|(result.op
                                (M.read (| UnsupportedLiteral : M.Val f64.t |))
                                (M.read (| UnsupportedLiteral : M.Val f64.t |)))
                              |)
                            |))))
                        |)
                      ]
                    |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      M.alloc (| tt |)
    |)
  ) : unit)).
