(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module checked.
  Module MathError.
    Inductive t : Set :=
    | DivisionByZero
    | NonPositiveLogarithm
    | NegativeSquareRoot.
  End MathError.
  
  Module  Impl_core_fmt_Debug_for_result_chaining_with_question_mark_checked_MathError_t.
  Section Impl_core_fmt_Debug_for_result_chaining_with_question_mark_checked_MathError_t.
    Definition Self : Set :=
      result_chaining_with_question_mark.checked.MathError.t.
    
    (*
        Debug
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      ltac:(M.monadic (
        let self := M.alloc (| self |) in
        let f := M.alloc (| f |) in
        M.call (|(core.fmt.Formatter.t::["write_str"]
          (M.read (| f |))
          (M.read (|
            ltac:
              (M.monadic_match_operator
                self
                [
                  fun
                      (γ :
                        M.Val
                          (ref
                            result_chaining_with_question_mark.checked.MathError.t)) =>
                    (let γ := deref (M.read (| γ |)) in
                    match M.read (| γ |) with
                    |
                        result_chaining_with_question_mark.checked.MathError.DivisionByZero
                        =>
                      M.alloc (| M.read (| mk_str "DivisionByZero" |) |)
                    | _ => M.break_match(||)
                    end) :
                    M.Val (ref str.t);
                  fun
                      (γ :
                        M.Val
                          (ref
                            result_chaining_with_question_mark.checked.MathError.t)) =>
                    (let γ := deref (M.read (| γ |)) in
                    match M.read (| γ |) with
                    |
                        result_chaining_with_question_mark.checked.MathError.NonPositiveLogarithm
                        =>
                      M.alloc (| M.read (| mk_str "NonPositiveLogarithm" |) |)
                    | _ => M.break_match(||)
                    end) :
                    M.Val (ref str.t);
                  fun
                      (γ :
                        M.Val
                          (ref
                            result_chaining_with_question_mark.checked.MathError.t)) =>
                    (let γ := deref (M.read (| γ |)) in
                    match M.read (| γ |) with
                    |
                        result_chaining_with_question_mark.checked.MathError.NegativeSquareRoot
                        =>
                      M.alloc (| M.read (| mk_str "NegativeSquareRoot" |) |)
                    | _ => M.break_match(||)
                    end) :
                    M.Val (ref str.t)
                ])
          |)))
        |)
      )).
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_result_chaining_with_question_mark_checked_MathError_t.
  End Impl_core_fmt_Debug_for_result_chaining_with_question_mark_checked_MathError_t.
  
  Ltac MathResult :=
    exact
      (core.result.Result.t
        f64.t
        result_chaining_with_question_mark.checked.MathError.t).
  
  (*
      fn div(x: f64, y: f64) -> MathResult {
          if y == 0.0 {
              Err(MathError::DivisionByZero)
          } else {
              Ok(x / y)
          }
      }
  *)
  Definition div
      (x : f64.t)
      (y : f64.t)
      : M ltac:(result_chaining_with_question_mark.checked.MathResult) :=
    ltac:(M.monadic (
      let x := M.alloc (| x |) in
      let y := M.alloc (| y |) in
      M.read (|
        if
          M.read (|
            use
              (M.alloc (|
                BinOp.Pure.eq
                  (M.read (| y |))
                  (M.read (| UnsupportedLiteral : M.Val f64.t |))
              |))
          |)
        then
          M.alloc (|
            core.result.Result.Err
              result_chaining_with_question_mark.checked.MathError.DivisionByZero
          |)
        else
          M.alloc (|
            core.result.Result.Ok
              (BinOp.Panic.div (| M.read (| x |), M.read (| y |) |))
          |)
      |)
    )).
  
  (*
      fn sqrt(x: f64) -> MathResult {
          if x < 0.0 {
              Err(MathError::NegativeSquareRoot)
          } else {
              Ok(x.sqrt())
          }
      }
  *)
  Definition sqrt
      (x : f64.t)
      : M ltac:(result_chaining_with_question_mark.checked.MathResult) :=
    ltac:(M.monadic (
      let x := M.alloc (| x |) in
      M.read (|
        if
          M.read (|
            use
              (M.alloc (|
                BinOp.Pure.lt
                  (M.read (| x |))
                  (M.read (| UnsupportedLiteral : M.Val f64.t |))
              |))
          |)
        then
          M.alloc (|
            core.result.Result.Err
              result_chaining_with_question_mark.checked.MathError.NegativeSquareRoot
          |)
        else
          M.alloc (|
            core.result.Result.Ok
              (M.call (|(f64.t::["sqrt"] (M.read (| x |))) |))
          |)
      |)
    )).
  
  (*
      fn ln(x: f64) -> MathResult {
          if x <= 0.0 {
              Err(MathError::NonPositiveLogarithm)
          } else {
              Ok(x.ln())
          }
      }
  *)
  Definition ln
      (x : f64.t)
      : M ltac:(result_chaining_with_question_mark.checked.MathResult) :=
    ltac:(M.monadic (
      let x := M.alloc (| x |) in
      M.read (|
        if
          M.read (|
            use
              (M.alloc (|
                BinOp.Pure.le
                  (M.read (| x |))
                  (M.read (| UnsupportedLiteral : M.Val f64.t |))
              |))
          |)
        then
          M.alloc (|
            core.result.Result.Err
              result_chaining_with_question_mark.checked.MathError.NonPositiveLogarithm
          |)
        else
          M.alloc (|
            core.result.Result.Ok (M.call (|(f64.t::["ln"] (M.read (| x |))) |))
          |)
      |)
    )).
  
  (*
      fn op_(x: f64, y: f64) -> MathResult {
          // if `div` "fails", then `DivisionByZero` will be `return`ed
          let ratio = div(x, y)?;
  
          // if `ln` "fails", then `NonPositiveLogarithm` will be `return`ed
          let ln = ln(ratio)?;
  
          sqrt(ln)
      }
  *)
  Definition op_
      (x : f64.t)
      (y : f64.t)
      : M ltac:(result_chaining_with_question_mark.checked.MathResult) :=
    ltac:(M.monadic (
      let x := M.alloc (| x |) in
      let y := M.alloc (| y |) in
      let return_ :=
        M.return_
          (R := ltac:(result_chaining_with_question_mark.checked.MathResult)) in
      M.catch_return
        (M.read (|
          let ratio : M.Val f64.t :=
            M.copy (|
              ltac:
                (M.monadic_match_operator
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.ops.try_trait.Try.branch
                          (Self :=
                            core.result.Result.t
                              f64.t
                              result_chaining_with_question_mark.checked.MathError.t)
                          (Trait := ℐ)))
                      (M.call (|(result_chaining_with_question_mark.checked.div
                        (M.read (| x |))
                        (M.read (| y |)))
                      |)))
                    |)
                  |))
                  [
                    fun
                        (γ :
                          M.Val
                            (core.ops.control_flow.ControlFlow.t
                              (core.result.Result.t
                                core.convert.Infallible.t
                                result_chaining_with_question_mark.checked.MathError.t)
                              f64.t)) =>
                      match M.read (| γ |) with
                      | core.ops.control_flow.ControlFlow.Break _ =>
                        let γ0_0 :=
                          core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                        let residual := M.copy (| γ0_0 |) in
                        M.alloc (|
                          never_to_any (|
                            M.read (|
                              return_
                                (M.call (|(ltac:(M.get_method (fun ℐ =>
                                    core.ops.try_trait.FromResidual.from_residual
                                      (Self :=
                                        core.result.Result.t
                                          f64.t
                                          result_chaining_with_question_mark.checked.MathError.t)
                                      (R :=
                                        core.result.Result.t
                                          core.convert.Infallible.t
                                          result_chaining_with_question_mark.checked.MathError.t)
                                      (Trait := ℐ)))
                                  (M.read (| residual |)))
                                |))
                            |)
                          |)
                        |)
                      | _ => M.break_match(||)
                      end :
                      M.Val f64.t;
                    fun
                        (γ :
                          M.Val
                            (core.ops.control_flow.ControlFlow.t
                              (core.result.Result.t
                                core.convert.Infallible.t
                                result_chaining_with_question_mark.checked.MathError.t)
                              f64.t)) =>
                      match M.read (| γ |) with
                      | core.ops.control_flow.ControlFlow.Continue _ =>
                        let γ0_0 :=
                          core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                        let val := M.copy (| γ0_0 |) in
                        val
                      | _ => M.break_match(||)
                      end :
                      M.Val f64.t
                  ])
            |) in
          let ln : M.Val f64.t :=
            M.copy (|
              ltac:
                (M.monadic_match_operator
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.ops.try_trait.Try.branch
                          (Self :=
                            core.result.Result.t
                              f64.t
                              result_chaining_with_question_mark.checked.MathError.t)
                          (Trait := ℐ)))
                      (M.call (|(result_chaining_with_question_mark.checked.ln
                        (M.read (| ratio |)))
                      |)))
                    |)
                  |))
                  [
                    fun
                        (γ :
                          M.Val
                            (core.ops.control_flow.ControlFlow.t
                              (core.result.Result.t
                                core.convert.Infallible.t
                                result_chaining_with_question_mark.checked.MathError.t)
                              f64.t)) =>
                      match M.read (| γ |) with
                      | core.ops.control_flow.ControlFlow.Break _ =>
                        let γ0_0 :=
                          core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                        let residual := M.copy (| γ0_0 |) in
                        M.alloc (|
                          never_to_any (|
                            M.read (|
                              return_
                                (M.call (|(ltac:(M.get_method (fun ℐ =>
                                    core.ops.try_trait.FromResidual.from_residual
                                      (Self :=
                                        core.result.Result.t
                                          f64.t
                                          result_chaining_with_question_mark.checked.MathError.t)
                                      (R :=
                                        core.result.Result.t
                                          core.convert.Infallible.t
                                          result_chaining_with_question_mark.checked.MathError.t)
                                      (Trait := ℐ)))
                                  (M.read (| residual |)))
                                |))
                            |)
                          |)
                        |)
                      | _ => M.break_match(||)
                      end :
                      M.Val f64.t;
                    fun
                        (γ :
                          M.Val
                            (core.ops.control_flow.ControlFlow.t
                              (core.result.Result.t
                                core.convert.Infallible.t
                                result_chaining_with_question_mark.checked.MathError.t)
                              f64.t)) =>
                      match M.read (| γ |) with
                      | core.ops.control_flow.ControlFlow.Continue _ =>
                        let γ0_0 :=
                          core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                        let val := M.copy (| γ0_0 |) in
                        val
                      | _ => M.break_match(||)
                      end :
                      M.Val f64.t
                  ])
            |) in
          M.alloc (|
            M.call (|(result_chaining_with_question_mark.checked.sqrt
              (M.read (| ln |)))
            |)
          |)
        |))
    )).
  
  (*
      pub fn op(x: f64, y: f64) {
          match op_(x, y) {
              Err(why) => panic!(
                  "{}",
                  match why {
                      MathError::NonPositiveLogarithm => "logarithm of non-positive number",
                      MathError::DivisionByZero => "division by zero",
                      MathError::NegativeSquareRoot => "square root of negative number",
                  }
              ),
              Ok(value) => println!("{}", value),
          }
      }
  *)
  Definition op (x : f64.t) (y : f64.t) : M unit :=
    ltac:(M.monadic (
      let x := M.alloc (| x |) in
      let y := M.alloc (| y |) in
      M.read (|
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              M.call (|(result_chaining_with_question_mark.checked.op_
                (M.read (| x |))
                (M.read (| y |)))
              |)
            |))
            [
              fun
                  (γ :
                    M.Val
                      (core.result.Result.t
                        f64.t
                        result_chaining_with_question_mark.checked.MathError.t)) =>
                match M.read (| γ |) with
                | core.result.Result.Err _ =>
                  let γ0_0 := core.result.Result.Get_Err_0 γ in
                  let why := M.copy (| γ0_0 |) in
                  M.alloc (|
                    never_to_any (|
                      M.call (|(core.panicking.panic_display
                        (borrow
                          (ltac:
                            (M.monadic_match_operator
                              why
                              [
                                fun
                                    (γ :
                                      M.Val
                                        result_chaining_with_question_mark.checked.MathError.t) =>
                                  match M.read (| γ |) with
                                  |
                                      result_chaining_with_question_mark.checked.MathError.NonPositiveLogarithm
                                      =>
                                    mk_str "logarithm of non-positive number"
                                  | _ => M.break_match(||)
                                  end :
                                  M.Val (ref str.t);
                                fun
                                    (γ :
                                      M.Val
                                        result_chaining_with_question_mark.checked.MathError.t) =>
                                  match M.read (| γ |) with
                                  |
                                      result_chaining_with_question_mark.checked.MathError.DivisionByZero
                                      =>
                                    M.alloc (|
                                      M.read (| mk_str "division by zero" |)
                                    |)
                                  | _ => M.break_match(||)
                                  end :
                                  M.Val (ref str.t);
                                fun
                                    (γ :
                                      M.Val
                                        result_chaining_with_question_mark.checked.MathError.t) =>
                                  match M.read (| γ |) with
                                  |
                                      result_chaining_with_question_mark.checked.MathError.NegativeSquareRoot
                                      =>
                                    M.alloc (|
                                      M.read (|
                                        mk_str "square root of negative number"
                                      |)
                                    |)
                                  | _ => M.break_match(||)
                                  end :
                                  M.Val (ref str.t)
                              ]))))
                      |)
                    |)
                  |)
                | _ => M.break_match(||)
                end :
                M.Val unit;
              fun
                  (γ :
                    M.Val
                      (core.result.Result.t
                        f64.t
                        result_chaining_with_question_mark.checked.MathError.t)) =>
                match M.read (| γ |) with
                | core.result.Result.Ok _ =>
                  let γ0_0 := core.result.Result.Get_Ok_0 γ in
                  let value := M.copy (| γ0_0 |) in
                  let _ : M.Val unit :=
                    M.alloc (|
                      M.call (|(std.io.stdio._print
                        (M.call (|(core.fmt.Arguments.t::["new_v1"]
                          (pointer_coercion
                            "Unsize"
                            (borrow
                              (M.alloc (|
                                [
                                  M.read (| mk_str "" |);
                                  M.read (| mk_str "
" |)
                                ]
                              |))))
                          (pointer_coercion
                            "Unsize"
                            (borrow
                              (M.alloc (|
                                [
                                  M.call (|(core.fmt.rt.Argument.t::["new_display"]
                                    (borrow value))
                                  |)
                                ]
                              |)))))
                        |)))
                      |)
                    |) in
                  M.alloc (| tt |)
                | _ => M.break_match(||)
                end :
                M.Val unit
            ])
      |)
    )).
End checked.

(*
fn main() {
    checked::op(1.0, 10.0);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic (
    M.read (|
      let _ : M.Val unit :=
        M.alloc (|
          M.call (|(result_chaining_with_question_mark.checked.op
            (M.read (| UnsupportedLiteral : M.Val f64.t |))
            (M.read (| UnsupportedLiteral : M.Val f64.t |)))
          |)
        |) in
      M.alloc (| tt |)
    |)
  )).
