(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn main() {
    // Note that this is not actually a `&str`
    let bytestring: &[u8; 21] = b"this is a byte string";

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!("A byte string: {:?}", bytestring);

    // Byte strings can have byte escapes...
    let escaped = b"\x52\x75\x73\x74 as bytes";
    // ...but no unicode escapes
    // let escaped = b"\u{211D} is not allowed";
    println!("Some escaped bytes: {:?}", escaped);

    // Raw byte strings work just like raw strings
    let raw_bytestring = br"\u{211D} is not escaped here";
    println!("{:?}", raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!("And the same as text: '{}'", my_str);
    }

    let _quotes = br#"You can also use "fancier" formatting, \
                    like with normal raw strings"#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b"\x82\xe6\x82\xa8\x82\xb1\x82\xbb"; // "ã‚ˆã†ã“ã" in SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) => println!("Conversion successful: '{}'", my_str),
        Err(e) => println!("Conversion failed: {:?}", e),
    };
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [], [] =>
    let* bytestring :=
      let* Î±0 :=
        M.read
          (UnsupportedLiteral :
            Ty.apply
              (Ty.path "ref")
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]) in
      M.alloc Î±0 in
    let* _ :=
      let* _ :=
        let* Î±0 := M.read (mk_str "A byte string: ") in
        let* Î±1 := M.read (mk_str "
") in
        let* Î±2 := M.alloc [ Î±0; Î±1 ] in
        let* Î±3 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_debug"]
            [ borrow bytestring ] in
        let* Î±4 := M.alloc [ Î±3 ] in
        let* Î±5 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±2);
              pointer_coercion "Unsize" (borrow Î±4)
            ] in
        let* Î±6 := M.call (M.var "std::io::stdio::_print") [ Î±5 ] in
        M.alloc Î±6 in
      M.alloc tt in
    let* escaped :=
      M.copy
        (UnsupportedLiteral :
          Ty.apply
            (Ty.path "ref")
            [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]) in
    let* _ :=
      let* _ :=
        let* Î±0 := M.read (mk_str "Some escaped bytes: ") in
        let* Î±1 := M.read (mk_str "
") in
        let* Î±2 := M.alloc [ Î±0; Î±1 ] in
        let* Î±3 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_debug"]
            [ borrow escaped ] in
        let* Î±4 := M.alloc [ Î±3 ] in
        let* Î±5 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±2);
              pointer_coercion "Unsize" (borrow Î±4)
            ] in
        let* Î±6 := M.call (M.var "std::io::stdio::_print") [ Î±5 ] in
        M.alloc Î±6 in
      M.alloc tt in
    let* raw_bytestring :=
      M.copy
        (UnsupportedLiteral :
          Ty.apply
            (Ty.path "ref")
            [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]) in
    let* _ :=
      let* _ :=
        let* Î±0 := M.read (mk_str "") in
        let* Î±1 := M.read (mk_str "
") in
        let* Î±2 := M.alloc [ Î±0; Î±1 ] in
        let* Î±3 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_debug"]
            [ borrow raw_bytestring ] in
        let* Î±4 := M.alloc [ Î±3 ] in
        let* Î±5 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [
              pointer_coercion "Unsize" (borrow Î±2);
              pointer_coercion "Unsize" (borrow Î±4)
            ] in
        let* Î±6 := M.call (M.var "std::io::stdio::_print") [ Î±5 ] in
        M.alloc Î±6 in
      M.alloc tt in
    let* _ :=
      let* Î±0 := M.read raw_bytestring in
      let* Î±1 :=
        M.call
          (M.var "core::str::converts::from_utf8")
          [ pointer_coercion "Unsize" Î±0 ] in
      let* Î±2 := M.alloc Î±1 in
      match_operator
        Î±2
        [
          fun Î³ =>
            (let* Î±0 := M.read Î³ in
            match Î±0 with
            | core.result.Result.Ok _ =>
              let Î³0_0 := (M.var "core::result::Result::Get_Ok_0") Î³ in
              let* my_str := M.copy Î³0_0 in
              let* _ :=
                let* _ :=
                  let* Î±0 := M.read (mk_str "And the same as text: '") in
                  let* Î±1 := M.read (mk_str "'
") in
                  let* Î±2 := M.alloc [ Î±0; Î±1 ] in
                  let* Î±3 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_display"]
                      [ borrow my_str ] in
                  let* Î±4 := M.alloc [ Î±3 ] in
                  let* Î±5 :=
                    M.call
                      (Ty.path "core::fmt::Arguments")::["new_v1"]
                      [
                        pointer_coercion "Unsize" (borrow Î±2);
                        pointer_coercion "Unsize" (borrow Î±4)
                      ] in
                  let* Î±6 := M.call (M.var "std::io::stdio::_print") [ Î±5 ] in
                  M.alloc Î±6 in
                M.alloc tt in
              M.alloc tt
            | _ => M.break_match 
            end) :
            Ty.tuple [];
          fun Î³ => (M.alloc tt) : Ty.path "unit"
        ] in
    let* _quotes :=
      M.copy
        (UnsupportedLiteral :
          Ty.apply
            (Ty.path "ref")
            [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]) in
    let* shift_jis :=
      M.copy
        (UnsupportedLiteral :
          Ty.apply
            (Ty.path "ref")
            [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]) in
    let* _ :=
      let* Î±0 := M.read shift_jis in
      let* Î±1 :=
        M.call
          (M.var "core::str::converts::from_utf8")
          [ pointer_coercion "Unsize" Î±0 ] in
      let* Î±2 := M.alloc Î±1 in
      match_operator
        Î±2
        [
          fun Î³ =>
            (let* Î±0 := M.read Î³ in
            match Î±0 with
            | core.result.Result.Ok _ =>
              let Î³0_0 := (M.var "core::result::Result::Get_Ok_0") Î³ in
              let* my_str := M.copy Î³0_0 in
              let* _ :=
                let* Î±0 := M.read (mk_str "Conversion successful: '") in
                let* Î±1 := M.read (mk_str "'
") in
                let* Î±2 := M.alloc [ Î±0; Î±1 ] in
                let* Î±3 :=
                  M.call
                    (Ty.path "core::fmt::rt::Argument")::["new_display"]
                    [ borrow my_str ] in
                let* Î±4 := M.alloc [ Î±3 ] in
                let* Î±5 :=
                  M.call
                    (Ty.path "core::fmt::Arguments")::["new_v1"]
                    [
                      pointer_coercion "Unsize" (borrow Î±2);
                      pointer_coercion "Unsize" (borrow Î±4)
                    ] in
                let* Î±6 := M.call (M.var "std::io::stdio::_print") [ Î±5 ] in
                M.alloc Î±6 in
              M.alloc tt
            | _ => M.break_match 
            end) :
            Ty.tuple [];
          fun Î³ =>
            (let* Î±0 := M.read Î³ in
            match Î±0 with
            | core.result.Result.Err _ =>
              let Î³0_0 := (M.var "core::result::Result::Get_Err_0") Î³ in
              let* e := M.copy Î³0_0 in
              let* _ :=
                let* Î±0 := M.read (mk_str "Conversion failed: ") in
                let* Î±1 := M.read (mk_str "
") in
                let* Î±2 := M.alloc [ Î±0; Î±1 ] in
                let* Î±3 :=
                  M.call
                    (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                    [ borrow e ] in
                let* Î±4 := M.alloc [ Î±3 ] in
                let* Î±5 :=
                  M.call
                    (Ty.path "core::fmt::Arguments")::["new_v1"]
                    [
                      pointer_coercion "Unsize" (borrow Î±2);
                      pointer_coercion "Unsize" (borrow Î±4)
                    ] in
                let* Î±6 := M.call (M.var "std::io::stdio::_print") [ Î±5 ] in
                M.alloc Î±6 in
              M.alloc tt
            | _ => M.break_match 
            end) :
            Ty.tuple []
        ] in
    let* Î±0 := M.alloc tt in
    M.read Î±0
  | _, _ => M.impossible
  end.
