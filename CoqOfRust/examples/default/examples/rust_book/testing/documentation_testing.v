(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
*)
Definition add (τ : list Ty.t) (α : list A.t) : M :=
  match τ, α with
  | [], [ a; b ] =>
    ltac:(M.monadic
      (let a := M.alloc (| a |) in
      let b := M.alloc (| b |) in
      BinOp.Panic.add (| Integer.I32, M.read (| a |), M.read (| b |) |)))
  | _, _ => M.impossible
  end.

(*
pub fn div(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    }

    a / b
}
*)
Definition div (τ : list Ty.t) (α : list A.t) : M :=
  match τ, α with
  | [], [ a; b ] =>
    ltac:(M.monadic
      (let a := M.alloc (| a |) in
      let b := M.alloc (| b |) in
      M.read (|
        let _ :=
          M.match_operator (|
            M.alloc (| M.of_value (| Value.Tuple [] |) |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        BinOp.Pure.eq (| M.read (| b |), M.of_value (| Value.Integer 0 |) |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (|
                          "std::panicking::begin_panic",
                          [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                        |),
                        [ M.read (| M.of_value (| Value.String "Divide-by-zero error" |) |) ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| M.of_value (| Value.Tuple [] |) |)))
            ]
          |) in
        M.alloc (| BinOp.Panic.div (| Integer.I32, M.read (| a |), M.read (| b |) |) |)
      |)))
  | _, _ => M.impossible
  end.
