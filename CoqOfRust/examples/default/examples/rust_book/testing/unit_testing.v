(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
*)
Definition add (τ : list Ty.t) (α : list Value.t) : M :=
  match τ, α with
  | [], [ a; b ] =>
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* α0 := M.read a in
    let* α1 := M.read b in
    BinOp.Panic.add α0 α1
  | _, _ => M.impossible
  end.

(*
fn bad_add(a: i32, b: i32) -> i32 {
    a - b
}
*)
Definition bad_add (τ : list Ty.t) (α : list Value.t) : M :=
  match τ, α with
  | [], [ a; b ] =>
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* α0 := M.read a in
    let* α1 := M.read b in
    BinOp.Panic.sub α0 α1
  | _, _ => M.impossible
  end.

Module tests.
  (*
      fn test_add() {
          assert_eq!(add(1, 2), 3);
      }
  *)
  Definition test_add (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* _ :=
        let* α0 := M.get_function "unit_testing::add" [] [] in
        let* α1 := M.call_closure α0 [ Value.Integer Integer.I32 1; Value.Integer Integer.I32 2 ] in
        let* α2 := M.alloc α1 in
        let* α3 := M.alloc (Value.Integer Integer.I32 3) in
        let* α4 := M.alloc (Value.Tuple [ α2; α3 ]) in
        M.match_operator
          α4
          [
            fun γ =>
              let γ0_0 := M.get_tuple_field γ 0 in
              let γ0_1 := M.get_tuple_field γ 1 in
              let* left_val := M.copy γ0_0 in
              let* right_val := M.copy γ0_1 in
              let* α0 := M.alloc (Value.Tuple []) in
              M.match_operator
                α0
                [
                  fun γ =>
                    let* γ :=
                      let* α0 := M.read left_val in
                      let* α1 := M.read α0 in
                      let* α2 := M.read right_val in
                      let* α3 := M.read α2 in
                      let* α4 := M.alloc (UnOp.Pure.not (BinOp.Pure.eq α1 α3)) in
                      M.pure (M.use α4) in
                    let* _ :=
                      let* α0 := M.read γ in
                      M.is_constant_or_break_match α0 (Value.Bool true) in
                    let* kind := M.alloc (Value.StructTuple "core::panicking::AssertKind::Eq" []) in
                    let* α0 :=
                      M.get_function
                        "core::panicking::assert_failed"
                        [ Ty.path "i32"; Ty.path "i32" ]
                        [] in
                    let* α1 := M.read kind in
                    let* α2 := M.read left_val in
                    let* α3 := M.read right_val in
                    let* α4 :=
                      M.call_closure
                        α0
                        [ α1; α2; α3; Value.StructTuple "core::option::Option::None" [] ] in
                    let* α0 := M.alloc α4 in
                    let* α1 := M.read α0 in
                    let* α2 := M.never_to_any α1 in
                    M.alloc α2;
                  fun γ => M.alloc (Value.Tuple [])
                ]
          ] in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
      fn test_bad_add() {
          // This assert would fire and test will fail.
          // Please note, that private functions can be tested too!
          assert_eq!(bad_add(1, 2), 3);
      }
  *)
  Definition test_bad_add (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      let* _ :=
        let* α0 := M.get_function "unit_testing::bad_add" [] [] in
        let* α1 := M.call_closure α0 [ Value.Integer Integer.I32 1; Value.Integer Integer.I32 2 ] in
        let* α2 := M.alloc α1 in
        let* α3 := M.alloc (Value.Integer Integer.I32 3) in
        let* α4 := M.alloc (Value.Tuple [ α2; α3 ]) in
        M.match_operator
          α4
          [
            fun γ =>
              let γ0_0 := M.get_tuple_field γ 0 in
              let γ0_1 := M.get_tuple_field γ 1 in
              let* left_val := M.copy γ0_0 in
              let* right_val := M.copy γ0_1 in
              let* α0 := M.alloc (Value.Tuple []) in
              M.match_operator
                α0
                [
                  fun γ =>
                    let* γ :=
                      let* α0 := M.read left_val in
                      let* α1 := M.read α0 in
                      let* α2 := M.read right_val in
                      let* α3 := M.read α2 in
                      let* α4 := M.alloc (UnOp.Pure.not (BinOp.Pure.eq α1 α3)) in
                      M.pure (M.use α4) in
                    let* _ :=
                      let* α0 := M.read γ in
                      M.is_constant_or_break_match α0 (Value.Bool true) in
                    let* kind := M.alloc (Value.StructTuple "core::panicking::AssertKind::Eq" []) in
                    let* α0 :=
                      M.get_function
                        "core::panicking::assert_failed"
                        [ Ty.path "i32"; Ty.path "i32" ]
                        [] in
                    let* α1 := M.read kind in
                    let* α2 := M.read left_val in
                    let* α3 := M.read right_val in
                    let* α4 :=
                      M.call_closure
                        α0
                        [ α1; α2; α3; Value.StructTuple "core::option::Option::None" [] ] in
                    let* α0 := M.alloc α4 in
                    let* α1 := M.read α0 in
                    let* α2 := M.never_to_any α1 in
                    M.alloc α2;
                  fun γ => M.alloc (Value.Tuple [])
                ]
          ] in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
End tests.
