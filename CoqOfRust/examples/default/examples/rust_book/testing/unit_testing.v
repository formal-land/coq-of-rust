(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
*)
Definition add (a : i32.t) (b : i32.t) : M i32.t :=
  ltac:(M.monadic ((
    let a := M.alloc (| a |) in
    let b := M.alloc (| b |) in
    BinOp.Panic.add (| M.read (| a |), M.read (| b |) |)
  ) : i32.t)).

(*
fn bad_add(a: i32, b: i32) -> i32 {
    a - b
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition bad_add (a : i32.t) (b : i32.t) : M i32.t :=
  ltac:(M.monadic ((
    let a := M.alloc (| a |) in
    let b := M.alloc (| b |) in
    BinOp.Panic.sub (| M.read (| a |), M.read (| b |) |)
  ) : i32.t)).

Module tests.
  (*
      fn test_add() {
          assert_eq!(add(1, 2), 3);
      }
  *)
  Definition test_add : M unit :=
    ltac:(M.monadic ((
      M.read (|
        let _ : M.Val unit :=
          ltac:
            (M.monadic_match_operator
              (M.alloc (|
                (borrow
                    (M.alloc (|
                      M.call (|(unit_testing.add
                        ((Integer.of_Z 1) : i32.t)
                        ((Integer.of_Z 2) : i32.t))
                      |)
                    |)),
                  borrow (M.alloc (| (Integer.of_Z 3) : i32.t |)))
              |))
              [
                fun (γ : M.Val ((ref i32.t) * (ref i32.t))) =>
                  match M.read (| γ |) with
                  | (_, _) =>
                    let γ0_0 := Tuple.Access.left γ in
                    let γ0_1 := Tuple.Access.right γ in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    if
                      M.read (|
                        use
                          (M.alloc (|
                            UnOp.not
                              (BinOp.Pure.eq
                                (M.read (| deref (M.read (| left_val |)) |))
                                (M.read (| deref (M.read (| right_val |)) |)))
                          |))
                      |)
                    then
                      M.alloc (|
                        (never_to_any (B := unit)) (|
                          M.read (|
                            let kind : M.Val core.panicking.AssertKind.t :=
                              M.alloc (| core.panicking.AssertKind.Eq |) in
                            M.alloc (|
                              M.call (|(core.panicking.assert_failed
                                (M.read (| kind |))
                                (M.read (| left_val |))
                                (M.read (| right_val |))
                                core.option.Option.None)
                              |)
                            |)
                          |)
                        |)
                      |)
                    else
                      M.alloc (| tt |)
                  end :
                  M.Val unit
              ]) in
        M.alloc (| tt |)
      |)
    ) : unit)).
  
  (*
      fn test_bad_add() {
          // This assert would fire and test will fail.
          // Please note, that private functions can be tested too!
          assert_eq!(bad_add(1, 2), 3);
      }
  *)
  Definition test_bad_add : M unit :=
    ltac:(M.monadic ((
      M.read (|
        let _ : M.Val unit :=
          ltac:
            (M.monadic_match_operator
              (M.alloc (|
                (borrow
                    (M.alloc (|
                      M.call (|(unit_testing.bad_add
                        ((Integer.of_Z 1) : i32.t)
                        ((Integer.of_Z 2) : i32.t))
                      |)
                    |)),
                  borrow (M.alloc (| (Integer.of_Z 3) : i32.t |)))
              |))
              [
                fun (γ : M.Val ((ref i32.t) * (ref i32.t))) =>
                  match M.read (| γ |) with
                  | (_, _) =>
                    let γ0_0 := Tuple.Access.left γ in
                    let γ0_1 := Tuple.Access.right γ in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    if
                      M.read (|
                        use
                          (M.alloc (|
                            UnOp.not
                              (BinOp.Pure.eq
                                (M.read (| deref (M.read (| left_val |)) |))
                                (M.read (| deref (M.read (| right_val |)) |)))
                          |))
                      |)
                    then
                      M.alloc (|
                        (never_to_any (B := unit)) (|
                          M.read (|
                            let kind : M.Val core.panicking.AssertKind.t :=
                              M.alloc (| core.panicking.AssertKind.Eq |) in
                            M.alloc (|
                              M.call (|(core.panicking.assert_failed
                                (M.read (| kind |))
                                (M.read (| left_val |))
                                (M.read (| right_val |))
                                core.option.Option.None)
                              |)
                            |)
                          |)
                        |)
                      |)
                    else
                      M.alloc (| tt |)
                  end :
                  M.Val unit
              ]) in
        M.alloc (| tt |)
      |)
    ) : unit)).
End tests.
