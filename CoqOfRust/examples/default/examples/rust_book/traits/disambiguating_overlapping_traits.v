(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  UsernameWidget.
Section UsernameWidget.
  Class Trait (Self : Set) : Type := {
    get : (ref Self) -> M alloc.string.String.t;
  }.
  
End UsernameWidget.
End UsernameWidget.

Module  AgeWidget.
Section AgeWidget.
  Class Trait (Self : Set) : Type := {
    get : (ref Self) -> M u8.t;
  }.
  
End AgeWidget.
End AgeWidget.

Module  Form.
Section Form.
  Record t : Set := {
    username : alloc.string.String.t;
    age : u8.t;
  }.
  
  Definition Get_username :=
    Ref.map
      (fun α => Some α.(username))
      (fun β α => Some (α <| username := β |>)).
  Definition Get_age :=
    Ref.map (fun α => Some α.(age)) (fun β α => Some (α <| age := β |>)).
End Form.
End Form.

Module  Impl_disambiguating_overlapping_traits_UsernameWidget_for_disambiguating_overlapping_traits_Form_t.
Section Impl_disambiguating_overlapping_traits_UsernameWidget_for_disambiguating_overlapping_traits_Form_t.
  Definition Self : Set := disambiguating_overlapping_traits.Form.t.
  
  (*
      fn get(&self) -> String {
          self.username.clone()
      }
  *)
  Definition get (self : ref Self) : M alloc.string.String.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.call (|(ltac:(M.get_method (fun ℐ =>
          core.clone.Clone.clone (Self := alloc.string.String.t) (Trait := ℐ)))
        (borrow
          (disambiguating_overlapping_traits.Form.Get_username
            (deref (M.read (| self |))))))
      |)
    ) : alloc.string.String.t)).
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  Global Instance ℐ :
    disambiguating_overlapping_traits.UsernameWidget.Trait Self := {
    disambiguating_overlapping_traits.UsernameWidget.get := get;
  }.
End Impl_disambiguating_overlapping_traits_UsernameWidget_for_disambiguating_overlapping_traits_Form_t.
End Impl_disambiguating_overlapping_traits_UsernameWidget_for_disambiguating_overlapping_traits_Form_t.

Module  Impl_disambiguating_overlapping_traits_AgeWidget_for_disambiguating_overlapping_traits_Form_t.
Section Impl_disambiguating_overlapping_traits_AgeWidget_for_disambiguating_overlapping_traits_Form_t.
  Definition Self : Set := disambiguating_overlapping_traits.Form.t.
  
  (*
      fn get(&self) -> u8 {
          self.age
      }
  *)
  Definition get (self : ref Self) : M u8.t :=
    ltac:(M.monadic ((
      let self := M.alloc (| self |) in
      M.read (|
        disambiguating_overlapping_traits.Form.Get_age
          (deref (M.read (| self |)))
      |)
    ) : u8.t)).
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  Global Instance ℐ :
    disambiguating_overlapping_traits.AgeWidget.Trait Self := {
    disambiguating_overlapping_traits.AgeWidget.get := get;
  }.
End Impl_disambiguating_overlapping_traits_AgeWidget_for_disambiguating_overlapping_traits_Form_t.
End Impl_disambiguating_overlapping_traits_AgeWidget_for_disambiguating_overlapping_traits_Form_t.

(*
fn main() {
    let form = Form {
        username: "rustacean".to_owned(),
        age: 28,
    };

    // If you uncomment this line, you'll get an error saying
    // "multiple `get` found". Because, after all, there are multiple methods
    // named `get`.
    // println!("{}", form.get());

    let username = <Form as UsernameWidget>::get(&form);
    assert_eq!(("rustacean".to_string()), username);
    let age = <Form as AgeWidget>::get(&form);
    assert_eq!(28, age);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic ((
    M.read (|
      let form : M.Val disambiguating_overlapping_traits.Form.t :=
        M.alloc (|
          {|
            disambiguating_overlapping_traits.Form.username :=
              M.call (|(ltac:(M.get_method (fun ℐ =>
                  alloc.borrow.ToOwned.to_owned (Self := str.t) (Trait := ℐ)))
                (M.read (| mk_str "rustacean" |)))
              |);
            disambiguating_overlapping_traits.Form.age :=
              (Integer.of_Z 28) : u8.t;
          |} : disambiguating_overlapping_traits.Form.t
        |) in
      let username : M.Val alloc.string.String.t :=
        M.alloc (|
          M.call (|(ltac:(M.get_method (fun ℐ =>
              disambiguating_overlapping_traits.UsernameWidget.get
                (Self := disambiguating_overlapping_traits.Form.t)
                (Trait := ℐ)))
            (borrow form))
          |)
        |) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        alloc.string.ToString.to_string
                          (Self := str.t)
                          (Trait := ℐ)))
                      (M.read (| mk_str "rustacean" |)))
                    |)
                  |)),
                borrow username)
            |))
            [
              fun
                  (γ :
                    M.Val
                      ((ref alloc.string.String.t)
                      *
                      (ref alloc.string.String.t))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.cmp.PartialEq.eq
                                  (Self := alloc.string.String.t)
                                  (Rhs := alloc.string.String.t)
                                  (Trait := ℐ)))
                              (M.read (| left_val |))
                              (M.read (| right_val |)))
                            |))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      let age : M.Val u8.t :=
        M.alloc (|
          M.call (|(ltac:(M.get_method (fun ℐ =>
              disambiguating_overlapping_traits.AgeWidget.get
                (Self := disambiguating_overlapping_traits.Form.t)
                (Trait := ℐ)))
            (borrow form))
          |)
        |) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow (M.alloc (| (Integer.of_Z 28) : u8.t |)), borrow age)
            |))
            [
              fun (γ : M.Val ((ref u8.t) * (ref u8.t))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (BinOp.Pure.eq
                              (M.read (| deref (M.read (| left_val |)) |))
                              (M.read (| deref (M.read (| right_val |)) |)))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      M.alloc (| tt |)
    |)
  ) : unit)).
