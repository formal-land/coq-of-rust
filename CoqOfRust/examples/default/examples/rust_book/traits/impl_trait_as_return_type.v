(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn combine_vecs_explicit_return_type(
    v: Vec<i32>,
    u: Vec<i32>,
) -> iter::Cycle<iter::Chain<IntoIter<i32>, IntoIter<i32>>> {
    v.into_iter().chain(u.into_iter()).cycle()
}
*)
Definition combine_vecs_explicit_return_type
    (v : alloc.vec.Vec.t i32.t alloc.vec.Vec.Default.A)
    (u : alloc.vec.Vec.t i32.t alloc.vec.Vec.Default.A)
    :
      M
        (core.iter.adapters.cycle.Cycle.t
          (core.iter.adapters.chain.Chain.t
            (alloc.vec.into_iter.IntoIter.t
              i32.t
              alloc.vec.into_iter.IntoIter.Default.A)
            (alloc.vec.into_iter.IntoIter.t
              i32.t
              alloc.vec.into_iter.IntoIter.Default.A))) :=
  ltac:(M.monadic (
    let v := M.alloc (| v |) in
    let u := M.alloc (| u |) in
    M.call (|(ltac:(M.get_method (fun ℐ =>
        core.iter.traits.iterator.Iterator.cycle
          (Self :=
            core.iter.adapters.chain.Chain.t
              (alloc.vec.into_iter.IntoIter.t i32.t alloc.alloc.Global.t)
              (alloc.vec.into_iter.IntoIter.t i32.t alloc.alloc.Global.t))
          (Trait := ℐ)))
      (M.call (|(ltac:(M.get_method (fun ℐ =>
          core.iter.traits.iterator.Iterator.chain
            (Self := alloc.vec.into_iter.IntoIter.t i32.t alloc.alloc.Global.t)
            (U := alloc.vec.into_iter.IntoIter.t i32.t alloc.alloc.Global.t)
            (Trait := ℐ)))
        (M.call (|(ltac:(M.get_method (fun ℐ =>
            core.iter.traits.collect.IntoIterator.into_iter
              (Self := alloc.vec.Vec.t i32.t alloc.alloc.Global.t)
              (Trait := ℐ)))
          (M.read (| v |)))
        |))
        (M.call (|(ltac:(M.get_method (fun ℐ =>
            core.iter.traits.collect.IntoIterator.into_iter
              (Self := alloc.vec.Vec.t i32.t alloc.alloc.Global.t)
              (Trait := ℐ)))
          (M.read (| u |)))
        |)))
      |)))
    |)
  )).

(*
fn combine_vecs(v: Vec<i32>, u: Vec<i32>) -> impl Iterator<Item = i32> {
    v.into_iter().chain(u.into_iter()).cycle()
}
*)
Definition combine_vecs
    (v : alloc.vec.Vec.t i32.t alloc.vec.Vec.Default.A)
    (u : alloc.vec.Vec.t i32.t alloc.vec.Vec.Default.A)
    : M _ (* OpaqueTy *) :=
  ltac:(M.monadic (
    let v := M.alloc (| v |) in
    let u := M.alloc (| u |) in
    M.call (|(ltac:(M.get_method (fun ℐ =>
        core.iter.traits.iterator.Iterator.cycle
          (Self :=
            core.iter.adapters.chain.Chain.t
              (alloc.vec.into_iter.IntoIter.t i32.t alloc.alloc.Global.t)
              (alloc.vec.into_iter.IntoIter.t i32.t alloc.alloc.Global.t))
          (Trait := ℐ)))
      (M.call (|(ltac:(M.get_method (fun ℐ =>
          core.iter.traits.iterator.Iterator.chain
            (Self := alloc.vec.into_iter.IntoIter.t i32.t alloc.alloc.Global.t)
            (U := alloc.vec.into_iter.IntoIter.t i32.t alloc.alloc.Global.t)
            (Trait := ℐ)))
        (M.call (|(ltac:(M.get_method (fun ℐ =>
            core.iter.traits.collect.IntoIterator.into_iter
              (Self := alloc.vec.Vec.t i32.t alloc.alloc.Global.t)
              (Trait := ℐ)))
          (M.read (| v |)))
        |))
        (M.call (|(ltac:(M.get_method (fun ℐ =>
            core.iter.traits.collect.IntoIterator.into_iter
              (Self := alloc.vec.Vec.t i32.t alloc.alloc.Global.t)
              (Trait := ℐ)))
          (M.read (| u |)))
        |)))
      |)))
    |)
  )).

Error OpaqueTy.

(*
fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!("all done");
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  ltac:(M.monadic (
    M.read (|
      let v1 : M.Val (alloc.vec.Vec.t i32.t alloc.alloc.Global.t) :=
        M.alloc (|
          M.call (|((slice i32.t)::["into_vec"]
            (pointer_coercion
              "Unsize"
              (M.read (|
                M.call (|((alloc.boxed.Box.t _ alloc.boxed.Box.Default.A)::["new"]
                  (M.alloc (|
                    [
                      (Integer.of_Z 1) : i32.t;
                      (Integer.of_Z 2) : i32.t;
                      (Integer.of_Z 3) : i32.t
                    ]
                  |)))
                |)
              |))))
          |)
        |) in
      let v2 : M.Val (alloc.vec.Vec.t i32.t alloc.alloc.Global.t) :=
        M.alloc (|
          M.call (|((slice i32.t)::["into_vec"]
            (pointer_coercion
              "Unsize"
              (M.read (|
                M.call (|((alloc.boxed.Box.t _ alloc.boxed.Box.Default.A)::["new"]
                  (M.alloc (|
                    [ (Integer.of_Z 4) : i32.t; (Integer.of_Z 5) : i32.t ]
                  |)))
                |)
              |))))
          |)
        |) in
      let v3 : M.Val _ :=
        M.alloc (|
          M.call (|(impl_trait_as_return_type.combine_vecs
            (M.read (| v1 |))
            (M.read (| v2 |)))
          |)
        |) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow
                  (M.alloc (| core.option.Option.Some ((Integer.of_Z 1) : i32.t)
                  |)),
                borrow
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.iter.traits.iterator.Iterator.next
                          (Self := _)
                          (Trait := ℐ)))
                      (borrow_mut v3))
                    |)
                  |)))
            |))
            [
              fun
                  (γ :
                    M.Val
                      ((ref (core.option.Option.t i32.t))
                      *
                      (ref (core.option.Option.t i32.t)))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.cmp.PartialEq.eq
                                  (Self := core.option.Option.t i32.t)
                                  (Rhs := core.option.Option.t i32.t)
                                  (Trait := ℐ)))
                              (M.read (| left_val |))
                              (M.read (| right_val |)))
                            |))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow
                  (M.alloc (| core.option.Option.Some ((Integer.of_Z 2) : i32.t)
                  |)),
                borrow
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.iter.traits.iterator.Iterator.next
                          (Self := _)
                          (Trait := ℐ)))
                      (borrow_mut v3))
                    |)
                  |)))
            |))
            [
              fun
                  (γ :
                    M.Val
                      ((ref (core.option.Option.t i32.t))
                      *
                      (ref (core.option.Option.t i32.t)))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.cmp.PartialEq.eq
                                  (Self := core.option.Option.t i32.t)
                                  (Rhs := core.option.Option.t i32.t)
                                  (Trait := ℐ)))
                              (M.read (| left_val |))
                              (M.read (| right_val |)))
                            |))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow
                  (M.alloc (| core.option.Option.Some ((Integer.of_Z 3) : i32.t)
                  |)),
                borrow
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.iter.traits.iterator.Iterator.next
                          (Self := _)
                          (Trait := ℐ)))
                      (borrow_mut v3))
                    |)
                  |)))
            |))
            [
              fun
                  (γ :
                    M.Val
                      ((ref (core.option.Option.t i32.t))
                      *
                      (ref (core.option.Option.t i32.t)))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.cmp.PartialEq.eq
                                  (Self := core.option.Option.t i32.t)
                                  (Rhs := core.option.Option.t i32.t)
                                  (Trait := ℐ)))
                              (M.read (| left_val |))
                              (M.read (| right_val |)))
                            |))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow
                  (M.alloc (| core.option.Option.Some ((Integer.of_Z 4) : i32.t)
                  |)),
                borrow
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.iter.traits.iterator.Iterator.next
                          (Self := _)
                          (Trait := ℐ)))
                      (borrow_mut v3))
                    |)
                  |)))
            |))
            [
              fun
                  (γ :
                    M.Val
                      ((ref (core.option.Option.t i32.t))
                      *
                      (ref (core.option.Option.t i32.t)))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.cmp.PartialEq.eq
                                  (Self := core.option.Option.t i32.t)
                                  (Rhs := core.option.Option.t i32.t)
                                  (Trait := ℐ)))
                              (M.read (| left_val |))
                              (M.read (| right_val |)))
                            |))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      let _ : M.Val unit :=
        ltac:
          (M.monadic_match_operator
            (M.alloc (|
              (borrow
                  (M.alloc (| core.option.Option.Some ((Integer.of_Z 5) : i32.t)
                  |)),
                borrow
                  (M.alloc (|
                    M.call (|(ltac:(M.get_method (fun ℐ =>
                        core.iter.traits.iterator.Iterator.next
                          (Self := _)
                          (Trait := ℐ)))
                      (borrow_mut v3))
                    |)
                  |)))
            |))
            [
              fun
                  (γ :
                    M.Val
                      ((ref (core.option.Option.t i32.t))
                      *
                      (ref (core.option.Option.t i32.t)))) =>
                match M.read (| γ |) with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let left_val := M.copy (| γ0_0 |) in
                  let right_val := M.copy (| γ0_1 |) in
                  if
                    M.read (|
                      use
                        (M.alloc (|
                          UnOp.not
                            (M.call (|(ltac:(M.get_method (fun ℐ =>
                                core.cmp.PartialEq.eq
                                  (Self := core.option.Option.t i32.t)
                                  (Rhs := core.option.Option.t i32.t)
                                  (Trait := ℐ)))
                              (M.read (| left_val |))
                              (M.read (| right_val |)))
                            |))
                        |))
                    |)
                  then
                    M.alloc (|
                      (never_to_any (B := unit)) (|
                        M.read (|
                          let kind : M.Val core.panicking.AssertKind.t :=
                            M.alloc (| core.panicking.AssertKind.Eq |) in
                          M.alloc (|
                            M.call (|(core.panicking.assert_failed
                              (M.read (| kind |))
                              (M.read (| left_val |))
                              (M.read (| right_val |))
                              core.option.Option.None)
                            |)
                          |)
                        |)
                      |)
                    |)
                  else
                    M.alloc (| tt |)
                end :
                M.Val unit
            ]) in
      let _ : M.Val unit :=
        let _ : M.Val unit :=
          M.alloc (|
            M.call (|(std.io.stdio._print
              (M.call (|(core.fmt.Arguments.t::["new_const"]
                (pointer_coercion
                  "Unsize"
                  (borrow (M.alloc (| [ M.read (| mk_str "all done
" |) ] |)))))
              |)))
            |)
          |) in
        M.alloc (| tt |) in
      M.alloc (| tt |)
    |)
  )).
