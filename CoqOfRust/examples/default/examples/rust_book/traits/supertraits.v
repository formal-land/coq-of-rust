(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Person.
Section Person.
  Class Trait (Self : Set) : Type := {
    name :
      Ty.function
        [Ty.apply (Ty.path "ref") [Self]]
        (Ty.apply (Ty.path "alloc::string::String") []);
  }.
  
End Person.
End Person.

Module  Student.
Section Student.
  Class Trait (Self : Set) : Type := {
    university :
      Ty.function
        [Ty.apply (Ty.path "ref") [Self]]
        (Ty.apply (Ty.path "alloc::string::String") []);
  }.
  
End Student.
End Student.

Module  Programmer.
Section Programmer.
  Class Trait (Self : Set) : Type := {
    fav_language :
      Ty.function
        [Ty.apply (Ty.path "ref") [Self]]
        (Ty.apply (Ty.path "alloc::string::String") []);
  }.
  
End Programmer.
End Programmer.

Module  CompSciStudent.
Section CompSciStudent.
  Class Trait (Self : Set) : Type := {
    git_username :
      Ty.function
        [Ty.apply (Ty.path "ref") [Self]]
        (Ty.apply (Ty.path "alloc::string::String") []);
  }.
  
End CompSciStudent.
End CompSciStudent.

(*
fn comp_sci_student_greeting(student: &dyn CompSciStudent) -> String {
    format!(
        "My name is {} and I attend {}. My favorite language is {}. My Git username is {}",
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}
*)
Definition comp_sci_student_greeting (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [DynT], [student] =>
    let* student := M.alloc student in
    let* res : Ty.apply (Ty.path "alloc::string::String") [] :=
      let* Î±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "My name is ") in
      let* Î±1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str " and I attend ") in
      let* Î±2 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str ". My favorite language is ") in
      let* Î±3 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str ". My Git username is ") in
      let* Î±4 :
          Ty.apply
            (Ty.path "array")
            [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
        M.alloc [ Î±0; Î±1; Î±2; Î±3 ] in
      let* Î±5 :
          Ty.function
            [Ty.apply (Ty.path "ref") [dyn [supertraits.CompSciStudent.Trait]]]
            (Ty.apply (Ty.path "alloc::string::String") []) :=
        ltac:(M.get_method (fun â„ =>
          supertraits.Person.name
            (Self := dyn [supertraits.CompSciStudent.Trait])
            (Trait := â„))) in
      let* Î±6 :
          Ty.apply (Ty.path "ref") [dyn [supertraits.CompSciStudent.Trait]] :=
        M.read student in
      let* Î±7 : Ty.apply (Ty.path "alloc::string::String") [] :=
        M.call (Î±5 Î±6) in
      let* Î±8 : Ty.apply (Ty.path "alloc::string::String") [] := M.alloc Î±7 in
      let* Î±9 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
        M.call
          ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_display"]
            (borrow Î±8)) in
      let* Î±10 :
          Ty.function
            [Ty.apply (Ty.path "ref") [dyn [supertraits.CompSciStudent.Trait]]]
            (Ty.apply (Ty.path "alloc::string::String") []) :=
        ltac:(M.get_method (fun â„ =>
          supertraits.Student.university
            (Self := dyn [supertraits.CompSciStudent.Trait])
            (Trait := â„))) in
      let* Î±11 :
          Ty.apply (Ty.path "ref") [dyn [supertraits.CompSciStudent.Trait]] :=
        M.read student in
      let* Î±12 : Ty.apply (Ty.path "alloc::string::String") [] :=
        M.call (Î±10 Î±11) in
      let* Î±13 : Ty.apply (Ty.path "alloc::string::String") [] := M.alloc Î±12 in
      let* Î±14 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
        M.call
          ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_display"]
            (borrow Î±13)) in
      let* Î±15 :
          Ty.function
            [Ty.apply (Ty.path "ref") [dyn [supertraits.CompSciStudent.Trait]]]
            (Ty.apply (Ty.path "alloc::string::String") []) :=
        ltac:(M.get_method (fun â„ =>
          supertraits.Programmer.fav_language
            (Self := dyn [supertraits.CompSciStudent.Trait])
            (Trait := â„))) in
      let* Î±16 :
          Ty.apply (Ty.path "ref") [dyn [supertraits.CompSciStudent.Trait]] :=
        M.read student in
      let* Î±17 : Ty.apply (Ty.path "alloc::string::String") [] :=
        M.call (Î±15 Î±16) in
      let* Î±18 : Ty.apply (Ty.path "alloc::string::String") [] := M.alloc Î±17 in
      let* Î±19 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
        M.call
          ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_display"]
            (borrow Î±18)) in
      let* Î±20 :
          Ty.function
            [Ty.apply (Ty.path "ref") [dyn [supertraits.CompSciStudent.Trait]]]
            (Ty.apply (Ty.path "alloc::string::String") []) :=
        ltac:(M.get_method (fun â„ =>
          supertraits.CompSciStudent.git_username
            (Self := dyn [supertraits.CompSciStudent.Trait])
            (Trait := â„))) in
      let* Î±21 :
          Ty.apply (Ty.path "ref") [dyn [supertraits.CompSciStudent.Trait]] :=
        M.read student in
      let* Î±22 : Ty.apply (Ty.path "alloc::string::String") [] :=
        M.call (Î±20 Î±21) in
      let* Î±23 : Ty.apply (Ty.path "alloc::string::String") [] := M.alloc Î±22 in
      let* Î±24 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
        M.call
          ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_display"]
            (borrow Î±23)) in
      let* Î±25 :
          Ty.apply
            (Ty.path "array")
            [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
        M.alloc [ Î±9; Î±14; Î±19; Î±24 ] in
      let* Î±26 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
        M.call
          ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
            (pointer_coercion "Unsize" (borrow Î±4))
            (pointer_coercion "Unsize" (borrow Î±25))) in
      let* Î±27 : Ty.apply (Ty.path "alloc::string::String") [] :=
        M.call (alloc.fmt.format Î±26) in
      M.alloc Î±27 in
    M.read res
  | _, _ => M.impossible
  end.

(*
fn main() {}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with | [], [] => M.pure tt | _, _ => M.impossible end.
