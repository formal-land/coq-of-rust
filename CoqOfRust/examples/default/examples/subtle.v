(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Struct Choice *)

Module Impl_core_marker_Copy_for_subtle_Choice.
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::Copy"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [].
End Impl_core_marker_Copy_for_subtle_Choice.

Module Impl_core_clone_Clone_for_subtle_Choice.
  (*
  Clone
  *)
  Definition clone (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 :=
        match_operator
          Value.DeclaredButUndefined
          [
            fun Î³ =>
              (let* Î±0 := M.read self in
              M.pure (deref Î±0)) :
              Ty.path "subtle::Choice"
          ] in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("clone", InstanceField.Method clone []) ].
End Impl_core_clone_Clone_for_subtle_Choice.

Module Impl_core_fmt_Debug_for_subtle_Choice.
  (*
  Debug
  *)
  Definition fmt (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Î±0 := M.read f in
      let* Î±1 := M.read (mk_str "Choice") in
      let* Î±2 := M.var "subtle::Choice::Get_0" in
      let* Î±3 := M.read self in
      let* Î±4 := M.alloc (borrow (Î±2 (deref Î±3))) in
      M.call
        (Ty.path "core::fmt::Formatter")::["debug_tuple_field1_finish"]
        [ Î±0; Î±1; pointer_coercion "Unsize" (borrow Î±4) ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("fmt", InstanceField.Method fmt []) ].
End Impl_core_fmt_Debug_for_subtle_Choice.

Module Impl_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      pub fn unwrap_u8(&self) -> u8 {
          self.0
      }
  *)
  Definition unwrap_u8 (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "subtle::Choice::Get_0" in
      let* Î±1 := M.read self in
      M.read (Î±0 (deref Î±1))
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_unwrap_u8 :
    M.IsAssociatedFunction Self "unwrap_u8" unwrap_u8 [].
End Impl_subtle_Choice.

Module Impl_core_convert_From_subtle_Choice_for_bool.
  (*
      fn from(source: Choice) -> bool {
          debug_assert!((source.0 == 0u8) | (source.0 == 1u8));
          source.0 != 0
      }
  *)
  Definition from (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ source ] =>
      let* source := M.alloc source in
      let* _ :=
        let* Î±0 := M.alloc true in
        let* Î±1 := M.read (use Î±0) in
        if Î±1 then
          let* _ :=
            let* Î±0 := M.var "UnOp::not" in
            let* Î±1 := M.var "BinOp::Pure::bit_or" in
            let* Î±2 := M.var "BinOp::Pure::eq" in
            let* Î±3 := M.var "subtle::Choice::Get_0" in
            let* Î±4 := M.read (Î±3 source) in
            let* Î±5 := M.var "BinOp::Pure::eq" in
            let* Î±6 := M.var "subtle::Choice::Get_0" in
            let* Î±7 := M.read (Î±6 source) in
            let* Î±8 :=
              M.alloc
                (Î±0
                  (Î±1
                    (Î±2 Î±4 ((Integer.of_Z 0) : Ty.path "u8"))
                    (Î±5 Î±7 ((Integer.of_Z 1) : Ty.path "u8")))) in
            let* Î±9 := M.read (use Î±8) in
            if Î±9 then
              let* Î±0 := M.var "core::panicking::panic" in
              let* Î±1 :=
                M.read
                  (mk_str
                    "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)") in
              let* Î±2 := M.call Î±0 [ Î±1 ] in
              let* Î±3 := never_to_any Î±2 in
              M.alloc Î±3
            else
              M.alloc tt in
          M.alloc tt
        else
          M.alloc tt in
      let* Î±0 := M.var "BinOp::Pure::ne" in
      let* Î±1 := M.var "subtle::Choice::Get_0" in
      let* Î±2 := M.read (Î±1 source) in
      let* Î±0 := M.alloc (Î±0 Î±2 ((Integer.of_Z 0) : Ty.path "u8")) in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      (* Self *) (Ty.path "bool")
      [ (* T *) Ty.path "subtle::Choice" ]
      [ ("from", InstanceField.Method from []) ].
End Impl_core_convert_From_subtle_Choice_for_bool.

Module Impl_core_ops_bit_BitAnd_for_subtle_Choice.
  (*
      type Output = Choice;
  *)
  Definition Output : Set := Ty.path "subtle::Choice".
  
  (*
      fn bitand(self, rhs: Choice) -> Choice {
          (self.0 & rhs.0).into()
      }
  *)
  Definition bitand (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* Î±0 :=
        M.get_method
          "core::convert::Into"
          "into"
          [ (* Self *) Ty.path "u8"; (* T *) Ty.path "subtle::Choice" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_and" in
      let* Î±2 := M.var "subtle::Choice::Get_0" in
      let* Î±3 := M.read (Î±2 self) in
      let* Î±4 := M.var "subtle::Choice::Get_0" in
      let* Î±5 := M.read (Î±4 rhs) in
      M.call Î±0 [ Î±1 Î±3 Î±5 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitAnd"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("Output", TODO); ("bitand", InstanceField.Method bitand []) ].
End Impl_core_ops_bit_BitAnd_for_subtle_Choice.

Module Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
  (*
      fn bitand_assign(&mut self, rhs: Choice) {
          *self = *self & rhs;
      }
  *)
  Definition bitand_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* _ :=
        let* Î±0 := M.read self in
        let* Î±1 :=
          M.get_method
            "core::ops::bit::BitAnd"
            "bitand"
            [
              (* Self *) Ty.path "subtle::Choice";
              (* Rhs *) Ty.path "subtle::Choice"
            ] in
        let* Î±2 := M.read self in
        let* Î±3 := M.read (deref Î±2) in
        let* Î±4 := M.read rhs in
        let* Î±5 := M.call Î±1 [ Î±3; Î±4 ] in
        assign (deref Î±0) Î±5 in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitAndAssign"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("bitand_assign", InstanceField.Method bitand_assign []) ].
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitOr_for_subtle_Choice.
  (*
      type Output = Choice;
  *)
  Definition Output : Set := Ty.path "subtle::Choice".
  
  (*
      fn bitor(self, rhs: Choice) -> Choice {
          (self.0 | rhs.0).into()
      }
  *)
  Definition bitor (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* Î±0 :=
        M.get_method
          "core::convert::Into"
          "into"
          [ (* Self *) Ty.path "u8"; (* T *) Ty.path "subtle::Choice" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_or" in
      let* Î±2 := M.var "subtle::Choice::Get_0" in
      let* Î±3 := M.read (Î±2 self) in
      let* Î±4 := M.var "subtle::Choice::Get_0" in
      let* Î±5 := M.read (Î±4 rhs) in
      M.call Î±0 [ Î±1 Î±3 Î±5 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitOr"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("Output", TODO); ("bitor", InstanceField.Method bitor []) ].
End Impl_core_ops_bit_BitOr_for_subtle_Choice.

Module Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
  (*
      fn bitor_assign(&mut self, rhs: Choice) {
          *self = *self | rhs;
      }
  *)
  Definition bitor_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* _ :=
        let* Î±0 := M.read self in
        let* Î±1 :=
          M.get_method
            "core::ops::bit::BitOr"
            "bitor"
            [
              (* Self *) Ty.path "subtle::Choice";
              (* Rhs *) Ty.path "subtle::Choice"
            ] in
        let* Î±2 := M.read self in
        let* Î±3 := M.read (deref Î±2) in
        let* Î±4 := M.read rhs in
        let* Î±5 := M.call Î±1 [ Î±3; Î±4 ] in
        assign (deref Î±0) Î±5 in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitOrAssign"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("bitor_assign", InstanceField.Method bitor_assign []) ].
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitXor_for_subtle_Choice.
  (*
      type Output = Choice;
  *)
  Definition Output : Set := Ty.path "subtle::Choice".
  
  (*
      fn bitxor(self, rhs: Choice) -> Choice {
          (self.0 ^ rhs.0).into()
      }
  *)
  Definition bitxor (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* Î±0 :=
        M.get_method
          "core::convert::Into"
          "into"
          [ (* Self *) Ty.path "u8"; (* T *) Ty.path "subtle::Choice" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_xor" in
      let* Î±2 := M.var "subtle::Choice::Get_0" in
      let* Î±3 := M.read (Î±2 self) in
      let* Î±4 := M.var "subtle::Choice::Get_0" in
      let* Î±5 := M.read (Î±4 rhs) in
      M.call Î±0 [ Î±1 Î±3 Î±5 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitXor"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("Output", TODO); ("bitxor", InstanceField.Method bitxor []) ].
End Impl_core_ops_bit_BitXor_for_subtle_Choice.

Module Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
  (*
      fn bitxor_assign(&mut self, rhs: Choice) {
          *self = *self ^ rhs;
      }
  *)
  Definition bitxor_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* _ :=
        let* Î±0 := M.read self in
        let* Î±1 :=
          M.get_method
            "core::ops::bit::BitXor"
            "bitxor"
            [
              (* Self *) Ty.path "subtle::Choice";
              (* Rhs *) Ty.path "subtle::Choice"
            ] in
        let* Î±2 := M.read self in
        let* Î±3 := M.read (deref Î±2) in
        let* Î±4 := M.read rhs in
        let* Î±5 := M.call Î±1 [ Î±3; Î±4 ] in
        assign (deref Î±0) Î±5 in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitXorAssign"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("bitxor_assign", InstanceField.Method bitxor_assign []) ].
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.

Module Impl_core_ops_bit_Not_for_subtle_Choice.
  (*
      type Output = Choice;
  *)
  Definition Output : Set := Ty.path "subtle::Choice".
  
  (*
      fn not(self) -> Choice {
          (1u8 & (!self.0)).into()
      }
  *)
  Definition not (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 :=
        M.get_method
          "core::convert::Into"
          "into"
          [ (* Self *) Ty.path "u8"; (* T *) Ty.path "subtle::Choice" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_and" in
      let* Î±2 := M.var "UnOp::not" in
      let* Î±3 := M.var "subtle::Choice::Get_0" in
      let* Î±4 := M.read (Î±3 self) in
      M.call Î±0 [ Î±1 ((Integer.of_Z 1) : Ty.path "u8") (Î±2 Î±4) ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::Not"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("Output", TODO); ("not", InstanceField.Method not []) ].
End Impl_core_ops_bit_Not_for_subtle_Choice.

(*
fn black_box(input: u8) -> u8 {
    debug_assert!((input == 0u8) | (input == 1u8));

    unsafe {
        // Optimization barrier
        //
        // Unsafe is ok, because:
        //   - &input is not NULL;
        //   - size of input is not zero;
        //   - u8 is neither Sync, nor Send;
        //   - u8 is Copy, so input is always live;
        //   - u8 type is always properly aligned.
        core::ptr::read_volatile(&input as *const u8)
    }
}
*)
Definition black_box (ðœ : list Ty.t) (Î± : list Value.t) : M :=
  match ðœ, Î± with
  | [], [ input ] =>
    let* input := M.alloc input in
    let* _ :=
      let* Î±0 := M.alloc true in
      let* Î±1 := M.read (use Î±0) in
      if Î±1 then
        let* _ :=
          let* Î±0 := M.var "UnOp::not" in
          let* Î±1 := M.var "BinOp::Pure::bit_or" in
          let* Î±2 := M.var "BinOp::Pure::eq" in
          let* Î±3 := M.read input in
          let* Î±4 := M.var "BinOp::Pure::eq" in
          let* Î±5 := M.read input in
          let* Î±6 :=
            M.alloc
              (Î±0
                (Î±1
                  (Î±2 Î±3 ((Integer.of_Z 0) : Ty.path "u8"))
                  (Î±4 Î±5 ((Integer.of_Z 1) : Ty.path "u8")))) in
          let* Î±7 := M.read (use Î±6) in
          if Î±7 then
            let* Î±0 := M.var "core::panicking::panic" in
            let* Î±1 :=
              M.read
                (mk_str "assertion failed: (input == 0u8) | (input == 1u8)") in
            let* Î±2 := M.call Î±0 [ Î±1 ] in
            let* Î±3 := never_to_any Î±2 in
            M.alloc Î±3
          else
            M.alloc tt in
        M.alloc tt
      else
        M.alloc tt in
    let* Î±0 := M.var "core::ptr::read_volatile" in
    let* Î±1 := M.alloc (addr_of input) in
    let* Î±2 := M.read (use Î±1) in
    let* Î±3 := M.call Î±0 [ Î±2 ] in
    let* Î±0 := M.alloc Î±3 in
    M.read Î±0
  | _, _ => M.impossible
  end.

Module Impl_core_convert_From_u8_for_subtle_Choice.
  (*
      fn from(input: u8) -> Choice {
          // Our goal is to prevent the compiler from inferring that the value held inside the
          // resulting `Choice` struct is really an `i1` instead of an `i8`.
          Choice(black_box(input))
      }
  *)
  Definition from (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ input ] =>
      let* input := M.alloc input in
      let* Î±0 := M.var "subtle::black_box" in
      let* Î±1 := M.read input in
      let* Î±2 := M.call Î±0 [ Î±1 ] in
      M.pure (Value.StructTuple "subtle::Choice" [ Î±2 ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      (* Self *) (Ty.path "subtle::Choice")
      [ (* T *) Ty.path "u8" ]
      [ ("from", InstanceField.Method from []) ].
End Impl_core_convert_From_u8_for_subtle_Choice.

(* Trait *)
Module ConstantTimeEq.
  Definition ct_ne (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::Not"
          "not"
          [ (* Self *) Ty.path "subtle::Choice" ] in
      let* Î±1 :=
        M.get_method "subtle::ConstantTimeEq" "ct_eq" [ (* Self *) Self ] in
      let* Î±2 := M.read self in
      let* Î±3 := M.read other in
      let* Î±4 := M.call Î±1 [ Î±2; Î±3 ] in
      M.call Î±0 [ Î±4 ]
    | _, _ => M.impossible
    end.
  
  Axiom ProvidedMethod_ct_ne :
    M.IsProvidedMethod "subtle::ConstantTimeEq" ct_ne.
End ConstantTimeEq.

Module Impl_subtle_ConstantTimeEq_for_slice_T.
  (*
      fn ct_eq(&self, _rhs: &[T]) -> Choice {
          let len = self.len();
  
          // Short-circuit on the *lengths* of the slices, not their
          // contents.
          if len != _rhs.len() {
              return Choice::from(0);
          }
  
          // This loop shouldn't be shortcircuitable, since the compiler
          // shouldn't be able to reason about the value of the `u8`
          // unwrapped from the `ct_eq` result.
          let mut x = 1u8;
          for (ai, bi) in self.iter().zip(_rhs.iter()) {
              x &= ai.ct_eq(bi).unwrap_u8();
          }
  
          x.into()
      }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ self; _rhs ] =>
      let* self := M.alloc self in
      let* _rhs := M.alloc _rhs in
      let return_ := M.return_ (R := Ty.path "subtle::Choice") in
      M.catch_return
        (let* len :=
          let* Î±0 := M.read self in
          let* Î±1 :=
            M.call (Ty.apply (Ty.path "slice") [ T ])::["len"] [ Î±0 ] in
          M.alloc Î±1 in
        let* _ :=
          let* Î±0 := M.var "BinOp::Pure::ne" in
          let* Î±1 := M.read len in
          let* Î±2 := M.read _rhs in
          let* Î±3 :=
            M.call (Ty.apply (Ty.path "slice") [ T ])::["len"] [ Î±2 ] in
          let* Î±4 := M.alloc (Î±0 Î±1 Î±3) in
          let* Î±5 := M.read (use Î±4) in
          if Î±5 then
            let* Î±0 :=
              M.get_method
                "core::convert::From"
                "from"
                [ (* Self *) Ty.path "subtle::Choice"; (* T *) Ty.path "u8" ] in
            let* Î±1 := M.call Î±0 [ (Integer.of_Z 0) : Ty.path "u8" ] in
            let* Î±2 := return_ Î±1 in
            let* Î±3 := M.read Î±2 in
            let* Î±4 := never_to_any Î±3 in
            M.alloc Î±4
          else
            M.alloc tt in
        let* x := M.alloc ((Integer.of_Z 1) : Ty.path "u8") in
        let* _ :=
          let* Î±0 :=
            M.get_method
              "core::iter::traits::collect::IntoIterator"
              "into_iter"
              [
                (* Self *)
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    [
                      Ty.apply (Ty.path "core::slice::iter::Iter") [ T ];
                      Ty.apply (Ty.path "core::slice::iter::Iter") [ T ]
                    ]
              ] in
          let* Î±1 :=
            M.get_method
              "core::iter::traits::iterator::Iterator"
              "zip"
              [
                (* Self *) Ty.apply (Ty.path "core::slice::iter::Iter") [ T ];
                (* U *) Ty.apply (Ty.path "core::slice::iter::Iter") [ T ]
              ] in
          let* Î±2 := M.read self in
          let* Î±3 :=
            M.call (Ty.apply (Ty.path "slice") [ T ])::["iter"] [ Î±2 ] in
          let* Î±4 := M.read _rhs in
          let* Î±5 :=
            M.call (Ty.apply (Ty.path "slice") [ T ])::["iter"] [ Î±4 ] in
          let* Î±6 := M.call Î±1 [ Î±3; Î±5 ] in
          let* Î±7 := M.call Î±0 [ Î±6 ] in
          let* Î±8 := M.alloc Î±7 in
          let* Î±9 :=
            match_operator
              Î±8
              [
                fun Î³ =>
                  (let* iter := M.copy Î³ in
                  M.loop
                    (let* _ :=
                      let* Î±0 :=
                        M.get_method
                          "core::iter::traits::iterator::Iterator"
                          "next"
                          [
                            (* Self *)
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [ T ];
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [ T ]
                                ]
                          ] in
                      let* Î±1 := M.call Î±0 [ borrow_mut iter ] in
                      let* Î±2 := M.alloc Î±1 in
                      match_operator
                        Î±2
                        [
                          fun Î³ =>
                            (let* Î±0 := M.read Î³ in
                            match Î±0 with
                            | core.option.Option.None =>
                              let* Î±0 := M.break in
                              let* Î±1 := M.read Î±0 in
                              let* Î±2 := never_to_any Î±1 in
                              M.alloc Î±2
                            | _ => M.break_match 
                            end) :
                            Ty.tuple [];
                          fun Î³ =>
                            (let* Î±0 := M.read Î³ in
                            match Î±0 with
                            | core.option.Option.Some _ =>
                              let* Î³0_0 :=
                                let* Î±0 :=
                                  M.var "core::option::Option::Get_Some_0" in
                                M.pure (Î±0 Î³) in
                              let* Î±0 := M.read Î³0_0 in
                              match Î±0 with
                              | (_, _) =>
                                let Î³1_0 := Tuple.Access.left Î³0_0 in
                                let Î³1_1 := Tuple.Access.right Î³0_0 in
                                let* ai := M.copy Î³1_0 in
                                let* bi := M.copy Î³1_1 in
                                let* _ :=
                                  let Î² := x in
                                  let* Î±0 := M.var "assign" in
                                  let* Î±1 := M.var "BinOp::Pure::bit_and" in
                                  let* Î±2 := M.read Î² in
                                  let* Î±3 :=
                                    M.get_method
                                      "subtle::ConstantTimeEq"
                                      "ct_eq"
                                      [ (* Self *) T ] in
                                  let* Î±4 := M.read ai in
                                  let* Î±5 := M.read bi in
                                  let* Î±6 := M.call Î±3 [ Î±4; Î±5 ] in
                                  let* Î±7 := M.alloc Î±6 in
                                  let* Î±8 :=
                                    M.call
                                      (Ty.path "subtle::Choice")::["unwrap_u8"]
                                      [ borrow Î±7 ] in
                                  Î±0 Î² (Î±1 Î±2 Î±8) in
                                M.alloc tt
                              end
                            | _ => M.break_match 
                            end) :
                            Ty.tuple []
                        ] in
                    M.alloc tt)) :
                  Ty.tuple []
              ] in
          M.pure (use Î±9) in
        let* Î±0 :=
          M.get_method
            "core::convert::Into"
            "into"
            [ (* Self *) Ty.path "u8"; (* T *) Ty.path "subtle::Choice" ] in
        let* Î±1 := M.read x in
        let* Î±2 := M.call Î±0 [ Î±1 ] in
        let* Î±0 := M.alloc Î±2 in
        M.read Î±0)
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.apply (Ty.path "slice") [ T ])
      []
      [ ("ct_eq", InstanceField.Method ct_eq [ T ]) ].
End Impl_subtle_ConstantTimeEq_for_slice_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_Choice.
  (*
      fn ct_eq(&self, rhs: &Choice) -> Choice {
          !( *self ^ *rhs)
      }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::Not"
          "not"
          [ (* Self *) Ty.path "subtle::Choice" ] in
      let* Î±1 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.path "subtle::Choice";
            (* Rhs *) Ty.path "subtle::Choice"
          ] in
      let* Î±2 := M.read self in
      let* Î±3 := M.read (deref Î±2) in
      let* Î±4 := M.read rhs in
      let* Î±5 := M.read (deref Î±4) in
      let* Î±6 := M.call Î±1 [ Î±3; Î±5 ] in
      M.call Î±0 [ Î±6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_subtle_Choice.

Module Impl_subtle_ConstantTimeEq_for_u8.
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitXor"
            "bitxor"
            [
              (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u8" ];
              (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u8" ]
            ] in
        let* Î±1 := M.read self in
        let* Î±2 := M.read other in
        let* Î±3 := M.call Î±0 [ Î±1; Î±2 ] in
        M.alloc Î±3 in
      let* y :=
        let* Î±0 := M.var "BinOp::Panic::shr" in
        let* Î±1 := M.var "BinOp::Pure::bit_or" in
        let* Î±2 := M.read x in
        let* Î±3 := M.read x in
        let* Î±4 := M.call (Ty.path "u8")::["wrapping_neg"] [ Î±3 ] in
        let* Î±5 := M.var "BinOp::Panic::sub" in
        let* Î±6 :=
          Î±5
            ((Integer.of_Z 8) : Ty.path "i32")
            ((Integer.of_Z 1) : Ty.path "i32") in
        let* Î±7 := Î±0 (Î±1 Î±2 Î±4) Î±6 in
        M.alloc Î±7 in
      let* Î±0 :=
        M.get_method
          "core::convert::Into"
          "into"
          [ (* Self *) Ty.path "u8"; (* T *) Ty.path "subtle::Choice" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_xor" in
      let* Î±2 := M.read y in
      let* Î±3 := M.alloc ((Integer.of_Z 1) : Ty.path "u8") in
      let* Î±4 := M.read (use Î±3) in
      let* Î±5 := M.alloc (Î±1 Î±2 Î±4) in
      let* Î±6 := M.read (use Î±5) in
      let* Î±7 := M.call Î±0 [ Î±6 ] in
      let* Î±0 := M.alloc Î±7 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "u8")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_u8.

Module Impl_subtle_ConstantTimeEq_for_i8.
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Î±0 :=
        M.get_method
          "subtle::ConstantTimeEq"
          "ct_eq"
          [ (* Self *) Ty.path "u8" ] in
      let* Î±1 := M.read self in
      let* Î±2 := M.read (deref Î±1) in
      let* Î±3 := M.alloc (rust_cast Î±2) in
      let* Î±4 := M.read other in
      let* Î±5 := M.read (deref Î±4) in
      let* Î±6 := M.alloc (rust_cast Î±5) in
      M.call Î±0 [ borrow Î±3; borrow Î±6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "i8")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_i8.

Module Impl_subtle_ConstantTimeEq_for_u16.
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitXor"
            "bitxor"
            [
              (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u16" ];
              (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u16" ]
            ] in
        let* Î±1 := M.read self in
        let* Î±2 := M.read other in
        let* Î±3 := M.call Î±0 [ Î±1; Î±2 ] in
        M.alloc Î±3 in
      let* y :=
        let* Î±0 := M.var "BinOp::Panic::shr" in
        let* Î±1 := M.var "BinOp::Pure::bit_or" in
        let* Î±2 := M.read x in
        let* Î±3 := M.read x in
        let* Î±4 := M.call (Ty.path "u16")::["wrapping_neg"] [ Î±3 ] in
        let* Î±5 := M.var "BinOp::Panic::sub" in
        let* Î±6 :=
          Î±5
            ((Integer.of_Z 16) : Ty.path "i32")
            ((Integer.of_Z 1) : Ty.path "i32") in
        let* Î±7 := Î±0 (Î±1 Î±2 Î±4) Î±6 in
        M.alloc Î±7 in
      let* Î±0 :=
        M.get_method
          "core::convert::Into"
          "into"
          [ (* Self *) Ty.path "u8"; (* T *) Ty.path "subtle::Choice" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_xor" in
      let* Î±2 := M.read y in
      let* Î±3 := M.alloc ((Integer.of_Z 1) : Ty.path "u16") in
      let* Î±4 := M.read (use Î±3) in
      let* Î±5 := M.call Î±0 [ rust_cast (Î±1 Î±2 Î±4) ] in
      let* Î±0 := M.alloc Î±5 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "u16")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_u16.

Module Impl_subtle_ConstantTimeEq_for_i16.
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Î±0 :=
        M.get_method
          "subtle::ConstantTimeEq"
          "ct_eq"
          [ (* Self *) Ty.path "u16" ] in
      let* Î±1 := M.read self in
      let* Î±2 := M.read (deref Î±1) in
      let* Î±3 := M.alloc (rust_cast Î±2) in
      let* Î±4 := M.read other in
      let* Î±5 := M.read (deref Î±4) in
      let* Î±6 := M.alloc (rust_cast Î±5) in
      M.call Î±0 [ borrow Î±3; borrow Î±6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "i16")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_i16.

Module Impl_subtle_ConstantTimeEq_for_u32.
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitXor"
            "bitxor"
            [
              (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u32" ];
              (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u32" ]
            ] in
        let* Î±1 := M.read self in
        let* Î±2 := M.read other in
        let* Î±3 := M.call Î±0 [ Î±1; Î±2 ] in
        M.alloc Î±3 in
      let* y :=
        let* Î±0 := M.var "BinOp::Panic::shr" in
        let* Î±1 := M.var "BinOp::Pure::bit_or" in
        let* Î±2 := M.read x in
        let* Î±3 := M.read x in
        let* Î±4 := M.call (Ty.path "u32")::["wrapping_neg"] [ Î±3 ] in
        let* Î±5 := M.var "BinOp::Panic::sub" in
        let* Î±6 :=
          Î±5
            ((Integer.of_Z 32) : Ty.path "i32")
            ((Integer.of_Z 1) : Ty.path "i32") in
        let* Î±7 := Î±0 (Î±1 Î±2 Î±4) Î±6 in
        M.alloc Î±7 in
      let* Î±0 :=
        M.get_method
          "core::convert::Into"
          "into"
          [ (* Self *) Ty.path "u8"; (* T *) Ty.path "subtle::Choice" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_xor" in
      let* Î±2 := M.read y in
      let* Î±3 := M.alloc ((Integer.of_Z 1) : Ty.path "u32") in
      let* Î±4 := M.read (use Î±3) in
      let* Î±5 := M.call Î±0 [ rust_cast (Î±1 Î±2 Î±4) ] in
      let* Î±0 := M.alloc Î±5 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "u32")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_u32.

Module Impl_subtle_ConstantTimeEq_for_i32.
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Î±0 :=
        M.get_method
          "subtle::ConstantTimeEq"
          "ct_eq"
          [ (* Self *) Ty.path "u32" ] in
      let* Î±1 := M.read self in
      let* Î±2 := M.read (deref Î±1) in
      let* Î±3 := M.alloc (rust_cast Î±2) in
      let* Î±4 := M.read other in
      let* Î±5 := M.read (deref Î±4) in
      let* Î±6 := M.alloc (rust_cast Î±5) in
      M.call Î±0 [ borrow Î±3; borrow Î±6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "i32")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_i32.

Module Impl_subtle_ConstantTimeEq_for_u64.
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitXor"
            "bitxor"
            [
              (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u64" ];
              (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u64" ]
            ] in
        let* Î±1 := M.read self in
        let* Î±2 := M.read other in
        let* Î±3 := M.call Î±0 [ Î±1; Î±2 ] in
        M.alloc Î±3 in
      let* y :=
        let* Î±0 := M.var "BinOp::Panic::shr" in
        let* Î±1 := M.var "BinOp::Pure::bit_or" in
        let* Î±2 := M.read x in
        let* Î±3 := M.read x in
        let* Î±4 := M.call (Ty.path "u64")::["wrapping_neg"] [ Î±3 ] in
        let* Î±5 := M.var "BinOp::Panic::sub" in
        let* Î±6 :=
          Î±5
            ((Integer.of_Z 64) : Ty.path "i32")
            ((Integer.of_Z 1) : Ty.path "i32") in
        let* Î±7 := Î±0 (Î±1 Î±2 Î±4) Î±6 in
        M.alloc Î±7 in
      let* Î±0 :=
        M.get_method
          "core::convert::Into"
          "into"
          [ (* Self *) Ty.path "u8"; (* T *) Ty.path "subtle::Choice" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_xor" in
      let* Î±2 := M.read y in
      let* Î±3 := M.alloc ((Integer.of_Z 1) : Ty.path "u64") in
      let* Î±4 := M.read (use Î±3) in
      let* Î±5 := M.call Î±0 [ rust_cast (Î±1 Î±2 Î±4) ] in
      let* Î±0 := M.alloc Î±5 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "u64")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_u64.

Module Impl_subtle_ConstantTimeEq_for_i64.
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Î±0 :=
        M.get_method
          "subtle::ConstantTimeEq"
          "ct_eq"
          [ (* Self *) Ty.path "u64" ] in
      let* Î±1 := M.read self in
      let* Î±2 := M.read (deref Î±1) in
      let* Î±3 := M.alloc (rust_cast Î±2) in
      let* Î±4 := M.read other in
      let* Î±5 := M.read (deref Î±4) in
      let* Î±6 := M.alloc (rust_cast Î±5) in
      M.call Î±0 [ borrow Î±3; borrow Î±6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "i64")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_i64.

Module Impl_subtle_ConstantTimeEq_for_usize.
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitXor"
            "bitxor"
            [
              (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "usize" ];
              (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "usize" ]
            ] in
        let* Î±1 := M.read self in
        let* Î±2 := M.read other in
        let* Î±3 := M.call Î±0 [ Î±1; Î±2 ] in
        M.alloc Î±3 in
      let* y :=
        let* Î±0 := M.var "BinOp::Panic::shr" in
        let* Î±1 := M.var "BinOp::Pure::bit_or" in
        let* Î±2 := M.read x in
        let* Î±3 := M.read x in
        let* Î±4 := M.call (Ty.path "usize")::["wrapping_neg"] [ Î±3 ] in
        let* Î±5 := M.var "BinOp::Panic::sub" in
        let* Î±6 := M.var "BinOp::Panic::mul" in
        let* Î±7 := M.var "core::mem::size_of" in
        let* Î±8 := M.call Î±7 [] in
        let* Î±9 := Î±6 Î±8 ((Integer.of_Z 8) : Ty.path "usize") in
        let* Î±10 := Î±5 Î±9 ((Integer.of_Z 1) : Ty.path "usize") in
        let* Î±11 := Î±0 (Î±1 Î±2 Î±4) Î±10 in
        M.alloc Î±11 in
      let* Î±0 :=
        M.get_method
          "core::convert::Into"
          "into"
          [ (* Self *) Ty.path "u8"; (* T *) Ty.path "subtle::Choice" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_xor" in
      let* Î±2 := M.read y in
      let* Î±3 := M.alloc ((Integer.of_Z 1) : Ty.path "usize") in
      let* Î±4 := M.read (use Î±3) in
      let* Î±5 := M.call Î±0 [ rust_cast (Î±1 Î±2 Î±4) ] in
      let* Î±0 := M.alloc Î±5 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "usize")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_usize.

Module Impl_subtle_ConstantTimeEq_for_isize.
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Î±0 :=
        M.get_method
          "subtle::ConstantTimeEq"
          "ct_eq"
          [ (* Self *) Ty.path "usize" ] in
      let* Î±1 := M.read self in
      let* Î±2 := M.read (deref Î±1) in
      let* Î±3 := M.alloc (rust_cast Î±2) in
      let* Î±4 := M.read other in
      let* Î±5 := M.read (deref Î±4) in
      let* Î±6 := M.alloc (rust_cast Î±5) in
      M.call Î±0 [ borrow Î±3; borrow Î±6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.path "isize")
      []
      [ ("ct_eq", InstanceField.Method ct_eq []) ].
End Impl_subtle_ConstantTimeEq_for_isize.

(* Trait *)
Module ConditionallySelectable.
  Definition conditional_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* _ :=
        let* Î±0 := M.read self in
        let* Î±1 :=
          M.get_method
            "subtle::ConditionallySelectable"
            "conditional_select"
            [ (* Self *) Self ] in
        let* Î±2 := M.read self in
        let* Î±3 := M.read other in
        let* Î±4 := M.read choice in
        let* Î±5 := M.call Î±1 [ borrow (deref Î±2); Î±3; Î±4 ] in
        assign (deref Î±0) Î±5 in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom ProvidedMethod_conditional_assign :
    M.IsProvidedMethod "subtle::ConditionallySelectable" conditional_assign.
  Definition conditional_swap (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* t :=
        let* Î±0 := M.read a in
        M.copy (deref Î±0) in
      let* _ :=
        let* Î±0 :=
          M.get_method
            "subtle::ConditionallySelectable"
            "conditional_assign"
            [ (* Self *) Self ] in
        let* Î±1 := M.read a in
        let* Î±2 := M.read b in
        let* Î±3 := M.read choice in
        let* Î±4 := M.call Î±0 [ Î±1; borrow (deref Î±2); Î±3 ] in
        M.alloc Î±4 in
      let* _ :=
        let* Î±0 :=
          M.get_method
            "subtle::ConditionallySelectable"
            "conditional_assign"
            [ (* Self *) Self ] in
        let* Î±1 := M.read b in
        let* Î±2 := M.read choice in
        let* Î±3 := M.call Î±0 [ Î±1; borrow t; Î±2 ] in
        M.alloc Î±3 in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom ProvidedMethod_conditional_swap :
    M.IsProvidedMethod "subtle::ConditionallySelectable" conditional_swap.
End ConditionallySelectable.

Module Impl_subtle_ConditionallySelectable_for_u8.
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u8" ];
            (* Rhs *) Ty.path "u8"
          ] in
      let* Î±1 := M.read a in
      let* Î±2 := M.var "BinOp::Pure::bit_and" in
      let* Î±3 := M.read mask in
      let* Î±4 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u8" ];
            (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u8" ]
          ] in
      let* Î±5 := M.read a in
      let* Î±6 := M.read b in
      let* Î±7 := M.call Î±4 [ Î±5; Î±6 ] in
      let* Î±8 := M.call Î±0 [ Î±1; Î±2 Î±3 Î±7 ] in
      let* Î±0 := M.alloc Î±8 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read self in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.var "BinOp::Pure::bit_and" in
        let* Î±4 := M.read mask in
        let* Î±5 := M.var "BinOp::Pure::bit_xor" in
        let* Î±6 := M.read self in
        let* Î±7 := M.read (deref Î±6) in
        let* Î±8 := M.read other in
        let* Î±9 := M.read (deref Î±8) in
        Î±0 Î² (Î±1 Î±2 (Î±3 Î±4 (Î±5 Î±7 Î±9))) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* t :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read mask in
        let* Î±2 := M.var "BinOp::Pure::bit_xor" in
        let* Î±3 := M.read a in
        let* Î±4 := M.read (deref Î±3) in
        let* Î±5 := M.read b in
        let* Î±6 := M.read (deref Î±5) in
        M.alloc (Î±0 Î±1 (Î±2 Î±4 Î±6)) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read a in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read b in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (* Self *) (Ty.path "u8")
      []
      [
        ("conditional_select", InstanceField.Method conditional_select []);
        ("conditional_assign", InstanceField.Method conditional_assign []);
        ("conditional_swap", InstanceField.Method conditional_swap [])
      ].
End Impl_subtle_ConditionallySelectable_for_u8.

Module Impl_subtle_ConditionallySelectable_for_i8.
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "i8" ];
            (* Rhs *) Ty.path "i8"
          ] in
      let* Î±1 := M.read a in
      let* Î±2 := M.var "BinOp::Pure::bit_and" in
      let* Î±3 := M.read mask in
      let* Î±4 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "i8" ];
            (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "i8" ]
          ] in
      let* Î±5 := M.read a in
      let* Î±6 := M.read b in
      let* Î±7 := M.call Î±4 [ Î±5; Î±6 ] in
      let* Î±8 := M.call Î±0 [ Î±1; Î±2 Î±3 Î±7 ] in
      let* Î±0 := M.alloc Î±8 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read self in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.var "BinOp::Pure::bit_and" in
        let* Î±4 := M.read mask in
        let* Î±5 := M.var "BinOp::Pure::bit_xor" in
        let* Î±6 := M.read self in
        let* Î±7 := M.read (deref Î±6) in
        let* Î±8 := M.read other in
        let* Î±9 := M.read (deref Î±8) in
        Î±0 Î² (Î±1 Î±2 (Î±3 Î±4 (Î±5 Î±7 Î±9))) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* t :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read mask in
        let* Î±2 := M.var "BinOp::Pure::bit_xor" in
        let* Î±3 := M.read a in
        let* Î±4 := M.read (deref Î±3) in
        let* Î±5 := M.read b in
        let* Î±6 := M.read (deref Î±5) in
        M.alloc (Î±0 Î±1 (Î±2 Î±4 Î±6)) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read a in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read b in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (* Self *) (Ty.path "i8")
      []
      [
        ("conditional_select", InstanceField.Method conditional_select []);
        ("conditional_assign", InstanceField.Method conditional_assign []);
        ("conditional_swap", InstanceField.Method conditional_swap [])
      ].
End Impl_subtle_ConditionallySelectable_for_i8.

Module Impl_subtle_ConditionallySelectable_for_u16.
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u16" ];
            (* Rhs *) Ty.path "u16"
          ] in
      let* Î±1 := M.read a in
      let* Î±2 := M.var "BinOp::Pure::bit_and" in
      let* Î±3 := M.read mask in
      let* Î±4 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u16" ];
            (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u16" ]
          ] in
      let* Î±5 := M.read a in
      let* Î±6 := M.read b in
      let* Î±7 := M.call Î±4 [ Î±5; Î±6 ] in
      let* Î±8 := M.call Î±0 [ Î±1; Î±2 Î±3 Î±7 ] in
      let* Î±0 := M.alloc Î±8 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read self in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.var "BinOp::Pure::bit_and" in
        let* Î±4 := M.read mask in
        let* Î±5 := M.var "BinOp::Pure::bit_xor" in
        let* Î±6 := M.read self in
        let* Î±7 := M.read (deref Î±6) in
        let* Î±8 := M.read other in
        let* Î±9 := M.read (deref Î±8) in
        Î±0 Î² (Î±1 Î±2 (Î±3 Î±4 (Î±5 Î±7 Î±9))) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* t :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read mask in
        let* Î±2 := M.var "BinOp::Pure::bit_xor" in
        let* Î±3 := M.read a in
        let* Î±4 := M.read (deref Î±3) in
        let* Î±5 := M.read b in
        let* Î±6 := M.read (deref Î±5) in
        M.alloc (Î±0 Î±1 (Î±2 Î±4 Î±6)) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read a in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read b in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (* Self *) (Ty.path "u16")
      []
      [
        ("conditional_select", InstanceField.Method conditional_select []);
        ("conditional_assign", InstanceField.Method conditional_assign []);
        ("conditional_swap", InstanceField.Method conditional_swap [])
      ].
End Impl_subtle_ConditionallySelectable_for_u16.

Module Impl_subtle_ConditionallySelectable_for_i16.
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "i16" ];
            (* Rhs *) Ty.path "i16"
          ] in
      let* Î±1 := M.read a in
      let* Î±2 := M.var "BinOp::Pure::bit_and" in
      let* Î±3 := M.read mask in
      let* Î±4 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "i16" ];
            (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "i16" ]
          ] in
      let* Î±5 := M.read a in
      let* Î±6 := M.read b in
      let* Î±7 := M.call Î±4 [ Î±5; Î±6 ] in
      let* Î±8 := M.call Î±0 [ Î±1; Î±2 Î±3 Î±7 ] in
      let* Î±0 := M.alloc Î±8 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read self in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.var "BinOp::Pure::bit_and" in
        let* Î±4 := M.read mask in
        let* Î±5 := M.var "BinOp::Pure::bit_xor" in
        let* Î±6 := M.read self in
        let* Î±7 := M.read (deref Î±6) in
        let* Î±8 := M.read other in
        let* Î±9 := M.read (deref Î±8) in
        Î±0 Î² (Î±1 Î±2 (Î±3 Î±4 (Î±5 Î±7 Î±9))) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* t :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read mask in
        let* Î±2 := M.var "BinOp::Pure::bit_xor" in
        let* Î±3 := M.read a in
        let* Î±4 := M.read (deref Î±3) in
        let* Î±5 := M.read b in
        let* Î±6 := M.read (deref Î±5) in
        M.alloc (Î±0 Î±1 (Î±2 Î±4 Î±6)) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read a in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read b in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (* Self *) (Ty.path "i16")
      []
      [
        ("conditional_select", InstanceField.Method conditional_select []);
        ("conditional_assign", InstanceField.Method conditional_assign []);
        ("conditional_swap", InstanceField.Method conditional_swap [])
      ].
End Impl_subtle_ConditionallySelectable_for_i16.

Module Impl_subtle_ConditionallySelectable_for_u32.
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u32" ];
            (* Rhs *) Ty.path "u32"
          ] in
      let* Î±1 := M.read a in
      let* Î±2 := M.var "BinOp::Pure::bit_and" in
      let* Î±3 := M.read mask in
      let* Î±4 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u32" ];
            (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u32" ]
          ] in
      let* Î±5 := M.read a in
      let* Î±6 := M.read b in
      let* Î±7 := M.call Î±4 [ Î±5; Î±6 ] in
      let* Î±8 := M.call Î±0 [ Î±1; Î±2 Î±3 Î±7 ] in
      let* Î±0 := M.alloc Î±8 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read self in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.var "BinOp::Pure::bit_and" in
        let* Î±4 := M.read mask in
        let* Î±5 := M.var "BinOp::Pure::bit_xor" in
        let* Î±6 := M.read self in
        let* Î±7 := M.read (deref Î±6) in
        let* Î±8 := M.read other in
        let* Î±9 := M.read (deref Î±8) in
        Î±0 Î² (Î±1 Î±2 (Î±3 Î±4 (Î±5 Î±7 Î±9))) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* t :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read mask in
        let* Î±2 := M.var "BinOp::Pure::bit_xor" in
        let* Î±3 := M.read a in
        let* Î±4 := M.read (deref Î±3) in
        let* Î±5 := M.read b in
        let* Î±6 := M.read (deref Î±5) in
        M.alloc (Î±0 Î±1 (Î±2 Î±4 Î±6)) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read a in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read b in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (* Self *) (Ty.path "u32")
      []
      [
        ("conditional_select", InstanceField.Method conditional_select []);
        ("conditional_assign", InstanceField.Method conditional_assign []);
        ("conditional_swap", InstanceField.Method conditional_swap [])
      ].
End Impl_subtle_ConditionallySelectable_for_u32.

Module Impl_subtle_ConditionallySelectable_for_i32.
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "i32" ];
            (* Rhs *) Ty.path "i32"
          ] in
      let* Î±1 := M.read a in
      let* Î±2 := M.var "BinOp::Pure::bit_and" in
      let* Î±3 := M.read mask in
      let* Î±4 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "i32" ];
            (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "i32" ]
          ] in
      let* Î±5 := M.read a in
      let* Î±6 := M.read b in
      let* Î±7 := M.call Î±4 [ Î±5; Î±6 ] in
      let* Î±8 := M.call Î±0 [ Î±1; Î±2 Î±3 Î±7 ] in
      let* Î±0 := M.alloc Î±8 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read self in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.var "BinOp::Pure::bit_and" in
        let* Î±4 := M.read mask in
        let* Î±5 := M.var "BinOp::Pure::bit_xor" in
        let* Î±6 := M.read self in
        let* Î±7 := M.read (deref Î±6) in
        let* Î±8 := M.read other in
        let* Î±9 := M.read (deref Î±8) in
        Î±0 Î² (Î±1 Î±2 (Î±3 Î±4 (Î±5 Î±7 Î±9))) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* t :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read mask in
        let* Î±2 := M.var "BinOp::Pure::bit_xor" in
        let* Î±3 := M.read a in
        let* Î±4 := M.read (deref Î±3) in
        let* Î±5 := M.read b in
        let* Î±6 := M.read (deref Î±5) in
        M.alloc (Î±0 Î±1 (Î±2 Î±4 Î±6)) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read a in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read b in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (* Self *) (Ty.path "i32")
      []
      [
        ("conditional_select", InstanceField.Method conditional_select []);
        ("conditional_assign", InstanceField.Method conditional_assign []);
        ("conditional_swap", InstanceField.Method conditional_swap [])
      ].
End Impl_subtle_ConditionallySelectable_for_i32.

Module Impl_subtle_ConditionallySelectable_for_u64.
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u64" ];
            (* Rhs *) Ty.path "u64"
          ] in
      let* Î±1 := M.read a in
      let* Î±2 := M.var "BinOp::Pure::bit_and" in
      let* Î±3 := M.read mask in
      let* Î±4 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u64" ];
            (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u64" ]
          ] in
      let* Î±5 := M.read a in
      let* Î±6 := M.read b in
      let* Î±7 := M.call Î±4 [ Î±5; Î±6 ] in
      let* Î±8 := M.call Î±0 [ Î±1; Î±2 Î±3 Î±7 ] in
      let* Î±0 := M.alloc Î±8 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read self in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.var "BinOp::Pure::bit_and" in
        let* Î±4 := M.read mask in
        let* Î±5 := M.var "BinOp::Pure::bit_xor" in
        let* Î±6 := M.read self in
        let* Î±7 := M.read (deref Î±6) in
        let* Î±8 := M.read other in
        let* Î±9 := M.read (deref Î±8) in
        Î±0 Î² (Î±1 Î±2 (Î±3 Î±4 (Î±5 Î±7 Î±9))) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        M.alloc (rust_cast Î±2) in
      let* t :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read mask in
        let* Î±2 := M.var "BinOp::Pure::bit_xor" in
        let* Î±3 := M.read a in
        let* Î±4 := M.read (deref Î±3) in
        let* Î±5 := M.read b in
        let* Î±6 := M.read (deref Î±5) in
        M.alloc (Î±0 Î±1 (Î±2 Î±4 Î±6)) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read a in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read b in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (* Self *) (Ty.path "u64")
      []
      [
        ("conditional_select", InstanceField.Method conditional_select []);
        ("conditional_assign", InstanceField.Method conditional_assign []);
        ("conditional_swap", InstanceField.Method conditional_swap [])
      ].
End Impl_subtle_ConditionallySelectable_for_u64.

Module Impl_subtle_ConditionallySelectable_for_i64.
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "i64" ];
            (* Rhs *) Ty.path "i64"
          ] in
      let* Î±1 := M.read a in
      let* Î±2 := M.var "BinOp::Pure::bit_and" in
      let* Î±3 := M.read mask in
      let* Î±4 :=
        M.get_method
          "core::ops::bit::BitXor"
          "bitxor"
          [
            (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "i64" ];
            (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "i64" ]
          ] in
      let* Î±5 := M.read a in
      let* Î±6 := M.read b in
      let* Î±7 := M.call Î±4 [ Î±5; Î±6 ] in
      let* Î±8 := M.call Î±0 [ Î±1; Î±2 Î±3 Î±7 ] in
      let* Î±0 := M.alloc Î±8 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read self in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.var "BinOp::Pure::bit_and" in
        let* Î±4 := M.read mask in
        let* Î±5 := M.var "BinOp::Pure::bit_xor" in
        let* Î±6 := M.read self in
        let* Î±7 := M.read (deref Î±6) in
        let* Î±8 := M.read other in
        let* Î±9 := M.read (deref Î±8) in
        Î±0 Î² (Î±1 Î±2 (Î±3 Î±4 (Î±5 Î±7 Î±9))) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* Î±0 := M.var "UnOp::neg" in
        let* Î±1 :=
          M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow choice ] in
        let* Î±2 := Î±0 (rust_cast Î±1) in
        let* Î±3 := M.alloc Î±2 in
        M.copy (use Î±3) in
      let* t :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read mask in
        let* Î±2 := M.var "BinOp::Pure::bit_xor" in
        let* Î±3 := M.read a in
        let* Î±4 := M.read (deref Î±3) in
        let* Î±5 := M.read b in
        let* Î±6 := M.read (deref Î±5) in
        M.alloc (Î±0 Î±1 (Î±2 Î±4 Î±6)) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read a in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* _ :=
        let* Î² :=
          let* Î±0 := M.read b in
          M.pure (deref Î±0) in
        let* Î±0 := M.var "assign" in
        let* Î±1 := M.var "BinOp::Pure::bit_xor" in
        let* Î±2 := M.read Î² in
        let* Î±3 := M.read t in
        Î±0 Î² (Î±1 Î±2 Î±3) in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (* Self *) (Ty.path "i64")
      []
      [
        ("conditional_select", InstanceField.Method conditional_select []);
        ("conditional_assign", InstanceField.Method conditional_assign []);
        ("conditional_swap", InstanceField.Method conditional_swap [])
      ].
End Impl_subtle_ConditionallySelectable_for_i64.

Module Impl_subtle_ConditionallySelectable_for_subtle_Choice.
  (*
      fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
          Choice(u8::conditional_select(&a.0, &b.0, choice))
      }
  *)
  Definition conditional_select (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* Î±0 :=
        M.get_method
          "subtle::ConditionallySelectable"
          "conditional_select"
          [ (* Self *) Ty.path "u8" ] in
      let* Î±1 := M.var "subtle::Choice::Get_0" in
      let* Î±2 := M.read a in
      let* Î±3 := M.var "subtle::Choice::Get_0" in
      let* Î±4 := M.read b in
      let* Î±5 := M.read choice in
      let* Î±6 :=
        M.call Î±0 [ borrow (Î±1 (deref Î±2)); borrow (Î±3 (deref Î±4)); Î±5 ] in
      M.pure (Value.StructTuple "subtle::Choice" [ Î±6 ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (* Self *) (Ty.path "subtle::Choice")
      []
      [ ("conditional_select", InstanceField.Method conditional_select []) ].
End Impl_subtle_ConditionallySelectable_for_subtle_Choice.

(* Trait *)
Module ConditionallyNegatable.
  
End ConditionallyNegatable.

Module Impl_subtle_ConditionallyNegatable_for_T.
  (*
      fn conditional_negate(&mut self, choice: Choice) {
          // Need to cast to eliminate mutability
          let self_neg: T = -(self as &T);
          self.conditional_assign(&self_neg, choice);
      }
  *)
  Definition conditional_negate (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ self; choice ] =>
      let* self := M.alloc self in
      let* choice := M.alloc choice in
      let* self_neg :=
        let* Î±0 :=
          M.get_method
            "core::ops::arith::Neg"
            "neg"
            [ (* Self *) Ty.apply (Ty.path "ref") [ T ] ] in
        let* Î±1 := M.read self in
        let* Î±2 := M.alloc (borrow (deref Î±1)) in
        let* Î±3 := M.read (use Î±2) in
        let* Î±4 := M.call Î±0 [ Î±3 ] in
        M.alloc Î±4 in
      let* _ :=
        let* Î±0 :=
          M.get_method
            "subtle::ConditionallySelectable"
            "conditional_assign"
            [ (* Self *) T ] in
        let* Î±1 := M.read self in
        let* Î±2 := M.read choice in
        let* Î±3 := M.call Î±0 [ Î±1; borrow self_neg; Î±2 ] in
        M.alloc Î±3 in
      let* Î±0 := M.alloc tt in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "subtle::ConditionallyNegatable"
      (* Self *) T
      []
      [ ("conditional_negate", InstanceField.Method conditional_negate [ T ]) ].
End Impl_subtle_ConditionallyNegatable_for_T.

(* Enum CtOption *)

Module Impl_core_clone_Clone_for_subtle_CtOption_T.
  (*
  Clone
  *)
  Definition clone (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.get_method "core::clone::Clone" "clone" [ (* Self *) T ] in
      let* Î±1 := M.var "subtle::CtOption::Get_value" in
      let* Î±2 := M.read self in
      let* Î±3 := M.call Î±0 [ borrow (Î±1 (deref Î±2)) ] in
      let* Î±4 :=
        M.get_method
          "core::clone::Clone"
          "clone"
          [ (* Self *) Ty.path "subtle::Choice" ] in
      let* Î±5 := M.var "subtle::CtOption::Get_is_some" in
      let* Î±6 := M.read self in
      let* Î±7 := M.call Î±4 [ borrow (Î±5 (deref Î±6)) ] in
      M.pure
        (Value.StructRecord
          "subtle::CtOption"
          [ ("value", Î±3); ("is_some", Î±7) ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::clone::Clone"
      (* Self *) (Ty.apply (Ty.path "subtle::CtOption") [ T ])
      []
      [ ("clone", InstanceField.Method clone [ T ]) ].
End Impl_core_clone_Clone_for_subtle_CtOption_T.

Module Impl_core_marker_Copy_for_subtle_CtOption_T.
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::marker::Copy"
      (* Self *) (Ty.apply (Ty.path "subtle::CtOption") [ T ])
      []
      [].
End Impl_core_marker_Copy_for_subtle_CtOption_T.

Module Impl_core_fmt_Debug_for_subtle_CtOption_T.
  (*
  Debug
  *)
  Definition fmt (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Î±0 := M.read f in
      let* Î±1 := M.read (mk_str "CtOption") in
      let* Î±2 := M.read (mk_str "value") in
      let* Î±3 := M.var "subtle::CtOption::Get_value" in
      let* Î±4 := M.read self in
      let* Î±5 := M.read (mk_str "is_some") in
      let* Î±6 := M.var "subtle::CtOption::Get_is_some" in
      let* Î±7 := M.read self in
      let* Î±8 := M.alloc (borrow (Î±6 (deref Î±7))) in
      M.call
        (Ty.path "core::fmt::Formatter")::["debug_struct_field2_finish"]
        [
          Î±0;
          Î±1;
          Î±2;
          pointer_coercion "Unsize" (borrow (Î±3 (deref Î±4)));
          Î±5;
          pointer_coercion "Unsize" (borrow Î±8)
        ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Self *) (Ty.apply (Ty.path "subtle::CtOption") [ T ])
      []
      [ ("fmt", InstanceField.Method fmt [ T ]) ].
End Impl_core_fmt_Debug_for_subtle_CtOption_T.

Module Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.
  (*
      fn from(source: CtOption<T>) -> Option<T> {
          if source.is_some().unwrap_u8() == 1u8 {
              Option::Some(source.value)
          } else {
              None
          }
      }
  *)
  Definition from (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ source ] =>
      let* source := M.alloc source in
      let* Î±0 := M.var "BinOp::Pure::eq" in
      let* Î±1 :=
        M.call
          (Ty.apply (Ty.path "subtle::CtOption") [ T ])::["is_some"]
          [ borrow source ] in
      let* Î±2 := M.alloc Î±1 in
      let* Î±3 :=
        M.call (Ty.path "subtle::Choice")::["unwrap_u8"] [ borrow Î±2 ] in
      let* Î±4 := M.alloc (Î±0 Î±3 ((Integer.of_Z 1) : Ty.path "u8")) in
      let* Î±5 := M.read (use Î±4) in
      let* Î±6 :=
        if Î±5 then
          let* Î±0 := M.var "subtle::CtOption::Get_value" in
          let* Î±1 := M.read (Î±0 source) in
          M.alloc (Value.StructTuple "core::option::Option::Some" [ Î±1 ])
        else
          M.alloc core.option.Option.None in
      M.read Î±6
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::convert::From"
      (* Self *) (Ty.apply (Ty.path "core::option::Option") [ T ])
      [ (* T *) Ty.apply (Ty.path "subtle::CtOption") [ T ] ]
      [ ("from", InstanceField.Method from [ T ]) ].
End Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.

Module Impl_subtle_CtOption_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "subtle::CtOption") [ T ].
  
  (*
      pub fn new(value: T, is_some: Choice) -> CtOption<T> {
          CtOption {
              value: value,
              is_some: is_some,
          }
      }
  *)
  Definition new (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ value; is_some ] =>
      let* value := M.alloc value in
      let* is_some := M.alloc is_some in
      let* Î±0 := M.read value in
      let* Î±1 := M.read is_some in
      M.pure
        (Value.StructRecord
          "subtle::CtOption"
          [ ("value", Î±0); ("is_some", Î±1) ])
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_new :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "new" new [ T ].
  
  (*
      pub fn expect(self, msg: &str) -> T {
          assert_eq!(self.is_some.unwrap_u8(), 1, "{}", msg);
  
          self.value
      }
  *)
  Definition expect (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ self; msg ] =>
      let* self := M.alloc self in
      let* msg := M.alloc msg in
      let* _ :=
        let* Î±0 := M.var "subtle::CtOption::Get_is_some" in
        let* Î±1 :=
          M.call
            (Ty.path "subtle::Choice")::["unwrap_u8"]
            [ borrow (Î±0 self) ] in
        let* Î±2 := M.alloc Î±1 in
        let* Î±3 := M.alloc ((Integer.of_Z 1) : Ty.path "u8") in
        let* Î±4 := M.alloc (borrow Î±2, borrow Î±3) in
        match_operator
          Î±4
          [
            fun Î³ =>
              (let* Î±0 := M.read Î³ in
              match Î±0 with
              | (_, _) =>
                let Î³0_0 := Tuple.Access.left Î³ in
                let Î³0_1 := Tuple.Access.right Î³ in
                let* left_val := M.copy Î³0_0 in
                let* right_val := M.copy Î³0_1 in
                let* Î±0 := M.var "UnOp::not" in
                let* Î±1 := M.var "BinOp::Pure::eq" in
                let* Î±2 := M.read left_val in
                let* Î±3 := M.read (deref Î±2) in
                let* Î±4 := M.read right_val in
                let* Î±5 := M.read (deref Î±4) in
                let* Î±6 := M.alloc (Î±0 (Î±1 Î±3 Î±5)) in
                let* Î±7 := M.read (use Î±6) in
                if Î±7 then
                  let* kind := M.alloc core.panicking.AssertKind.Eq in
                  let* Î±0 := M.var "core::panicking::assert_failed" in
                  let* Î±1 := M.read kind in
                  let* Î±2 := M.read left_val in
                  let* Î±3 := M.read right_val in
                  let* Î±4 := M.read (mk_str "") in
                  let* Î±5 := M.alloc [ Î±4 ] in
                  let* Î±6 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_display"]
                      [ borrow msg ] in
                  let* Î±7 := M.alloc [ Î±6 ] in
                  let* Î±8 :=
                    M.call
                      (Ty.path "core::fmt::Arguments")::["new_v1"]
                      [
                        pointer_coercion "Unsize" (borrow Î±5);
                        pointer_coercion "Unsize" (borrow Î±7)
                      ] in
                  let* Î±9 :=
                    M.call
                      Î±0
                      [
                        Î±1;
                        Î±2;
                        Î±3;
                        Value.StructTuple "core::option::Option::Some" [ Î±8 ]
                      ] in
                  let* Î±0 := M.alloc Î±9 in
                  let* Î±1 := M.read Î±0 in
                  let* Î±2 := never_to_any Î±1 in
                  M.alloc Î±2
                else
                  M.alloc tt
              end) :
              Ty.tuple []
          ] in
      let* Î±0 := M.var "subtle::CtOption::Get_value" in
      M.read (Î±0 self)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_expect :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "expect" expect [ T ].
  
  (*
      pub fn unwrap(self) -> T {
          assert_eq!(self.is_some.unwrap_u8(), 1);
  
          self.value
      }
  *)
  Definition unwrap (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ self ] =>
      let* self := M.alloc self in
      let* _ :=
        let* Î±0 := M.var "subtle::CtOption::Get_is_some" in
        let* Î±1 :=
          M.call
            (Ty.path "subtle::Choice")::["unwrap_u8"]
            [ borrow (Î±0 self) ] in
        let* Î±2 := M.alloc Î±1 in
        let* Î±3 := M.alloc ((Integer.of_Z 1) : Ty.path "u8") in
        let* Î±4 := M.alloc (borrow Î±2, borrow Î±3) in
        match_operator
          Î±4
          [
            fun Î³ =>
              (let* Î±0 := M.read Î³ in
              match Î±0 with
              | (_, _) =>
                let Î³0_0 := Tuple.Access.left Î³ in
                let Î³0_1 := Tuple.Access.right Î³ in
                let* left_val := M.copy Î³0_0 in
                let* right_val := M.copy Î³0_1 in
                let* Î±0 := M.var "UnOp::not" in
                let* Î±1 := M.var "BinOp::Pure::eq" in
                let* Î±2 := M.read left_val in
                let* Î±3 := M.read (deref Î±2) in
                let* Î±4 := M.read right_val in
                let* Î±5 := M.read (deref Î±4) in
                let* Î±6 := M.alloc (Î±0 (Î±1 Î±3 Î±5)) in
                let* Î±7 := M.read (use Î±6) in
                if Î±7 then
                  let* kind := M.alloc core.panicking.AssertKind.Eq in
                  let* Î±0 := M.var "core::panicking::assert_failed" in
                  let* Î±1 := M.read kind in
                  let* Î±2 := M.read left_val in
                  let* Î±3 := M.read right_val in
                  let* Î±4 :=
                    M.call Î±0 [ Î±1; Î±2; Î±3; core.option.Option.None ] in
                  let* Î±0 := M.alloc Î±4 in
                  let* Î±1 := M.read Î±0 in
                  let* Î±2 := never_to_any Î±1 in
                  M.alloc Î±2
                else
                  M.alloc tt
              end) :
              Ty.tuple []
          ] in
      let* Î±0 := M.var "subtle::CtOption::Get_value" in
      M.read (Î±0 self)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_unwrap :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "unwrap" unwrap [ T ].
  
  (*
      pub fn unwrap_or(self, def: T) -> T
      where
          T: ConditionallySelectable,
      {
          T::conditional_select(&def, &self.value, self.is_some)
      }
  *)
  Definition unwrap_or (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ self; def ] =>
      let* self := M.alloc self in
      let* def := M.alloc def in
      let* Î±0 :=
        M.get_method
          "subtle::ConditionallySelectable"
          "conditional_select"
          [ (* Self *) T ] in
      let* Î±1 := M.var "subtle::CtOption::Get_value" in
      let* Î±2 := M.var "subtle::CtOption::Get_is_some" in
      let* Î±3 := M.read (Î±2 self) in
      M.call Î±0 [ borrow def; borrow (Î±1 self); Î±3 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_unwrap_or :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "unwrap_or" unwrap_or [ T ].
  
  (*
      pub fn unwrap_or_else<F>(self, f: F) -> T
      where
          T: ConditionallySelectable,
          F: FnOnce() -> T,
      {
          T::conditional_select(&f(), &self.value, self.is_some)
      }
  *)
  Definition unwrap_or_else (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T; F ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Î±0 :=
        M.get_method
          "subtle::ConditionallySelectable"
          "conditional_select"
          [ (* Self *) T ] in
      let* Î±1 :=
        M.get_method
          "core::ops::function::FnOnce"
          "call_once"
          [ (* Self *) F; (* Args *) Ty.tuple [] ] in
      let* Î±2 := M.read f in
      let* Î±3 := M.call Î±1 [ Î±2; tt ] in
      let* Î±4 := M.alloc Î±3 in
      let* Î±5 := M.var "subtle::CtOption::Get_value" in
      let* Î±6 := M.var "subtle::CtOption::Get_is_some" in
      let* Î±7 := M.read (Î±6 self) in
      M.call Î±0 [ borrow Î±4; borrow (Î±5 self); Î±7 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_unwrap_or_else :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "unwrap_or_else" unwrap_or_else [ T ].
  
  (*
      pub fn is_some(&self) -> Choice {
          self.is_some
      }
  *)
  Definition is_some (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 := M.var "subtle::CtOption::Get_is_some" in
      let* Î±1 := M.read self in
      M.read (Î±0 (deref Î±1))
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_is_some :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "is_some" is_some [ T ].
  
  (*
      pub fn is_none(&self) -> Choice {
          !self.is_some
      }
  *)
  Definition is_none (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ self ] =>
      let* self := M.alloc self in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::Not"
          "not"
          [ (* Self *) Ty.path "subtle::Choice" ] in
      let* Î±1 := M.var "subtle::CtOption::Get_is_some" in
      let* Î±2 := M.read self in
      let* Î±3 := M.read (Î±1 (deref Î±2)) in
      M.call Î±0 [ Î±3 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_is_none :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "is_none" is_none [ T ].
  
  (*
      pub fn map<U, F>(self, f: F) -> CtOption<U>
      where
          T: Default + ConditionallySelectable,
          F: FnOnce(T) -> U,
      {
          CtOption::new(
              f(T::conditional_select(
                  &T::default(),
                  &self.value,
                  self.is_some,
              )),
              self.is_some,
          )
      }
  *)
  Definition map (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T; U; F ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Î±0 :=
        M.get_method
          "core::ops::function::FnOnce"
          "call_once"
          [ (* Self *) F; (* Args *) Ty.tuple [ T ] ] in
      let* Î±1 := M.read f in
      let* Î±2 :=
        M.get_method
          "subtle::ConditionallySelectable"
          "conditional_select"
          [ (* Self *) T ] in
      let* Î±3 :=
        M.get_method "core::default::Default" "default" [ (* Self *) T ] in
      let* Î±4 := M.call Î±3 [] in
      let* Î±5 := M.alloc Î±4 in
      let* Î±6 := M.var "subtle::CtOption::Get_value" in
      let* Î±7 := M.var "subtle::CtOption::Get_is_some" in
      let* Î±8 := M.read (Î±7 self) in
      let* Î±9 := M.call Î±2 [ borrow Î±5; borrow (Î±6 self); Î±8 ] in
      let* Î±10 := M.call Î±0 [ Î±1; (Î±9) ] in
      let* Î±11 := M.var "subtle::CtOption::Get_is_some" in
      let* Î±12 := M.read (Î±11 self) in
      M.call (Ty.apply (Ty.path "subtle::CtOption") [ U ])::["new"] [ Î±10; Î±12 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_map :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "map" map [ T ].
  
  (*
      pub fn and_then<U, F>(self, f: F) -> CtOption<U>
      where
          T: Default + ConditionallySelectable,
          F: FnOnce(T) -> CtOption<U>,
      {
          let mut tmp = f(T::conditional_select(
              &T::default(),
              &self.value,
              self.is_some,
          ));
          tmp.is_some &= self.is_some;
  
          tmp
      }
  *)
  Definition and_then (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T; U; F ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* tmp :=
        let* Î±0 :=
          M.get_method
            "core::ops::function::FnOnce"
            "call_once"
            [ (* Self *) F; (* Args *) Ty.tuple [ T ] ] in
        let* Î±1 := M.read f in
        let* Î±2 :=
          M.get_method
            "subtle::ConditionallySelectable"
            "conditional_select"
            [ (* Self *) T ] in
        let* Î±3 :=
          M.get_method "core::default::Default" "default" [ (* Self *) T ] in
        let* Î±4 := M.call Î±3 [] in
        let* Î±5 := M.alloc Î±4 in
        let* Î±6 := M.var "subtle::CtOption::Get_value" in
        let* Î±7 := M.var "subtle::CtOption::Get_is_some" in
        let* Î±8 := M.read (Î±7 self) in
        let* Î±9 := M.call Î±2 [ borrow Î±5; borrow (Î±6 self); Î±8 ] in
        let* Î±10 := M.call Î±0 [ Î±1; (Î±9) ] in
        M.alloc Î±10 in
      let* _ :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitAndAssign"
            "bitand_assign"
            [
              (* Self *) Ty.path "subtle::Choice";
              (* Rhs *) Ty.path "subtle::Choice"
            ] in
        let* Î±1 := M.var "subtle::CtOption::Get_is_some" in
        let* Î±2 := M.var "subtle::CtOption::Get_is_some" in
        let* Î±3 := M.read (Î±2 self) in
        let* Î±4 := M.call Î±0 [ borrow_mut (Î±1 tmp); Î±3 ] in
        M.alloc Î±4 in
      M.read tmp
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_and_then :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "and_then" and_then [ T ].
  
  (*
      pub fn or_else<F>(self, f: F) -> CtOption<T>
      where
          T: ConditionallySelectable,
          F: FnOnce() -> CtOption<T>,
      {
          let is_none = self.is_none();
          let f = f();
  
          Self::conditional_select(&self, &f, is_none)
      }
  *)
  Definition or_else (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T; F ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* is_none :=
        let* Î±0 :=
          M.call
            (Ty.apply (Ty.path "subtle::CtOption") [ T ])::["is_none"]
            [ borrow self ] in
        M.alloc Î±0 in
      let* f :=
        let* Î±0 :=
          M.get_method
            "core::ops::function::FnOnce"
            "call_once"
            [ (* Self *) F; (* Args *) Ty.tuple [] ] in
        let* Î±1 := M.read f in
        let* Î±2 := M.call Î±0 [ Î±1; tt ] in
        M.alloc Î±2 in
      let* Î±0 :=
        M.get_method
          "subtle::ConditionallySelectable"
          "conditional_select"
          [ (* Self *) Ty.apply (Ty.path "subtle::CtOption") [ T ] ] in
      let* Î±1 := M.read is_none in
      let* Î±2 := M.call Î±0 [ borrow self; borrow f; Î±1 ] in
      let* Î±0 := M.alloc Î±2 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_or_else :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "or_else" or_else [ T ].
End Impl_subtle_CtOption_T.

Module Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  (*
      fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
          CtOption::new(
              T::conditional_select(&a.value, &b.value, choice),
              Choice::conditional_select(&a.is_some, &b.is_some, choice),
          )
      }
  *)
  Definition conditional_select (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* Î±0 :=
        M.get_method
          "subtle::ConditionallySelectable"
          "conditional_select"
          [ (* Self *) T ] in
      let* Î±1 := M.var "subtle::CtOption::Get_value" in
      let* Î±2 := M.read a in
      let* Î±3 := M.var "subtle::CtOption::Get_value" in
      let* Î±4 := M.read b in
      let* Î±5 := M.read choice in
      let* Î±6 :=
        M.call Î±0 [ borrow (Î±1 (deref Î±2)); borrow (Î±3 (deref Î±4)); Î±5 ] in
      let* Î±7 :=
        M.get_method
          "subtle::ConditionallySelectable"
          "conditional_select"
          [ (* Self *) Ty.path "subtle::Choice" ] in
      let* Î±8 := M.var "subtle::CtOption::Get_is_some" in
      let* Î±9 := M.read a in
      let* Î±10 := M.var "subtle::CtOption::Get_is_some" in
      let* Î±11 := M.read b in
      let* Î±12 := M.read choice in
      let* Î±13 :=
        M.call Î±7 [ borrow (Î±8 (deref Î±9)); borrow (Î±10 (deref Î±11)); Î±12 ] in
      M.call (Ty.apply (Ty.path "subtle::CtOption") [ T ])::["new"] [ Î±6; Î±13 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (* Self *) (Ty.apply (Ty.path "subtle::CtOption") [ T ])
      []
      [ ("conditional_select", InstanceField.Method conditional_select [ T ]) ].
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  (*
      fn ct_eq(&self, rhs: &CtOption<T>) -> Choice {
          let a = self.is_some();
          let b = rhs.is_some();
  
          (a & b & self.value.ct_eq(&rhs.value)) | (!a & !b)
      }
  *)
  Definition ct_eq (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self; T ], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* a :=
        let* Î±0 := M.read self in
        let* Î±1 :=
          M.call
            (Ty.apply (Ty.path "subtle::CtOption") [ T ])::["is_some"]
            [ Î±0 ] in
        M.alloc Î±1 in
      let* b :=
        let* Î±0 := M.read rhs in
        let* Î±1 :=
          M.call
            (Ty.apply (Ty.path "subtle::CtOption") [ T ])::["is_some"]
            [ Î±0 ] in
        M.alloc Î±1 in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::BitOr"
          "bitor"
          [
            (* Self *) Ty.path "subtle::Choice";
            (* Rhs *) Ty.path "subtle::Choice"
          ] in
      let* Î±1 :=
        M.get_method
          "core::ops::bit::BitAnd"
          "bitand"
          [
            (* Self *) Ty.path "subtle::Choice";
            (* Rhs *) Ty.path "subtle::Choice"
          ] in
      let* Î±2 :=
        M.get_method
          "core::ops::bit::BitAnd"
          "bitand"
          [
            (* Self *) Ty.path "subtle::Choice";
            (* Rhs *) Ty.path "subtle::Choice"
          ] in
      let* Î±3 := M.read a in
      let* Î±4 := M.read b in
      let* Î±5 := M.call Î±2 [ Î±3; Î±4 ] in
      let* Î±6 :=
        M.get_method "subtle::ConstantTimeEq" "ct_eq" [ (* Self *) T ] in
      let* Î±7 := M.var "subtle::CtOption::Get_value" in
      let* Î±8 := M.read self in
      let* Î±9 := M.var "subtle::CtOption::Get_value" in
      let* Î±10 := M.read rhs in
      let* Î±11 :=
        M.call Î±6 [ borrow (Î±7 (deref Î±8)); borrow (Î±9 (deref Î±10)) ] in
      let* Î±12 := M.call Î±1 [ Î±5; Î±11 ] in
      let* Î±13 :=
        M.get_method
          "core::ops::bit::BitAnd"
          "bitand"
          [
            (* Self *) Ty.path "subtle::Choice";
            (* Rhs *) Ty.path "subtle::Choice"
          ] in
      let* Î±14 :=
        M.get_method
          "core::ops::bit::Not"
          "not"
          [ (* Self *) Ty.path "subtle::Choice" ] in
      let* Î±15 := M.read a in
      let* Î±16 := M.call Î±14 [ Î±15 ] in
      let* Î±17 :=
        M.get_method
          "core::ops::bit::Not"
          "not"
          [ (* Self *) Ty.path "subtle::Choice" ] in
      let* Î±18 := M.read b in
      let* Î±19 := M.call Î±17 [ Î±18 ] in
      let* Î±20 := M.call Î±13 [ Î±16; Î±19 ] in
      let* Î±21 := M.call Î±0 [ Î±12; Î±20 ] in
      let* Î±0 := M.alloc Î±21 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (* Self *) (Ty.apply (Ty.path "subtle::CtOption") [ T ])
      []
      [ ("ct_eq", InstanceField.Method ct_eq [ T ]) ].
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.

(* Trait *)
Module ConstantTimeGreater.
  
End ConstantTimeGreater.

Module Impl_subtle_ConstantTimeGreater_for_u8.
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitAnd"
            "bitand"
            [
              (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u8" ];
              (* Rhs *) Ty.path "u8"
            ] in
        let* Î±1 := M.read self in
        let* Î±2 :=
          M.get_method
            "core::ops::bit::Not"
            "not"
            [ (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u8" ] ] in
        let* Î±3 := M.read other in
        let* Î±4 := M.call Î±2 [ Î±3 ] in
        let* Î±5 := M.call Î±0 [ Î±1; Î±4 ] in
        M.alloc Î±5 in
      let* ltb :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitAnd"
            "bitand"
            [
              (* Self *) Ty.path "u8";
              (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u8" ]
            ] in
        let* Î±1 :=
          M.get_method
            "core::ops::bit::Not"
            "not"
            [ (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u8" ] ] in
        let* Î±2 := M.read self in
        let* Î±3 := M.call Î±1 [ Î±2 ] in
        let* Î±4 := M.read other in
        let* Î±5 := M.call Î±0 [ Î±3; Î±4 ] in
        M.alloc Î±5 in
      let* pow := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ :=
        M.loop
          (let* Î±0 := M.var "BinOp::Pure::lt" in
          let* Î±1 := M.read pow in
          let* Î±2 := M.alloc (Î±0 Î±1 ((Integer.of_Z 8) : Ty.path "i32")) in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* _ :=
              let Î² := ltb in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Pure::bit_or" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.var "BinOp::Panic::shr" in
              let* Î±4 := M.read ltb in
              let* Î±5 := M.read pow in
              let* Î±6 := Î±3 Î±4 Î±5 in
              Î±0 Î² (Î±1 Î±2 Î±6) in
            let* _ :=
              let Î² := pow in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Panic::add" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.read pow in
              let* Î±4 := Î±1 Î±2 Î±3 in
              Î±0 Î² Î±4 in
            M.alloc tt
          else
            let* _ :=
              let* Î±0 := M.break in
              let* Î±1 := M.read Î±0 in
              let* Î±2 := never_to_any Î±1 in
              M.alloc Î±2 in
            let* Î±0 := M.alloc tt in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2) in
      let* bit :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read gtb in
        let* Î±2 := M.var "UnOp::not" in
        let* Î±3 := M.read ltb in
        M.alloc (Î±0 Î±1 (Î±2 Î±3)) in
      let* pow := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ :=
        M.loop
          (let* Î±0 := M.var "BinOp::Pure::lt" in
          let* Î±1 := M.read pow in
          let* Î±2 := M.alloc (Î±0 Î±1 ((Integer.of_Z 8) : Ty.path "i32")) in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* _ :=
              let Î² := bit in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Pure::bit_or" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.var "BinOp::Panic::shr" in
              let* Î±4 := M.read bit in
              let* Î±5 := M.read pow in
              let* Î±6 := Î±3 Î±4 Î±5 in
              Î±0 Î² (Î±1 Î±2 Î±6) in
            let* _ :=
              let Î² := pow in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Panic::add" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.read pow in
              let* Î±4 := Î±1 Î±2 Î±3 in
              Î±0 Î² Î±4 in
            M.alloc tt
          else
            let* _ :=
              let* Î±0 := M.break in
              let* Î±1 := M.read Î±0 in
              let* Î±2 := never_to_any Î±1 in
              M.alloc Î±2 in
            let* Î±0 := M.alloc tt in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2) in
      let* Î±0 :=
        M.get_method
          "core::convert::From"
          "from"
          [ (* Self *) Ty.path "subtle::Choice"; (* T *) Ty.path "u8" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_and" in
      let* Î±2 := M.read bit in
      let* Î±3 := M.alloc (Î±1 Î±2 ((Integer.of_Z 1) : Ty.path "u8")) in
      let* Î±4 := M.read (use Î±3) in
      let* Î±5 := M.call Î±0 [ Î±4 ] in
      let* Î±0 := M.alloc Î±5 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeGreater"
      (* Self *) (Ty.path "u8")
      []
      [ ("ct_gt", InstanceField.Method ct_gt []) ].
End Impl_subtle_ConstantTimeGreater_for_u8.

Module Impl_subtle_ConstantTimeGreater_for_u16.
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitAnd"
            "bitand"
            [
              (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u16" ];
              (* Rhs *) Ty.path "u16"
            ] in
        let* Î±1 := M.read self in
        let* Î±2 :=
          M.get_method
            "core::ops::bit::Not"
            "not"
            [ (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u16" ] ] in
        let* Î±3 := M.read other in
        let* Î±4 := M.call Î±2 [ Î±3 ] in
        let* Î±5 := M.call Î±0 [ Î±1; Î±4 ] in
        M.alloc Î±5 in
      let* ltb :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitAnd"
            "bitand"
            [
              (* Self *) Ty.path "u16";
              (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u16" ]
            ] in
        let* Î±1 :=
          M.get_method
            "core::ops::bit::Not"
            "not"
            [ (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u16" ] ] in
        let* Î±2 := M.read self in
        let* Î±3 := M.call Î±1 [ Î±2 ] in
        let* Î±4 := M.read other in
        let* Î±5 := M.call Î±0 [ Î±3; Î±4 ] in
        M.alloc Î±5 in
      let* pow := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ :=
        M.loop
          (let* Î±0 := M.var "BinOp::Pure::lt" in
          let* Î±1 := M.read pow in
          let* Î±2 := M.alloc (Î±0 Î±1 ((Integer.of_Z 16) : Ty.path "i32")) in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* _ :=
              let Î² := ltb in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Pure::bit_or" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.var "BinOp::Panic::shr" in
              let* Î±4 := M.read ltb in
              let* Î±5 := M.read pow in
              let* Î±6 := Î±3 Î±4 Î±5 in
              Î±0 Î² (Î±1 Î±2 Î±6) in
            let* _ :=
              let Î² := pow in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Panic::add" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.read pow in
              let* Î±4 := Î±1 Î±2 Î±3 in
              Î±0 Î² Î±4 in
            M.alloc tt
          else
            let* _ :=
              let* Î±0 := M.break in
              let* Î±1 := M.read Î±0 in
              let* Î±2 := never_to_any Î±1 in
              M.alloc Î±2 in
            let* Î±0 := M.alloc tt in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2) in
      let* bit :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read gtb in
        let* Î±2 := M.var "UnOp::not" in
        let* Î±3 := M.read ltb in
        M.alloc (Î±0 Î±1 (Î±2 Î±3)) in
      let* pow := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ :=
        M.loop
          (let* Î±0 := M.var "BinOp::Pure::lt" in
          let* Î±1 := M.read pow in
          let* Î±2 := M.alloc (Î±0 Î±1 ((Integer.of_Z 16) : Ty.path "i32")) in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* _ :=
              let Î² := bit in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Pure::bit_or" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.var "BinOp::Panic::shr" in
              let* Î±4 := M.read bit in
              let* Î±5 := M.read pow in
              let* Î±6 := Î±3 Î±4 Î±5 in
              Î±0 Î² (Î±1 Î±2 Î±6) in
            let* _ :=
              let Î² := pow in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Panic::add" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.read pow in
              let* Î±4 := Î±1 Î±2 Î±3 in
              Î±0 Î² Î±4 in
            M.alloc tt
          else
            let* _ :=
              let* Î±0 := M.break in
              let* Î±1 := M.read Î±0 in
              let* Î±2 := never_to_any Î±1 in
              M.alloc Î±2 in
            let* Î±0 := M.alloc tt in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2) in
      let* Î±0 :=
        M.get_method
          "core::convert::From"
          "from"
          [ (* Self *) Ty.path "subtle::Choice"; (* T *) Ty.path "u8" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_and" in
      let* Î±2 := M.read bit in
      let* Î±3 :=
        M.call Î±0 [ rust_cast (Î±1 Î±2 ((Integer.of_Z 1) : Ty.path "u16")) ] in
      let* Î±0 := M.alloc Î±3 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeGreater"
      (* Self *) (Ty.path "u16")
      []
      [ ("ct_gt", InstanceField.Method ct_gt []) ].
End Impl_subtle_ConstantTimeGreater_for_u16.

Module Impl_subtle_ConstantTimeGreater_for_u32.
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitAnd"
            "bitand"
            [
              (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u32" ];
              (* Rhs *) Ty.path "u32"
            ] in
        let* Î±1 := M.read self in
        let* Î±2 :=
          M.get_method
            "core::ops::bit::Not"
            "not"
            [ (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u32" ] ] in
        let* Î±3 := M.read other in
        let* Î±4 := M.call Î±2 [ Î±3 ] in
        let* Î±5 := M.call Î±0 [ Î±1; Î±4 ] in
        M.alloc Î±5 in
      let* ltb :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitAnd"
            "bitand"
            [
              (* Self *) Ty.path "u32";
              (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u32" ]
            ] in
        let* Î±1 :=
          M.get_method
            "core::ops::bit::Not"
            "not"
            [ (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u32" ] ] in
        let* Î±2 := M.read self in
        let* Î±3 := M.call Î±1 [ Î±2 ] in
        let* Î±4 := M.read other in
        let* Î±5 := M.call Î±0 [ Î±3; Î±4 ] in
        M.alloc Î±5 in
      let* pow := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ :=
        M.loop
          (let* Î±0 := M.var "BinOp::Pure::lt" in
          let* Î±1 := M.read pow in
          let* Î±2 := M.alloc (Î±0 Î±1 ((Integer.of_Z 32) : Ty.path "i32")) in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* _ :=
              let Î² := ltb in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Pure::bit_or" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.var "BinOp::Panic::shr" in
              let* Î±4 := M.read ltb in
              let* Î±5 := M.read pow in
              let* Î±6 := Î±3 Î±4 Î±5 in
              Î±0 Î² (Î±1 Î±2 Î±6) in
            let* _ :=
              let Î² := pow in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Panic::add" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.read pow in
              let* Î±4 := Î±1 Î±2 Î±3 in
              Î±0 Î² Î±4 in
            M.alloc tt
          else
            let* _ :=
              let* Î±0 := M.break in
              let* Î±1 := M.read Î±0 in
              let* Î±2 := never_to_any Î±1 in
              M.alloc Î±2 in
            let* Î±0 := M.alloc tt in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2) in
      let* bit :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read gtb in
        let* Î±2 := M.var "UnOp::not" in
        let* Î±3 := M.read ltb in
        M.alloc (Î±0 Î±1 (Î±2 Î±3)) in
      let* pow := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ :=
        M.loop
          (let* Î±0 := M.var "BinOp::Pure::lt" in
          let* Î±1 := M.read pow in
          let* Î±2 := M.alloc (Î±0 Î±1 ((Integer.of_Z 32) : Ty.path "i32")) in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* _ :=
              let Î² := bit in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Pure::bit_or" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.var "BinOp::Panic::shr" in
              let* Î±4 := M.read bit in
              let* Î±5 := M.read pow in
              let* Î±6 := Î±3 Î±4 Î±5 in
              Î±0 Î² (Î±1 Î±2 Î±6) in
            let* _ :=
              let Î² := pow in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Panic::add" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.read pow in
              let* Î±4 := Î±1 Î±2 Î±3 in
              Î±0 Î² Î±4 in
            M.alloc tt
          else
            let* _ :=
              let* Î±0 := M.break in
              let* Î±1 := M.read Î±0 in
              let* Î±2 := never_to_any Î±1 in
              M.alloc Î±2 in
            let* Î±0 := M.alloc tt in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2) in
      let* Î±0 :=
        M.get_method
          "core::convert::From"
          "from"
          [ (* Self *) Ty.path "subtle::Choice"; (* T *) Ty.path "u8" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_and" in
      let* Î±2 := M.read bit in
      let* Î±3 :=
        M.call Î±0 [ rust_cast (Î±1 Î±2 ((Integer.of_Z 1) : Ty.path "u32")) ] in
      let* Î±0 := M.alloc Î±3 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeGreater"
      (* Self *) (Ty.path "u32")
      []
      [ ("ct_gt", InstanceField.Method ct_gt []) ].
End Impl_subtle_ConstantTimeGreater_for_u32.

Module Impl_subtle_ConstantTimeGreater_for_u64.
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [ Self ], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitAnd"
            "bitand"
            [
              (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u64" ];
              (* Rhs *) Ty.path "u64"
            ] in
        let* Î±1 := M.read self in
        let* Î±2 :=
          M.get_method
            "core::ops::bit::Not"
            "not"
            [ (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u64" ] ] in
        let* Î±3 := M.read other in
        let* Î±4 := M.call Î±2 [ Î±3 ] in
        let* Î±5 := M.call Î±0 [ Î±1; Î±4 ] in
        M.alloc Î±5 in
      let* ltb :=
        let* Î±0 :=
          M.get_method
            "core::ops::bit::BitAnd"
            "bitand"
            [
              (* Self *) Ty.path "u64";
              (* Rhs *) Ty.apply (Ty.path "ref") [ Ty.path "u64" ]
            ] in
        let* Î±1 :=
          M.get_method
            "core::ops::bit::Not"
            "not"
            [ (* Self *) Ty.apply (Ty.path "ref") [ Ty.path "u64" ] ] in
        let* Î±2 := M.read self in
        let* Î±3 := M.call Î±1 [ Î±2 ] in
        let* Î±4 := M.read other in
        let* Î±5 := M.call Î±0 [ Î±3; Î±4 ] in
        M.alloc Î±5 in
      let* pow := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ :=
        M.loop
          (let* Î±0 := M.var "BinOp::Pure::lt" in
          let* Î±1 := M.read pow in
          let* Î±2 := M.alloc (Î±0 Î±1 ((Integer.of_Z 64) : Ty.path "i32")) in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* _ :=
              let Î² := ltb in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Pure::bit_or" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.var "BinOp::Panic::shr" in
              let* Î±4 := M.read ltb in
              let* Î±5 := M.read pow in
              let* Î±6 := Î±3 Î±4 Î±5 in
              Î±0 Î² (Î±1 Î±2 Î±6) in
            let* _ :=
              let Î² := pow in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Panic::add" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.read pow in
              let* Î±4 := Î±1 Î±2 Î±3 in
              Î±0 Î² Î±4 in
            M.alloc tt
          else
            let* _ :=
              let* Î±0 := M.break in
              let* Î±1 := M.read Î±0 in
              let* Î±2 := never_to_any Î±1 in
              M.alloc Î±2 in
            let* Î±0 := M.alloc tt in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2) in
      let* bit :=
        let* Î±0 := M.var "BinOp::Pure::bit_and" in
        let* Î±1 := M.read gtb in
        let* Î±2 := M.var "UnOp::not" in
        let* Î±3 := M.read ltb in
        M.alloc (Î±0 Î±1 (Î±2 Î±3)) in
      let* pow := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ :=
        M.loop
          (let* Î±0 := M.var "BinOp::Pure::lt" in
          let* Î±1 := M.read pow in
          let* Î±2 := M.alloc (Î±0 Î±1 ((Integer.of_Z 64) : Ty.path "i32")) in
          let* Î±3 := M.read (use Î±2) in
          if Î±3 then
            let* _ :=
              let Î² := bit in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Pure::bit_or" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.var "BinOp::Panic::shr" in
              let* Î±4 := M.read bit in
              let* Î±5 := M.read pow in
              let* Î±6 := Î±3 Î±4 Î±5 in
              Î±0 Î² (Î±1 Î±2 Î±6) in
            let* _ :=
              let Î² := pow in
              let* Î±0 := M.var "assign" in
              let* Î±1 := M.var "BinOp::Panic::add" in
              let* Î±2 := M.read Î² in
              let* Î±3 := M.read pow in
              let* Î±4 := Î±1 Î±2 Î±3 in
              Î±0 Î² Î±4 in
            M.alloc tt
          else
            let* _ :=
              let* Î±0 := M.break in
              let* Î±1 := M.read Î±0 in
              let* Î±2 := never_to_any Î±1 in
              M.alloc Î±2 in
            let* Î±0 := M.alloc tt in
            let* Î±1 := M.read Î±0 in
            let* Î±2 := never_to_any Î±1 in
            M.alloc Î±2) in
      let* Î±0 :=
        M.get_method
          "core::convert::From"
          "from"
          [ (* Self *) Ty.path "subtle::Choice"; (* T *) Ty.path "u8" ] in
      let* Î±1 := M.var "BinOp::Pure::bit_and" in
      let* Î±2 := M.read bit in
      let* Î±3 :=
        M.call Î±0 [ rust_cast (Î±1 Î±2 ((Integer.of_Z 1) : Ty.path "u64")) ] in
      let* Î±0 := M.alloc Î±3 in
      M.read Î±0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeGreater"
      (* Self *) (Ty.path "u64")
      []
      [ ("ct_gt", InstanceField.Method ct_gt []) ].
End Impl_subtle_ConstantTimeGreater_for_u64.

(* Trait *)
Module ConstantTimeLess.
  Definition ct_lt (ðœ : list Ty.t) (Î± : list Value.t) : M :=
    match ðœ, Î± with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Î±0 :=
        M.get_method
          "core::ops::bit::BitAnd"
          "bitand"
          [
            (* Self *) Ty.path "subtle::Choice";
            (* Rhs *) Ty.path "subtle::Choice"
          ] in
      let* Î±1 :=
        M.get_method
          "core::ops::bit::Not"
          "not"
          [ (* Self *) Ty.path "subtle::Choice" ] in
      let* Î±2 :=
        M.get_method
          "subtle::ConstantTimeGreater"
          "ct_gt"
          [ (* Self *) Self ] in
      let* Î±3 := M.read self in
      let* Î±4 := M.read other in
      let* Î±5 := M.call Î±2 [ Î±3; Î±4 ] in
      let* Î±6 := M.call Î±1 [ Î±5 ] in
      let* Î±7 :=
        M.get_method
          "core::ops::bit::Not"
          "not"
          [ (* Self *) Ty.path "subtle::Choice" ] in
      let* Î±8 :=
        M.get_method "subtle::ConstantTimeEq" "ct_eq" [ (* Self *) Self ] in
      let* Î±9 := M.read self in
      let* Î±10 := M.read other in
      let* Î±11 := M.call Î±8 [ Î±9; Î±10 ] in
      let* Î±12 := M.call Î±7 [ Î±11 ] in
      M.call Î±0 [ Î±6; Î±12 ]
    | _, _ => M.impossible
    end.
  
  Axiom ProvidedMethod_ct_lt :
    M.IsProvidedMethod "subtle::ConstantTimeLess" ct_lt.
End ConstantTimeLess.

Module Impl_subtle_ConstantTimeLess_for_u8.
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeLess"
      (* Self *) (Ty.path "u8")
      []
      [].
End Impl_subtle_ConstantTimeLess_for_u8.

Module Impl_subtle_ConstantTimeLess_for_u16.
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeLess"
      (* Self *) (Ty.path "u16")
      []
      [].
End Impl_subtle_ConstantTimeLess_for_u16.

Module Impl_subtle_ConstantTimeLess_for_u32.
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeLess"
      (* Self *) (Ty.path "u32")
      []
      [].
End Impl_subtle_ConstantTimeLess_for_u32.

Module Impl_subtle_ConstantTimeLess_for_u64.
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeLess"
      (* Self *) (Ty.path "u64")
      []
      [].
End Impl_subtle_ConstantTimeLess_for_u64.
