(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* StructTuple
  {
    name := "Choice";
    ty_params := [];
    fields := [ Ty.path "u8" ];
  } *)

Module Impl_core_marker_Copy_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::Copy"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_Copy_for_subtle_Choice.

Module Impl_core_clone_Clone_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
  Clone
  *)
  Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 :=
        M.match_operator Value.DeclaredButUndefined [ fun γ => M.read self ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_subtle_Choice.

Module Impl_core_fmt_Debug_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
  Debug
  *)
  Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* α0 :=
        M.get_associated_function
          (Ty.path "core::fmt::Formatter")
          "debug_tuple_field1_finish"
          [] in
      let* α1 := M.read f in
      let* α2 := M.read (mk_str "Choice") in
      let* α5 :=
        (* Unsize *)
          let* α3 := M.read self in
          let* α4 := M.alloc (M.get_struct_tuple_field α3 "subtle::Choice" 0) in
          M.pure (M.pointer_coercion α4) in
      M.call_closure α0 [ α1; α2; α5 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_subtle_Choice.

Module Impl_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      pub fn unwrap_u8(&self) -> u8 {
          self.0
      }
  *)
  Definition unwrap_u8 (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read (M.get_struct_tuple_field α0 "subtle::Choice" 0)
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_unwrap_u8 :
    M.IsAssociatedFunction Self "unwrap_u8" unwrap_u8.
End Impl_subtle_Choice.

Module Impl_core_convert_From_subtle_Choice_for_bool.
  Definition Self : Ty.t := Ty.path "bool".
  
  (*
      fn from(source: Choice) -> bool {
          debug_assert!((source.0 == 0u8) | (source.0 == 1u8));
          source.0 != 0
      }
  *)
  Definition from (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ source ] =>
      let* source := M.alloc source in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 := M.alloc (Value.Bool true) in
                M.pure (M.use α0) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* _ :=
                let* α0 := M.alloc (Value.Tuple []) in
                M.match_operator
                  α0
                  [
                    fun γ =>
                      let* γ :=
                        let* α0 :=
                          M.read
                            (M.get_struct_tuple_field
                              source
                              "subtle::Choice"
                              0) in
                        let* α1 :=
                          M.read
                            (M.get_struct_tuple_field
                              source
                              "subtle::Choice"
                              0) in
                        let* α2 :=
                          M.alloc
                            (UnOp.Pure.not
                              (BinOp.Pure.bit_or
                                (BinOp.Pure.eq α0 (Value.Integer Integer.U8 0))
                                (BinOp.Pure.eq
                                  α1
                                  (Value.Integer Integer.U8 1)))) in
                        M.pure (M.use α2) in
                      let* _ :=
                        let* α0 := M.read γ in
                        M.is_constant_or_break_match α0 (Value.Bool true) in
                      let* α0 := M.get_function "core::panicking::panic" [] in
                      let* α1 :=
                        M.read
                          (mk_str
                            "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)") in
                      let* α2 := M.call_closure α0 [ α1 ] in
                      let* α3 := M.never_to_any α2 in
                      M.alloc α3;
                    fun γ => M.alloc (Value.Tuple [])
                  ] in
              M.alloc (Value.Tuple []);
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* α0 := M.read (M.get_struct_tuple_field source "subtle::Choice" 0) in
      let* α0 := M.alloc (BinOp.Pure.ne α0 (Value.Integer Integer.U8 0)) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      Self
      (* Trait polymorphic types *) [ (* T *) Ty.path "subtle::Choice" ]
      (* Instance *) [ ("from", InstanceField.Method from) ].
End Impl_core_convert_From_subtle_Choice_for_bool.

Module Impl_core_ops_bit_BitAnd_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      type Output = Choice;
  *)
  Definition _Output : Ty.t := Ty.path "subtle::Choice".
  
  (*
      fn bitand(self, rhs: Choice) -> Choice {
          (self.0 & rhs.0).into()
      }
  *)
  Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* α0 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.path "u8")
          [ Ty.path "subtle::Choice" ]
          "into"
          [] in
      let* α1 := M.read (M.get_struct_tuple_field self "subtle::Choice" 0) in
      let* α2 := M.read (M.get_struct_tuple_field rhs "subtle::Choice" 0) in
      M.call_closure α0 [ BinOp.Pure.bit_and α1 α2 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitAnd"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("Output", InstanceField.Ty _Output);
          ("bitand", InstanceField.Method bitand)
        ].
End Impl_core_ops_bit_BitAnd_for_subtle_Choice.

Module Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      fn bitand_assign(&mut self, rhs: Choice) {
          *self = *self & rhs;
      }
  *)
  Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* _ :=
        let* α0 := M.read self in
        let* α1 :=
          M.get_trait_method
            "core::ops::bit::BitAnd"
            (Ty.path "subtle::Choice")
            [ Ty.path "subtle::Choice" ]
            "bitand"
            [] in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read rhs in
        let* α5 := M.call_closure α1 [ α3; α4 ] in
        M.assign α0 α5 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitAndAssign"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitOr_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      type Output = Choice;
  *)
  Definition _Output : Ty.t := Ty.path "subtle::Choice".
  
  (*
      fn bitor(self, rhs: Choice) -> Choice {
          (self.0 | rhs.0).into()
      }
  *)
  Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* α0 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.path "u8")
          [ Ty.path "subtle::Choice" ]
          "into"
          [] in
      let* α1 := M.read (M.get_struct_tuple_field self "subtle::Choice" 0) in
      let* α2 := M.read (M.get_struct_tuple_field rhs "subtle::Choice" 0) in
      M.call_closure α0 [ BinOp.Pure.bit_or α1 α2 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitOr"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("Output", InstanceField.Ty _Output);
          ("bitor", InstanceField.Method bitor)
        ].
End Impl_core_ops_bit_BitOr_for_subtle_Choice.

Module Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      fn bitor_assign(&mut self, rhs: Choice) {
          *self = *self | rhs;
      }
  *)
  Definition bitor_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* _ :=
        let* α0 := M.read self in
        let* α1 :=
          M.get_trait_method
            "core::ops::bit::BitOr"
            (Ty.path "subtle::Choice")
            [ Ty.path "subtle::Choice" ]
            "bitor"
            [] in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read rhs in
        let* α5 := M.call_closure α1 [ α3; α4 ] in
        M.assign α0 α5 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitOrAssign"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitXor_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      type Output = Choice;
  *)
  Definition _Output : Ty.t := Ty.path "subtle::Choice".
  
  (*
      fn bitxor(self, rhs: Choice) -> Choice {
          (self.0 ^ rhs.0).into()
      }
  *)
  Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* α0 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.path "u8")
          [ Ty.path "subtle::Choice" ]
          "into"
          [] in
      let* α1 := M.read (M.get_struct_tuple_field self "subtle::Choice" 0) in
      let* α2 := M.read (M.get_struct_tuple_field rhs "subtle::Choice" 0) in
      M.call_closure α0 [ BinOp.Pure.bit_xor α1 α2 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitXor"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("Output", InstanceField.Ty _Output);
          ("bitxor", InstanceField.Method bitxor)
        ].
End Impl_core_ops_bit_BitXor_for_subtle_Choice.

Module Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      fn bitxor_assign(&mut self, rhs: Choice) {
          *self = *self ^ rhs;
      }
  *)
  Definition bitxor_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* _ :=
        let* α0 := M.read self in
        let* α1 :=
          M.get_trait_method
            "core::ops::bit::BitXor"
            (Ty.path "subtle::Choice")
            [ Ty.path "subtle::Choice" ]
            "bitxor"
            [] in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read rhs in
        let* α5 := M.call_closure α1 [ α3; α4 ] in
        M.assign α0 α5 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::BitXorAssign"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.

Module Impl_core_ops_bit_Not_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      type Output = Choice;
  *)
  Definition _Output : Ty.t := Ty.path "subtle::Choice".
  
  (*
      fn not(self) -> Choice {
          (1u8 & (!self.0)).into()
      }
  *)
  Definition not (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.path "u8")
          [ Ty.path "subtle::Choice" ]
          "into"
          [] in
      let* α1 := M.read (M.get_struct_tuple_field self "subtle::Choice" 0) in
      M.call_closure
        α0
        [ BinOp.Pure.bit_and (Value.Integer Integer.U8 1) (UnOp.Pure.not α1) ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::bit::Not"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("Output", InstanceField.Ty _Output);
          ("not", InstanceField.Method not)
        ].
End Impl_core_ops_bit_Not_for_subtle_Choice.

(*
fn black_box(input: u8) -> u8 {
    debug_assert!((input == 0u8) | (input == 1u8));

    unsafe {
        // Optimization barrier
        //
        // Unsafe is ok, because:
        //   - &input is not NULL;
        //   - size of input is not zero;
        //   - u8 is neither Sync, nor Send;
        //   - u8 is Copy, so input is always live;
        //   - u8 type is always properly aligned.
        core::ptr::read_volatile(&input as *const u8)
    }
}
*)
Definition black_box (τ : list Ty.t) (α : list Value.t) : M :=
  match τ, α with
  | [], [ input ] =>
    let* input := M.alloc input in
    let* _ :=
      let* α0 := M.alloc (Value.Tuple []) in
      M.match_operator
        α0
        [
          fun γ =>
            let* γ :=
              let* α0 := M.alloc (Value.Bool true) in
              M.pure (M.use α0) in
            let* _ :=
              let* α0 := M.read γ in
              M.is_constant_or_break_match α0 (Value.Bool true) in
            let* _ :=
              let* α0 := M.alloc (Value.Tuple []) in
              M.match_operator
                α0
                [
                  fun γ =>
                    let* γ :=
                      let* α0 := M.read input in
                      let* α1 := M.read input in
                      let* α2 :=
                        M.alloc
                          (UnOp.Pure.not
                            (BinOp.Pure.bit_or
                              (BinOp.Pure.eq α0 (Value.Integer Integer.U8 0))
                              (BinOp.Pure.eq
                                α1
                                (Value.Integer Integer.U8 1)))) in
                      M.pure (M.use α2) in
                    let* _ :=
                      let* α0 := M.read γ in
                      M.is_constant_or_break_match α0 (Value.Bool true) in
                    let* α0 := M.get_function "core::panicking::panic" [] in
                    let* α1 :=
                      M.read
                        (mk_str
                          "assertion failed: (input == 0u8) | (input == 1u8)") in
                    let* α2 := M.call_closure α0 [ α1 ] in
                    let* α3 := M.never_to_any α2 in
                    M.alloc α3;
                  fun γ => M.alloc (Value.Tuple [])
                ] in
            M.alloc (Value.Tuple []);
          fun γ => M.alloc (Value.Tuple [])
        ] in
    let* α0 := M.get_function "core::ptr::read_volatile" [ Ty.path "u8" ] in
    let* α1 := M.alloc input in
    let* α2 := M.read (M.use α1) in
    let* α3 := M.call_closure α0 [ α2 ] in
    let* α0 := M.alloc α3 in
    M.read α0
  | _, _ => M.impossible
  end.

Module Impl_core_convert_From_u8_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      fn from(input: u8) -> Choice {
          // Our goal is to prevent the compiler from inferring that the value held inside the
          // resulting `Choice` struct is really an `i1` instead of an `i8`.
          Choice(black_box(input))
      }
  *)
  Definition from (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ input ] =>
      let* input := M.alloc input in
      let* α0 := M.get_function "subtle::black_box" [] in
      let* α1 := M.read input in
      let* α2 := M.call_closure α0 [ α1 ] in
      M.pure (Value.StructTuple "subtle::Choice" [ α2 ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      Self
      (* Trait polymorphic types *) [ (* T *) Ty.path "u8" ]
      (* Instance *) [ ("from", InstanceField.Method from) ].
End Impl_core_convert_From_u8_for_subtle_Choice.

(* Trait *)
Module ConstantTimeEq.
  Definition ct_ne (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::Not"
          (Ty.path "subtle::Choice")
          []
          "not"
          [] in
      let* α1 :=
        M.get_trait_method "subtle::ConstantTimeEq" Self [] "ct_eq" [] in
      let* α2 := M.read self in
      let* α3 := M.read other in
      let* α4 := M.call_closure α1 [ α2; α3 ] in
      M.call_closure α0 [ α4 ]
    | _, _ => M.impossible
    end.
  
  Axiom ProvidedMethod_ct_ne :
    M.IsProvidedMethod "subtle::ConstantTimeEq" "ct_ne" ct_ne.
End ConstantTimeEq.

Module Impl_subtle_ConstantTimeEq_for_slice_T.
  Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [ T ].
  
  (*
      fn ct_eq(&self, _rhs: &[T]) -> Choice {
          let len = self.len();
  
          // Short-circuit on the *lengths* of the slices, not their
          // contents.
          if len != _rhs.len() {
              return Choice::from(0);
          }
  
          // This loop shouldn't be shortcircuitable, since the compiler
          // shouldn't be able to reason about the value of the `u8`
          // unwrapped from the `ct_eq` result.
          let mut x = 1u8;
          for (ai, bi) in self.iter().zip(_rhs.iter()) {
              x &= ai.ct_eq(bi).unwrap_u8();
          }
  
          x.into()
      }
  *)
  Definition ct_eq (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ self; _rhs ] =>
      let* self := M.alloc self in
      let* _rhs := M.alloc _rhs in
      let* len :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "slice") [ T ])
            "len"
            [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* _ :=
        let* α0 := M.alloc (Value.Tuple []) in
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 := M.read len in
                let* α1 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "slice") [ T ])
                    "len"
                    [] in
                let* α2 := M.read _rhs in
                let* α3 := M.call_closure α1 [ α2 ] in
                let* α4 := M.alloc (BinOp.Pure.ne α0 α3) in
                M.pure (M.use α4) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.get_trait_method
                  "core::convert::From"
                  (Ty.path "subtle::Choice")
                  [ Ty.path "u8" ]
                  "from"
                  [] in
              let* α1 := M.call_closure α0 [ Value.Integer Integer.U8 0 ] in
              let* α2 := M.return_ α1 in
              let* α3 := M.read α2 in
              let* α4 := M.never_to_any α3 in
              M.alloc α4;
            fun γ => M.alloc (Value.Tuple [])
          ] in
      let* x := M.alloc (Value.Integer Integer.U8 1) in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "core::iter::traits::collect::IntoIterator"
            (Ty.apply
              (Ty.path "core::iter::adapters::zip::Zip")
              [
                Ty.apply (Ty.path "core::slice::iter::Iter") [ T ];
                Ty.apply (Ty.path "core::slice::iter::Iter") [ T ]
              ])
            []
            "into_iter"
            [] in
        let* α1 :=
          M.get_trait_method
            "core::iter::traits::iterator::Iterator"
            (Ty.apply (Ty.path "core::slice::iter::Iter") [ T ])
            []
            "zip"
            [ Ty.apply (Ty.path "core::slice::iter::Iter") [ T ] ] in
        let* α2 :=
          M.get_associated_function
            (Ty.apply (Ty.path "slice") [ T ])
            "iter"
            [] in
        let* α3 := M.read self in
        let* α4 := M.call_closure α2 [ α3 ] in
        let* α5 :=
          M.get_associated_function
            (Ty.apply (Ty.path "slice") [ T ])
            "iter"
            [] in
        let* α6 := M.read _rhs in
        let* α7 := M.call_closure α5 [ α6 ] in
        let* α8 := M.call_closure α1 [ α4; α7 ] in
        let* α9 := M.call_closure α0 [ α8 ] in
        let* α10 := M.alloc α9 in
        let* α11 :=
          M.match_operator
            α10
            [
              fun γ =>
                let* iter := M.copy γ in
                M.loop
                  (let* _ :=
                    let* α0 :=
                      M.get_trait_method
                        "core::iter::traits::iterator::Iterator"
                        (Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          [
                            Ty.apply (Ty.path "core::slice::iter::Iter") [ T ];
                            Ty.apply (Ty.path "core::slice::iter::Iter") [ T ]
                          ])
                        []
                        "next"
                        [] in
                    let* α1 := M.call_closure α0 [ iter ] in
                    let* α2 := M.alloc α1 in
                    M.match_operator
                      α2
                      [
                        fun γ =>
                          let* α0 := M.break in
                          let* α1 := M.read α0 in
                          let* α2 := M.never_to_any α1 in
                          M.alloc α2;
                        fun γ =>
                          let* γ0_0 :=
                            M.get_struct_tuple_field_or_break_match
                              γ
                              "core::option::Option::Some"
                              0 in
                          let γ1_0 := M.get_tuple_field γ0_0 0 in
                          let γ1_1 := M.get_tuple_field γ0_0 1 in
                          let* ai := M.copy γ1_0 in
                          let* bi := M.copy γ1_1 in
                          let* _ :=
                            let β := x in
                            let* α0 := M.read β in
                            let* α1 :=
                              M.get_associated_function
                                (Ty.path "subtle::Choice")
                                "unwrap_u8"
                                [] in
                            let* α2 :=
                              M.get_trait_method
                                "subtle::ConstantTimeEq"
                                T
                                []
                                "ct_eq"
                                [] in
                            let* α3 := M.read ai in
                            let* α4 := M.read bi in
                            let* α5 := M.call_closure α2 [ α3; α4 ] in
                            let* α6 := M.alloc α5 in
                            let* α7 := M.call_closure α1 [ α6 ] in
                            M.assign β (BinOp.Pure.bit_and α0 α7) in
                          M.alloc (Value.Tuple [])
                      ] in
                  M.alloc (Value.Tuple []))
            ] in
        M.pure (M.use α11) in
      let* α0 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.path "u8")
          [ Ty.path "subtle::Choice" ]
          "into"
          [] in
      let* α1 := M.read x in
      let* α2 := M.call_closure α0 [ α1 ] in
      let* α0 := M.alloc α2 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (Self T)
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method (ct_eq T)) ].
End Impl_subtle_ConstantTimeEq_for_slice_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      fn ct_eq(&self, rhs: &Choice) -> Choice {
          !( *self ^ *rhs)
      }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::Not"
          (Ty.path "subtle::Choice")
          []
          "not"
          [] in
      let* α1 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.path "subtle::Choice")
          [ Ty.path "subtle::Choice" ]
          "bitxor"
          [] in
      let* α2 := M.read self in
      let* α3 := M.read α2 in
      let* α4 := M.read rhs in
      let* α5 := M.read α4 in
      let* α6 := M.call_closure α1 [ α3; α5 ] in
      M.call_closure α0 [ α6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_subtle_Choice.

Module Impl_subtle_ConstantTimeEq_for_u8.
  Definition Self : Ty.t := Ty.path "u8".
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitXor"
            (Ty.apply (Ty.path "&") [ Ty.path "u8" ])
            [ Ty.apply (Ty.path "&") [ Ty.path "u8" ] ]
            "bitxor"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read other in
        let* α3 := M.call_closure α0 [ α1; α2 ] in
        M.alloc α3 in
      let* y :=
        let* α0 := M.read x in
        let* α1 := M.get_associated_function (Ty.path "u8") "wrapping_neg" [] in
        let* α2 := M.read x in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 :=
          BinOp.Panic.sub
            (Value.Integer Integer.I32 8)
            (Value.Integer Integer.I32 1) in
        let* α5 := BinOp.Panic.shr (BinOp.Pure.bit_or α0 α3) α4 in
        M.alloc α5 in
      let* α0 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.path "u8")
          [ Ty.path "subtle::Choice" ]
          "into"
          [] in
      let* α1 := M.read y in
      let* α2 := M.alloc (Value.Integer Integer.U8 1) in
      let* α3 := M.read (M.use α2) in
      let* α4 := M.alloc (BinOp.Pure.bit_xor α1 α3) in
      let* α5 := M.read (M.use α4) in
      let* α6 := M.call_closure α0 [ α5 ] in
      let* α0 := M.alloc α6 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_u8.

Module Impl_subtle_ConstantTimeEq_for_i8.
  Definition Self : Ty.t := Ty.path "i8".
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 :=
        M.get_trait_method
          "subtle::ConstantTimeEq"
          (Ty.path "u8")
          []
          "ct_eq"
          [] in
      let* α1 := M.read self in
      let* α2 := M.read α1 in
      let* α3 := M.alloc (M.rust_cast α2) in
      let* α4 := M.read other in
      let* α5 := M.read α4 in
      let* α6 := M.alloc (M.rust_cast α5) in
      M.call_closure α0 [ α3; α6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_i8.

Module Impl_subtle_ConstantTimeEq_for_u16.
  Definition Self : Ty.t := Ty.path "u16".
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitXor"
            (Ty.apply (Ty.path "&") [ Ty.path "u16" ])
            [ Ty.apply (Ty.path "&") [ Ty.path "u16" ] ]
            "bitxor"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read other in
        let* α3 := M.call_closure α0 [ α1; α2 ] in
        M.alloc α3 in
      let* y :=
        let* α0 := M.read x in
        let* α1 :=
          M.get_associated_function (Ty.path "u16") "wrapping_neg" [] in
        let* α2 := M.read x in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 :=
          BinOp.Panic.sub
            (Value.Integer Integer.I32 16)
            (Value.Integer Integer.I32 1) in
        let* α5 := BinOp.Panic.shr (BinOp.Pure.bit_or α0 α3) α4 in
        M.alloc α5 in
      let* α0 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.path "u8")
          [ Ty.path "subtle::Choice" ]
          "into"
          [] in
      let* α1 := M.read y in
      let* α2 := M.alloc (Value.Integer Integer.U16 1) in
      let* α3 := M.read (M.use α2) in
      let* α4 := M.call_closure α0 [ M.rust_cast (BinOp.Pure.bit_xor α1 α3) ] in
      let* α0 := M.alloc α4 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_u16.

Module Impl_subtle_ConstantTimeEq_for_i16.
  Definition Self : Ty.t := Ty.path "i16".
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 :=
        M.get_trait_method
          "subtle::ConstantTimeEq"
          (Ty.path "u16")
          []
          "ct_eq"
          [] in
      let* α1 := M.read self in
      let* α2 := M.read α1 in
      let* α3 := M.alloc (M.rust_cast α2) in
      let* α4 := M.read other in
      let* α5 := M.read α4 in
      let* α6 := M.alloc (M.rust_cast α5) in
      M.call_closure α0 [ α3; α6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_i16.

Module Impl_subtle_ConstantTimeEq_for_u32.
  Definition Self : Ty.t := Ty.path "u32".
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitXor"
            (Ty.apply (Ty.path "&") [ Ty.path "u32" ])
            [ Ty.apply (Ty.path "&") [ Ty.path "u32" ] ]
            "bitxor"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read other in
        let* α3 := M.call_closure α0 [ α1; α2 ] in
        M.alloc α3 in
      let* y :=
        let* α0 := M.read x in
        let* α1 :=
          M.get_associated_function (Ty.path "u32") "wrapping_neg" [] in
        let* α2 := M.read x in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 :=
          BinOp.Panic.sub
            (Value.Integer Integer.I32 32)
            (Value.Integer Integer.I32 1) in
        let* α5 := BinOp.Panic.shr (BinOp.Pure.bit_or α0 α3) α4 in
        M.alloc α5 in
      let* α0 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.path "u8")
          [ Ty.path "subtle::Choice" ]
          "into"
          [] in
      let* α1 := M.read y in
      let* α2 := M.alloc (Value.Integer Integer.U32 1) in
      let* α3 := M.read (M.use α2) in
      let* α4 := M.call_closure α0 [ M.rust_cast (BinOp.Pure.bit_xor α1 α3) ] in
      let* α0 := M.alloc α4 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_u32.

Module Impl_subtle_ConstantTimeEq_for_i32.
  Definition Self : Ty.t := Ty.path "i32".
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 :=
        M.get_trait_method
          "subtle::ConstantTimeEq"
          (Ty.path "u32")
          []
          "ct_eq"
          [] in
      let* α1 := M.read self in
      let* α2 := M.read α1 in
      let* α3 := M.alloc (M.rust_cast α2) in
      let* α4 := M.read other in
      let* α5 := M.read α4 in
      let* α6 := M.alloc (M.rust_cast α5) in
      M.call_closure α0 [ α3; α6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_i32.

Module Impl_subtle_ConstantTimeEq_for_u64.
  Definition Self : Ty.t := Ty.path "u64".
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitXor"
            (Ty.apply (Ty.path "&") [ Ty.path "u64" ])
            [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
            "bitxor"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read other in
        let* α3 := M.call_closure α0 [ α1; α2 ] in
        M.alloc α3 in
      let* y :=
        let* α0 := M.read x in
        let* α1 :=
          M.get_associated_function (Ty.path "u64") "wrapping_neg" [] in
        let* α2 := M.read x in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 :=
          BinOp.Panic.sub
            (Value.Integer Integer.I32 64)
            (Value.Integer Integer.I32 1) in
        let* α5 := BinOp.Panic.shr (BinOp.Pure.bit_or α0 α3) α4 in
        M.alloc α5 in
      let* α0 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.path "u8")
          [ Ty.path "subtle::Choice" ]
          "into"
          [] in
      let* α1 := M.read y in
      let* α2 := M.alloc (Value.Integer Integer.U64 1) in
      let* α3 := M.read (M.use α2) in
      let* α4 := M.call_closure α0 [ M.rust_cast (BinOp.Pure.bit_xor α1 α3) ] in
      let* α0 := M.alloc α4 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_u64.

Module Impl_subtle_ConstantTimeEq_for_i64.
  Definition Self : Ty.t := Ty.path "i64".
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 :=
        M.get_trait_method
          "subtle::ConstantTimeEq"
          (Ty.path "u64")
          []
          "ct_eq"
          [] in
      let* α1 := M.read self in
      let* α2 := M.read α1 in
      let* α3 := M.alloc (M.rust_cast α2) in
      let* α4 := M.read other in
      let* α5 := M.read α4 in
      let* α6 := M.alloc (M.rust_cast α5) in
      M.call_closure α0 [ α3; α6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_i64.

Module Impl_subtle_ConstantTimeEq_for_usize.
  Definition Self : Ty.t := Ty.path "usize".
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitXor"
            (Ty.apply (Ty.path "&") [ Ty.path "usize" ])
            [ Ty.apply (Ty.path "&") [ Ty.path "usize" ] ]
            "bitxor"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read other in
        let* α3 := M.call_closure α0 [ α1; α2 ] in
        M.alloc α3 in
      let* y :=
        let* α0 := M.read x in
        let* α1 :=
          M.get_associated_function (Ty.path "usize") "wrapping_neg" [] in
        let* α2 := M.read x in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.get_function "core::mem::size_of" [ Ty.path "usize" ] in
        let* α5 := M.call_closure α4 [] in
        let* α6 := BinOp.Panic.mul α5 (Value.Integer Integer.Usize 8) in
        let* α7 := BinOp.Panic.sub α6 (Value.Integer Integer.Usize 1) in
        let* α8 := BinOp.Panic.shr (BinOp.Pure.bit_or α0 α3) α7 in
        M.alloc α8 in
      let* α0 :=
        M.get_trait_method
          "core::convert::Into"
          (Ty.path "u8")
          [ Ty.path "subtle::Choice" ]
          "into"
          [] in
      let* α1 := M.read y in
      let* α2 := M.alloc (Value.Integer Integer.Usize 1) in
      let* α3 := M.read (M.use α2) in
      let* α4 := M.call_closure α0 [ M.rust_cast (BinOp.Pure.bit_xor α1 α3) ] in
      let* α0 := M.alloc α4 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_usize.

Module Impl_subtle_ConstantTimeEq_for_isize.
  Definition Self : Ty.t := Ty.path "isize".
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 :=
        M.get_trait_method
          "subtle::ConstantTimeEq"
          (Ty.path "usize")
          []
          "ct_eq"
          [] in
      let* α1 := M.read self in
      let* α2 := M.read α1 in
      let* α3 := M.alloc (M.rust_cast α2) in
      let* α4 := M.read other in
      let* α5 := M.read α4 in
      let* α6 := M.alloc (M.rust_cast α5) in
      M.call_closure α0 [ α3; α6 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method ct_eq) ].
End Impl_subtle_ConstantTimeEq_for_isize.

(* Trait *)
Module ConditionallySelectable.
  Definition conditional_assign
      (Self : Ty.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match τ, α with
    | [], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* _ :=
        let* α0 := M.read self in
        let* α1 :=
          M.get_trait_method
            "subtle::ConditionallySelectable"
            Self
            []
            "conditional_select"
            [] in
        let* α2 := M.read self in
        let* α3 := M.read other in
        let* α4 := M.read choice in
        let* α5 := M.call_closure α1 [ α2; α3; α4 ] in
        M.assign α0 α5 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom ProvidedMethod_conditional_assign :
    M.IsProvidedMethod
      "subtle::ConditionallySelectable"
      "conditional_assign"
      conditional_assign.
  Definition conditional_swap
      (Self : Ty.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* t :=
        let* α0 := M.read a in
        M.copy α0 in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "subtle::ConditionallySelectable"
            Self
            []
            "conditional_assign"
            [] in
        let* α1 := M.read a in
        let* α2 := M.read b in
        let* α3 := M.read choice in
        let* α4 := M.call_closure α0 [ α1; α2; α3 ] in
        M.alloc α4 in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "subtle::ConditionallySelectable"
            Self
            []
            "conditional_assign"
            [] in
        let* α1 := M.read b in
        let* α2 := M.read choice in
        let* α3 := M.call_closure α0 [ α1; t; α2 ] in
        M.alloc α3 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom ProvidedMethod_conditional_swap :
    M.IsProvidedMethod
      "subtle::ConditionallySelectable"
      "conditional_swap"
      conditional_swap.
End ConditionallySelectable.

Module Impl_subtle_ConditionallySelectable_for_u8.
  Definition Self : Ty.t := Ty.path "u8".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "u8" ])
          [ Ty.path "u8" ]
          "bitxor"
          [] in
      let* α1 := M.read a in
      let* α2 := M.read mask in
      let* α3 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "u8" ])
          [ Ty.apply (Ty.path "&") [ Ty.path "u8" ] ]
          "bitxor"
          [] in
      let* α4 := M.read a in
      let* α5 := M.read b in
      let* α6 := M.call_closure α3 [ α4; α5 ] in
      let* α7 := M.call_closure α0 [ α1; BinOp.Pure.bit_and α2 α6 ] in
      let* α0 := M.alloc α7 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* _ :=
        let* β := M.read self in
        let* α0 := M.read β in
        let* α1 := M.read mask in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read other in
        let* α5 := M.read α4 in
        M.assign
          β
          (BinOp.Pure.bit_xor
            α0
            (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* t :=
        let* α0 := M.read mask in
        let* α1 := M.read a in
        let* α2 := M.read α1 in
        let* α3 := M.read b in
        let* α4 := M.read α3 in
        M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
      let* _ :=
        let* β := M.read a in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* _ :=
        let* β := M.read b in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("conditional_select", InstanceField.Method conditional_select);
          ("conditional_assign", InstanceField.Method conditional_assign);
          ("conditional_swap", InstanceField.Method conditional_swap)
        ].
End Impl_subtle_ConditionallySelectable_for_u8.

Module Impl_subtle_ConditionallySelectable_for_i8.
  Definition Self : Ty.t := Ty.path "i8".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "i8" ])
          [ Ty.path "i8" ]
          "bitxor"
          [] in
      let* α1 := M.read a in
      let* α2 := M.read mask in
      let* α3 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "i8" ])
          [ Ty.apply (Ty.path "&") [ Ty.path "i8" ] ]
          "bitxor"
          [] in
      let* α4 := M.read a in
      let* α5 := M.read b in
      let* α6 := M.call_closure α3 [ α4; α5 ] in
      let* α7 := M.call_closure α0 [ α1; BinOp.Pure.bit_and α2 α6 ] in
      let* α0 := M.alloc α7 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* _ :=
        let* β := M.read self in
        let* α0 := M.read β in
        let* α1 := M.read mask in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read other in
        let* α5 := M.read α4 in
        M.assign
          β
          (BinOp.Pure.bit_xor
            α0
            (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* t :=
        let* α0 := M.read mask in
        let* α1 := M.read a in
        let* α2 := M.read α1 in
        let* α3 := M.read b in
        let* α4 := M.read α3 in
        M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
      let* _ :=
        let* β := M.read a in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* _ :=
        let* β := M.read b in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("conditional_select", InstanceField.Method conditional_select);
          ("conditional_assign", InstanceField.Method conditional_assign);
          ("conditional_swap", InstanceField.Method conditional_swap)
        ].
End Impl_subtle_ConditionallySelectable_for_i8.

Module Impl_subtle_ConditionallySelectable_for_u16.
  Definition Self : Ty.t := Ty.path "u16".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "u16" ])
          [ Ty.path "u16" ]
          "bitxor"
          [] in
      let* α1 := M.read a in
      let* α2 := M.read mask in
      let* α3 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "u16" ])
          [ Ty.apply (Ty.path "&") [ Ty.path "u16" ] ]
          "bitxor"
          [] in
      let* α4 := M.read a in
      let* α5 := M.read b in
      let* α6 := M.call_closure α3 [ α4; α5 ] in
      let* α7 := M.call_closure α0 [ α1; BinOp.Pure.bit_and α2 α6 ] in
      let* α0 := M.alloc α7 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* _ :=
        let* β := M.read self in
        let* α0 := M.read β in
        let* α1 := M.read mask in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read other in
        let* α5 := M.read α4 in
        M.assign
          β
          (BinOp.Pure.bit_xor
            α0
            (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* t :=
        let* α0 := M.read mask in
        let* α1 := M.read a in
        let* α2 := M.read α1 in
        let* α3 := M.read b in
        let* α4 := M.read α3 in
        M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
      let* _ :=
        let* β := M.read a in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* _ :=
        let* β := M.read b in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("conditional_select", InstanceField.Method conditional_select);
          ("conditional_assign", InstanceField.Method conditional_assign);
          ("conditional_swap", InstanceField.Method conditional_swap)
        ].
End Impl_subtle_ConditionallySelectable_for_u16.

Module Impl_subtle_ConditionallySelectable_for_i16.
  Definition Self : Ty.t := Ty.path "i16".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "i16" ])
          [ Ty.path "i16" ]
          "bitxor"
          [] in
      let* α1 := M.read a in
      let* α2 := M.read mask in
      let* α3 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "i16" ])
          [ Ty.apply (Ty.path "&") [ Ty.path "i16" ] ]
          "bitxor"
          [] in
      let* α4 := M.read a in
      let* α5 := M.read b in
      let* α6 := M.call_closure α3 [ α4; α5 ] in
      let* α7 := M.call_closure α0 [ α1; BinOp.Pure.bit_and α2 α6 ] in
      let* α0 := M.alloc α7 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* _ :=
        let* β := M.read self in
        let* α0 := M.read β in
        let* α1 := M.read mask in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read other in
        let* α5 := M.read α4 in
        M.assign
          β
          (BinOp.Pure.bit_xor
            α0
            (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* t :=
        let* α0 := M.read mask in
        let* α1 := M.read a in
        let* α2 := M.read α1 in
        let* α3 := M.read b in
        let* α4 := M.read α3 in
        M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
      let* _ :=
        let* β := M.read a in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* _ :=
        let* β := M.read b in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("conditional_select", InstanceField.Method conditional_select);
          ("conditional_assign", InstanceField.Method conditional_assign);
          ("conditional_swap", InstanceField.Method conditional_swap)
        ].
End Impl_subtle_ConditionallySelectable_for_i16.

Module Impl_subtle_ConditionallySelectable_for_u32.
  Definition Self : Ty.t := Ty.path "u32".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "u32" ])
          [ Ty.path "u32" ]
          "bitxor"
          [] in
      let* α1 := M.read a in
      let* α2 := M.read mask in
      let* α3 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "u32" ])
          [ Ty.apply (Ty.path "&") [ Ty.path "u32" ] ]
          "bitxor"
          [] in
      let* α4 := M.read a in
      let* α5 := M.read b in
      let* α6 := M.call_closure α3 [ α4; α5 ] in
      let* α7 := M.call_closure α0 [ α1; BinOp.Pure.bit_and α2 α6 ] in
      let* α0 := M.alloc α7 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* _ :=
        let* β := M.read self in
        let* α0 := M.read β in
        let* α1 := M.read mask in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read other in
        let* α5 := M.read α4 in
        M.assign
          β
          (BinOp.Pure.bit_xor
            α0
            (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* t :=
        let* α0 := M.read mask in
        let* α1 := M.read a in
        let* α2 := M.read α1 in
        let* α3 := M.read b in
        let* α4 := M.read α3 in
        M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
      let* _ :=
        let* β := M.read a in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* _ :=
        let* β := M.read b in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("conditional_select", InstanceField.Method conditional_select);
          ("conditional_assign", InstanceField.Method conditional_assign);
          ("conditional_swap", InstanceField.Method conditional_swap)
        ].
End Impl_subtle_ConditionallySelectable_for_u32.

Module Impl_subtle_ConditionallySelectable_for_i32.
  Definition Self : Ty.t := Ty.path "i32".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "i32" ])
          [ Ty.path "i32" ]
          "bitxor"
          [] in
      let* α1 := M.read a in
      let* α2 := M.read mask in
      let* α3 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "i32" ])
          [ Ty.apply (Ty.path "&") [ Ty.path "i32" ] ]
          "bitxor"
          [] in
      let* α4 := M.read a in
      let* α5 := M.read b in
      let* α6 := M.call_closure α3 [ α4; α5 ] in
      let* α7 := M.call_closure α0 [ α1; BinOp.Pure.bit_and α2 α6 ] in
      let* α0 := M.alloc α7 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* _ :=
        let* β := M.read self in
        let* α0 := M.read β in
        let* α1 := M.read mask in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read other in
        let* α5 := M.read α4 in
        M.assign
          β
          (BinOp.Pure.bit_xor
            α0
            (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* t :=
        let* α0 := M.read mask in
        let* α1 := M.read a in
        let* α2 := M.read α1 in
        let* α3 := M.read b in
        let* α4 := M.read α3 in
        M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
      let* _ :=
        let* β := M.read a in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* _ :=
        let* β := M.read b in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("conditional_select", InstanceField.Method conditional_select);
          ("conditional_assign", InstanceField.Method conditional_assign);
          ("conditional_swap", InstanceField.Method conditional_swap)
        ].
End Impl_subtle_ConditionallySelectable_for_i32.

Module Impl_subtle_ConditionallySelectable_for_u64.
  Definition Self : Ty.t := Ty.path "u64".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "u64" ])
          [ Ty.path "u64" ]
          "bitxor"
          [] in
      let* α1 := M.read a in
      let* α2 := M.read mask in
      let* α3 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "u64" ])
          [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
          "bitxor"
          [] in
      let* α4 := M.read a in
      let* α5 := M.read b in
      let* α6 := M.call_closure α3 [ α4; α5 ] in
      let* α7 := M.call_closure α0 [ α1; BinOp.Pure.bit_and α2 α6 ] in
      let* α0 := M.alloc α7 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* _ :=
        let* β := M.read self in
        let* α0 := M.read β in
        let* α1 := M.read mask in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read other in
        let* α5 := M.read α4 in
        M.assign
          β
          (BinOp.Pure.bit_xor
            α0
            (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        M.alloc (M.rust_cast α2) in
      let* t :=
        let* α0 := M.read mask in
        let* α1 := M.read a in
        let* α2 := M.read α1 in
        let* α3 := M.read b in
        let* α4 := M.read α3 in
        M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
      let* _ :=
        let* β := M.read a in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* _ :=
        let* β := M.read b in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("conditional_select", InstanceField.Method conditional_select);
          ("conditional_assign", InstanceField.Method conditional_assign);
          ("conditional_swap", InstanceField.Method conditional_swap)
        ].
End Impl_subtle_ConditionallySelectable_for_u64.

Module Impl_subtle_ConditionallySelectable_for_i64.
  Definition Self : Ty.t := Ty.path "i64".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "i64" ])
          [ Ty.path "i64" ]
          "bitxor"
          [] in
      let* α1 := M.read a in
      let* α2 := M.read mask in
      let* α3 :=
        M.get_trait_method
          "core::ops::bit::BitXor"
          (Ty.apply (Ty.path "&") [ Ty.path "i64" ])
          [ Ty.apply (Ty.path "&") [ Ty.path "i64" ] ]
          "bitxor"
          [] in
      let* α4 := M.read a in
      let* α5 := M.read b in
      let* α6 := M.call_closure α3 [ α4; α5 ] in
      let* α7 := M.call_closure α0 [ α1; BinOp.Pure.bit_and α2 α6 ] in
      let* α0 := M.alloc α7 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other; choice ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* _ :=
        let* β := M.read self in
        let* α0 := M.read β in
        let* α1 := M.read mask in
        let* α2 := M.read self in
        let* α3 := M.read α2 in
        let* α4 := M.read other in
        let* α5 := M.read α4 in
        M.assign
          β
          (BinOp.Pure.bit_xor
            α0
            (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 := M.call_closure α0 [ choice ] in
        let* α2 := UnOp.Panic.neg (M.rust_cast α1) in
        let* α3 := M.alloc α2 in
        M.copy (M.use α3) in
      let* t :=
        let* α0 := M.read mask in
        let* α1 := M.read a in
        let* α2 := M.read α1 in
        let* α3 := M.read b in
        let* α4 := M.read α3 in
        M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
      let* _ :=
        let* β := M.read a in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* _ :=
        let* β := M.read b in
        let* α0 := M.read β in
        let* α1 := M.read t in
        M.assign β (BinOp.Pure.bit_xor α0 α1) in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [
          ("conditional_select", InstanceField.Method conditional_select);
          ("conditional_assign", InstanceField.Method conditional_assign);
          ("conditional_swap", InstanceField.Method conditional_swap)
        ].
End Impl_subtle_ConditionallySelectable_for_i64.

Module Impl_subtle_ConditionallySelectable_for_subtle_Choice.
  Definition Self : Ty.t := Ty.path "subtle::Choice".
  
  (*
      fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
          Choice(u8::conditional_select(&a.0, &b.0, choice))
      }
  *)
  Definition conditional_select (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* α0 :=
        M.get_trait_method
          "subtle::ConditionallySelectable"
          (Ty.path "u8")
          []
          "conditional_select"
          [] in
      let* α1 := M.read a in
      let* α2 := M.read b in
      let* α3 := M.read choice in
      let* α4 :=
        M.call_closure
          α0
          [
            M.get_struct_tuple_field α1 "subtle::Choice" 0;
            M.get_struct_tuple_field α2 "subtle::Choice" 0;
            α3
          ] in
      M.pure (Value.StructTuple "subtle::Choice" [ α4 ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      Self
      (* Trait polymorphic types *) []
      (* Instance *)
        [ ("conditional_select", InstanceField.Method conditional_select) ].
End Impl_subtle_ConditionallySelectable_for_subtle_Choice.

(* Trait *)
Module ConditionallyNegatable.
  
End ConditionallyNegatable.

Module Impl_subtle_ConditionallyNegatable_for_T.
  Definition Self (T : Ty.t) : Ty.t := T.
  
  (*
      fn conditional_negate(&mut self, choice: Choice) {
          // Need to cast to eliminate mutability
          let self_neg: T = -(self as &T);
          self.conditional_assign(&self_neg, choice);
      }
  *)
  Definition conditional_negate
      (T : Ty.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ self; choice ] =>
      let* self := M.alloc self in
      let* choice := M.alloc choice in
      let* self_neg :=
        let* α0 :=
          M.get_trait_method
            "core::ops::arith::Neg"
            (Ty.apply (Ty.path "&") [ T ])
            []
            "neg"
            [] in
        let* α1 := M.read self in
        let* α2 := M.alloc α1 in
        let* α3 := M.read (M.use α2) in
        let* α4 := M.call_closure α0 [ α3 ] in
        M.alloc α4 in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "subtle::ConditionallySelectable"
            T
            []
            "conditional_assign"
            [] in
        let* α1 := M.read self in
        let* α2 := M.read choice in
        let* α3 := M.call_closure α0 [ α1; self_neg; α2 ] in
        M.alloc α3 in
      let* α0 := M.alloc (Value.Tuple []) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "subtle::ConditionallyNegatable"
      (Self T)
      (* Trait polymorphic types *) []
      (* Instance *)
        [ ("conditional_negate", InstanceField.Method (conditional_negate T)) ].
End Impl_subtle_ConditionallyNegatable_for_T.

(* StructRecord
  {
    name := "CtOption";
    ty_params := [ "T" ];
    fields := [ ("value", T); ("is_some", Ty.path "subtle::Choice") ];
  } *)

Module Impl_core_clone_Clone_for_subtle_CtOption_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "subtle::CtOption") [ T ].
  
  (*
  Clone
  *)
  Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.get_trait_method "core::clone::Clone" T [] "clone" [] in
      let* α1 := M.read self in
      let* α2 :=
        M.call_closure
          α0
          [ M.get_struct_record_field α1 "subtle::CtOption" "value" ] in
      let* α3 :=
        M.get_trait_method
          "core::clone::Clone"
          (Ty.path "subtle::Choice")
          []
          "clone"
          [] in
      let* α4 := M.read self in
      let* α5 :=
        M.call_closure
          α3
          [ M.get_struct_record_field α4 "subtle::CtOption" "is_some" ] in
      M.pure
        (Value.StructRecord
          "subtle::CtOption"
          [ ("value", α2); ("is_some", α5) ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::clone::Clone"
      (Self T)
      (* Trait polymorphic types *) []
      (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
End Impl_core_clone_Clone_for_subtle_CtOption_T.

Module Impl_core_marker_Copy_for_subtle_CtOption_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "subtle::CtOption") [ T ].
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::marker::Copy"
      (Self T)
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_core_marker_Copy_for_subtle_CtOption_T.

Module Impl_core_fmt_Debug_for_subtle_CtOption_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "subtle::CtOption") [ T ].
  
  (*
  Debug
  *)
  Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* α0 :=
        M.get_associated_function
          (Ty.path "core::fmt::Formatter")
          "debug_struct_field2_finish"
          [] in
      let* α1 := M.read f in
      let* α2 := M.read (mk_str "CtOption") in
      let* α3 := M.read (mk_str "value") in
      let* α5 :=
        (* Unsize *)
          let* α4 := M.read self in
          M.pure
            (M.pointer_coercion
              (M.get_struct_record_field α4 "subtle::CtOption" "value")) in
      let* α6 := M.read (mk_str "is_some") in
      let* α9 :=
        (* Unsize *)
          let* α7 := M.read self in
          let* α8 :=
            M.alloc
              (M.get_struct_record_field α7 "subtle::CtOption" "is_some") in
          M.pure (M.pointer_coercion α8) in
      M.call_closure α0 [ α1; α2; α3; α5; α6; α9 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::fmt::Debug"
      (Self T)
      (* Trait polymorphic types *) []
      (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
End Impl_core_fmt_Debug_for_subtle_CtOption_T.

Module Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "core::option::Option") [ T ].
  
  (*
      fn from(source: CtOption<T>) -> Option<T> {
          if source.is_some().unwrap_u8() == 1u8 {
              Option::Some(source.value)
          } else {
              None
          }
      }
  *)
  Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ source ] =>
      let* source := M.alloc source in
      let* α0 := M.alloc (Value.Tuple []) in
      let* α1 :=
        M.match_operator
          α0
          [
            fun γ =>
              let* γ :=
                let* α0 :=
                  M.get_associated_function
                    (Ty.path "subtle::Choice")
                    "unwrap_u8"
                    [] in
                let* α1 :=
                  M.get_associated_function
                    (Ty.apply (Ty.path "subtle::CtOption") [ T ])
                    "is_some"
                    [] in
                let* α2 := M.call_closure α1 [ source ] in
                let* α3 := M.alloc α2 in
                let* α4 := M.call_closure α0 [ α3 ] in
                let* α5 :=
                  M.alloc (BinOp.Pure.eq α4 (Value.Integer Integer.U8 1)) in
                M.pure (M.use α5) in
              let* _ :=
                let* α0 := M.read γ in
                M.is_constant_or_break_match α0 (Value.Bool true) in
              let* α0 :=
                M.read
                  (M.get_struct_record_field
                    source
                    "subtle::CtOption"
                    "value") in
              M.alloc (Value.StructTuple "core::option::Option::Some" [ α0 ]);
            fun γ => M.alloc (Value.StructTuple "core::option::Option::None" [])
          ] in
      M.read α1
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "core::convert::From"
      (Self T)
      (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "subtle::CtOption") [ T ] ]
      (* Instance *) [ ("from", InstanceField.Method (from T)) ].
End Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.

Module Impl_subtle_CtOption_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "subtle::CtOption") [ T ].
  
  (*
      pub fn new(value: T, is_some: Choice) -> CtOption<T> {
          CtOption {
              value: value,
              is_some: is_some,
          }
      }
  *)
  Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ value; is_some ] =>
      let* value := M.alloc value in
      let* is_some := M.alloc is_some in
      let* α0 := M.read value in
      let* α1 := M.read is_some in
      M.pure
        (Value.StructRecord
          "subtle::CtOption"
          [ ("value", α0); ("is_some", α1) ])
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_new :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "new" (new T).
  
  (*
      pub fn expect(self, msg: &str) -> T {
          assert_eq!(self.is_some.unwrap_u8(), 1, "{}", msg);
  
          self.value
      }
  *)
  Definition expect (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ self; msg ] =>
      let* self := M.alloc self in
      let* msg := M.alloc msg in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 :=
          M.call_closure
            α0
            [ M.get_struct_record_field self "subtle::CtOption" "is_some" ] in
        let* α2 := M.alloc α1 in
        let* α3 := M.alloc (Value.Integer Integer.U8 1) in
        let* α4 := M.alloc (Value.Tuple [ α2; α3 ]) in
        M.match_operator
          α4
          [
            fun γ =>
              let γ0_0 := M.get_tuple_field γ 0 in
              let γ0_1 := M.get_tuple_field γ 1 in
              let* left_val := M.copy γ0_0 in
              let* right_val := M.copy γ0_1 in
              let* α0 := M.alloc (Value.Tuple []) in
              M.match_operator
                α0
                [
                  fun γ =>
                    let* γ :=
                      let* α0 := M.read left_val in
                      let* α1 := M.read α0 in
                      let* α2 := M.read right_val in
                      let* α3 := M.read α2 in
                      let* α4 :=
                        M.alloc (UnOp.Pure.not (BinOp.Pure.eq α1 α3)) in
                      M.pure (M.use α4) in
                    let* _ :=
                      let* α0 := M.read γ in
                      M.is_constant_or_break_match α0 (Value.Bool true) in
                    let* kind :=
                      M.alloc
                        (Value.StructTuple
                          "core::panicking::AssertKind::Eq"
                          []) in
                    let* α0 :=
                      M.get_function
                        "core::panicking::assert_failed"
                        [ Ty.path "u8"; Ty.path "u8" ] in
                    let* α1 := M.read kind in
                    let* α2 := M.read left_val in
                    let* α3 := M.read right_val in
                    let* α4 :=
                      M.get_associated_function
                        (Ty.path "core::fmt::Arguments")
                        "new_v1"
                        [] in
                    let* α7 :=
                      (* Unsize *)
                        let* α5 := M.read (mk_str "") in
                        let* α6 := M.alloc (Value.Array [ α5 ]) in
                        M.pure (M.pointer_coercion α6) in
                    let* α11 :=
                      (* Unsize *)
                        let* α8 :=
                          M.get_associated_function
                            (Ty.path "core::fmt::rt::Argument")
                            "new_display"
                            [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ] in
                        let* α9 := M.call_closure α8 [ msg ] in
                        let* α10 := M.alloc (Value.Array [ α9 ]) in
                        M.pure (M.pointer_coercion α10) in
                    let* α12 := M.call_closure α4 [ α7; α11 ] in
                    let* α13 :=
                      M.call_closure
                        α0
                        [
                          α1;
                          α2;
                          α3;
                          Value.StructTuple "core::option::Option::Some" [ α12 ]
                        ] in
                    let* α0 := M.alloc α13 in
                    let* α1 := M.read α0 in
                    let* α2 := M.never_to_any α1 in
                    M.alloc α2;
                  fun γ => M.alloc (Value.Tuple [])
                ]
          ] in
      M.read (M.get_struct_record_field self "subtle::CtOption" "value")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_expect :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "expect" (expect T).
  
  (*
      pub fn unwrap(self) -> T {
          assert_eq!(self.is_some.unwrap_u8(), 1);
  
          self.value
      }
  *)
  Definition unwrap (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* _ :=
        let* α0 :=
          M.get_associated_function (Ty.path "subtle::Choice") "unwrap_u8" [] in
        let* α1 :=
          M.call_closure
            α0
            [ M.get_struct_record_field self "subtle::CtOption" "is_some" ] in
        let* α2 := M.alloc α1 in
        let* α3 := M.alloc (Value.Integer Integer.U8 1) in
        let* α4 := M.alloc (Value.Tuple [ α2; α3 ]) in
        M.match_operator
          α4
          [
            fun γ =>
              let γ0_0 := M.get_tuple_field γ 0 in
              let γ0_1 := M.get_tuple_field γ 1 in
              let* left_val := M.copy γ0_0 in
              let* right_val := M.copy γ0_1 in
              let* α0 := M.alloc (Value.Tuple []) in
              M.match_operator
                α0
                [
                  fun γ =>
                    let* γ :=
                      let* α0 := M.read left_val in
                      let* α1 := M.read α0 in
                      let* α2 := M.read right_val in
                      let* α3 := M.read α2 in
                      let* α4 :=
                        M.alloc (UnOp.Pure.not (BinOp.Pure.eq α1 α3)) in
                      M.pure (M.use α4) in
                    let* _ :=
                      let* α0 := M.read γ in
                      M.is_constant_or_break_match α0 (Value.Bool true) in
                    let* kind :=
                      M.alloc
                        (Value.StructTuple
                          "core::panicking::AssertKind::Eq"
                          []) in
                    let* α0 :=
                      M.get_function
                        "core::panicking::assert_failed"
                        [ Ty.path "u8"; Ty.path "u8" ] in
                    let* α1 := M.read kind in
                    let* α2 := M.read left_val in
                    let* α3 := M.read right_val in
                    let* α4 :=
                      M.call_closure
                        α0
                        [
                          α1;
                          α2;
                          α3;
                          Value.StructTuple "core::option::Option::None" []
                        ] in
                    let* α0 := M.alloc α4 in
                    let* α1 := M.read α0 in
                    let* α2 := M.never_to_any α1 in
                    M.alloc α2;
                  fun γ => M.alloc (Value.Tuple [])
                ]
          ] in
      M.read (M.get_struct_record_field self "subtle::CtOption" "value")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_unwrap :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "unwrap" (unwrap T).
  
  (*
      pub fn unwrap_or(self, def: T) -> T
      where
          T: ConditionallySelectable,
      {
          T::conditional_select(&def, &self.value, self.is_some)
      }
  *)
  Definition unwrap_or (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ self; def ] =>
      let* self := M.alloc self in
      let* def := M.alloc def in
      let* α0 :=
        M.get_trait_method
          "subtle::ConditionallySelectable"
          T
          []
          "conditional_select"
          [] in
      let* α1 :=
        M.read (M.get_struct_record_field self "subtle::CtOption" "is_some") in
      M.call_closure
        α0
        [ def; M.get_struct_record_field self "subtle::CtOption" "value"; α1 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_unwrap_or :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "unwrap_or" (unwrap_or T).
  
  (*
      pub fn unwrap_or_else<F>(self, f: F) -> T
      where
          T: ConditionallySelectable,
          F: FnOnce() -> T,
      {
          T::conditional_select(&f(), &self.value, self.is_some)
      }
  *)
  Definition unwrap_or_else (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [ F ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* α0 :=
        M.get_trait_method
          "subtle::ConditionallySelectable"
          T
          []
          "conditional_select"
          [] in
      let* α1 :=
        M.get_trait_method
          "core::ops::function::FnOnce"
          F
          [ Ty.tuple [] ]
          "call_once"
          [] in
      let* α2 := M.read f in
      let* α3 := M.call_closure α1 [ α2; Value.Tuple [] ] in
      let* α4 := M.alloc α3 in
      let* α5 :=
        M.read (M.get_struct_record_field self "subtle::CtOption" "is_some") in
      M.call_closure
        α0
        [ α4; M.get_struct_record_field self "subtle::CtOption" "value"; α5 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_unwrap_or_else :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "unwrap_or_else" (unwrap_or_else T).
  
  (*
      pub fn is_some(&self) -> Choice {
          self.is_some
      }
  *)
  Definition is_some (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read (M.get_struct_record_field α0 "subtle::CtOption" "is_some")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_is_some :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "is_some" (is_some T).
  
  (*
      pub fn is_none(&self) -> Choice {
          !self.is_some
      }
  *)
  Definition is_none (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ self ] =>
      let* self := M.alloc self in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::Not"
          (Ty.path "subtle::Choice")
          []
          "not"
          [] in
      let* α1 := M.read self in
      let* α2 :=
        M.read (M.get_struct_record_field α1 "subtle::CtOption" "is_some") in
      M.call_closure α0 [ α2 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_is_none :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "is_none" (is_none T).
  
  (*
      pub fn map<U, F>(self, f: F) -> CtOption<U>
      where
          T: Default + ConditionallySelectable,
          F: FnOnce(T) -> U,
      {
          CtOption::new(
              f(T::conditional_select(
                  &T::default(),
                  &self.value,
                  self.is_some,
              )),
              self.is_some,
          )
      }
  *)
  Definition map (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [ U; F ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* α0 :=
        M.get_associated_function
          (Ty.apply (Ty.path "subtle::CtOption") [ U ])
          "new"
          [] in
      let* α1 :=
        M.get_trait_method
          "core::ops::function::FnOnce"
          F
          [ Ty.tuple [ T ] ]
          "call_once"
          [] in
      let* α2 := M.read f in
      let* α3 :=
        M.get_trait_method
          "subtle::ConditionallySelectable"
          T
          []
          "conditional_select"
          [] in
      let* α4 :=
        M.get_trait_method "core::default::Default" T [] "default" [] in
      let* α5 := M.call_closure α4 [] in
      let* α6 := M.alloc α5 in
      let* α7 :=
        M.read (M.get_struct_record_field self "subtle::CtOption" "is_some") in
      let* α8 :=
        M.call_closure
          α3
          [ α6; M.get_struct_record_field self "subtle::CtOption" "value"; α7
          ] in
      let* α9 := M.call_closure α1 [ α2; Value.Tuple [ α8 ] ] in
      let* α10 :=
        M.read (M.get_struct_record_field self "subtle::CtOption" "is_some") in
      M.call_closure α0 [ α9; α10 ]
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_map :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "map" (map T).
  
  (*
      pub fn and_then<U, F>(self, f: F) -> CtOption<U>
      where
          T: Default + ConditionallySelectable,
          F: FnOnce(T) -> CtOption<U>,
      {
          let mut tmp = f(T::conditional_select(
              &T::default(),
              &self.value,
              self.is_some,
          ));
          tmp.is_some &= self.is_some;
  
          tmp
      }
  *)
  Definition and_then (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [ U; F ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* tmp :=
        let* α0 :=
          M.get_trait_method
            "core::ops::function::FnOnce"
            F
            [ Ty.tuple [ T ] ]
            "call_once"
            [] in
        let* α1 := M.read f in
        let* α2 :=
          M.get_trait_method
            "subtle::ConditionallySelectable"
            T
            []
            "conditional_select"
            [] in
        let* α3 :=
          M.get_trait_method "core::default::Default" T [] "default" [] in
        let* α4 := M.call_closure α3 [] in
        let* α5 := M.alloc α4 in
        let* α6 :=
          M.read
            (M.get_struct_record_field self "subtle::CtOption" "is_some") in
        let* α7 :=
          M.call_closure
            α2
            [ α5; M.get_struct_record_field self "subtle::CtOption" "value"; α6
            ] in
        let* α8 := M.call_closure α0 [ α1; Value.Tuple [ α7 ] ] in
        M.alloc α8 in
      let* _ :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitAndAssign"
            (Ty.path "subtle::Choice")
            [ Ty.path "subtle::Choice" ]
            "bitand_assign"
            [] in
        let* α1 :=
          M.read
            (M.get_struct_record_field self "subtle::CtOption" "is_some") in
        let* α2 :=
          M.call_closure
            α0
            [ M.get_struct_record_field tmp "subtle::CtOption" "is_some"; α1
            ] in
        M.alloc α2 in
      M.read tmp
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_and_then :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "and_then" (and_then T).
  
  (*
      pub fn or_else<F>(self, f: F) -> CtOption<T>
      where
          T: ConditionallySelectable,
          F: FnOnce() -> CtOption<T>,
      {
          let is_none = self.is_none();
          let f = f();
  
          Self::conditional_select(&self, &f, is_none)
      }
  *)
  Definition or_else (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [ F ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* is_none :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "subtle::CtOption") [ T ])
            "is_none"
            [] in
        let* α1 := M.call_closure α0 [ self ] in
        M.alloc α1 in
      let* f :=
        let* α0 :=
          M.get_trait_method
            "core::ops::function::FnOnce"
            F
            [ Ty.tuple [] ]
            "call_once"
            [] in
        let* α1 := M.read f in
        let* α2 := M.call_closure α0 [ α1; Value.Tuple [] ] in
        M.alloc α2 in
      let* α0 :=
        M.get_trait_method
          "subtle::ConditionallySelectable"
          (Ty.apply (Ty.path "subtle::CtOption") [ T ])
          []
          "conditional_select"
          [] in
      let* α1 := M.read is_none in
      let* α2 := M.call_closure α0 [ self; f; α1 ] in
      let* α0 := M.alloc α2 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_or_else :
    forall (T : Ty.t),
    M.IsAssociatedFunction (Self T) "or_else" (or_else T).
End Impl_subtle_CtOption_T.

Module Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "subtle::CtOption") [ T ].
  
  (*
      fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
          CtOption::new(
              T::conditional_select(&a.value, &b.value, choice),
              Choice::conditional_select(&a.is_some, &b.is_some, choice),
          )
      }
  *)
  Definition conditional_select
      (T : Ty.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ a; b; choice ] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* α0 :=
        M.get_associated_function
          (Ty.apply (Ty.path "subtle::CtOption") [ T ])
          "new"
          [] in
      let* α1 :=
        M.get_trait_method
          "subtle::ConditionallySelectable"
          T
          []
          "conditional_select"
          [] in
      let* α2 := M.read a in
      let* α3 := M.read b in
      let* α4 := M.read choice in
      let* α5 :=
        M.call_closure
          α1
          [
            M.get_struct_record_field α2 "subtle::CtOption" "value";
            M.get_struct_record_field α3 "subtle::CtOption" "value";
            α4
          ] in
      let* α6 :=
        M.get_trait_method
          "subtle::ConditionallySelectable"
          (Ty.path "subtle::Choice")
          []
          "conditional_select"
          [] in
      let* α7 := M.read a in
      let* α8 := M.read b in
      let* α9 := M.read choice in
      let* α10 :=
        M.call_closure
          α6
          [
            M.get_struct_record_field α7 "subtle::CtOption" "is_some";
            M.get_struct_record_field α8 "subtle::CtOption" "is_some";
            α9
          ] in
      M.call_closure α0 [ α5; α10 ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "subtle::ConditionallySelectable"
      (Self T)
      (* Trait polymorphic types *) []
      (* Instance *)
        [ ("conditional_select", InstanceField.Method (conditional_select T)) ].
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  Definition Self (T : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "subtle::CtOption") [ T ].
  
  (*
      fn ct_eq(&self, rhs: &CtOption<T>) -> Choice {
          let a = self.is_some();
          let b = rhs.is_some();
  
          (a & b & self.value.ct_eq(&rhs.value)) | (!a & !b)
      }
  *)
  Definition ct_eq (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self T in
    match τ, α with
    | [], [ self; rhs ] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* a :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "subtle::CtOption") [ T ])
            "is_some"
            [] in
        let* α1 := M.read self in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* b :=
        let* α0 :=
          M.get_associated_function
            (Ty.apply (Ty.path "subtle::CtOption") [ T ])
            "is_some"
            [] in
        let* α1 := M.read rhs in
        let* α2 := M.call_closure α0 [ α1 ] in
        M.alloc α2 in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::BitOr"
          (Ty.path "subtle::Choice")
          [ Ty.path "subtle::Choice" ]
          "bitor"
          [] in
      let* α1 :=
        M.get_trait_method
          "core::ops::bit::BitAnd"
          (Ty.path "subtle::Choice")
          [ Ty.path "subtle::Choice" ]
          "bitand"
          [] in
      let* α2 :=
        M.get_trait_method
          "core::ops::bit::BitAnd"
          (Ty.path "subtle::Choice")
          [ Ty.path "subtle::Choice" ]
          "bitand"
          [] in
      let* α3 := M.read a in
      let* α4 := M.read b in
      let* α5 := M.call_closure α2 [ α3; α4 ] in
      let* α6 := M.get_trait_method "subtle::ConstantTimeEq" T [] "ct_eq" [] in
      let* α7 := M.read self in
      let* α8 := M.read rhs in
      let* α9 :=
        M.call_closure
          α6
          [
            M.get_struct_record_field α7 "subtle::CtOption" "value";
            M.get_struct_record_field α8 "subtle::CtOption" "value"
          ] in
      let* α10 := M.call_closure α1 [ α5; α9 ] in
      let* α11 :=
        M.get_trait_method
          "core::ops::bit::BitAnd"
          (Ty.path "subtle::Choice")
          [ Ty.path "subtle::Choice" ]
          "bitand"
          [] in
      let* α12 :=
        M.get_trait_method
          "core::ops::bit::Not"
          (Ty.path "subtle::Choice")
          []
          "not"
          [] in
      let* α13 := M.read a in
      let* α14 := M.call_closure α12 [ α13 ] in
      let* α15 :=
        M.get_trait_method
          "core::ops::bit::Not"
          (Ty.path "subtle::Choice")
          []
          "not"
          [] in
      let* α16 := M.read b in
      let* α17 := M.call_closure α15 [ α16 ] in
      let* α18 := M.call_closure α11 [ α14; α17 ] in
      let* α19 := M.call_closure α0 [ α10; α18 ] in
      let* α0 := M.alloc α19 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    forall (T : Ty.t),
    M.IsTraitInstance
      "subtle::ConstantTimeEq"
      (Self T)
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_eq", InstanceField.Method (ct_eq T)) ].
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.

(* Trait *)
Module ConstantTimeGreater.
  
End ConstantTimeGreater.

Module Impl_subtle_ConstantTimeGreater_for_u8.
  Definition Self : Ty.t := Ty.path "u8".
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitAnd"
            (Ty.apply (Ty.path "&") [ Ty.path "u8" ])
            [ Ty.path "u8" ]
            "bitand"
            [] in
        let* α1 := M.read self in
        let* α2 :=
          M.get_trait_method
            "core::ops::bit::Not"
            (Ty.apply (Ty.path "&") [ Ty.path "u8" ])
            []
            "not"
            [] in
        let* α3 := M.read other in
        let* α4 := M.call_closure α2 [ α3 ] in
        let* α5 := M.call_closure α0 [ α1; α4 ] in
        M.alloc α5 in
      let* ltb :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitAnd"
            (Ty.path "u8")
            [ Ty.apply (Ty.path "&") [ Ty.path "u8" ] ]
            "bitand"
            [] in
        let* α1 :=
          M.get_trait_method
            "core::ops::bit::Not"
            (Ty.apply (Ty.path "&") [ Ty.path "u8" ])
            []
            "not"
            [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.read other in
        let* α5 := M.call_closure α0 [ α3; α4 ] in
        M.alloc α5 in
      let* pow := M.alloc (Value.Integer Integer.I32 1) in
      let* _ :=
        M.loop
          (let* α0 := M.alloc (Value.Tuple []) in
          M.match_operator
            α0
            [
              fun γ =>
                let* γ :=
                  let* α0 := M.read pow in
                  let* α1 :=
                    M.alloc (BinOp.Pure.lt α0 (Value.Integer Integer.I32 8)) in
                  M.pure (M.use α1) in
                let* _ :=
                  let* α0 := M.read γ in
                  M.is_constant_or_break_match α0 (Value.Bool true) in
                let* _ :=
                  let β := ltb in
                  let* α0 := M.read β in
                  let* α1 := M.read ltb in
                  let* α2 := M.read pow in
                  let* α3 := BinOp.Panic.shr α1 α2 in
                  M.assign β (BinOp.Pure.bit_or α0 α3) in
                let* _ :=
                  let β := pow in
                  let* α0 := M.read β in
                  let* α1 := M.read pow in
                  let* α2 := BinOp.Panic.add α0 α1 in
                  M.assign β α2 in
                M.alloc (Value.Tuple []);
              fun γ =>
                let* _ :=
                  let* α0 := M.break in
                  let* α1 := M.read α0 in
                  let* α2 := M.never_to_any α1 in
                  M.alloc α2 in
                let* α0 := M.alloc (Value.Tuple []) in
                let* α1 := M.read α0 in
                let* α2 := M.never_to_any α1 in
                M.alloc α2
            ]) in
      let* bit :=
        let* α0 := M.read gtb in
        let* α1 := M.read ltb in
        M.alloc (BinOp.Pure.bit_and α0 (UnOp.Pure.not α1)) in
      let* pow := M.alloc (Value.Integer Integer.I32 1) in
      let* _ :=
        M.loop
          (let* α0 := M.alloc (Value.Tuple []) in
          M.match_operator
            α0
            [
              fun γ =>
                let* γ :=
                  let* α0 := M.read pow in
                  let* α1 :=
                    M.alloc (BinOp.Pure.lt α0 (Value.Integer Integer.I32 8)) in
                  M.pure (M.use α1) in
                let* _ :=
                  let* α0 := M.read γ in
                  M.is_constant_or_break_match α0 (Value.Bool true) in
                let* _ :=
                  let β := bit in
                  let* α0 := M.read β in
                  let* α1 := M.read bit in
                  let* α2 := M.read pow in
                  let* α3 := BinOp.Panic.shr α1 α2 in
                  M.assign β (BinOp.Pure.bit_or α0 α3) in
                let* _ :=
                  let β := pow in
                  let* α0 := M.read β in
                  let* α1 := M.read pow in
                  let* α2 := BinOp.Panic.add α0 α1 in
                  M.assign β α2 in
                M.alloc (Value.Tuple []);
              fun γ =>
                let* _ :=
                  let* α0 := M.break in
                  let* α1 := M.read α0 in
                  let* α2 := M.never_to_any α1 in
                  M.alloc α2 in
                let* α0 := M.alloc (Value.Tuple []) in
                let* α1 := M.read α0 in
                let* α2 := M.never_to_any α1 in
                M.alloc α2
            ]) in
      let* α0 :=
        M.get_trait_method
          "core::convert::From"
          (Ty.path "subtle::Choice")
          [ Ty.path "u8" ]
          "from"
          [] in
      let* α1 := M.read bit in
      let* α2 := M.alloc (BinOp.Pure.bit_and α1 (Value.Integer Integer.U8 1)) in
      let* α3 := M.read (M.use α2) in
      let* α4 := M.call_closure α0 [ α3 ] in
      let* α0 := M.alloc α4 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeGreater"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_gt", InstanceField.Method ct_gt) ].
End Impl_subtle_ConstantTimeGreater_for_u8.

Module Impl_subtle_ConstantTimeGreater_for_u16.
  Definition Self : Ty.t := Ty.path "u16".
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitAnd"
            (Ty.apply (Ty.path "&") [ Ty.path "u16" ])
            [ Ty.path "u16" ]
            "bitand"
            [] in
        let* α1 := M.read self in
        let* α2 :=
          M.get_trait_method
            "core::ops::bit::Not"
            (Ty.apply (Ty.path "&") [ Ty.path "u16" ])
            []
            "not"
            [] in
        let* α3 := M.read other in
        let* α4 := M.call_closure α2 [ α3 ] in
        let* α5 := M.call_closure α0 [ α1; α4 ] in
        M.alloc α5 in
      let* ltb :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitAnd"
            (Ty.path "u16")
            [ Ty.apply (Ty.path "&") [ Ty.path "u16" ] ]
            "bitand"
            [] in
        let* α1 :=
          M.get_trait_method
            "core::ops::bit::Not"
            (Ty.apply (Ty.path "&") [ Ty.path "u16" ])
            []
            "not"
            [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.read other in
        let* α5 := M.call_closure α0 [ α3; α4 ] in
        M.alloc α5 in
      let* pow := M.alloc (Value.Integer Integer.I32 1) in
      let* _ :=
        M.loop
          (let* α0 := M.alloc (Value.Tuple []) in
          M.match_operator
            α0
            [
              fun γ =>
                let* γ :=
                  let* α0 := M.read pow in
                  let* α1 :=
                    M.alloc (BinOp.Pure.lt α0 (Value.Integer Integer.I32 16)) in
                  M.pure (M.use α1) in
                let* _ :=
                  let* α0 := M.read γ in
                  M.is_constant_or_break_match α0 (Value.Bool true) in
                let* _ :=
                  let β := ltb in
                  let* α0 := M.read β in
                  let* α1 := M.read ltb in
                  let* α2 := M.read pow in
                  let* α3 := BinOp.Panic.shr α1 α2 in
                  M.assign β (BinOp.Pure.bit_or α0 α3) in
                let* _ :=
                  let β := pow in
                  let* α0 := M.read β in
                  let* α1 := M.read pow in
                  let* α2 := BinOp.Panic.add α0 α1 in
                  M.assign β α2 in
                M.alloc (Value.Tuple []);
              fun γ =>
                let* _ :=
                  let* α0 := M.break in
                  let* α1 := M.read α0 in
                  let* α2 := M.never_to_any α1 in
                  M.alloc α2 in
                let* α0 := M.alloc (Value.Tuple []) in
                let* α1 := M.read α0 in
                let* α2 := M.never_to_any α1 in
                M.alloc α2
            ]) in
      let* bit :=
        let* α0 := M.read gtb in
        let* α1 := M.read ltb in
        M.alloc (BinOp.Pure.bit_and α0 (UnOp.Pure.not α1)) in
      let* pow := M.alloc (Value.Integer Integer.I32 1) in
      let* _ :=
        M.loop
          (let* α0 := M.alloc (Value.Tuple []) in
          M.match_operator
            α0
            [
              fun γ =>
                let* γ :=
                  let* α0 := M.read pow in
                  let* α1 :=
                    M.alloc (BinOp.Pure.lt α0 (Value.Integer Integer.I32 16)) in
                  M.pure (M.use α1) in
                let* _ :=
                  let* α0 := M.read γ in
                  M.is_constant_or_break_match α0 (Value.Bool true) in
                let* _ :=
                  let β := bit in
                  let* α0 := M.read β in
                  let* α1 := M.read bit in
                  let* α2 := M.read pow in
                  let* α3 := BinOp.Panic.shr α1 α2 in
                  M.assign β (BinOp.Pure.bit_or α0 α3) in
                let* _ :=
                  let β := pow in
                  let* α0 := M.read β in
                  let* α1 := M.read pow in
                  let* α2 := BinOp.Panic.add α0 α1 in
                  M.assign β α2 in
                M.alloc (Value.Tuple []);
              fun γ =>
                let* _ :=
                  let* α0 := M.break in
                  let* α1 := M.read α0 in
                  let* α2 := M.never_to_any α1 in
                  M.alloc α2 in
                let* α0 := M.alloc (Value.Tuple []) in
                let* α1 := M.read α0 in
                let* α2 := M.never_to_any α1 in
                M.alloc α2
            ]) in
      let* α0 :=
        M.get_trait_method
          "core::convert::From"
          (Ty.path "subtle::Choice")
          [ Ty.path "u8" ]
          "from"
          [] in
      let* α1 := M.read bit in
      let* α2 :=
        M.call_closure
          α0
          [ M.rust_cast (BinOp.Pure.bit_and α1 (Value.Integer Integer.U16 1))
          ] in
      let* α0 := M.alloc α2 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeGreater"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_gt", InstanceField.Method ct_gt) ].
End Impl_subtle_ConstantTimeGreater_for_u16.

Module Impl_subtle_ConstantTimeGreater_for_u32.
  Definition Self : Ty.t := Ty.path "u32".
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitAnd"
            (Ty.apply (Ty.path "&") [ Ty.path "u32" ])
            [ Ty.path "u32" ]
            "bitand"
            [] in
        let* α1 := M.read self in
        let* α2 :=
          M.get_trait_method
            "core::ops::bit::Not"
            (Ty.apply (Ty.path "&") [ Ty.path "u32" ])
            []
            "not"
            [] in
        let* α3 := M.read other in
        let* α4 := M.call_closure α2 [ α3 ] in
        let* α5 := M.call_closure α0 [ α1; α4 ] in
        M.alloc α5 in
      let* ltb :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitAnd"
            (Ty.path "u32")
            [ Ty.apply (Ty.path "&") [ Ty.path "u32" ] ]
            "bitand"
            [] in
        let* α1 :=
          M.get_trait_method
            "core::ops::bit::Not"
            (Ty.apply (Ty.path "&") [ Ty.path "u32" ])
            []
            "not"
            [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.read other in
        let* α5 := M.call_closure α0 [ α3; α4 ] in
        M.alloc α5 in
      let* pow := M.alloc (Value.Integer Integer.I32 1) in
      let* _ :=
        M.loop
          (let* α0 := M.alloc (Value.Tuple []) in
          M.match_operator
            α0
            [
              fun γ =>
                let* γ :=
                  let* α0 := M.read pow in
                  let* α1 :=
                    M.alloc (BinOp.Pure.lt α0 (Value.Integer Integer.I32 32)) in
                  M.pure (M.use α1) in
                let* _ :=
                  let* α0 := M.read γ in
                  M.is_constant_or_break_match α0 (Value.Bool true) in
                let* _ :=
                  let β := ltb in
                  let* α0 := M.read β in
                  let* α1 := M.read ltb in
                  let* α2 := M.read pow in
                  let* α3 := BinOp.Panic.shr α1 α2 in
                  M.assign β (BinOp.Pure.bit_or α0 α3) in
                let* _ :=
                  let β := pow in
                  let* α0 := M.read β in
                  let* α1 := M.read pow in
                  let* α2 := BinOp.Panic.add α0 α1 in
                  M.assign β α2 in
                M.alloc (Value.Tuple []);
              fun γ =>
                let* _ :=
                  let* α0 := M.break in
                  let* α1 := M.read α0 in
                  let* α2 := M.never_to_any α1 in
                  M.alloc α2 in
                let* α0 := M.alloc (Value.Tuple []) in
                let* α1 := M.read α0 in
                let* α2 := M.never_to_any α1 in
                M.alloc α2
            ]) in
      let* bit :=
        let* α0 := M.read gtb in
        let* α1 := M.read ltb in
        M.alloc (BinOp.Pure.bit_and α0 (UnOp.Pure.not α1)) in
      let* pow := M.alloc (Value.Integer Integer.I32 1) in
      let* _ :=
        M.loop
          (let* α0 := M.alloc (Value.Tuple []) in
          M.match_operator
            α0
            [
              fun γ =>
                let* γ :=
                  let* α0 := M.read pow in
                  let* α1 :=
                    M.alloc (BinOp.Pure.lt α0 (Value.Integer Integer.I32 32)) in
                  M.pure (M.use α1) in
                let* _ :=
                  let* α0 := M.read γ in
                  M.is_constant_or_break_match α0 (Value.Bool true) in
                let* _ :=
                  let β := bit in
                  let* α0 := M.read β in
                  let* α1 := M.read bit in
                  let* α2 := M.read pow in
                  let* α3 := BinOp.Panic.shr α1 α2 in
                  M.assign β (BinOp.Pure.bit_or α0 α3) in
                let* _ :=
                  let β := pow in
                  let* α0 := M.read β in
                  let* α1 := M.read pow in
                  let* α2 := BinOp.Panic.add α0 α1 in
                  M.assign β α2 in
                M.alloc (Value.Tuple []);
              fun γ =>
                let* _ :=
                  let* α0 := M.break in
                  let* α1 := M.read α0 in
                  let* α2 := M.never_to_any α1 in
                  M.alloc α2 in
                let* α0 := M.alloc (Value.Tuple []) in
                let* α1 := M.read α0 in
                let* α2 := M.never_to_any α1 in
                M.alloc α2
            ]) in
      let* α0 :=
        M.get_trait_method
          "core::convert::From"
          (Ty.path "subtle::Choice")
          [ Ty.path "u8" ]
          "from"
          [] in
      let* α1 := M.read bit in
      let* α2 :=
        M.call_closure
          α0
          [ M.rust_cast (BinOp.Pure.bit_and α1 (Value.Integer Integer.U32 1))
          ] in
      let* α0 := M.alloc α2 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeGreater"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_gt", InstanceField.Method ct_gt) ].
End Impl_subtle_ConstantTimeGreater_for_u32.

Module Impl_subtle_ConstantTimeGreater_for_u64.
  Definition Self : Ty.t := Ty.path "u64".
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitAnd"
            (Ty.apply (Ty.path "&") [ Ty.path "u64" ])
            [ Ty.path "u64" ]
            "bitand"
            [] in
        let* α1 := M.read self in
        let* α2 :=
          M.get_trait_method
            "core::ops::bit::Not"
            (Ty.apply (Ty.path "&") [ Ty.path "u64" ])
            []
            "not"
            [] in
        let* α3 := M.read other in
        let* α4 := M.call_closure α2 [ α3 ] in
        let* α5 := M.call_closure α0 [ α1; α4 ] in
        M.alloc α5 in
      let* ltb :=
        let* α0 :=
          M.get_trait_method
            "core::ops::bit::BitAnd"
            (Ty.path "u64")
            [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
            "bitand"
            [] in
        let* α1 :=
          M.get_trait_method
            "core::ops::bit::Not"
            (Ty.apply (Ty.path "&") [ Ty.path "u64" ])
            []
            "not"
            [] in
        let* α2 := M.read self in
        let* α3 := M.call_closure α1 [ α2 ] in
        let* α4 := M.read other in
        let* α5 := M.call_closure α0 [ α3; α4 ] in
        M.alloc α5 in
      let* pow := M.alloc (Value.Integer Integer.I32 1) in
      let* _ :=
        M.loop
          (let* α0 := M.alloc (Value.Tuple []) in
          M.match_operator
            α0
            [
              fun γ =>
                let* γ :=
                  let* α0 := M.read pow in
                  let* α1 :=
                    M.alloc (BinOp.Pure.lt α0 (Value.Integer Integer.I32 64)) in
                  M.pure (M.use α1) in
                let* _ :=
                  let* α0 := M.read γ in
                  M.is_constant_or_break_match α0 (Value.Bool true) in
                let* _ :=
                  let β := ltb in
                  let* α0 := M.read β in
                  let* α1 := M.read ltb in
                  let* α2 := M.read pow in
                  let* α3 := BinOp.Panic.shr α1 α2 in
                  M.assign β (BinOp.Pure.bit_or α0 α3) in
                let* _ :=
                  let β := pow in
                  let* α0 := M.read β in
                  let* α1 := M.read pow in
                  let* α2 := BinOp.Panic.add α0 α1 in
                  M.assign β α2 in
                M.alloc (Value.Tuple []);
              fun γ =>
                let* _ :=
                  let* α0 := M.break in
                  let* α1 := M.read α0 in
                  let* α2 := M.never_to_any α1 in
                  M.alloc α2 in
                let* α0 := M.alloc (Value.Tuple []) in
                let* α1 := M.read α0 in
                let* α2 := M.never_to_any α1 in
                M.alloc α2
            ]) in
      let* bit :=
        let* α0 := M.read gtb in
        let* α1 := M.read ltb in
        M.alloc (BinOp.Pure.bit_and α0 (UnOp.Pure.not α1)) in
      let* pow := M.alloc (Value.Integer Integer.I32 1) in
      let* _ :=
        M.loop
          (let* α0 := M.alloc (Value.Tuple []) in
          M.match_operator
            α0
            [
              fun γ =>
                let* γ :=
                  let* α0 := M.read pow in
                  let* α1 :=
                    M.alloc (BinOp.Pure.lt α0 (Value.Integer Integer.I32 64)) in
                  M.pure (M.use α1) in
                let* _ :=
                  let* α0 := M.read γ in
                  M.is_constant_or_break_match α0 (Value.Bool true) in
                let* _ :=
                  let β := bit in
                  let* α0 := M.read β in
                  let* α1 := M.read bit in
                  let* α2 := M.read pow in
                  let* α3 := BinOp.Panic.shr α1 α2 in
                  M.assign β (BinOp.Pure.bit_or α0 α3) in
                let* _ :=
                  let β := pow in
                  let* α0 := M.read β in
                  let* α1 := M.read pow in
                  let* α2 := BinOp.Panic.add α0 α1 in
                  M.assign β α2 in
                M.alloc (Value.Tuple []);
              fun γ =>
                let* _ :=
                  let* α0 := M.break in
                  let* α1 := M.read α0 in
                  let* α2 := M.never_to_any α1 in
                  M.alloc α2 in
                let* α0 := M.alloc (Value.Tuple []) in
                let* α1 := M.read α0 in
                let* α2 := M.never_to_any α1 in
                M.alloc α2
            ]) in
      let* α0 :=
        M.get_trait_method
          "core::convert::From"
          (Ty.path "subtle::Choice")
          [ Ty.path "u8" ]
          "from"
          [] in
      let* α1 := M.read bit in
      let* α2 :=
        M.call_closure
          α0
          [ M.rust_cast (BinOp.Pure.bit_and α1 (Value.Integer Integer.U64 1))
          ] in
      let* α0 := M.alloc α2 in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeGreater"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [ ("ct_gt", InstanceField.Method ct_gt) ].
End Impl_subtle_ConstantTimeGreater_for_u64.

(* Trait *)
Module ConstantTimeLess.
  Definition ct_lt (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ self; other ] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 :=
        M.get_trait_method
          "core::ops::bit::BitAnd"
          (Ty.path "subtle::Choice")
          [ Ty.path "subtle::Choice" ]
          "bitand"
          [] in
      let* α1 :=
        M.get_trait_method
          "core::ops::bit::Not"
          (Ty.path "subtle::Choice")
          []
          "not"
          [] in
      let* α2 :=
        M.get_trait_method "subtle::ConstantTimeGreater" Self [] "ct_gt" [] in
      let* α3 := M.read self in
      let* α4 := M.read other in
      let* α5 := M.call_closure α2 [ α3; α4 ] in
      let* α6 := M.call_closure α1 [ α5 ] in
      let* α7 :=
        M.get_trait_method
          "core::ops::bit::Not"
          (Ty.path "subtle::Choice")
          []
          "not"
          [] in
      let* α8 :=
        M.get_trait_method "subtle::ConstantTimeEq" Self [] "ct_eq" [] in
      let* α9 := M.read self in
      let* α10 := M.read other in
      let* α11 := M.call_closure α8 [ α9; α10 ] in
      let* α12 := M.call_closure α7 [ α11 ] in
      M.call_closure α0 [ α6; α12 ]
    | _, _ => M.impossible
    end.
  
  Axiom ProvidedMethod_ct_lt :
    M.IsProvidedMethod "subtle::ConstantTimeLess" "ct_lt" ct_lt.
End ConstantTimeLess.

Module Impl_subtle_ConstantTimeLess_for_u8.
  Definition Self : Ty.t := Ty.path "u8".
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeLess"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_subtle_ConstantTimeLess_for_u8.

Module Impl_subtle_ConstantTimeLess_for_u16.
  Definition Self : Ty.t := Ty.path "u16".
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeLess"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_subtle_ConstantTimeLess_for_u16.

Module Impl_subtle_ConstantTimeLess_for_u32.
  Definition Self : Ty.t := Ty.path "u32".
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeLess"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_subtle_ConstantTimeLess_for_u32.

Module Impl_subtle_ConstantTimeLess_for_u64.
  Definition Self : Ty.t := Ty.path "u64".
  
  Axiom Implements :
    M.IsTraitInstance
      "subtle::ConstantTimeLess"
      Self
      (* Trait polymorphic types *) []
      (* Instance *) [].
End Impl_subtle_ConstantTimeLess_for_u64.
