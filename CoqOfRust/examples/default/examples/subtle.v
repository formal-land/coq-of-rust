(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Choice.
Section Choice.
  Record t : Set := {
    x0 : u8.t;
  }.
  
  Definition Get_0 :=
    Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
End Choice.
End Choice.

Module  Impl_core_marker_Copy_for_subtle_Choice_t.
Section Impl_core_marker_Copy_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_subtle_Choice_t.
End Impl_core_marker_Copy_for_subtle_Choice_t.

Module  Impl_core_clone_Clone_for_subtle_Choice_t.
Section Impl_core_clone_Clone_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* α0 : M.Val subtle.Choice.t :=
      match_operator
        (DeclaredButUndefinedVariable
          (A := core.clone.AssertParamIsClone.t u8.t))
        [
          fun γ =>
            (let* α0 : ref subtle.Choice.t := M.read self in
            M.pure (deref α0)) :
            M (M.Val subtle.Choice.t)
        ] in
    M.read α0.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_subtle_Choice_t.
End Impl_core_clone_Clone_for_subtle_Choice_t.

Module  Impl_core_fmt_Debug_for_subtle_Choice_t.
Section Impl_core_fmt_Debug_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
    let* α1 : ref str.t := M.read (mk_str "Choice") in
    let* α2 : ref subtle.Choice.t := M.read self in
    let* α3 : M.Val (ref u8.t) :=
      M.alloc (borrow (subtle.Choice.Get_0 (deref α2))) in
    M.call
      (core.fmt.Formatter.t::["debug_tuple_field1_finish"]
        α0
        α1
        (pointer_coercion "Unsize" (borrow α3))).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_subtle_Choice_t.
End Impl_core_fmt_Debug_for_subtle_Choice_t.

Module  Impl_subtle_Choice_t.
Section Impl_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      pub fn unwrap_u8(&self) -> u8 {
          self.0
      }
  *)
  Definition unwrap_u8 (self : ref Self) : M u8.t :=
    let* self := M.alloc self in
    let* α0 : ref subtle.Choice.t := M.read self in
    M.read (subtle.Choice.Get_0 (deref α0)).
  
  Global Instance AssociatedFunction_unwrap_u8 :
    Notations.DoubleColon Self "unwrap_u8" := {
    Notations.double_colon := unwrap_u8;
  }.
End Impl_subtle_Choice_t.
End Impl_subtle_Choice_t.

Module  Impl_core_convert_From_subtle_Choice_t_for_bool_t.
Section Impl_core_convert_From_subtle_Choice_t_for_bool_t.
  Definition Self : Set := bool.t.
  
  (*
      fn from(source: Choice) -> bool {
          debug_assert!((source.0 == 0u8) | (source.0 == 1u8));
          source.0 != 0
      }
  *)
  Definition from (source : subtle.Choice.t) : M bool.t :=
    let* source := M.alloc source in
    let* _ : M.Val unit :=
      let* α0 : M.Val bool.t := M.alloc true in
      let* α1 : bool.t := M.read (use α0) in
      if α1 then
        let* _ : M.Val unit :=
          let* α0 : u8.t := M.read (subtle.Choice.Get_0 source) in
          let* α1 : u8.t := M.read (subtle.Choice.Get_0 source) in
          let* α2 : M.Val bool.t :=
            M.alloc
              (UnOp.not
                (BinOp.Pure.bit_or
                  (BinOp.Pure.eq α0 ((Integer.of_Z 0) : u8.t))
                  (BinOp.Pure.eq α1 ((Integer.of_Z 1) : u8.t)))) in
          let* α3 : bool.t := M.read (use α2) in
          if α3 then
            let* α0 : ref str.t :=
              M.read
                (mk_str
                  "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)") in
            let* α1 : never.t := M.call (core.panicking.panic α0) in
            let* α2 : unit := never_to_any α1 in
            M.alloc α2
          else
            M.alloc tt in
        M.alloc tt
      else
        M.alloc tt in
    let* α0 : u8.t := M.read (subtle.Choice.Get_0 source) in
    let* α0 : M.Val bool.t :=
      M.alloc (BinOp.Pure.ne α0 ((Integer.of_Z 0) : u8.t)) in
    M.read α0.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := subtle.Choice.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_subtle_Choice_t_for_bool_t.
End Impl_core_convert_From_subtle_Choice_t_for_bool_t.

Module  Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := subtle.Choice.t.
  
  (*
      fn bitand(self, rhs: Choice) -> Choice {
          (self.0 & rhs.0).into()
      }
  *)
  Definition bitand (self : Self) (rhs : subtle.Choice.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* rhs := M.alloc rhs in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.Into.into
          (Self := u8.t)
          (T := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α1 : u8.t := M.read (subtle.Choice.Get_0 self) in
    let* α2 : u8.t := M.read (subtle.Choice.Get_0 rhs) in
    M.call (α0 (BinOp.Pure.bit_and α1 α2)).
  
  Global Instance AssociatedFunction_bitand :
    Notations.DoubleColon Self "bitand" := {
    Notations.double_colon := bitand;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitAnd.Trait Self
      (Rhs := core.ops.bit.BitAnd.Default.Rhs Self) := {
    core.ops.bit.BitAnd.Output := Output;
    core.ops.bit.BitAnd.bitand := bitand;
  }.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      fn bitand_assign(&mut self, rhs: Choice) {
          *self = *self & rhs;
      }
  *)
  Definition bitand_assign
      (self : mut_ref Self)
      (rhs : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* rhs := M.alloc rhs in
    let* _ : M.Val unit :=
      let* α0 : mut_ref subtle.Choice.t := M.read self in
      let* α1 : subtle.Choice.t -> subtle.Choice.t -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitAnd.bitand
            (Self := subtle.Choice.t)
            (Rhs := subtle.Choice.t)
            (Trait := ℐ))) in
      let* α2 : mut_ref subtle.Choice.t := M.read self in
      let* α3 : subtle.Choice.t := M.read (deref α2) in
      let* α4 : subtle.Choice.t := M.read rhs in
      let* α5 : subtle.Choice.t := M.call (α1 α3 α4) in
      assign (deref α0) α5 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_bitand_assign :
    Notations.DoubleColon Self "bitand_assign" := {
    Notations.double_colon := bitand_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitAndAssign.Trait Self
      (Rhs := core.ops.bit.BitAndAssign.Default.Rhs Self) := {
    core.ops.bit.BitAndAssign.bitand_assign := bitand_assign;
  }.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitOr_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitOr_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := subtle.Choice.t.
  
  (*
      fn bitor(self, rhs: Choice) -> Choice {
          (self.0 | rhs.0).into()
      }
  *)
  Definition bitor (self : Self) (rhs : subtle.Choice.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* rhs := M.alloc rhs in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.Into.into
          (Self := u8.t)
          (T := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α1 : u8.t := M.read (subtle.Choice.Get_0 self) in
    let* α2 : u8.t := M.read (subtle.Choice.Get_0 rhs) in
    M.call (α0 (BinOp.Pure.bit_or α1 α2)).
  
  Global Instance AssociatedFunction_bitor :
    Notations.DoubleColon Self "bitor" := {
    Notations.double_colon := bitor;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitOr.Trait Self
      (Rhs := core.ops.bit.BitOr.Default.Rhs Self) := {
    core.ops.bit.BitOr.Output := Output;
    core.ops.bit.BitOr.bitor := bitor;
  }.
End Impl_core_ops_bit_BitOr_for_subtle_Choice_t.
End Impl_core_ops_bit_BitOr_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      fn bitor_assign(&mut self, rhs: Choice) {
          *self = *self | rhs;
      }
  *)
  Definition bitor_assign
      (self : mut_ref Self)
      (rhs : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* rhs := M.alloc rhs in
    let* _ : M.Val unit :=
      let* α0 : mut_ref subtle.Choice.t := M.read self in
      let* α1 : subtle.Choice.t -> subtle.Choice.t -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitOr.bitor
            (Self := subtle.Choice.t)
            (Rhs := subtle.Choice.t)
            (Trait := ℐ))) in
      let* α2 : mut_ref subtle.Choice.t := M.read self in
      let* α3 : subtle.Choice.t := M.read (deref α2) in
      let* α4 : subtle.Choice.t := M.read rhs in
      let* α5 : subtle.Choice.t := M.call (α1 α3 α4) in
      assign (deref α0) α5 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_bitor_assign :
    Notations.DoubleColon Self "bitor_assign" := {
    Notations.double_colon := bitor_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitOrAssign.Trait Self
      (Rhs := core.ops.bit.BitOrAssign.Default.Rhs Self) := {
    core.ops.bit.BitOrAssign.bitor_assign := bitor_assign;
  }.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitXor_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitXor_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := subtle.Choice.t.
  
  (*
      fn bitxor(self, rhs: Choice) -> Choice {
          (self.0 ^ rhs.0).into()
      }
  *)
  Definition bitxor (self : Self) (rhs : subtle.Choice.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* rhs := M.alloc rhs in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.Into.into
          (Self := u8.t)
          (T := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α1 : u8.t := M.read (subtle.Choice.Get_0 self) in
    let* α2 : u8.t := M.read (subtle.Choice.Get_0 rhs) in
    M.call (α0 (BinOp.Pure.bit_xor α1 α2)).
  
  Global Instance AssociatedFunction_bitxor :
    Notations.DoubleColon Self "bitxor" := {
    Notations.double_colon := bitxor;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitXor.Trait Self
      (Rhs := core.ops.bit.BitXor.Default.Rhs Self) := {
    core.ops.bit.BitXor.Output := Output;
    core.ops.bit.BitXor.bitxor := bitxor;
  }.
End Impl_core_ops_bit_BitXor_for_subtle_Choice_t.
End Impl_core_ops_bit_BitXor_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      fn bitxor_assign(&mut self, rhs: Choice) {
          *self = *self ^ rhs;
      }
  *)
  Definition bitxor_assign
      (self : mut_ref Self)
      (rhs : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* rhs := M.alloc rhs in
    let* _ : M.Val unit :=
      let* α0 : mut_ref subtle.Choice.t := M.read self in
      let* α1 : subtle.Choice.t -> subtle.Choice.t -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitXor.bitxor
            (Self := subtle.Choice.t)
            (Rhs := subtle.Choice.t)
            (Trait := ℐ))) in
      let* α2 : mut_ref subtle.Choice.t := M.read self in
      let* α3 : subtle.Choice.t := M.read (deref α2) in
      let* α4 : subtle.Choice.t := M.read rhs in
      let* α5 : subtle.Choice.t := M.call (α1 α3 α4) in
      assign (deref α0) α5 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_bitxor_assign :
    Notations.DoubleColon Self "bitxor_assign" := {
    Notations.double_colon := bitxor_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitXorAssign.Trait Self
      (Rhs := core.ops.bit.BitXorAssign.Default.Rhs Self) := {
    core.ops.bit.BitXorAssign.bitxor_assign := bitxor_assign;
  }.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.

Module  Impl_core_ops_bit_Not_for_subtle_Choice_t.
Section Impl_core_ops_bit_Not_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := subtle.Choice.t.
  
  (*
      fn not(self) -> Choice {
          (1u8 & (!self.0)).into()
      }
  *)
  Definition not (self : Self) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.Into.into
          (Self := u8.t)
          (T := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α1 : u8.t := M.read (subtle.Choice.Get_0 self) in
    M.call (α0 (BinOp.Pure.bit_and ((Integer.of_Z 1) : u8.t) (UnOp.not α1))).
  
  Global Instance AssociatedFunction_not : Notations.DoubleColon Self "not" := {
    Notations.double_colon := not;
  }.
  
  Global Instance ℐ : core.ops.bit.Not.Trait Self := {
    core.ops.bit.Not.Output := Output;
    core.ops.bit.Not.not := not;
  }.
End Impl_core_ops_bit_Not_for_subtle_Choice_t.
End Impl_core_ops_bit_Not_for_subtle_Choice_t.

(*
fn black_box(input: u8) -> u8 {
    debug_assert!((input == 0u8) | (input == 1u8));

    unsafe {
        // Optimization barrier
        //
        // Unsafe is ok, because:
        //   - &input is not NULL;
        //   - size of input is not zero;
        //   - u8 is neither Sync, nor Send;
        //   - u8 is Copy, so input is always live;
        //   - u8 type is always properly aligned.
        core::ptr::read_volatile(&input as *const u8)
    }
}
*)
Definition black_box (input : u8.t) : M u8.t :=
  let* input := M.alloc input in
  let* _ : M.Val unit :=
    let* α0 : M.Val bool.t := M.alloc true in
    let* α1 : bool.t := M.read (use α0) in
    if α1 then
      let* _ : M.Val unit :=
        let* α0 : u8.t := M.read input in
        let* α1 : u8.t := M.read input in
        let* α2 : M.Val bool.t :=
          M.alloc
            (UnOp.not
              (BinOp.Pure.bit_or
                (BinOp.Pure.eq α0 ((Integer.of_Z 0) : u8.t))
                (BinOp.Pure.eq α1 ((Integer.of_Z 1) : u8.t)))) in
        let* α3 : bool.t := M.read (use α2) in
        if α3 then
          let* α0 : ref str.t :=
            M.read
              (mk_str "assertion failed: (input == 0u8) | (input == 1u8)") in
          let* α1 : never.t := M.call (core.panicking.panic α0) in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      M.alloc tt
    else
      M.alloc tt in
  let* α0 : M.Val (ref u8.t) := M.alloc (addr_of input) in
  let* α1 : ref u8.t := M.read (use α0) in
  let* α2 : u8.t := M.call (core.ptr.read_volatile α1) in
  let* α0 : M.Val u8.t := M.alloc α2 in
  M.read α0.

Module  Impl_core_convert_From_u8_t_for_subtle_Choice_t.
Section Impl_core_convert_From_u8_t_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      fn from(input: u8) -> Choice {
          // Our goal is to prevent the compiler from inferring that the value held inside the
          // resulting `Choice` struct is really an `i1` instead of an `i8`.
          Choice(black_box(input))
      }
  *)
  Definition from (input : u8.t) : M subtle.Choice.t :=
    let* input := M.alloc input in
    let* α0 : u8.t := M.read input in
    let* α1 : u8.t := M.call (subtle.black_box α0) in
    M.pure (subtle.Choice.Build_t α1).
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := u8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u8_t_for_subtle_Choice_t.
End Impl_core_convert_From_u8_t_for_subtle_Choice_t.

Module  ConstantTimeEq.
Section ConstantTimeEq.
  Class Trait (Self : Set) : Type := {
    ct_eq : (ref Self) -> (ref Self) -> M subtle.Choice.t;
  }.
  
End ConstantTimeEq.
End ConstantTimeEq.

Module  Impl_subtle_ConstantTimeEq_for_slice_T.
Section Impl_subtle_ConstantTimeEq_for_slice_T.
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConstantTimeEq.Trait T}.
  
  Definition Self : Set := slice T.
  
  (*
      fn ct_eq(&self, _rhs: &[T]) -> Choice {
          let len = self.len();
  
          // Short-circuit on the *lengths* of the slices, not their
          // contents.
          if len != _rhs.len() {
              return Choice::from(0);
          }
  
          // This loop shouldn't be shortcircuitable, since the compiler
          // shouldn't be able to reason about the value of the `u8`
          // unwrapped from the `ct_eq` result.
          let mut x = 1u8;
          for (ai, bi) in self.iter().zip(_rhs.iter()) {
              x &= ai.ct_eq(bi).unwrap_u8();
          }
  
          x.into()
      }
  *)
  Definition ct_eq
      (self : ref Self)
      (_rhs : ref (slice T))
      : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* _rhs := M.alloc _rhs in
    let return_ := M.return_ (R := subtle.Choice.t) in
    M.catch_return
      (let* len : M.Val usize.t :=
        let* α0 : ref (slice T) := M.read self in
        let* α1 : usize.t := M.call ((slice T)::["len"] α0) in
        M.alloc α1 in
      let* _ : M.Val unit :=
        let* α0 : usize.t := M.read len in
        let* α1 : ref (slice T) := M.read _rhs in
        let* α2 : usize.t := M.call ((slice T)::["len"] α1) in
        let* α3 : M.Val bool.t := M.alloc (BinOp.Pure.ne α0 α2) in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* α0 : u8.t -> M subtle.Choice.t :=
            ltac:(M.get_method (fun ℐ =>
              core.convert.From.from
                (Self := subtle.Choice.t)
                (T := u8.t)
                (Trait := ℐ))) in
          let* α1 : subtle.Choice.t := M.call (α0 ((Integer.of_Z 0) : u8.t)) in
          let* α2 : M.Val never.t := return_ α1 in
          let* α3 := M.read α2 in
          let* α4 : unit := never_to_any α3 in
          M.alloc α4
        else
          M.alloc tt in
      let* x : M.Val u8.t := M.alloc ((Integer.of_Z 1) : u8.t) in
      let* _ : M.Val unit :=
        let* α0 :
            (core.iter.adapters.zip.Zip.t
                (core.slice.iter.Iter.t T)
                (core.slice.iter.Iter.t T))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            core.iter.traits.collect.IntoIterator.into_iter
              (Self :=
                core.iter.adapters.zip.Zip.t
                  (core.slice.iter.Iter.t T)
                  (core.slice.iter.Iter.t T))
              (Trait := ℐ))) in
        let* α1 :
            (core.slice.iter.Iter.t T) ->
              (core.slice.iter.Iter.t T) ->
              M (core.iter.adapters.zip.Zip.t (core.slice.iter.Iter.t T) _) :=
          ltac:(M.get_method (fun ℐ =>
            core.iter.traits.iterator.Iterator.zip
              (Self := core.slice.iter.Iter.t T)
              (U := core.slice.iter.Iter.t T)
              (Trait := ℐ))) in
        let* α2 : ref (slice T) := M.read self in
        let* α3 : core.slice.iter.Iter.t T := M.call ((slice T)::["iter"] α2) in
        let* α4 : ref (slice T) := M.read _rhs in
        let* α5 : core.slice.iter.Iter.t T := M.call ((slice T)::["iter"] α4) in
        let* α6 :
            core.iter.adapters.zip.Zip.t
              (core.slice.iter.Iter.t T)
              (core.slice.iter.Iter.t T) :=
          M.call (α1 α3 α5) in
        let* α7 :
            core.iter.adapters.zip.Zip.t
              (core.slice.iter.Iter.t T)
              (core.slice.iter.Iter.t T) :=
          M.call (α0 α6) in
        let* α8 :
            M.Val
              (core.iter.adapters.zip.Zip.t
                (core.slice.iter.Iter.t T)
                (core.slice.iter.Iter.t T)) :=
          M.alloc α7 in
        let* α9 : M.Val unit :=
          match_operator
            α8
            [
              fun γ =>
                (let* iter := M.copy γ in
                M.loop
                  (let* _ : M.Val unit :=
                    let* α0 :
                        (mut_ref
                            (core.iter.adapters.zip.Zip.t
                              (core.slice.iter.Iter.t T)
                              (core.slice.iter.Iter.t T)))
                          ->
                          M (core.option.Option.t _) :=
                      ltac:(M.get_method (fun ℐ =>
                        core.iter.traits.iterator.Iterator.next
                          (Self :=
                            core.iter.adapters.zip.Zip.t
                              (core.slice.iter.Iter.t T)
                              (core.slice.iter.Iter.t T))
                          (Trait := ℐ))) in
                    let* α1 : core.option.Option.t ((ref T) * (ref T)) :=
                      M.call (α0 (borrow_mut iter)) in
                    let* α2 :
                        M.Val (core.option.Option.t ((ref T) * (ref T))) :=
                      M.alloc α1 in
                    match_operator
                      α2
                      [
                        fun γ =>
                          (let* α0 := M.read γ in
                          match α0 with
                          | core.option.Option.None =>
                            let* α0 : M.Val never.t := M.break in
                            let* α1 := M.read α0 in
                            let* α2 : unit := never_to_any α1 in
                            M.alloc α2
                          | _ => M.break_match
                          end) :
                          M (M.Val unit);
                        fun γ =>
                          (let* α0 := M.read γ in
                          match α0 with
                          | core.option.Option.Some _ =>
                            let γ0_0 := core.option.Option.Get_Some_0 γ in
                            let* α0 := M.read γ0_0 in
                            match α0 with
                            | (_, _) =>
                              let γ1_0 := Tuple.Access.left γ0_0 in
                              let γ1_1 := Tuple.Access.right γ0_0 in
                              let* ai := M.copy γ1_0 in
                              let* bi := M.copy γ1_1 in
                              let* _ : M.Val unit :=
                                let β : M.Val u8.t := x in
                                let* α0 := M.read β in
                                let* α1 :
                                    (ref T) -> (ref T) -> M subtle.Choice.t :=
                                  ltac:(M.get_method (fun ℐ =>
                                    subtle.ConstantTimeEq.ct_eq
                                      (Self := T)
                                      (Trait := ℐ))) in
                                let* α2 : ref T := M.read ai in
                                let* α3 : ref T := M.read bi in
                                let* α4 : subtle.Choice.t :=
                                  M.call (α1 α2 α3) in
                                let* α5 : M.Val subtle.Choice.t := M.alloc α4 in
                                let* α6 : u8.t :=
                                  M.call
                                    (subtle.Choice.t::["unwrap_u8"]
                                      (borrow α5)) in
                                assign β (BinOp.Pure.bit_and α0 α6) in
                              M.alloc tt
                            end
                          | _ => M.break_match
                          end) :
                          M (M.Val unit)
                      ] in
                  M.alloc tt)) :
                M (M.Val unit)
            ] in
        M.pure (use α9) in
      let* α0 : u8.t -> M subtle.Choice.t :=
        ltac:(M.get_method (fun ℐ =>
          core.convert.Into.into
            (Self := u8.t)
            (T := subtle.Choice.t)
            (Trait := ℐ))) in
      let* α1 : u8.t := M.read x in
      let* α2 : subtle.Choice.t := M.call (α0 α1) in
      let* α0 : M.Val subtle.Choice.t := M.alloc α2 in
      M.read α0).
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_slice_T.
End Impl_subtle_ConstantTimeEq_for_slice_T.

Module  Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.
Section Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      fn ct_eq(&self, rhs: &Choice) -> Choice {
          !( *self ^ *rhs)
      }
  *)
  Definition ct_eq
      (self : ref Self)
      (rhs : ref subtle.Choice.t)
      : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* rhs := M.alloc rhs in
    let* α0 : subtle.Choice.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.Not.not (Self := subtle.Choice.t) (Trait := ℐ))) in
    let* α1 : subtle.Choice.t -> subtle.Choice.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := subtle.Choice.t)
          (Rhs := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α2 : ref subtle.Choice.t := M.read self in
    let* α3 : subtle.Choice.t := M.read (deref α2) in
    let* α4 : ref subtle.Choice.t := M.read rhs in
    let* α5 : subtle.Choice.t := M.read (deref α4) in
    let* α6 : subtle.Choice.t := M.call (α1 α3 α5) in
    M.call (α0 α6).
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.

Module  Impl_subtle_ConstantTimeEq_for_u8_t.
Section Impl_subtle_ConstantTimeEq_for_u8_t.
  Definition Self : Set := u8.t.
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (self : ref Self) (other : ref u8.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* x : M.Val u8.t :=
      let* α0 : (ref u8.t) -> (ref u8.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitXor.bitxor
            (Self := ref u8.t)
            (Rhs := ref u8.t)
            (Trait := ℐ))) in
      let* α1 : ref u8.t := M.read self in
      let* α2 : ref u8.t := M.read other in
      let* α3 : u8.t := M.call (α0 α1 α2) in
      M.alloc α3 in
    let* y : M.Val u8.t :=
      let* α0 : u8.t := M.read x in
      let* α1 : u8.t := M.read x in
      let* α2 : u8.t := M.call (u8.t::["wrapping_neg"] α1) in
      let* α3 : i32.t :=
        BinOp.Panic.sub ((Integer.of_Z 8) : i32.t) ((Integer.of_Z 1) : i32.t) in
      let* α4 : u8.t := BinOp.Panic.shr (BinOp.Pure.bit_or α0 α2) α3 in
      M.alloc α4 in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.Into.into
          (Self := u8.t)
          (T := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α1 : u8.t := M.read y in
    let* α2 : M.Val u8.t := M.alloc ((Integer.of_Z 1) : u8.t) in
    let* α3 : u8.t := M.read (use α2) in
    let* α4 : M.Val u8.t := M.alloc (BinOp.Pure.bit_xor α1 α3) in
    let* α5 : u8.t := M.read (use α4) in
    let* α6 : subtle.Choice.t := M.call (α0 α5) in
    let* α0 : M.Val subtle.Choice.t := M.alloc α6 in
    M.read α0.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u8_t.
End Impl_subtle_ConstantTimeEq_for_u8_t.

Module  Impl_subtle_ConstantTimeEq_for_i8_t.
Section Impl_subtle_ConstantTimeEq_for_i8_t.
  Definition Self : Set := i8.t.
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (self : ref Self) (other : ref i8.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : (ref u8.t) -> (ref u8.t) -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConstantTimeEq.ct_eq (Self := u8.t) (Trait := ℐ))) in
    let* α1 : ref i8.t := M.read self in
    let* α2 : i8.t := M.read (deref α1) in
    let* α3 : M.Val u8.t := M.alloc (rust_cast α2) in
    let* α4 : ref i8.t := M.read other in
    let* α5 : i8.t := M.read (deref α4) in
    let* α6 : M.Val u8.t := M.alloc (rust_cast α5) in
    M.call (α0 (borrow α3) (borrow α6)).
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i8_t.
End Impl_subtle_ConstantTimeEq_for_i8_t.

Module  Impl_subtle_ConstantTimeEq_for_u16_t.
Section Impl_subtle_ConstantTimeEq_for_u16_t.
  Definition Self : Set := u16.t.
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (self : ref Self) (other : ref u16.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* x : M.Val u16.t :=
      let* α0 : (ref u16.t) -> (ref u16.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitXor.bitxor
            (Self := ref u16.t)
            (Rhs := ref u16.t)
            (Trait := ℐ))) in
      let* α1 : ref u16.t := M.read self in
      let* α2 : ref u16.t := M.read other in
      let* α3 : u16.t := M.call (α0 α1 α2) in
      M.alloc α3 in
    let* y : M.Val u16.t :=
      let* α0 : u16.t := M.read x in
      let* α1 : u16.t := M.read x in
      let* α2 : u16.t := M.call (u16.t::["wrapping_neg"] α1) in
      let* α3 : i32.t :=
        BinOp.Panic.sub
          ((Integer.of_Z 16) : i32.t)
          ((Integer.of_Z 1) : i32.t) in
      let* α4 : u16.t := BinOp.Panic.shr (BinOp.Pure.bit_or α0 α2) α3 in
      M.alloc α4 in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.Into.into
          (Self := u8.t)
          (T := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α1 : u16.t := M.read y in
    let* α2 : M.Val u16.t := M.alloc ((Integer.of_Z 1) : u16.t) in
    let* α3 : u16.t := M.read (use α2) in
    let* α4 : subtle.Choice.t :=
      M.call (α0 (rust_cast (BinOp.Pure.bit_xor α1 α3))) in
    let* α0 : M.Val subtle.Choice.t := M.alloc α4 in
    M.read α0.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u16_t.
End Impl_subtle_ConstantTimeEq_for_u16_t.

Module  Impl_subtle_ConstantTimeEq_for_i16_t.
Section Impl_subtle_ConstantTimeEq_for_i16_t.
  Definition Self : Set := i16.t.
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (self : ref Self) (other : ref i16.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : (ref u16.t) -> (ref u16.t) -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConstantTimeEq.ct_eq (Self := u16.t) (Trait := ℐ))) in
    let* α1 : ref i16.t := M.read self in
    let* α2 : i16.t := M.read (deref α1) in
    let* α3 : M.Val u16.t := M.alloc (rust_cast α2) in
    let* α4 : ref i16.t := M.read other in
    let* α5 : i16.t := M.read (deref α4) in
    let* α6 : M.Val u16.t := M.alloc (rust_cast α5) in
    M.call (α0 (borrow α3) (borrow α6)).
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i16_t.
End Impl_subtle_ConstantTimeEq_for_i16_t.

Module  Impl_subtle_ConstantTimeEq_for_u32_t.
Section Impl_subtle_ConstantTimeEq_for_u32_t.
  Definition Self : Set := u32.t.
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (self : ref Self) (other : ref u32.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* x : M.Val u32.t :=
      let* α0 : (ref u32.t) -> (ref u32.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitXor.bitxor
            (Self := ref u32.t)
            (Rhs := ref u32.t)
            (Trait := ℐ))) in
      let* α1 : ref u32.t := M.read self in
      let* α2 : ref u32.t := M.read other in
      let* α3 : u32.t := M.call (α0 α1 α2) in
      M.alloc α3 in
    let* y : M.Val u32.t :=
      let* α0 : u32.t := M.read x in
      let* α1 : u32.t := M.read x in
      let* α2 : u32.t := M.call (u32.t::["wrapping_neg"] α1) in
      let* α3 : i32.t :=
        BinOp.Panic.sub
          ((Integer.of_Z 32) : i32.t)
          ((Integer.of_Z 1) : i32.t) in
      let* α4 : u32.t := BinOp.Panic.shr (BinOp.Pure.bit_or α0 α2) α3 in
      M.alloc α4 in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.Into.into
          (Self := u8.t)
          (T := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α1 : u32.t := M.read y in
    let* α2 : M.Val u32.t := M.alloc ((Integer.of_Z 1) : u32.t) in
    let* α3 : u32.t := M.read (use α2) in
    let* α4 : subtle.Choice.t :=
      M.call (α0 (rust_cast (BinOp.Pure.bit_xor α1 α3))) in
    let* α0 : M.Val subtle.Choice.t := M.alloc α4 in
    M.read α0.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u32_t.
End Impl_subtle_ConstantTimeEq_for_u32_t.

Module  Impl_subtle_ConstantTimeEq_for_i32_t.
Section Impl_subtle_ConstantTimeEq_for_i32_t.
  Definition Self : Set := i32.t.
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (self : ref Self) (other : ref i32.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : (ref u32.t) -> (ref u32.t) -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConstantTimeEq.ct_eq (Self := u32.t) (Trait := ℐ))) in
    let* α1 : ref i32.t := M.read self in
    let* α2 : i32.t := M.read (deref α1) in
    let* α3 : M.Val u32.t := M.alloc (rust_cast α2) in
    let* α4 : ref i32.t := M.read other in
    let* α5 : i32.t := M.read (deref α4) in
    let* α6 : M.Val u32.t := M.alloc (rust_cast α5) in
    M.call (α0 (borrow α3) (borrow α6)).
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i32_t.
End Impl_subtle_ConstantTimeEq_for_i32_t.

Module  Impl_subtle_ConstantTimeEq_for_u64_t.
Section Impl_subtle_ConstantTimeEq_for_u64_t.
  Definition Self : Set := u64.t.
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (self : ref Self) (other : ref u64.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* x : M.Val u64.t :=
      let* α0 : (ref u64.t) -> (ref u64.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitXor.bitxor
            (Self := ref u64.t)
            (Rhs := ref u64.t)
            (Trait := ℐ))) in
      let* α1 : ref u64.t := M.read self in
      let* α2 : ref u64.t := M.read other in
      let* α3 : u64.t := M.call (α0 α1 α2) in
      M.alloc α3 in
    let* y : M.Val u64.t :=
      let* α0 : u64.t := M.read x in
      let* α1 : u64.t := M.read x in
      let* α2 : u64.t := M.call (u64.t::["wrapping_neg"] α1) in
      let* α3 : i32.t :=
        BinOp.Panic.sub
          ((Integer.of_Z 64) : i32.t)
          ((Integer.of_Z 1) : i32.t) in
      let* α4 : u64.t := BinOp.Panic.shr (BinOp.Pure.bit_or α0 α2) α3 in
      M.alloc α4 in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.Into.into
          (Self := u8.t)
          (T := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α1 : u64.t := M.read y in
    let* α2 : M.Val u64.t := M.alloc ((Integer.of_Z 1) : u64.t) in
    let* α3 : u64.t := M.read (use α2) in
    let* α4 : subtle.Choice.t :=
      M.call (α0 (rust_cast (BinOp.Pure.bit_xor α1 α3))) in
    let* α0 : M.Val subtle.Choice.t := M.alloc α4 in
    M.read α0.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u64_t.
End Impl_subtle_ConstantTimeEq_for_u64_t.

Module  Impl_subtle_ConstantTimeEq_for_i64_t.
Section Impl_subtle_ConstantTimeEq_for_i64_t.
  Definition Self : Set := i64.t.
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (self : ref Self) (other : ref i64.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : (ref u64.t) -> (ref u64.t) -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConstantTimeEq.ct_eq (Self := u64.t) (Trait := ℐ))) in
    let* α1 : ref i64.t := M.read self in
    let* α2 : i64.t := M.read (deref α1) in
    let* α3 : M.Val u64.t := M.alloc (rust_cast α2) in
    let* α4 : ref i64.t := M.read other in
    let* α5 : i64.t := M.read (deref α4) in
    let* α6 : M.Val u64.t := M.alloc (rust_cast α5) in
    M.call (α0 (borrow α3) (borrow α6)).
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i64_t.
End Impl_subtle_ConstantTimeEq_for_i64_t.

Module  Impl_subtle_ConstantTimeEq_for_usize_t.
Section Impl_subtle_ConstantTimeEq_for_usize_t.
  Definition Self : Set := usize.t.
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq
      (self : ref Self)
      (other : ref usize.t)
      : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* x : M.Val usize.t :=
      let* α0 : (ref usize.t) -> (ref usize.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitXor.bitxor
            (Self := ref usize.t)
            (Rhs := ref usize.t)
            (Trait := ℐ))) in
      let* α1 : ref usize.t := M.read self in
      let* α2 : ref usize.t := M.read other in
      let* α3 : usize.t := M.call (α0 α1 α2) in
      M.alloc α3 in
    let* y : M.Val usize.t :=
      let* α0 : usize.t := M.read x in
      let* α1 : usize.t := M.read x in
      let* α2 : usize.t := M.call (usize.t::["wrapping_neg"] α1) in
      let* α3 : usize.t := M.call core.mem.size_of in
      let* α4 : usize.t := BinOp.Panic.mul α3 ((Integer.of_Z 8) : usize.t) in
      let* α5 : usize.t := BinOp.Panic.sub α4 ((Integer.of_Z 1) : usize.t) in
      let* α6 : usize.t := BinOp.Panic.shr (BinOp.Pure.bit_or α0 α2) α5 in
      M.alloc α6 in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.Into.into
          (Self := u8.t)
          (T := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α1 : usize.t := M.read y in
    let* α2 : M.Val usize.t := M.alloc ((Integer.of_Z 1) : usize.t) in
    let* α3 : usize.t := M.read (use α2) in
    let* α4 : subtle.Choice.t :=
      M.call (α0 (rust_cast (BinOp.Pure.bit_xor α1 α3))) in
    let* α0 : M.Val subtle.Choice.t := M.alloc α4 in
    M.read α0.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_usize_t.
End Impl_subtle_ConstantTimeEq_for_usize_t.

Module  Impl_subtle_ConstantTimeEq_for_isize_t.
Section Impl_subtle_ConstantTimeEq_for_isize_t.
  Definition Self : Set := isize.t.
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq
      (self : ref Self)
      (other : ref isize.t)
      : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : (ref usize.t) -> (ref usize.t) -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConstantTimeEq.ct_eq (Self := usize.t) (Trait := ℐ))) in
    let* α1 : ref isize.t := M.read self in
    let* α2 : isize.t := M.read (deref α1) in
    let* α3 : M.Val usize.t := M.alloc (rust_cast α2) in
    let* α4 : ref isize.t := M.read other in
    let* α5 : isize.t := M.read (deref α4) in
    let* α6 : M.Val usize.t := M.alloc (rust_cast α5) in
    M.call (α0 (borrow α3) (borrow α6)).
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_isize_t.
End Impl_subtle_ConstantTimeEq_for_isize_t.

Module  ConditionallySelectable.
Section ConditionallySelectable.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: core.marker.Copy.Trait Self;
    conditional_select : (ref Self) -> (ref Self) -> subtle.Choice.t -> M Self;
  }.
  
End ConditionallySelectable.
End ConditionallySelectable.

Module  Impl_subtle_ConditionallySelectable_for_u8_t.
Section Impl_subtle_ConditionallySelectable_for_u8_t.
  Definition Self : Set := u8.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice.t)
      : M Self :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val u8.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i8.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* α0 : (ref u8.t) -> u8.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref u8.t)
          (Rhs := u8.t)
          (Trait := ℐ))) in
    let* α1 : ref u8.t := M.read a in
    let* α2 : u8.t := M.read mask in
    let* α3 : (ref u8.t) -> (ref u8.t) -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref u8.t)
          (Rhs := ref u8.t)
          (Trait := ℐ))) in
    let* α4 : ref u8.t := M.read a in
    let* α5 : ref u8.t := M.read b in
    let* α6 : u8.t := M.call (α3 α4 α5) in
    let* α7 : u8.t := M.call (α0 α1 (BinOp.Pure.bit_and α2 α6)) in
    let* α0 : M.Val u8.t := M.alloc α7 in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon Self "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* choice := M.alloc choice in
    let* mask : M.Val u8.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i8.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* _ : M.Val unit :=
      let* β : M.Val u8.t :=
        let* α0 : mut_ref u8.t := M.read self in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u8.t := M.read mask in
      let* α2 : mut_ref u8.t := M.read self in
      let* α3 : u8.t := M.read (deref α2) in
      let* α4 : ref u8.t := M.read other in
      let* α5 : u8.t := M.read (deref α4) in
      assign
        β
        (BinOp.Pure.bit_xor
          α0
          (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon Self "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val u8.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i8.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* t : M.Val u8.t :=
      let* α0 : u8.t := M.read mask in
      let* α1 : mut_ref u8.t := M.read a in
      let* α2 : u8.t := M.read (deref α1) in
      let* α3 : mut_ref u8.t := M.read b in
      let* α4 : u8.t := M.read (deref α3) in
      M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
    let* _ : M.Val unit :=
      let* β : M.Val u8.t :=
        let* α0 : mut_ref u8.t := M.read a in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u8.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* _ : M.Val unit :=
      let* β : M.Val u8.t :=
        let* α0 : mut_ref u8.t := M.read b in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u8.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon Self "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u8_t.
End Impl_subtle_ConditionallySelectable_for_u8_t.

Module  Impl_subtle_ConditionallySelectable_for_i8_t.
Section Impl_subtle_ConditionallySelectable_for_i8_t.
  Definition Self : Set := i8.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice.t)
      : M Self :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val i8.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i8.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i8.t := M.alloc α1 in
      M.copy (use α2) in
    let* α0 : (ref i8.t) -> i8.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref i8.t)
          (Rhs := i8.t)
          (Trait := ℐ))) in
    let* α1 : ref i8.t := M.read a in
    let* α2 : i8.t := M.read mask in
    let* α3 : (ref i8.t) -> (ref i8.t) -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref i8.t)
          (Rhs := ref i8.t)
          (Trait := ℐ))) in
    let* α4 : ref i8.t := M.read a in
    let* α5 : ref i8.t := M.read b in
    let* α6 : i8.t := M.call (α3 α4 α5) in
    let* α7 : i8.t := M.call (α0 α1 (BinOp.Pure.bit_and α2 α6)) in
    let* α0 : M.Val i8.t := M.alloc α7 in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon Self "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* choice := M.alloc choice in
    let* mask : M.Val i8.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i8.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i8.t := M.alloc α1 in
      M.copy (use α2) in
    let* _ : M.Val unit :=
      let* β : M.Val i8.t :=
        let* α0 : mut_ref i8.t := M.read self in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i8.t := M.read mask in
      let* α2 : mut_ref i8.t := M.read self in
      let* α3 : i8.t := M.read (deref α2) in
      let* α4 : ref i8.t := M.read other in
      let* α5 : i8.t := M.read (deref α4) in
      assign
        β
        (BinOp.Pure.bit_xor
          α0
          (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon Self "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val i8.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i8.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i8.t := M.alloc α1 in
      M.copy (use α2) in
    let* t : M.Val i8.t :=
      let* α0 : i8.t := M.read mask in
      let* α1 : mut_ref i8.t := M.read a in
      let* α2 : i8.t := M.read (deref α1) in
      let* α3 : mut_ref i8.t := M.read b in
      let* α4 : i8.t := M.read (deref α3) in
      M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
    let* _ : M.Val unit :=
      let* β : M.Val i8.t :=
        let* α0 : mut_ref i8.t := M.read a in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i8.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* _ : M.Val unit :=
      let* β : M.Val i8.t :=
        let* α0 : mut_ref i8.t := M.read b in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i8.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon Self "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i8_t.
End Impl_subtle_ConditionallySelectable_for_i8_t.

Module  Impl_subtle_ConditionallySelectable_for_u16_t.
Section Impl_subtle_ConditionallySelectable_for_u16_t.
  Definition Self : Set := u16.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice.t)
      : M Self :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val u16.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i16.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* α0 : (ref u16.t) -> u16.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref u16.t)
          (Rhs := u16.t)
          (Trait := ℐ))) in
    let* α1 : ref u16.t := M.read a in
    let* α2 : u16.t := M.read mask in
    let* α3 : (ref u16.t) -> (ref u16.t) -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref u16.t)
          (Rhs := ref u16.t)
          (Trait := ℐ))) in
    let* α4 : ref u16.t := M.read a in
    let* α5 : ref u16.t := M.read b in
    let* α6 : u16.t := M.call (α3 α4 α5) in
    let* α7 : u16.t := M.call (α0 α1 (BinOp.Pure.bit_and α2 α6)) in
    let* α0 : M.Val u16.t := M.alloc α7 in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon Self "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* choice := M.alloc choice in
    let* mask : M.Val u16.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i16.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* _ : M.Val unit :=
      let* β : M.Val u16.t :=
        let* α0 : mut_ref u16.t := M.read self in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u16.t := M.read mask in
      let* α2 : mut_ref u16.t := M.read self in
      let* α3 : u16.t := M.read (deref α2) in
      let* α4 : ref u16.t := M.read other in
      let* α5 : u16.t := M.read (deref α4) in
      assign
        β
        (BinOp.Pure.bit_xor
          α0
          (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon Self "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val u16.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i16.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* t : M.Val u16.t :=
      let* α0 : u16.t := M.read mask in
      let* α1 : mut_ref u16.t := M.read a in
      let* α2 : u16.t := M.read (deref α1) in
      let* α3 : mut_ref u16.t := M.read b in
      let* α4 : u16.t := M.read (deref α3) in
      M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
    let* _ : M.Val unit :=
      let* β : M.Val u16.t :=
        let* α0 : mut_ref u16.t := M.read a in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u16.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* _ : M.Val unit :=
      let* β : M.Val u16.t :=
        let* α0 : mut_ref u16.t := M.read b in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u16.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon Self "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u16_t.
End Impl_subtle_ConditionallySelectable_for_u16_t.

Module  Impl_subtle_ConditionallySelectable_for_i16_t.
Section Impl_subtle_ConditionallySelectable_for_i16_t.
  Definition Self : Set := i16.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice.t)
      : M Self :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val i16.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i16.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i16.t := M.alloc α1 in
      M.copy (use α2) in
    let* α0 : (ref i16.t) -> i16.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref i16.t)
          (Rhs := i16.t)
          (Trait := ℐ))) in
    let* α1 : ref i16.t := M.read a in
    let* α2 : i16.t := M.read mask in
    let* α3 : (ref i16.t) -> (ref i16.t) -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref i16.t)
          (Rhs := ref i16.t)
          (Trait := ℐ))) in
    let* α4 : ref i16.t := M.read a in
    let* α5 : ref i16.t := M.read b in
    let* α6 : i16.t := M.call (α3 α4 α5) in
    let* α7 : i16.t := M.call (α0 α1 (BinOp.Pure.bit_and α2 α6)) in
    let* α0 : M.Val i16.t := M.alloc α7 in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon Self "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* choice := M.alloc choice in
    let* mask : M.Val i16.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i16.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i16.t := M.alloc α1 in
      M.copy (use α2) in
    let* _ : M.Val unit :=
      let* β : M.Val i16.t :=
        let* α0 : mut_ref i16.t := M.read self in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i16.t := M.read mask in
      let* α2 : mut_ref i16.t := M.read self in
      let* α3 : i16.t := M.read (deref α2) in
      let* α4 : ref i16.t := M.read other in
      let* α5 : i16.t := M.read (deref α4) in
      assign
        β
        (BinOp.Pure.bit_xor
          α0
          (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon Self "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val i16.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i16.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i16.t := M.alloc α1 in
      M.copy (use α2) in
    let* t : M.Val i16.t :=
      let* α0 : i16.t := M.read mask in
      let* α1 : mut_ref i16.t := M.read a in
      let* α2 : i16.t := M.read (deref α1) in
      let* α3 : mut_ref i16.t := M.read b in
      let* α4 : i16.t := M.read (deref α3) in
      M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
    let* _ : M.Val unit :=
      let* β : M.Val i16.t :=
        let* α0 : mut_ref i16.t := M.read a in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i16.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* _ : M.Val unit :=
      let* β : M.Val i16.t :=
        let* α0 : mut_ref i16.t := M.read b in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i16.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon Self "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i16_t.
End Impl_subtle_ConditionallySelectable_for_i16_t.

Module  Impl_subtle_ConditionallySelectable_for_u32_t.
Section Impl_subtle_ConditionallySelectable_for_u32_t.
  Definition Self : Set := u32.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice.t)
      : M Self :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val u32.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i32.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* α0 : (ref u32.t) -> u32.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref u32.t)
          (Rhs := u32.t)
          (Trait := ℐ))) in
    let* α1 : ref u32.t := M.read a in
    let* α2 : u32.t := M.read mask in
    let* α3 : (ref u32.t) -> (ref u32.t) -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref u32.t)
          (Rhs := ref u32.t)
          (Trait := ℐ))) in
    let* α4 : ref u32.t := M.read a in
    let* α5 : ref u32.t := M.read b in
    let* α6 : u32.t := M.call (α3 α4 α5) in
    let* α7 : u32.t := M.call (α0 α1 (BinOp.Pure.bit_and α2 α6)) in
    let* α0 : M.Val u32.t := M.alloc α7 in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon Self "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* choice := M.alloc choice in
    let* mask : M.Val u32.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i32.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* _ : M.Val unit :=
      let* β : M.Val u32.t :=
        let* α0 : mut_ref u32.t := M.read self in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u32.t := M.read mask in
      let* α2 : mut_ref u32.t := M.read self in
      let* α3 : u32.t := M.read (deref α2) in
      let* α4 : ref u32.t := M.read other in
      let* α5 : u32.t := M.read (deref α4) in
      assign
        β
        (BinOp.Pure.bit_xor
          α0
          (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon Self "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val u32.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i32.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* t : M.Val u32.t :=
      let* α0 : u32.t := M.read mask in
      let* α1 : mut_ref u32.t := M.read a in
      let* α2 : u32.t := M.read (deref α1) in
      let* α3 : mut_ref u32.t := M.read b in
      let* α4 : u32.t := M.read (deref α3) in
      M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
    let* _ : M.Val unit :=
      let* β : M.Val u32.t :=
        let* α0 : mut_ref u32.t := M.read a in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u32.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* _ : M.Val unit :=
      let* β : M.Val u32.t :=
        let* α0 : mut_ref u32.t := M.read b in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u32.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon Self "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u32_t.
End Impl_subtle_ConditionallySelectable_for_u32_t.

Module  Impl_subtle_ConditionallySelectable_for_i32_t.
Section Impl_subtle_ConditionallySelectable_for_i32_t.
  Definition Self : Set := i32.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice.t)
      : M Self :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val i32.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i32.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i32.t := M.alloc α1 in
      M.copy (use α2) in
    let* α0 : (ref i32.t) -> i32.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref i32.t)
          (Rhs := i32.t)
          (Trait := ℐ))) in
    let* α1 : ref i32.t := M.read a in
    let* α2 : i32.t := M.read mask in
    let* α3 : (ref i32.t) -> (ref i32.t) -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref i32.t)
          (Rhs := ref i32.t)
          (Trait := ℐ))) in
    let* α4 : ref i32.t := M.read a in
    let* α5 : ref i32.t := M.read b in
    let* α6 : i32.t := M.call (α3 α4 α5) in
    let* α7 : i32.t := M.call (α0 α1 (BinOp.Pure.bit_and α2 α6)) in
    let* α0 : M.Val i32.t := M.alloc α7 in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon Self "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* choice := M.alloc choice in
    let* mask : M.Val i32.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i32.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i32.t := M.alloc α1 in
      M.copy (use α2) in
    let* _ : M.Val unit :=
      let* β : M.Val i32.t :=
        let* α0 : mut_ref i32.t := M.read self in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i32.t := M.read mask in
      let* α2 : mut_ref i32.t := M.read self in
      let* α3 : i32.t := M.read (deref α2) in
      let* α4 : ref i32.t := M.read other in
      let* α5 : i32.t := M.read (deref α4) in
      assign
        β
        (BinOp.Pure.bit_xor
          α0
          (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon Self "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val i32.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i32.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i32.t := M.alloc α1 in
      M.copy (use α2) in
    let* t : M.Val i32.t :=
      let* α0 : i32.t := M.read mask in
      let* α1 : mut_ref i32.t := M.read a in
      let* α2 : i32.t := M.read (deref α1) in
      let* α3 : mut_ref i32.t := M.read b in
      let* α4 : i32.t := M.read (deref α3) in
      M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
    let* _ : M.Val unit :=
      let* β : M.Val i32.t :=
        let* α0 : mut_ref i32.t := M.read a in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i32.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* _ : M.Val unit :=
      let* β : M.Val i32.t :=
        let* α0 : mut_ref i32.t := M.read b in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i32.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon Self "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i32_t.
End Impl_subtle_ConditionallySelectable_for_i32_t.

Module  Impl_subtle_ConditionallySelectable_for_u64_t.
Section Impl_subtle_ConditionallySelectable_for_u64_t.
  Definition Self : Set := u64.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice.t)
      : M Self :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val u64.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i64.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* α0 : (ref u64.t) -> u64.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref u64.t)
          (Rhs := u64.t)
          (Trait := ℐ))) in
    let* α1 : ref u64.t := M.read a in
    let* α2 : u64.t := M.read mask in
    let* α3 : (ref u64.t) -> (ref u64.t) -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref u64.t)
          (Rhs := ref u64.t)
          (Trait := ℐ))) in
    let* α4 : ref u64.t := M.read a in
    let* α5 : ref u64.t := M.read b in
    let* α6 : u64.t := M.call (α3 α4 α5) in
    let* α7 : u64.t := M.call (α0 α1 (BinOp.Pure.bit_and α2 α6)) in
    let* α0 : M.Val u64.t := M.alloc α7 in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon Self "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* choice := M.alloc choice in
    let* mask : M.Val u64.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i64.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* _ : M.Val unit :=
      let* β : M.Val u64.t :=
        let* α0 : mut_ref u64.t := M.read self in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u64.t := M.read mask in
      let* α2 : mut_ref u64.t := M.read self in
      let* α3 : u64.t := M.read (deref α2) in
      let* α4 : ref u64.t := M.read other in
      let* α5 : u64.t := M.read (deref α4) in
      assign
        β
        (BinOp.Pure.bit_xor
          α0
          (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon Self "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val u64.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i64.t := UnOp.neg (rust_cast α0) in
      M.alloc (rust_cast α1) in
    let* t : M.Val u64.t :=
      let* α0 : u64.t := M.read mask in
      let* α1 : mut_ref u64.t := M.read a in
      let* α2 : u64.t := M.read (deref α1) in
      let* α3 : mut_ref u64.t := M.read b in
      let* α4 : u64.t := M.read (deref α3) in
      M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
    let* _ : M.Val unit :=
      let* β : M.Val u64.t :=
        let* α0 : mut_ref u64.t := M.read a in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u64.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* _ : M.Val unit :=
      let* β : M.Val u64.t :=
        let* α0 : mut_ref u64.t := M.read b in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : u64.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon Self "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u64_t.
End Impl_subtle_ConditionallySelectable_for_u64_t.

Module  Impl_subtle_ConditionallySelectable_for_i64_t.
Section Impl_subtle_ConditionallySelectable_for_i64_t.
  Definition Self : Set := i64.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice.t)
      : M Self :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val i64.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i64.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i64.t := M.alloc α1 in
      M.copy (use α2) in
    let* α0 : (ref i64.t) -> i64.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref i64.t)
          (Rhs := i64.t)
          (Trait := ℐ))) in
    let* α1 : ref i64.t := M.read a in
    let* α2 : i64.t := M.read mask in
    let* α3 : (ref i64.t) -> (ref i64.t) -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitXor.bitxor
          (Self := ref i64.t)
          (Rhs := ref i64.t)
          (Trait := ℐ))) in
    let* α4 : ref i64.t := M.read a in
    let* α5 : ref i64.t := M.read b in
    let* α6 : i64.t := M.call (α3 α4 α5) in
    let* α7 : i64.t := M.call (α0 α1 (BinOp.Pure.bit_and α2 α6)) in
    let* α0 : M.Val i64.t := M.alloc α7 in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon Self "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* choice := M.alloc choice in
    let* mask : M.Val i64.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i64.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i64.t := M.alloc α1 in
      M.copy (use α2) in
    let* _ : M.Val unit :=
      let* β : M.Val i64.t :=
        let* α0 : mut_ref i64.t := M.read self in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i64.t := M.read mask in
      let* α2 : mut_ref i64.t := M.read self in
      let* α3 : i64.t := M.read (deref α2) in
      let* α4 : ref i64.t := M.read other in
      let* α5 : i64.t := M.read (deref α4) in
      assign
        β
        (BinOp.Pure.bit_xor
          α0
          (BinOp.Pure.bit_and α1 (BinOp.Pure.bit_xor α3 α5))) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon Self "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* mask : M.Val i64.t :=
      let* α0 : u8.t :=
        M.call (subtle.Choice.t::["unwrap_u8"] (borrow choice)) in
      let* α1 : i64.t := UnOp.neg (rust_cast α0) in
      let* α2 : M.Val i64.t := M.alloc α1 in
      M.copy (use α2) in
    let* t : M.Val i64.t :=
      let* α0 : i64.t := M.read mask in
      let* α1 : mut_ref i64.t := M.read a in
      let* α2 : i64.t := M.read (deref α1) in
      let* α3 : mut_ref i64.t := M.read b in
      let* α4 : i64.t := M.read (deref α3) in
      M.alloc (BinOp.Pure.bit_and α0 (BinOp.Pure.bit_xor α2 α4)) in
    let* _ : M.Val unit :=
      let* β : M.Val i64.t :=
        let* α0 : mut_ref i64.t := M.read a in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i64.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* _ : M.Val unit :=
      let* β : M.Val i64.t :=
        let* α0 : mut_ref i64.t := M.read b in
        M.pure (deref α0) in
      let* α0 := M.read β in
      let* α1 : i64.t := M.read t in
      assign β (BinOp.Pure.bit_xor α0 α1) in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon Self "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i64_t.
End Impl_subtle_ConditionallySelectable_for_i64_t.

Module  Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.
Section Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.
  Definition Self : Set := subtle.Choice.t.
  
  (*
      fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
          Choice(u8::conditional_select(&a.0, &b.0, choice))
      }
  *)
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice.t)
      : M Self :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* α0 : (ref u8.t) -> (ref u8.t) -> subtle.Choice.t -> M u8.t :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConditionallySelectable.conditional_select
          (Self := u8.t)
          (Trait := ℐ))) in
    let* α1 : ref subtle.Choice.t := M.read a in
    let* α2 : ref subtle.Choice.t := M.read b in
    let* α3 : subtle.Choice.t := M.read choice in
    let* α4 : u8.t :=
      M.call
        (α0
          (borrow (subtle.Choice.Get_0 (deref α1)))
          (borrow (subtle.Choice.Get_0 (deref α2)))
          α3) in
    M.pure (subtle.Choice.Build_t α4).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon Self "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign := Datatypes.None;
    subtle.ConditionallySelectable.conditional_swap := Datatypes.None;
  }.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.

Module  ConditionallyNegatable.
Section ConditionallyNegatable.
  Class Trait (Self : Set) : Type := {
    conditional_negate : (mut_ref Self) -> subtle.Choice.t -> M unit;
  }.
  
End ConditionallyNegatable.
End ConditionallyNegatable.

Module  Impl_subtle_ConditionallyNegatable_for_T.
Section Impl_subtle_ConditionallyNegatable_for_T.
  Context {T : Set}.
  
  Context
    {ℋ_0 : subtle.ConditionallySelectable.Trait T}
    {ℋ_1 : core.ops.arith.Neg.Trait (ref T)}.
  
  Definition Self : Set := T.
  
  (*
      fn conditional_negate(&mut self, choice: Choice) {
          // Need to cast to eliminate mutability
          let self_neg: T = -(self as &T);
          self.conditional_assign(&self_neg, choice);
      }
  *)
  Definition conditional_negate
      (self : mut_ref Self)
      (choice : subtle.Choice.t)
      : M unit :=
    let* self := M.alloc self in
    let* choice := M.alloc choice in
    let* self_neg : M.Val T :=
      let* α0 : (ref T) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.arith.Neg.neg (Self := ref T) (Trait := ℐ))) in
      let* α1 : mut_ref T := M.read self in
      let* α2 : M.Val (ref T) := M.alloc (borrow (deref α1)) in
      let* α3 : ref T := M.read (use α2) in
      let* α4 : T := M.call (α0 α3) in
      M.alloc α4 in
    let* _ : M.Val unit :=
      let* α0 : (mut_ref T) -> (ref T) -> subtle.Choice.t -> M unit :=
        ltac:(M.get_method (fun ℐ =>
          subtle.ConditionallySelectable.conditional_assign
            (Self := T)
            (Trait := ℐ))) in
      let* α1 : mut_ref T := M.read self in
      let* α2 : subtle.Choice.t := M.read choice in
      let* α3 : unit := M.call (α0 α1 (borrow self_neg) α2) in
      M.alloc α3 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_conditional_negate :
    Notations.DoubleColon Self "conditional_negate" := {
    Notations.double_colon := conditional_negate;
  }.
  
  Global Instance ℐ : subtle.ConditionallyNegatable.Trait Self := {
    subtle.ConditionallyNegatable.conditional_negate := conditional_negate;
  }.
End Impl_subtle_ConditionallyNegatable_for_T.
End Impl_subtle_ConditionallyNegatable_for_T.

Module  CtOption.
Section CtOption.
  Context (T : Set).
  
  Record t : Set := {
    value : T;
    is_some : subtle.Choice.t;
  }.
  
  Definition Get_value :=
    Ref.map (fun α => Some α.(value)) (fun β α => Some (α <| value := β |>)).
  Definition Get_is_some :=
    Ref.map
      (fun α => Some α.(is_some))
      (fun β α => Some (α <| is_some := β |>)).
End CtOption.
End CtOption.

Module  Impl_core_clone_Clone_for_subtle_CtOption_t_T.
Section Impl_core_clone_Clone_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Definition Self : Set := subtle.CtOption.t T.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M (subtle.CtOption.t T) :=
    let* self := M.alloc self in
    let* α0 : (ref T) -> M T :=
      ltac:(M.get_method (fun ℐ =>
        core.clone.Clone.clone (Self := T) (Trait := ℐ))) in
    let* α1 : ref (subtle.CtOption.t T) := M.read self in
    let* α2 : T :=
      M.call (α0 (borrow (subtle.CtOption.Get_value (deref α1)))) in
    let* α3 : (ref subtle.Choice.t) -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.clone.Clone.clone (Self := subtle.Choice.t) (Trait := ℐ))) in
    let* α4 : ref (subtle.CtOption.t T) := M.read self in
    let* α5 : subtle.Choice.t :=
      M.call (α3 (borrow (subtle.CtOption.Get_is_some (deref α4)))) in
    M.pure {| subtle.CtOption.value := α2; subtle.CtOption.is_some := α5; |}.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_subtle_CtOption_t_T.
End Impl_core_clone_Clone_for_subtle_CtOption_t_T.

Module  Impl_core_marker_Copy_for_subtle_CtOption_t_T.
Section Impl_core_marker_Copy_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Definition Self : Set := subtle.CtOption.t T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_subtle_CtOption_t_T.
End Impl_core_marker_Copy_for_subtle_CtOption_t_T.

Module  Impl_core_fmt_Debug_for_subtle_CtOption_t_T.
Section Impl_core_fmt_Debug_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Definition Self : Set := subtle.CtOption.t T.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
    let* α1 : ref str.t := M.read (mk_str "CtOption") in
    let* α2 : ref str.t := M.read (mk_str "value") in
    let* α3 : ref (subtle.CtOption.t T) := M.read self in
    let* α4 : ref str.t := M.read (mk_str "is_some") in
    let* α5 : ref (subtle.CtOption.t T) := M.read self in
    let* α6 : M.Val (ref subtle.Choice.t) :=
      M.alloc (borrow (subtle.CtOption.Get_is_some (deref α5))) in
    M.call
      (core.fmt.Formatter.t::["debug_struct_field2_finish"]
        α0
        α1
        α2
        (pointer_coercion
          "Unsize"
          (borrow (subtle.CtOption.Get_value (deref α3))))
        α4
        (pointer_coercion "Unsize" (borrow α6))).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_subtle_CtOption_t_T.
End Impl_core_fmt_Debug_for_subtle_CtOption_t_T.

Module  Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.
Section Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.
  Context {T : Set}.
  
  Definition Self : Set := core.option.Option.t T.
  
  (*
      fn from(source: CtOption<T>) -> Option<T> {
          if source.is_some().unwrap_u8() == 1u8 {
              Option::Some(source.value)
          } else {
              None
          }
      }
  *)
  Definition from (source : subtle.CtOption.t T) : M (core.option.Option.t T) :=
    let* source := M.alloc source in
    let* α0 : subtle.Choice.t :=
      M.call ((subtle.CtOption.t T)::["is_some"] (borrow source)) in
    let* α1 : M.Val subtle.Choice.t := M.alloc α0 in
    let* α2 : u8.t := M.call (subtle.Choice.t::["unwrap_u8"] (borrow α1)) in
    let* α3 : M.Val bool.t :=
      M.alloc (BinOp.Pure.eq α2 ((Integer.of_Z 1) : u8.t)) in
    let* α4 : bool.t := M.read (use α3) in
    let* α5 : M.Val (core.option.Option.t T) :=
      if α4 then
        let* α0 : T := M.read (subtle.CtOption.Get_value source) in
        M.alloc (core.option.Option.Some α0)
      else
        M.alloc core.option.Option.None in
    M.read α5.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait Self (T := subtle.CtOption.t T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.
End Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.

Module  Impl_subtle_CtOption_t_T.
Section Impl_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Definition Self : Set := subtle.CtOption.t T.
  
  (*
      pub fn new(value: T, is_some: Choice) -> CtOption<T> {
          CtOption {
              value: value,
              is_some: is_some,
          }
      }
  *)
  Definition new
      (value : T)
      (is_some : subtle.Choice.t)
      : M (subtle.CtOption.t T) :=
    let* value := M.alloc value in
    let* is_some := M.alloc is_some in
    let* α0 : T := M.read value in
    let* α1 : subtle.Choice.t := M.read is_some in
    M.pure {| subtle.CtOption.value := α0; subtle.CtOption.is_some := α1; |}.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn expect(self, msg: &str) -> T {
          assert_eq!(self.is_some.unwrap_u8(), 1, "{}", msg);
  
          self.value
      }
  *)
  Definition expect (self : Self) (msg : ref str.t) : M T :=
    let* self := M.alloc self in
    let* msg := M.alloc msg in
    let* _ : M.Val unit :=
      let* α0 : u8.t :=
        M.call
          (subtle.Choice.t::["unwrap_u8"]
            (borrow (subtle.CtOption.Get_is_some self))) in
      let* α1 : M.Val u8.t := M.alloc α0 in
      let* α2 : M.Val u8.t := M.alloc ((Integer.of_Z 1) : u8.t) in
      let* α3 : M.Val ((ref u8.t) * (ref u8.t)) :=
        M.alloc (borrow α1, borrow α2) in
      match_operator
        α3
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | (_, _) =>
              let γ0_0 := Tuple.Access.left γ in
              let γ0_1 := Tuple.Access.right γ in
              let* left_val := M.copy γ0_0 in
              let* right_val := M.copy γ0_1 in
              let* α0 : ref u8.t := M.read left_val in
              let* α1 : u8.t := M.read (deref α0) in
              let* α2 : ref u8.t := M.read right_val in
              let* α3 : u8.t := M.read (deref α2) in
              let* α4 : M.Val bool.t :=
                M.alloc (UnOp.not (BinOp.Pure.eq α1 α3)) in
              let* α5 : bool.t := M.read (use α4) in
              if α5 then
                let* kind : M.Val core.panicking.AssertKind.t :=
                  M.alloc core.panicking.AssertKind.Eq in
                let* α0 : core.panicking.AssertKind.t := M.read kind in
                let* α1 : ref u8.t := M.read left_val in
                let* α2 : ref u8.t := M.read right_val in
                let* α3 : ref str.t := M.read (mk_str "") in
                let* α4 : M.Val (array (ref str.t)) := M.alloc [ α3 ] in
                let* α5 : core.fmt.rt.Argument.t :=
                  M.call
                    (core.fmt.rt.Argument.t::["new_display"] (borrow msg)) in
                let* α6 : M.Val (array core.fmt.rt.Argument.t) :=
                  M.alloc [ α5 ] in
                let* α7 : core.fmt.Arguments.t :=
                  M.call
                    (core.fmt.Arguments.t::["new_v1"]
                      (pointer_coercion "Unsize" (borrow α4))
                      (pointer_coercion "Unsize" (borrow α6))) in
                let* α8 : never.t :=
                  M.call
                    (core.panicking.assert_failed
                      α0
                      α1
                      α2
                      (core.option.Option.Some α7)) in
                let* α0 : M.Val never.t := M.alloc α8 in
                let* α1 := M.read α0 in
                let* α2 : unit := never_to_any α1 in
                M.alloc α2
              else
                M.alloc tt
            end) :
            M (M.Val unit)
        ] in
    M.read (subtle.CtOption.Get_value self).
  
  Global Instance AssociatedFunction_expect :
    Notations.DoubleColon Self "expect" := {
    Notations.double_colon := expect;
  }.
  
  (*
      pub fn unwrap(self) -> T {
          assert_eq!(self.is_some.unwrap_u8(), 1);
  
          self.value
      }
  *)
  Definition unwrap (self : Self) : M T :=
    let* self := M.alloc self in
    let* _ : M.Val unit :=
      let* α0 : u8.t :=
        M.call
          (subtle.Choice.t::["unwrap_u8"]
            (borrow (subtle.CtOption.Get_is_some self))) in
      let* α1 : M.Val u8.t := M.alloc α0 in
      let* α2 : M.Val u8.t := M.alloc ((Integer.of_Z 1) : u8.t) in
      let* α3 : M.Val ((ref u8.t) * (ref u8.t)) :=
        M.alloc (borrow α1, borrow α2) in
      match_operator
        α3
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | (_, _) =>
              let γ0_0 := Tuple.Access.left γ in
              let γ0_1 := Tuple.Access.right γ in
              let* left_val := M.copy γ0_0 in
              let* right_val := M.copy γ0_1 in
              let* α0 : ref u8.t := M.read left_val in
              let* α1 : u8.t := M.read (deref α0) in
              let* α2 : ref u8.t := M.read right_val in
              let* α3 : u8.t := M.read (deref α2) in
              let* α4 : M.Val bool.t :=
                M.alloc (UnOp.not (BinOp.Pure.eq α1 α3)) in
              let* α5 : bool.t := M.read (use α4) in
              if α5 then
                let* kind : M.Val core.panicking.AssertKind.t :=
                  M.alloc core.panicking.AssertKind.Eq in
                let* α0 : core.panicking.AssertKind.t := M.read kind in
                let* α1 : ref u8.t := M.read left_val in
                let* α2 : ref u8.t := M.read right_val in
                let* α3 : never.t :=
                  M.call
                    (core.panicking.assert_failed
                      α0
                      α1
                      α2
                      core.option.Option.None) in
                let* α0 : M.Val never.t := M.alloc α3 in
                let* α1 := M.read α0 in
                let* α2 : unit := never_to_any α1 in
                M.alloc α2
              else
                M.alloc tt
            end) :
            M (M.Val unit)
        ] in
    M.read (subtle.CtOption.Get_value self).
  
  Global Instance AssociatedFunction_unwrap :
    Notations.DoubleColon Self "unwrap" := {
    Notations.double_colon := unwrap;
  }.
  
  (*
      pub fn unwrap_or(self, def: T) -> T
      where
          T: ConditionallySelectable,
      {
          T::conditional_select(&def, &self.value, self.is_some)
      }
  *)
  Definition unwrap_or (self : Self) (def : T) : M T :=
    let* self := M.alloc self in
    let* def := M.alloc def in
    let* α0 : (ref T) -> (ref T) -> subtle.Choice.t -> M T :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConditionallySelectable.conditional_select
          (Self := T)
          (Trait := ℐ))) in
    let* α1 : subtle.Choice.t := M.read (subtle.CtOption.Get_is_some self) in
    M.call (α0 (borrow def) (borrow (subtle.CtOption.Get_value self)) α1).
  
  Global Instance AssociatedFunction_unwrap_or :
    Notations.DoubleColon Self "unwrap_or" := {
    Notations.double_colon := unwrap_or;
  }.
  
  (*
      pub fn unwrap_or_else<F>(self, f: F) -> T
      where
          T: ConditionallySelectable,
          F: FnOnce() -> T,
      {
          T::conditional_select(&f(), &self.value, self.is_some)
      }
  *)
  Definition unwrap_or_else {F : Set} (self : Self) (f : F) : M T :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : (ref T) -> (ref T) -> subtle.Choice.t -> M T :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConditionallySelectable.conditional_select
          (Self := T)
          (Trait := ℐ))) in
    let* α1 : F -> unit -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.function.FnOnce.call_once
          (Self := F)
          (Args := unit)
          (Trait := ℐ))) in
    let* α2 : F := M.read f in
    let* α3 : T := M.call (α1 α2 tt) in
    let* α4 : M.Val T := M.alloc α3 in
    let* α5 : subtle.Choice.t := M.read (subtle.CtOption.Get_is_some self) in
    M.call (α0 (borrow α4) (borrow (subtle.CtOption.Get_value self)) α5).
  
  Global Instance AssociatedFunction_unwrap_or_else {F : Set} :
    Notations.DoubleColon Self "unwrap_or_else" := {
    Notations.double_colon := unwrap_or_else (F := F);
  }.
  
  (*
      pub fn is_some(&self) -> Choice {
          self.is_some
      }
  *)
  Definition is_some (self : ref Self) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* α0 : ref (subtle.CtOption.t T) := M.read self in
    M.read (subtle.CtOption.Get_is_some (deref α0)).
  
  Global Instance AssociatedFunction_is_some :
    Notations.DoubleColon Self "is_some" := {
    Notations.double_colon := is_some;
  }.
  
  (*
      pub fn is_none(&self) -> Choice {
          !self.is_some
      }
  *)
  Definition is_none (self : ref Self) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* α0 : subtle.Choice.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.Not.not (Self := subtle.Choice.t) (Trait := ℐ))) in
    let* α1 : ref (subtle.CtOption.t T) := M.read self in
    let* α2 : subtle.Choice.t :=
      M.read (subtle.CtOption.Get_is_some (deref α1)) in
    M.call (α0 α2).
  
  Global Instance AssociatedFunction_is_none :
    Notations.DoubleColon Self "is_none" := {
    Notations.double_colon := is_none;
  }.
  
  (*
      pub fn map<U, F>(self, f: F) -> CtOption<U>
      where
          T: Default + ConditionallySelectable,
          F: FnOnce(T) -> U,
      {
          CtOption::new(
              f(T::conditional_select(
                  &T::default(),
                  &self.value,
                  self.is_some,
              )),
              self.is_some,
          )
      }
  *)
  Definition map {U F : Set} (self : Self) (f : F) : M (subtle.CtOption.t U) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : F -> T -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.function.FnOnce.call_once
          (Self := F)
          (Args := T)
          (Trait := ℐ))) in
    let* α1 : F := M.read f in
    let* α2 : (ref T) -> (ref T) -> subtle.Choice.t -> M T :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConditionallySelectable.conditional_select
          (Self := T)
          (Trait := ℐ))) in
    let* α3 : M T :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default (Self := T) (Trait := ℐ))) in
    let* α4 : T := M.call α3 in
    let* α5 : M.Val T := M.alloc α4 in
    let* α6 : subtle.Choice.t := M.read (subtle.CtOption.Get_is_some self) in
    let* α7 : T :=
      M.call (α2 (borrow α5) (borrow (subtle.CtOption.Get_value self)) α6) in
    let* α8 : U := M.call (α0 α1 (α7)) in
    let* α9 : subtle.Choice.t := M.read (subtle.CtOption.Get_is_some self) in
    M.call ((subtle.CtOption.t U)::["new"] α8 α9).
  
  Global Instance AssociatedFunction_map {U F : Set} :
    Notations.DoubleColon Self "map" := {
    Notations.double_colon := map (U := U) (F := F);
  }.
  
  (*
      pub fn and_then<U, F>(self, f: F) -> CtOption<U>
      where
          T: Default + ConditionallySelectable,
          F: FnOnce(T) -> CtOption<U>,
      {
          let mut tmp = f(T::conditional_select(
              &T::default(),
              &self.value,
              self.is_some,
          ));
          tmp.is_some &= self.is_some;
  
          tmp
      }
  *)
  Definition and_then
      {U F : Set}
      (self : Self)
      (f : F)
      : M (subtle.CtOption.t U) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* tmp : M.Val (subtle.CtOption.t U) :=
      let* α0 : F -> T -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.function.FnOnce.call_once
            (Self := F)
            (Args := T)
            (Trait := ℐ))) in
      let* α1 : F := M.read f in
      let* α2 : (ref T) -> (ref T) -> subtle.Choice.t -> M T :=
        ltac:(M.get_method (fun ℐ =>
          subtle.ConditionallySelectable.conditional_select
            (Self := T)
            (Trait := ℐ))) in
      let* α3 : M T :=
        ltac:(M.get_method (fun ℐ =>
          core.default.Default.default (Self := T) (Trait := ℐ))) in
      let* α4 : T := M.call α3 in
      let* α5 : M.Val T := M.alloc α4 in
      let* α6 : subtle.Choice.t := M.read (subtle.CtOption.Get_is_some self) in
      let* α7 : T :=
        M.call (α2 (borrow α5) (borrow (subtle.CtOption.Get_value self)) α6) in
      let* α8 : subtle.CtOption.t U := M.call (α0 α1 (α7)) in
      M.alloc α8 in
    let* _ : M.Val unit :=
      let* α0 : (mut_ref subtle.Choice.t) -> subtle.Choice.t -> M unit :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitAndAssign.bitand_assign
            (Self := subtle.Choice.t)
            (Rhs := subtle.Choice.t)
            (Trait := ℐ))) in
      let* α1 : subtle.Choice.t := M.read (subtle.CtOption.Get_is_some self) in
      let* α2 : unit :=
        M.call (α0 (borrow_mut (subtle.CtOption.Get_is_some tmp)) α1) in
      M.alloc α2 in
    M.read tmp.
  
  Global Instance AssociatedFunction_and_then {U F : Set} :
    Notations.DoubleColon Self "and_then" := {
    Notations.double_colon := and_then (U := U) (F := F);
  }.
  
  (*
      pub fn or_else<F>(self, f: F) -> CtOption<T>
      where
          T: ConditionallySelectable,
          F: FnOnce() -> CtOption<T>,
      {
          let is_none = self.is_none();
          let f = f();
  
          Self::conditional_select(&self, &f, is_none)
      }
  *)
  Definition or_else
      {F : Set}
      (self : Self)
      (f : F)
      : M (subtle.CtOption.t T) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* is_none : M.Val subtle.Choice.t :=
      let* α0 : subtle.Choice.t :=
        M.call ((subtle.CtOption.t T)::["is_none"] (borrow self)) in
      M.alloc α0 in
    let* f : M.Val (subtle.CtOption.t T) :=
      let* α0 : F -> unit -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.function.FnOnce.call_once
            (Self := F)
            (Args := unit)
            (Trait := ℐ))) in
      let* α1 : F := M.read f in
      let* α2 : subtle.CtOption.t T := M.call (α0 α1 tt) in
      M.alloc α2 in
    let* α0 :
        (ref (subtle.CtOption.t T)) ->
          (ref (subtle.CtOption.t T)) ->
          subtle.Choice.t ->
          M (subtle.CtOption.t T) :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConditionallySelectable.conditional_select
          (Self := subtle.CtOption.t T)
          (Trait := ℐ))) in
    let* α1 : subtle.Choice.t := M.read is_none in
    let* α2 : subtle.CtOption.t T := M.call (α0 (borrow self) (borrow f) α1) in
    let* α0 : M.Val (subtle.CtOption.t T) := M.alloc α2 in
    M.read α0.
  
  Global Instance AssociatedFunction_or_else {F : Set} :
    Notations.DoubleColon Self "or_else" := {
    Notations.double_colon := or_else (F := F);
  }.
End Impl_subtle_CtOption_t_T.
End Impl_subtle_CtOption_t_T.

Module  Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.
Section Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConditionallySelectable.Trait T}.
  
  Definition Self : Set := subtle.CtOption.t T.
  
  (*
      fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
          CtOption::new(
              T::conditional_select(&a.value, &b.value, choice),
              Choice::conditional_select(&a.is_some, &b.is_some, choice),
          )
      }
  *)
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice.t)
      : M Self :=
    let* a := M.alloc a in
    let* b := M.alloc b in
    let* choice := M.alloc choice in
    let* α0 : (ref T) -> (ref T) -> subtle.Choice.t -> M T :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConditionallySelectable.conditional_select
          (Self := T)
          (Trait := ℐ))) in
    let* α1 : ref (subtle.CtOption.t T) := M.read a in
    let* α2 : ref (subtle.CtOption.t T) := M.read b in
    let* α3 : subtle.Choice.t := M.read choice in
    let* α4 : T :=
      M.call
        (α0
          (borrow (subtle.CtOption.Get_value (deref α1)))
          (borrow (subtle.CtOption.Get_value (deref α2)))
          α3) in
    let* α5 :
        (ref subtle.Choice.t) ->
          (ref subtle.Choice.t) ->
          subtle.Choice.t ->
          M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConditionallySelectable.conditional_select
          (Self := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α6 : ref (subtle.CtOption.t T) := M.read a in
    let* α7 : ref (subtle.CtOption.t T) := M.read b in
    let* α8 : subtle.Choice.t := M.read choice in
    let* α9 : subtle.Choice.t :=
      M.call
        (α5
          (borrow (subtle.CtOption.Get_is_some (deref α6)))
          (borrow (subtle.CtOption.Get_is_some (deref α7)))
          α8) in
    M.call ((subtle.CtOption.t T)::["new"] α4 α9).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon Self "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign := Datatypes.None;
    subtle.ConditionallySelectable.conditional_swap := Datatypes.None;
  }.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.

Module  Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.
Section Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConstantTimeEq.Trait T}.
  
  Definition Self : Set := subtle.CtOption.t T.
  
  (*
      fn ct_eq(&self, rhs: &CtOption<T>) -> Choice {
          let a = self.is_some();
          let b = rhs.is_some();
  
          (a & b & self.value.ct_eq(&rhs.value)) | (!a & !b)
      }
  *)
  Definition ct_eq
      (self : ref Self)
      (rhs : ref (subtle.CtOption.t T))
      : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* rhs := M.alloc rhs in
    let* a : M.Val subtle.Choice.t :=
      let* α0 : ref (subtle.CtOption.t T) := M.read self in
      let* α1 : subtle.Choice.t :=
        M.call ((subtle.CtOption.t T)::["is_some"] α0) in
      M.alloc α1 in
    let* b : M.Val subtle.Choice.t :=
      let* α0 : ref (subtle.CtOption.t T) := M.read rhs in
      let* α1 : subtle.Choice.t :=
        M.call ((subtle.CtOption.t T)::["is_some"] α0) in
      M.alloc α1 in
    let* α0 : subtle.Choice.t -> subtle.Choice.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitOr.bitor
          (Self := subtle.Choice.t)
          (Rhs := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α1 : subtle.Choice.t -> subtle.Choice.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitAnd.bitand
          (Self := subtle.Choice.t)
          (Rhs := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α2 : subtle.Choice.t -> subtle.Choice.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitAnd.bitand
          (Self := subtle.Choice.t)
          (Rhs := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α3 : subtle.Choice.t := M.read a in
    let* α4 : subtle.Choice.t := M.read b in
    let* α5 : subtle.Choice.t := M.call (α2 α3 α4) in
    let* α6 : (ref T) -> (ref T) -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        subtle.ConstantTimeEq.ct_eq (Self := T) (Trait := ℐ))) in
    let* α7 : ref (subtle.CtOption.t T) := M.read self in
    let* α8 : ref (subtle.CtOption.t T) := M.read rhs in
    let* α9 : subtle.Choice.t :=
      M.call
        (α6
          (borrow (subtle.CtOption.Get_value (deref α7)))
          (borrow (subtle.CtOption.Get_value (deref α8)))) in
    let* α10 : subtle.Choice.t := M.call (α1 α5 α9) in
    let* α11 : subtle.Choice.t -> subtle.Choice.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.BitAnd.bitand
          (Self := subtle.Choice.t)
          (Rhs := subtle.Choice.t)
          (Trait := ℐ))) in
    let* α12 : subtle.Choice.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.Not.not (Self := subtle.Choice.t) (Trait := ℐ))) in
    let* α13 : subtle.Choice.t := M.read a in
    let* α14 : subtle.Choice.t := M.call (α12 α13) in
    let* α15 : subtle.Choice.t -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.bit.Not.not (Self := subtle.Choice.t) (Trait := ℐ))) in
    let* α16 : subtle.Choice.t := M.read b in
    let* α17 : subtle.Choice.t := M.call (α15 α16) in
    let* α18 : subtle.Choice.t := M.call (α11 α14 α17) in
    let* α19 : subtle.Choice.t := M.call (α0 α10 α18) in
    let* α0 : M.Val subtle.Choice.t := M.alloc α19 in
    M.read α0.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon Self "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.

Module  ConstantTimeGreater.
Section ConstantTimeGreater.
  Class Trait (Self : Set) : Type := {
    ct_gt : (ref Self) -> (ref Self) -> M subtle.Choice.t;
  }.
  
End ConstantTimeGreater.
End ConstantTimeGreater.

Module  Impl_subtle_ConstantTimeGreater_for_u8_t.
Section Impl_subtle_ConstantTimeGreater_for_u8_t.
  Definition Self : Set := u8.t.
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (self : ref Self) (other : ref u8.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* gtb : M.Val u8.t :=
      let* α0 : (ref u8.t) -> u8.t -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitAnd.bitand
            (Self := ref u8.t)
            (Rhs := u8.t)
            (Trait := ℐ))) in
      let* α1 : ref u8.t := M.read self in
      let* α2 : (ref u8.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.Not.not (Self := ref u8.t) (Trait := ℐ))) in
      let* α3 : ref u8.t := M.read other in
      let* α4 : u8.t := M.call (α2 α3) in
      let* α5 : u8.t := M.call (α0 α1 α4) in
      M.alloc α5 in
    let* ltb : M.Val u8.t :=
      let* α0 : u8.t -> (ref u8.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitAnd.bitand
            (Self := u8.t)
            (Rhs := ref u8.t)
            (Trait := ℐ))) in
      let* α1 : (ref u8.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.Not.not (Self := ref u8.t) (Trait := ℐ))) in
      let* α2 : ref u8.t := M.read self in
      let* α3 : u8.t := M.call (α1 α2) in
      let* α4 : ref u8.t := M.read other in
      let* α5 : u8.t := M.call (α0 α3 α4) in
      M.alloc α5 in
    let* pow : M.Val i32.t := M.alloc ((Integer.of_Z 1) : i32.t) in
    let* _ : M.Val unit :=
      M.loop
        (let* α0 : i32.t := M.read pow in
        let* α1 : M.Val bool.t :=
          M.alloc (BinOp.Pure.lt α0 ((Integer.of_Z 8) : i32.t)) in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val unit :=
            let β : M.Val u8.t := ltb in
            let* α0 := M.read β in
            let* α1 : u8.t := M.read ltb in
            let* α2 : i32.t := M.read pow in
            let* α3 : u8.t := BinOp.Panic.shr α1 α2 in
            assign β (BinOp.Pure.bit_or α0 α3) in
          let* _ : M.Val unit :=
            let β : M.Val i32.t := pow in
            let* α0 := M.read β in
            let* α1 : i32.t := M.read pow in
            let* α2 := BinOp.Panic.add α0 α1 in
            assign β α2 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : M.Val never.t := M.break in
            let* α1 := M.read α0 in
            let* α2 : unit := never_to_any α1 in
            M.alloc α2 in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2) in
    let* bit : M.Val u8.t :=
      let* α0 : u8.t := M.read gtb in
      let* α1 : u8.t := M.read ltb in
      M.alloc (BinOp.Pure.bit_and α0 (UnOp.not α1)) in
    let* pow : M.Val i32.t := M.alloc ((Integer.of_Z 1) : i32.t) in
    let* _ : M.Val unit :=
      M.loop
        (let* α0 : i32.t := M.read pow in
        let* α1 : M.Val bool.t :=
          M.alloc (BinOp.Pure.lt α0 ((Integer.of_Z 8) : i32.t)) in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val unit :=
            let β : M.Val u8.t := bit in
            let* α0 := M.read β in
            let* α1 : u8.t := M.read bit in
            let* α2 : i32.t := M.read pow in
            let* α3 : u8.t := BinOp.Panic.shr α1 α2 in
            assign β (BinOp.Pure.bit_or α0 α3) in
          let* _ : M.Val unit :=
            let β : M.Val i32.t := pow in
            let* α0 := M.read β in
            let* α1 : i32.t := M.read pow in
            let* α2 := BinOp.Panic.add α0 α1 in
            assign β α2 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : M.Val never.t := M.break in
            let* α1 := M.read α0 in
            let* α2 : unit := never_to_any α1 in
            M.alloc α2 in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2) in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.From.from
          (Self := subtle.Choice.t)
          (T := u8.t)
          (Trait := ℐ))) in
    let* α1 : u8.t := M.read bit in
    let* α2 : M.Val u8.t :=
      M.alloc (BinOp.Pure.bit_and α1 ((Integer.of_Z 1) : u8.t)) in
    let* α3 : u8.t := M.read (use α2) in
    let* α4 : subtle.Choice.t := M.call (α0 α3) in
    let* α0 : M.Val subtle.Choice.t := M.alloc α4 in
    M.read α0.
  
  Global Instance AssociatedFunction_ct_gt :
    Notations.DoubleColon Self "ct_gt" := {
    Notations.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u8_t.
End Impl_subtle_ConstantTimeGreater_for_u8_t.

Module  Impl_subtle_ConstantTimeGreater_for_u16_t.
Section Impl_subtle_ConstantTimeGreater_for_u16_t.
  Definition Self : Set := u16.t.
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (self : ref Self) (other : ref u16.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* gtb : M.Val u16.t :=
      let* α0 : (ref u16.t) -> u16.t -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitAnd.bitand
            (Self := ref u16.t)
            (Rhs := u16.t)
            (Trait := ℐ))) in
      let* α1 : ref u16.t := M.read self in
      let* α2 : (ref u16.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.Not.not (Self := ref u16.t) (Trait := ℐ))) in
      let* α3 : ref u16.t := M.read other in
      let* α4 : u16.t := M.call (α2 α3) in
      let* α5 : u16.t := M.call (α0 α1 α4) in
      M.alloc α5 in
    let* ltb : M.Val u16.t :=
      let* α0 : u16.t -> (ref u16.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitAnd.bitand
            (Self := u16.t)
            (Rhs := ref u16.t)
            (Trait := ℐ))) in
      let* α1 : (ref u16.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.Not.not (Self := ref u16.t) (Trait := ℐ))) in
      let* α2 : ref u16.t := M.read self in
      let* α3 : u16.t := M.call (α1 α2) in
      let* α4 : ref u16.t := M.read other in
      let* α5 : u16.t := M.call (α0 α3 α4) in
      M.alloc α5 in
    let* pow : M.Val i32.t := M.alloc ((Integer.of_Z 1) : i32.t) in
    let* _ : M.Val unit :=
      M.loop
        (let* α0 : i32.t := M.read pow in
        let* α1 : M.Val bool.t :=
          M.alloc (BinOp.Pure.lt α0 ((Integer.of_Z 16) : i32.t)) in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val unit :=
            let β : M.Val u16.t := ltb in
            let* α0 := M.read β in
            let* α1 : u16.t := M.read ltb in
            let* α2 : i32.t := M.read pow in
            let* α3 : u16.t := BinOp.Panic.shr α1 α2 in
            assign β (BinOp.Pure.bit_or α0 α3) in
          let* _ : M.Val unit :=
            let β : M.Val i32.t := pow in
            let* α0 := M.read β in
            let* α1 : i32.t := M.read pow in
            let* α2 := BinOp.Panic.add α0 α1 in
            assign β α2 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : M.Val never.t := M.break in
            let* α1 := M.read α0 in
            let* α2 : unit := never_to_any α1 in
            M.alloc α2 in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2) in
    let* bit : M.Val u16.t :=
      let* α0 : u16.t := M.read gtb in
      let* α1 : u16.t := M.read ltb in
      M.alloc (BinOp.Pure.bit_and α0 (UnOp.not α1)) in
    let* pow : M.Val i32.t := M.alloc ((Integer.of_Z 1) : i32.t) in
    let* _ : M.Val unit :=
      M.loop
        (let* α0 : i32.t := M.read pow in
        let* α1 : M.Val bool.t :=
          M.alloc (BinOp.Pure.lt α0 ((Integer.of_Z 16) : i32.t)) in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val unit :=
            let β : M.Val u16.t := bit in
            let* α0 := M.read β in
            let* α1 : u16.t := M.read bit in
            let* α2 : i32.t := M.read pow in
            let* α3 : u16.t := BinOp.Panic.shr α1 α2 in
            assign β (BinOp.Pure.bit_or α0 α3) in
          let* _ : M.Val unit :=
            let β : M.Val i32.t := pow in
            let* α0 := M.read β in
            let* α1 : i32.t := M.read pow in
            let* α2 := BinOp.Panic.add α0 α1 in
            assign β α2 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : M.Val never.t := M.break in
            let* α1 := M.read α0 in
            let* α2 : unit := never_to_any α1 in
            M.alloc α2 in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2) in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.From.from
          (Self := subtle.Choice.t)
          (T := u8.t)
          (Trait := ℐ))) in
    let* α1 : u16.t := M.read bit in
    let* α2 : subtle.Choice.t :=
      M.call
        (α0 (rust_cast (BinOp.Pure.bit_and α1 ((Integer.of_Z 1) : u16.t)))) in
    let* α0 : M.Val subtle.Choice.t := M.alloc α2 in
    M.read α0.
  
  Global Instance AssociatedFunction_ct_gt :
    Notations.DoubleColon Self "ct_gt" := {
    Notations.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u16_t.
End Impl_subtle_ConstantTimeGreater_for_u16_t.

Module  Impl_subtle_ConstantTimeGreater_for_u32_t.
Section Impl_subtle_ConstantTimeGreater_for_u32_t.
  Definition Self : Set := u32.t.
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (self : ref Self) (other : ref u32.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* gtb : M.Val u32.t :=
      let* α0 : (ref u32.t) -> u32.t -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitAnd.bitand
            (Self := ref u32.t)
            (Rhs := u32.t)
            (Trait := ℐ))) in
      let* α1 : ref u32.t := M.read self in
      let* α2 : (ref u32.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.Not.not (Self := ref u32.t) (Trait := ℐ))) in
      let* α3 : ref u32.t := M.read other in
      let* α4 : u32.t := M.call (α2 α3) in
      let* α5 : u32.t := M.call (α0 α1 α4) in
      M.alloc α5 in
    let* ltb : M.Val u32.t :=
      let* α0 : u32.t -> (ref u32.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitAnd.bitand
            (Self := u32.t)
            (Rhs := ref u32.t)
            (Trait := ℐ))) in
      let* α1 : (ref u32.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.Not.not (Self := ref u32.t) (Trait := ℐ))) in
      let* α2 : ref u32.t := M.read self in
      let* α3 : u32.t := M.call (α1 α2) in
      let* α4 : ref u32.t := M.read other in
      let* α5 : u32.t := M.call (α0 α3 α4) in
      M.alloc α5 in
    let* pow : M.Val i32.t := M.alloc ((Integer.of_Z 1) : i32.t) in
    let* _ : M.Val unit :=
      M.loop
        (let* α0 : i32.t := M.read pow in
        let* α1 : M.Val bool.t :=
          M.alloc (BinOp.Pure.lt α0 ((Integer.of_Z 32) : i32.t)) in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val unit :=
            let β : M.Val u32.t := ltb in
            let* α0 := M.read β in
            let* α1 : u32.t := M.read ltb in
            let* α2 : i32.t := M.read pow in
            let* α3 : u32.t := BinOp.Panic.shr α1 α2 in
            assign β (BinOp.Pure.bit_or α0 α3) in
          let* _ : M.Val unit :=
            let β : M.Val i32.t := pow in
            let* α0 := M.read β in
            let* α1 : i32.t := M.read pow in
            let* α2 := BinOp.Panic.add α0 α1 in
            assign β α2 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : M.Val never.t := M.break in
            let* α1 := M.read α0 in
            let* α2 : unit := never_to_any α1 in
            M.alloc α2 in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2) in
    let* bit : M.Val u32.t :=
      let* α0 : u32.t := M.read gtb in
      let* α1 : u32.t := M.read ltb in
      M.alloc (BinOp.Pure.bit_and α0 (UnOp.not α1)) in
    let* pow : M.Val i32.t := M.alloc ((Integer.of_Z 1) : i32.t) in
    let* _ : M.Val unit :=
      M.loop
        (let* α0 : i32.t := M.read pow in
        let* α1 : M.Val bool.t :=
          M.alloc (BinOp.Pure.lt α0 ((Integer.of_Z 32) : i32.t)) in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val unit :=
            let β : M.Val u32.t := bit in
            let* α0 := M.read β in
            let* α1 : u32.t := M.read bit in
            let* α2 : i32.t := M.read pow in
            let* α3 : u32.t := BinOp.Panic.shr α1 α2 in
            assign β (BinOp.Pure.bit_or α0 α3) in
          let* _ : M.Val unit :=
            let β : M.Val i32.t := pow in
            let* α0 := M.read β in
            let* α1 : i32.t := M.read pow in
            let* α2 := BinOp.Panic.add α0 α1 in
            assign β α2 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : M.Val never.t := M.break in
            let* α1 := M.read α0 in
            let* α2 : unit := never_to_any α1 in
            M.alloc α2 in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2) in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.From.from
          (Self := subtle.Choice.t)
          (T := u8.t)
          (Trait := ℐ))) in
    let* α1 : u32.t := M.read bit in
    let* α2 : subtle.Choice.t :=
      M.call
        (α0 (rust_cast (BinOp.Pure.bit_and α1 ((Integer.of_Z 1) : u32.t)))) in
    let* α0 : M.Val subtle.Choice.t := M.alloc α2 in
    M.read α0.
  
  Global Instance AssociatedFunction_ct_gt :
    Notations.DoubleColon Self "ct_gt" := {
    Notations.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u32_t.
End Impl_subtle_ConstantTimeGreater_for_u32_t.

Module  Impl_subtle_ConstantTimeGreater_for_u64_t.
Section Impl_subtle_ConstantTimeGreater_for_u64_t.
  Definition Self : Set := u64.t.
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (self : ref Self) (other : ref u64.t) : M subtle.Choice.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* gtb : M.Val u64.t :=
      let* α0 : (ref u64.t) -> u64.t -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitAnd.bitand
            (Self := ref u64.t)
            (Rhs := u64.t)
            (Trait := ℐ))) in
      let* α1 : ref u64.t := M.read self in
      let* α2 : (ref u64.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.Not.not (Self := ref u64.t) (Trait := ℐ))) in
      let* α3 : ref u64.t := M.read other in
      let* α4 : u64.t := M.call (α2 α3) in
      let* α5 : u64.t := M.call (α0 α1 α4) in
      M.alloc α5 in
    let* ltb : M.Val u64.t :=
      let* α0 : u64.t -> (ref u64.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.BitAnd.bitand
            (Self := u64.t)
            (Rhs := ref u64.t)
            (Trait := ℐ))) in
      let* α1 : (ref u64.t) -> M _ :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.bit.Not.not (Self := ref u64.t) (Trait := ℐ))) in
      let* α2 : ref u64.t := M.read self in
      let* α3 : u64.t := M.call (α1 α2) in
      let* α4 : ref u64.t := M.read other in
      let* α5 : u64.t := M.call (α0 α3 α4) in
      M.alloc α5 in
    let* pow : M.Val i32.t := M.alloc ((Integer.of_Z 1) : i32.t) in
    let* _ : M.Val unit :=
      M.loop
        (let* α0 : i32.t := M.read pow in
        let* α1 : M.Val bool.t :=
          M.alloc (BinOp.Pure.lt α0 ((Integer.of_Z 64) : i32.t)) in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val unit :=
            let β : M.Val u64.t := ltb in
            let* α0 := M.read β in
            let* α1 : u64.t := M.read ltb in
            let* α2 : i32.t := M.read pow in
            let* α3 : u64.t := BinOp.Panic.shr α1 α2 in
            assign β (BinOp.Pure.bit_or α0 α3) in
          let* _ : M.Val unit :=
            let β : M.Val i32.t := pow in
            let* α0 := M.read β in
            let* α1 : i32.t := M.read pow in
            let* α2 := BinOp.Panic.add α0 α1 in
            assign β α2 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : M.Val never.t := M.break in
            let* α1 := M.read α0 in
            let* α2 : unit := never_to_any α1 in
            M.alloc α2 in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2) in
    let* bit : M.Val u64.t :=
      let* α0 : u64.t := M.read gtb in
      let* α1 : u64.t := M.read ltb in
      M.alloc (BinOp.Pure.bit_and α0 (UnOp.not α1)) in
    let* pow : M.Val i32.t := M.alloc ((Integer.of_Z 1) : i32.t) in
    let* _ : M.Val unit :=
      M.loop
        (let* α0 : i32.t := M.read pow in
        let* α1 : M.Val bool.t :=
          M.alloc (BinOp.Pure.lt α0 ((Integer.of_Z 64) : i32.t)) in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val unit :=
            let β : M.Val u64.t := bit in
            let* α0 := M.read β in
            let* α1 : u64.t := M.read bit in
            let* α2 : i32.t := M.read pow in
            let* α3 : u64.t := BinOp.Panic.shr α1 α2 in
            assign β (BinOp.Pure.bit_or α0 α3) in
          let* _ : M.Val unit :=
            let β : M.Val i32.t := pow in
            let* α0 := M.read β in
            let* α1 : i32.t := M.read pow in
            let* α2 := BinOp.Panic.add α0 α1 in
            assign β α2 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : M.Val never.t := M.break in
            let* α1 := M.read α0 in
            let* α2 : unit := never_to_any α1 in
            M.alloc α2 in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2) in
    let* α0 : u8.t -> M subtle.Choice.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.From.from
          (Self := subtle.Choice.t)
          (T := u8.t)
          (Trait := ℐ))) in
    let* α1 : u64.t := M.read bit in
    let* α2 : subtle.Choice.t :=
      M.call
        (α0 (rust_cast (BinOp.Pure.bit_and α1 ((Integer.of_Z 1) : u64.t)))) in
    let* α0 : M.Val subtle.Choice.t := M.alloc α2 in
    M.read α0.
  
  Global Instance AssociatedFunction_ct_gt :
    Notations.DoubleColon Self "ct_gt" := {
    Notations.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u64_t.
End Impl_subtle_ConstantTimeGreater_for_u64_t.

Module  ConstantTimeLess.
Section ConstantTimeLess.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: subtle.ConstantTimeEq.Trait Self;
    ℒ_1 :: subtle.ConstantTimeGreater.Trait Self;
  }.
  
End ConstantTimeLess.
End ConstantTimeLess.

Module  Impl_subtle_ConstantTimeLess_for_u8_t.
Section Impl_subtle_ConstantTimeLess_for_u8_t.
  Definition Self : Set := u8.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait Self := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u8_t.
End Impl_subtle_ConstantTimeLess_for_u8_t.

Module  Impl_subtle_ConstantTimeLess_for_u16_t.
Section Impl_subtle_ConstantTimeLess_for_u16_t.
  Definition Self : Set := u16.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait Self := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u16_t.
End Impl_subtle_ConstantTimeLess_for_u16_t.

Module  Impl_subtle_ConstantTimeLess_for_u32_t.
Section Impl_subtle_ConstantTimeLess_for_u32_t.
  Definition Self : Set := u32.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait Self := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u32_t.
End Impl_subtle_ConstantTimeLess_for_u32_t.

Module  Impl_subtle_ConstantTimeLess_for_u64_t.
Section Impl_subtle_ConstantTimeLess_for_u64_t.
  Definition Self : Set := u64.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait Self := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u64_t.
End Impl_subtle_ConstantTimeLess_for_u64_t.
