(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module circuit.
  (* Trait *)
  (* Empty module 'Chip' *)
  
  (* StructTuple
    {
      name := "RegionIndex";
      ty_params := [];
      fields := [ Ty.path "usize" ];
    } *)
  
  Module Impl_core_clone_Clone_for_halo2_proofs_circuit_RegionIndex.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionIndex".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_halo2_proofs_circuit_RegionIndex.
  
  Module Impl_core_marker_Copy_for_halo2_proofs_circuit_RegionIndex.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_halo2_proofs_circuit_RegionIndex.
  
  Module Impl_core_fmt_Debug_for_halo2_proofs_circuit_RegionIndex.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionIndex".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "RegionIndex" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::RegionIndex",
                    0
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_halo2_proofs_circuit_RegionIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_circuit_RegionIndex.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_circuit_RegionIndex.
  
  Module Impl_core_cmp_PartialEq_for_halo2_proofs_circuit_RegionIndex.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionIndex".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          BinOp.Pure.eq
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "halo2_proofs::circuit::RegionIndex",
                0
              |)
            |))
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "halo2_proofs::circuit::RegionIndex",
                0
              |)
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_halo2_proofs_circuit_RegionIndex.
  
  Module Impl_core_convert_From_usize_for_halo2_proofs_circuit_RegionIndex.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionIndex".
    
    (*
        fn from(idx: usize) -> RegionIndex {
            RegionIndex(idx)
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple "halo2_proofs::circuit::RegionIndex" [ M.read (| idx |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "usize" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_usize_for_halo2_proofs_circuit_RegionIndex.
  
  Module Impl_core_ops_deref_Deref_for_halo2_proofs_circuit_RegionIndex.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionIndex".
    
    (*     type Target = usize; *)
    Definition _Target : Ty.t := Ty.path "usize".
    
    (*
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    *)
    Definition deref (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_tuple_field (|
            M.read (| self |),
            "halo2_proofs::circuit::RegionIndex",
            0
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::deref::Deref"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty _Target); ("deref", InstanceField.Method deref) ].
  End Impl_core_ops_deref_Deref_for_halo2_proofs_circuit_RegionIndex.
  
  (* StructTuple
    {
      name := "RegionStart";
      ty_params := [];
      fields := [ Ty.path "usize" ];
    } *)
  
  Module Impl_core_clone_Clone_for_halo2_proofs_circuit_RegionStart.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionStart".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_halo2_proofs_circuit_RegionStart.
  
  Module Impl_core_marker_Copy_for_halo2_proofs_circuit_RegionStart.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionStart".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_halo2_proofs_circuit_RegionStart.
  
  Module Impl_core_fmt_Debug_for_halo2_proofs_circuit_RegionStart.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionStart".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "RegionStart" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::RegionStart",
                    0
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_halo2_proofs_circuit_RegionStart.
  
  Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_circuit_RegionStart.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionStart".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_circuit_RegionStart.
  
  Module Impl_core_cmp_PartialEq_for_halo2_proofs_circuit_RegionStart.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionStart".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          BinOp.Pure.eq
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "halo2_proofs::circuit::RegionStart",
                0
              |)
            |))
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "halo2_proofs::circuit::RegionStart",
                0
              |)
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_halo2_proofs_circuit_RegionStart.
  
  Module Impl_core_marker_StructuralEq_for_halo2_proofs_circuit_RegionStart.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionStart".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_halo2_proofs_circuit_RegionStart.
  
  Module Impl_core_cmp_Eq_for_halo2_proofs_circuit_RegionStart.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionStart".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_halo2_proofs_circuit_RegionStart.
  
  Module Impl_core_convert_From_usize_for_halo2_proofs_circuit_RegionStart.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionStart".
    
    (*
        fn from(idx: usize) -> RegionStart {
            RegionStart(idx)
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple "halo2_proofs::circuit::RegionStart" [ M.read (| idx |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "usize" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_usize_for_halo2_proofs_circuit_RegionStart.
  
  Module Impl_core_ops_deref_Deref_for_halo2_proofs_circuit_RegionStart.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::RegionStart".
    
    (*     type Target = usize; *)
    Definition _Target : Ty.t := Ty.path "usize".
    
    (*
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    *)
    Definition deref (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_tuple_field (|
            M.read (| self |),
            "halo2_proofs::circuit::RegionStart",
            0
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::deref::Deref"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty _Target); ("deref", InstanceField.Method deref) ].
  End Impl_core_ops_deref_Deref_for_halo2_proofs_circuit_RegionStart.
  
  (* StructRecord
    {
      name := "Cell";
      ty_params := [];
      fields :=
        [
          ("region_index", Ty.path "halo2_proofs::circuit::RegionIndex");
          ("row_offset", Ty.path "usize");
          ("column",
            Ty.apply
              (Ty.path "halo2_proofs::plonk::circuit::Column")
              [ Ty.path "halo2_proofs::plonk::circuit::Any" ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_halo2_proofs_circuit_Cell.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::Cell".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_halo2_proofs_circuit_Cell.
  
  Module Impl_core_marker_Copy_for_halo2_proofs_circuit_Cell.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::Cell".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_halo2_proofs_circuit_Cell.
  
  Module Impl_core_fmt_Debug_for_halo2_proofs_circuit_Cell.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::Cell".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "Cell" |);
              M.read (| Value.String "region_index" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::Cell",
                  "region_index"
                |));
              M.read (| Value.String "row_offset" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::Cell",
                  "row_offset"
                |));
              M.read (| Value.String "column" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::Cell",
                    "column"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_halo2_proofs_circuit_Cell.
  
  Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_circuit_Cell.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::Cell".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_circuit_Cell.
  
  Module Impl_core_cmp_PartialEq_for_halo2_proofs_circuit_Cell.
    Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::Cell".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "halo2_proofs::circuit::RegionIndex",
                  [ Ty.path "halo2_proofs::circuit::RegionIndex" ],
                  "eq",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::Cell",
                    "region_index"
                  |);
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "halo2_proofs::circuit::Cell",
                    "region_index"
                  |)
                ]
              |),
              ltac:(M.monadic
                (BinOp.Pure.eq
                  (M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::Cell",
                      "row_offset"
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "halo2_proofs::circuit::Cell",
                      "row_offset"
                    |)
                  |))))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                  [
                    Ty.apply
                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                      [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::Cell",
                    "column"
                  |);
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "halo2_proofs::circuit::Cell",
                    "column"
                  |)
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_halo2_proofs_circuit_Cell.
  
  (* StructRecord
    {
      name := "AssignedCell";
      ty_params := [ "V"; "F" ];
      fields :=
        [
          ("value", Ty.apply (Ty.path "core::option::Option") [ V ]);
          ("cell", Ty.path "halo2_proofs::circuit::Cell");
          ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ F ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_V_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_circuit_AssignedCell_V_F.
    Definition Self (V F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::circuit::AssignedCell") [ V; F ].
    
    (* Clone *)
    Definition clone (V F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self V F in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "halo2_proofs::circuit::AssignedCell"
            [
              ("value",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::option::Option") [ V ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::AssignedCell",
                      "value"
                    |)
                  ]
                |));
              ("cell",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "halo2_proofs::circuit::Cell",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::AssignedCell",
                      "cell"
                    |)
                  ]
                |));
              ("_marker",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::marker::PhantomData") [ F ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::AssignedCell",
                      "_marker"
                    |)
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (V F : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self V F)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone V F)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_V_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_circuit_AssignedCell_V_F.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_V_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_circuit_AssignedCell_V_F.
    Definition Self (V F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::circuit::AssignedCell") [ V; F ].
    
    (* Debug *)
    Definition fmt (V F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self V F in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "AssignedCell" |);
              M.read (| Value.String "value" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::AssignedCell",
                  "value"
                |));
              M.read (| Value.String "cell" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::AssignedCell",
                  "cell"
                |));
              M.read (| Value.String "_marker" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::AssignedCell",
                    "_marker"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (V F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self V F)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt V F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_V_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_circuit_AssignedCell_V_F.
  
  Module Impl_halo2_proofs_circuit_AssignedCell_V_F.
    Definition Self (V F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::circuit::AssignedCell") [ V; F ].
    
    (*
        pub fn value(&self) -> Option<&V> {
            self.value.as_ref()
        }
    *)
    Definition value (V F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self V F in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [ V ],
              "as_ref",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::circuit::AssignedCell",
                "value"
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_value :
      forall (V F : Ty.t),
      M.IsAssociatedFunction (Self V F) "value" (value V F).
    
    (*
        pub fn cell(&self) -> Cell {
            self.cell
        }
    *)
    Definition cell (V F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self V F in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "halo2_proofs::circuit::AssignedCell",
              "cell"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_cell :
      forall (V F : Ty.t),
      M.IsAssociatedFunction (Self V F) "cell" (cell V F).
    (*
        pub fn value_field(&self) -> Option<Assigned<F>> {
            self.value().map(|v| v.into())
        }
    *)
    Definition value_field (V F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self V F in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [ Ty.apply (Ty.path "&") [ V ] ],
              "map",
              [
                Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "&") [ V ] ] ]
                  (Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "halo2_proofs::circuit::AssignedCell") [ V; F ],
                  "value",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let v := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::convert::Into",
                                  Ty.apply (Ty.path "&") [ V ],
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                      [ F ]
                                  ],
                                  "into",
                                  []
                                |),
                                [ M.read (| v |) ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_value_field :
      forall (V F : Ty.t),
      M.IsAssociatedFunction (Self V F) "value_field" (value_field V F).
    (*
        pub fn copy_advice<A, AR>(
            &self,
            annotation: A,
            region: &mut Region<'_, F>,
            column: Column<Advice>,
            offset: usize,
        ) -> Result<Self, Error>
        where
            A: Fn() -> AR,
            AR: Into<String>,
        {
            let assigned_cell = region.assign_advice(annotation, column, offset, || {
                self.value.clone().ok_or(Error::Synthesis)
            })?;
            region.constrain_equal(assigned_cell.cell(), self.cell())?;
    
            Ok(assigned_cell)
        }
    *)
    Definition copy_advice (V F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self V F in
      match τ, α with
      | [ A; AR ], [ self; annotation; region; column; offset ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let annotation := M.alloc (| annotation |) in
          let region := M.alloc (| region |) in
          let column := M.alloc (| column |) in
          let offset := M.alloc (| offset |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let assigned_cell :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply (Ty.path "halo2_proofs::circuit::AssignedCell") [ V; F ];
                                Ty.path "halo2_proofs::plonk::error::Error"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ],
                                "assign_advice",
                                [
                                  Ty.function
                                    [ Ty.tuple [] ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ V; Ty.path "halo2_proofs::plonk::error::Error" ]);
                                  V;
                                  A;
                                  AR
                                ]
                              |),
                              [
                                M.read (| region |);
                                M.read (| annotation |);
                                M.read (| column |);
                                M.read (| offset |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "core::option::Option") [ V ],
                                                    "ok_or",
                                                    [ Ty.path "halo2_proofs::plonk::error::Error" ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::clone::Clone",
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          [ V ],
                                                        [],
                                                        "clone",
                                                        []
                                                      |),
                                                      [
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.read (| self |),
                                                          "halo2_proofs::circuit::AssignedCell",
                                                          "value"
                                                        |)
                                                      ]
                                                    |);
                                                    Value.StructTuple
                                                      "halo2_proofs::plonk::error::Error::Synthesis"
                                                      []
                                                  ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end))
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::circuit::AssignedCell")
                                              [ V; F ];
                                            Ty.path "halo2_proofs::plonk::error::Error"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ],
                              "constrain_equal",
                              []
                            |),
                            [
                              M.read (| region |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "halo2_proofs::circuit::AssignedCell") [ V; F ],
                                  "cell",
                                  []
                                |),
                                [ assigned_cell ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "halo2_proofs::circuit::AssignedCell") [ V; F ],
                                  "cell",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::circuit::AssignedCell")
                                            [ V; F ];
                                          Ty.path "halo2_proofs::plonk::error::Error"
                                        ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "halo2_proofs::plonk::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple "core::result::Result::Ok" [ M.read (| assigned_cell |) ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_copy_advice :
      forall (V F : Ty.t),
      M.IsAssociatedFunction (Self V F) "copy_advice" (copy_advice V F).
  End Impl_halo2_proofs_circuit_AssignedCell_V_F.
  
  
  
  (* StructRecord
    {
      name := "Region";
      ty_params := [ "F" ];
      fields :=
        [
          ("region",
            Ty.apply
              (Ty.path "&")
              [ Ty.dyn [ ("halo2_proofs::circuit::layouter::RegionLayouter::Trait", []) ] ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_circuit_Region_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ].
    
    (* Clone *)
    Definition clone (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "halo2_proofs::circuit::Region"
            [
              ("region",
                (* Unsize *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "&")
                        [ Ty.dyn [ ("halo2_proofs::circuit::layouter::RegionLayouter::Trait", []) ]
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::circuit::Region",
                        "region"
                      |)
                    ]
                  |)))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self F)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_circuit_Region_F.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_circuit_Region_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ].
    
    (* Debug *)
    Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "Region" |);
              M.read (| Value.String "region" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::Region",
                    "region"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self F)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_circuit_Region_F.
  
  Module Impl_core_marker_Sync_where_ff_Field_F_for_halo2_proofs_circuit_Region_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ].
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (Self F)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Sync_where_ff_Field_F_for_halo2_proofs_circuit_Region_F.
  
  Module Impl_core_marker_Send_where_ff_Field_F_for_halo2_proofs_circuit_Region_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ].
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (Self F)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Send_where_ff_Field_F_for_halo2_proofs_circuit_Region_F.
  
  Module Impl_core_convert_From_where_ff_Field_F_ref__Dyn_halo2_proofs_circuit_layouter_RegionLayouter_Trait_for_halo2_proofs_circuit_Region_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ].
    
    (*
        fn from(region: &'r dyn layouter::RegionLayouter<F>) -> Self {
            Region { region }
        }
    *)
    Definition from (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [], [ region ] =>
        ltac:(M.monadic
          (let region := M.alloc (| region |) in
          Value.StructRecord
            "halo2_proofs::circuit::Region"
            [ ("region", (* Unsize *) M.pointer_coercion (M.read (| region |))) ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self F)
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply
            (Ty.path "&")
            [ Ty.dyn [ ("halo2_proofs::circuit::layouter::RegionLayouter::Trait", []) ] ]
        ]
        (* Instance *) [ ("from", InstanceField.Method (from F)) ].
  End Impl_core_convert_From_where_ff_Field_F_ref__Dyn_halo2_proofs_circuit_layouter_RegionLayouter_Trait_for_halo2_proofs_circuit_Region_F.
  
  Module Impl_halo2_proofs_circuit_Region_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ].
    
    (*
        pub(crate) fn enable_selector<A, AR>(
            &self,
            annotation: A,
            selector: &Selector,
            offset: usize,
        ) -> Result<(), Error>
        where
            A: Fn() -> AR,
            AR: Into<String>,
        {
            self.region
                .enable_selector(&|| annotation().into(), selector, offset)
        }
    *)
    Definition enable_selector (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [ A; AR ], [ self; annotation; selector; offset ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let annotation := M.alloc (| annotation |) in
          let selector := M.alloc (| selector |) in
          let offset := M.alloc (| offset |) in
          M.call_closure (|
            M.get_trait_method (|
              "halo2_proofs::circuit::layouter::RegionLayouter",
              Ty.dyn [ ("halo2_proofs::circuit::layouter::RegionLayouter::Trait", []) ],
              [ F ],
              "enable_selector",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::Region",
                  "region"
                |)
              |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      AR,
                                      [ Ty.path "alloc::string::String" ],
                                      "into",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::function::Fn",
                                          A,
                                          [ Ty.tuple [] ],
                                          "call",
                                          []
                                        |),
                                        [ annotation; Value.Tuple [] ]
                                      |)
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |));
              M.read (| selector |);
              M.read (| offset |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_enable_selector :
      forall (F : Ty.t),
      M.IsAssociatedFunction (Self F) "enable_selector" (enable_selector F).
    
    (*
        pub fn assign_advice<'v, V, VR, A, AR>(
            &'v self,
            annotation: A,
            column: Column<Advice>,
            offset: usize,
            mut to: V,
        ) -> Result<AssignedCell<VR, F>, Error>
        where
            V: FnMut() -> Result<VR, Error> + 'v,
            for<'vr> Assigned<F>: From<&'vr VR>,
            A: Fn() -> AR,
            AR: Into<String>,
        {
            let mut value = None;
            let cell =
                self.region
                    .assign_advice(&|| annotation().into(), column, offset, &mut || {
                        let v = to()?;
                        let value_f = (&v).into();
                        value = Some(v);
                        Ok(value_f)
                    })?;
    
            Ok(AssignedCell {
                value,
                cell,
                _marker: PhantomData,
            })
        }
    *)
    Definition assign_advice (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [ V; VR; A; AR ], [ self; annotation; column; offset; to ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let annotation := M.alloc (| annotation |) in
          let column := M.alloc (| column |) in
          let offset := M.alloc (| offset |) in
          let to := M.alloc (| to |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let value := M.alloc (| Value.StructTuple "core::option::Option::None" [] |) in
                let cell :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.path "halo2_proofs::circuit::Cell";
                                Ty.path "halo2_proofs::plonk::error::Error"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "halo2_proofs::circuit::layouter::RegionLayouter",
                                Ty.dyn
                                  [ ("halo2_proofs::circuit::layouter::RegionLayouter::Trait", [])
                                  ],
                                [ F ],
                                "assign_advice",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::Region",
                                    "region"
                                  |)
                                |);
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::convert::Into",
                                                        AR,
                                                        [ Ty.path "alloc::string::String" ],
                                                        "into",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::function::Fn",
                                                            A,
                                                            [ Ty.tuple [] ],
                                                            "call",
                                                            []
                                                          |),
                                                          [ annotation; Value.Tuple [] ]
                                                        |)
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  |));
                                M.read (| column |);
                                M.read (| offset |);
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.read (|
                                                      let v :=
                                                        M.copy (|
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::Try",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      VR;
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::error::Error"
                                                                    ],
                                                                  [],
                                                                  "branch",
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::ops::function::FnMut",
                                                                      V,
                                                                      [ Ty.tuple [] ],
                                                                      "call_mut",
                                                                      []
                                                                    |),
                                                                    [ to; Value.Tuple [] ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Break",
                                                                      0
                                                                    |) in
                                                                  let residual :=
                                                                    M.copy (| γ0_0 |) in
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (|
                                                                        M.return_ (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::try_trait::FromResidual",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "halo2_proofs::plonk::assigned::Assigned")
                                                                                    [ F ];
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::error::Error"
                                                                                ],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::result::Result")
                                                                                  [
                                                                                    Ty.path
                                                                                      "core::convert::Infallible";
                                                                                    Ty.path
                                                                                      "halo2_proofs::plonk::error::Error"
                                                                                  ]
                                                                              ],
                                                                              "from_residual",
                                                                              []
                                                                            |),
                                                                            [ M.read (| residual |)
                                                                            ]
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                                      0
                                                                    |) in
                                                                  let val := M.copy (| γ0_0 |) in
                                                                  val))
                                                            ]
                                                          |)
                                                        |) in
                                                      let value_f :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::convert::Into",
                                                              Ty.apply (Ty.path "&") [ VR ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                                  [ F ]
                                                              ],
                                                              "into",
                                                              []
                                                            |),
                                                            [ v ]
                                                          |)
                                                        |) in
                                                      let _ :=
                                                        M.write (|
                                                          value,
                                                          Value.StructTuple
                                                            "core::option::Option::Some"
                                                            [ M.read (| v |) ]
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "core::result::Result::Ok"
                                                          [ M.read (| value_f |) ]
                                                      |)
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::circuit::AssignedCell")
                                              [ VR; F ];
                                            Ty.path "halo2_proofs::plonk::error::Error"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      Value.StructRecord
                        "halo2_proofs::circuit::AssignedCell"
                        [
                          ("value", M.read (| value |));
                          ("cell", M.read (| cell |));
                          ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                        ]
                    ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assign_advice :
      forall (F : Ty.t),
      M.IsAssociatedFunction (Self F) "assign_advice" (assign_advice F).
    
    (*
        pub fn assign_advice_from_constant<VR, A, AR>(
            &self,
            annotation: A,
            column: Column<Advice>,
            offset: usize,
            constant: VR,
        ) -> Result<AssignedCell<VR, F>, Error>
        where
            for<'vr> Assigned<F>: From<&'vr VR>,
            A: Fn() -> AR,
            AR: Into<String>,
        {
            let cell = self.region.assign_advice_from_constant(
                &|| annotation().into(),
                column,
                offset,
                (&constant).into(),
            )?;
    
            Ok(AssignedCell {
                value: Some(constant),
                cell,
                _marker: PhantomData,
            })
        }
    *)
    Definition assign_advice_from_constant (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [ VR; A; AR ], [ self; annotation; column; offset; constant ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let annotation := M.alloc (| annotation |) in
          let column := M.alloc (| column |) in
          let offset := M.alloc (| offset |) in
          let constant := M.alloc (| constant |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let cell :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.path "halo2_proofs::circuit::Cell";
                                Ty.path "halo2_proofs::plonk::error::Error"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "halo2_proofs::circuit::layouter::RegionLayouter",
                                Ty.dyn
                                  [ ("halo2_proofs::circuit::layouter::RegionLayouter::Trait", [])
                                  ],
                                [ F ],
                                "assign_advice_from_constant",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::Region",
                                    "region"
                                  |)
                                |);
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::convert::Into",
                                                        AR,
                                                        [ Ty.path "alloc::string::String" ],
                                                        "into",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::function::Fn",
                                                            A,
                                                            [ Ty.tuple [] ],
                                                            "call",
                                                            []
                                                          |),
                                                          [ annotation; Value.Tuple [] ]
                                                        |)
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  |));
                                M.read (| column |);
                                M.read (| offset |);
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::Into",
                                    Ty.apply (Ty.path "&") [ VR ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                        [ F ]
                                    ],
                                    "into",
                                    []
                                  |),
                                  [ constant ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::circuit::AssignedCell")
                                              [ VR; F ];
                                            Ty.path "halo2_proofs::plonk::error::Error"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      Value.StructRecord
                        "halo2_proofs::circuit::AssignedCell"
                        [
                          ("value",
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ M.read (| constant |) ]);
                          ("cell", M.read (| cell |));
                          ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                        ]
                    ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assign_advice_from_constant :
      forall (F : Ty.t),
      M.IsAssociatedFunction (Self F) "assign_advice_from_constant" (assign_advice_from_constant F).
    
    (*
        pub fn assign_advice_from_instance<A, AR>(
            &mut self,
            annotation: A,
            instance: Column<Instance>,
            row: usize,
            advice: Column<Advice>,
            offset: usize,
        ) -> Result<AssignedCell<F, F>, Error>
        where
            A: Fn() -> AR,
            AR: Into<String>,
        {
            let (cell, value) = self.region.assign_advice_from_instance(
                &|| annotation().into(),
                instance,
                row,
                advice,
                offset,
            )?;
    
            Ok(AssignedCell {
                value,
                cell,
                _marker: PhantomData,
            })
        }
    *)
    Definition assign_advice_from_instance (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [ A; AR ], [ self; annotation; instance; row; advice; offset ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let annotation := M.alloc (| annotation |) in
          let instance := M.alloc (| instance |) in
          let row := M.alloc (| row |) in
          let advice := M.alloc (| advice |) in
          let offset := M.alloc (| offset |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.tuple
                                [
                                  Ty.path "halo2_proofs::circuit::Cell";
                                  Ty.apply (Ty.path "core::option::Option") [ F ]
                                ];
                              Ty.path "halo2_proofs::plonk::error::Error"
                            ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "halo2_proofs::circuit::layouter::RegionLayouter",
                              Ty.dyn
                                [ ("halo2_proofs::circuit::layouter::RegionLayouter::Trait", []) ],
                              [ F ],
                              "assign_advice_from_instance",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::circuit::Region",
                                  "region"
                                |)
                              |);
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::convert::Into",
                                                      AR,
                                                      [ Ty.path "alloc::string::String" ],
                                                      "into",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::function::Fn",
                                                          A,
                                                          [ Ty.tuple [] ],
                                                          "call",
                                                          []
                                                        |),
                                                        [ annotation; Value.Tuple [] ]
                                                      |)
                                                    ]
                                                  |)))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                |));
                              M.read (| instance |);
                              M.read (| row |);
                              M.read (| advice |);
                              M.read (| offset |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::circuit::AssignedCell")
                                            [ F; F ];
                                          Ty.path "halo2_proofs::plonk::error::Error"
                                        ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "halo2_proofs::plonk::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let cell := M.copy (| γ0_0 |) in
                        let value := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [
                              Value.StructRecord
                                "halo2_proofs::circuit::AssignedCell"
                                [
                                  ("value", M.read (| value |));
                                  ("cell", M.read (| cell |));
                                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                                ]
                            ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assign_advice_from_instance :
      forall (F : Ty.t),
      M.IsAssociatedFunction (Self F) "assign_advice_from_instance" (assign_advice_from_instance F).
    
    (*
        pub fn assign_fixed<'v, V, VR, A, AR>(
            &'v self,
            annotation: A,
            column: Column<Fixed>,
            offset: usize,
            mut to: V,
        ) -> Result<AssignedCell<VR, F>, Error>
        where
            V: FnMut() -> Result<VR, Error> + 'v,
            for<'vr> Assigned<F>: From<&'vr VR>,
            A: Fn() -> AR,
            AR: Into<String>,
        {
            let mut value = None;
            let cell =
                self.region
                    .assign_fixed(&|| annotation().into(), column, offset, &mut || {
                        let v = to()?;
                        let value_f = (&v).into();
                        value = Some(v);
                        Ok(value_f)
                    })?;
    
            Ok(AssignedCell {
                value,
                cell,
                _marker: PhantomData,
            })
        }
    *)
    Definition assign_fixed (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [ V; VR; A; AR ], [ self; annotation; column; offset; to ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let annotation := M.alloc (| annotation |) in
          let column := M.alloc (| column |) in
          let offset := M.alloc (| offset |) in
          let to := M.alloc (| to |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let value := M.alloc (| Value.StructTuple "core::option::Option::None" [] |) in
                let cell :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.path "halo2_proofs::circuit::Cell";
                                Ty.path "halo2_proofs::plonk::error::Error"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "halo2_proofs::circuit::layouter::RegionLayouter",
                                Ty.dyn
                                  [ ("halo2_proofs::circuit::layouter::RegionLayouter::Trait", [])
                                  ],
                                [ F ],
                                "assign_fixed",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::Region",
                                    "region"
                                  |)
                                |);
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::convert::Into",
                                                        AR,
                                                        [ Ty.path "alloc::string::String" ],
                                                        "into",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::function::Fn",
                                                            A,
                                                            [ Ty.tuple [] ],
                                                            "call",
                                                            []
                                                          |),
                                                          [ annotation; Value.Tuple [] ]
                                                        |)
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  |));
                                M.read (| column |);
                                M.read (| offset |);
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.read (|
                                                      let v :=
                                                        M.copy (|
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::Try",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      VR;
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::error::Error"
                                                                    ],
                                                                  [],
                                                                  "branch",
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::ops::function::FnMut",
                                                                      V,
                                                                      [ Ty.tuple [] ],
                                                                      "call_mut",
                                                                      []
                                                                    |),
                                                                    [ to; Value.Tuple [] ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Break",
                                                                      0
                                                                    |) in
                                                                  let residual :=
                                                                    M.copy (| γ0_0 |) in
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (|
                                                                        M.return_ (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::try_trait::FromResidual",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "halo2_proofs::plonk::assigned::Assigned")
                                                                                    [ F ];
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::error::Error"
                                                                                ],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::result::Result")
                                                                                  [
                                                                                    Ty.path
                                                                                      "core::convert::Infallible";
                                                                                    Ty.path
                                                                                      "halo2_proofs::plonk::error::Error"
                                                                                  ]
                                                                              ],
                                                                              "from_residual",
                                                                              []
                                                                            |),
                                                                            [ M.read (| residual |)
                                                                            ]
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                                      0
                                                                    |) in
                                                                  let val := M.copy (| γ0_0 |) in
                                                                  val))
                                                            ]
                                                          |)
                                                        |) in
                                                      let value_f :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::convert::Into",
                                                              Ty.apply (Ty.path "&") [ VR ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                                  [ F ]
                                                              ],
                                                              "into",
                                                              []
                                                            |),
                                                            [ v ]
                                                          |)
                                                        |) in
                                                      let _ :=
                                                        M.write (|
                                                          value,
                                                          Value.StructTuple
                                                            "core::option::Option::Some"
                                                            [ M.read (| v |) ]
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "core::result::Result::Ok"
                                                          [ M.read (| value_f |) ]
                                                      |)
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::circuit::AssignedCell")
                                              [ VR; F ];
                                            Ty.path "halo2_proofs::plonk::error::Error"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      Value.StructRecord
                        "halo2_proofs::circuit::AssignedCell"
                        [
                          ("value", M.read (| value |));
                          ("cell", M.read (| cell |));
                          ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                        ]
                    ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assign_fixed :
      forall (F : Ty.t),
      M.IsAssociatedFunction (Self F) "assign_fixed" (assign_fixed F).
    
    (*
        pub fn constrain_constant<VR>(&mut self, cell: Cell, constant: VR) -> Result<(), Error>
        where
            VR: Into<Assigned<F>>,
        {
            self.region.constrain_constant(cell, constant.into())
        }
    *)
    Definition constrain_constant (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [ VR ], [ self; cell; constant ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cell := M.alloc (| cell |) in
          let constant := M.alloc (| constant |) in
          M.call_closure (|
            M.get_trait_method (|
              "halo2_proofs::circuit::layouter::RegionLayouter",
              Ty.dyn [ ("halo2_proofs::circuit::layouter::RegionLayouter::Trait", []) ],
              [ F ],
              "constrain_constant",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::Region",
                  "region"
                |)
              |);
              M.read (| cell |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::Into",
                  VR,
                  [ Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ] ],
                  "into",
                  []
                |),
                [ M.read (| constant |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_constrain_constant :
      forall (F : Ty.t),
      M.IsAssociatedFunction (Self F) "constrain_constant" (constrain_constant F).
    
    (*
        pub fn constrain_equal(&self, left: Cell, right: Cell) -> Result<(), Error> {
            self.region.constrain_equal(left, right)
        }
    *)
    Definition constrain_equal (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [], [ self; _ as left; _ as right ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let left := M.alloc (| left |) in
          let right := M.alloc (| right |) in
          M.call_closure (|
            M.get_trait_method (|
              "halo2_proofs::circuit::layouter::RegionLayouter",
              Ty.dyn [ ("halo2_proofs::circuit::layouter::RegionLayouter::Trait", []) ],
              [ F ],
              "constrain_equal",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::Region",
                  "region"
                |)
              |);
              M.read (| left |);
              M.read (| right |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_constrain_equal :
      forall (F : Ty.t),
      M.IsAssociatedFunction (Self F) "constrain_equal" (constrain_equal F).
  End Impl_halo2_proofs_circuit_Region_F.
  
  (* StructRecord
    {
      name := "Table";
      ty_params := [ "F" ];
      fields :=
        [
          ("table",
            Ty.apply
              (Ty.path "&")
              [ Ty.dyn [ ("halo2_proofs::circuit::layouter::TableLayouter::Trait", []) ] ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_circuit_Table_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "halo2_proofs::circuit::Table") [ F ].
    
    (* Debug *)
    Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "Table" |);
              M.read (| Value.String "table" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::Table",
                    "table"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self F)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_circuit_Table_F.
  
  Module Impl_core_convert_From_where_ff_Field_F_ref__Dyn_halo2_proofs_circuit_layouter_TableLayouter_Trait_for_halo2_proofs_circuit_Table_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "halo2_proofs::circuit::Table") [ F ].
    
    (*
        fn from(table: &'r dyn layouter::TableLayouter<F>) -> Self {
            Table { table }
        }
    *)
    Definition from (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [], [ table ] =>
        ltac:(M.monadic
          (let table := M.alloc (| table |) in
          Value.StructRecord
            "halo2_proofs::circuit::Table"
            [ ("table", (* Unsize *) M.pointer_coercion (M.read (| table |))) ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self F)
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply
            (Ty.path "&")
            [ Ty.dyn [ ("halo2_proofs::circuit::layouter::TableLayouter::Trait", []) ] ]
        ]
        (* Instance *) [ ("from", InstanceField.Method (from F)) ].
  End Impl_core_convert_From_where_ff_Field_F_ref__Dyn_halo2_proofs_circuit_layouter_TableLayouter_Trait_for_halo2_proofs_circuit_Table_F.
  
  Module Impl_halo2_proofs_circuit_Table_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "halo2_proofs::circuit::Table") [ F ].
    
    (*
        pub fn assign_cell<'v, V, VR, A, AR>(
            &'v self,
            annotation: A,
            column: TableColumn,
            offset: usize,
            mut to: V,
        ) -> Result<(), Error>
        where
            V: FnMut() -> Result<VR, Error> + 'v,
            VR: Into<Assigned<F>>,
            A: Fn() -> AR,
            AR: Into<String>,
        {
            self.table
                .assign_cell(&|| annotation().into(), column, offset, &mut || {
                    to().map(|v| v.into())
                })
        }
    *)
    Definition assign_cell (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [ V; VR; A; AR ], [ self; annotation; column; offset; to ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let annotation := M.alloc (| annotation |) in
          let column := M.alloc (| column |) in
          let offset := M.alloc (| offset |) in
          let to := M.alloc (| to |) in
          M.call_closure (|
            M.get_trait_method (|
              "halo2_proofs::circuit::layouter::TableLayouter",
              Ty.dyn [ ("halo2_proofs::circuit::layouter::TableLayouter::Trait", []) ],
              [ F ],
              "assign_cell",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::Table",
                  "table"
                |)
              |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      AR,
                                      [ Ty.path "alloc::string::String" ],
                                      "into",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::function::Fn",
                                          A,
                                          [ Ty.tuple [] ],
                                          "call",
                                          []
                                        |),
                                        [ annotation; Value.Tuple [] ]
                                      |)
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |));
              M.read (| column |);
              M.read (| offset |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ VR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                      "map",
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                          [ F ];
                                        Ty.function
                                          [ Ty.tuple [ VR ] ]
                                          (Ty.apply
                                            (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                            [ F ])
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::function::FnMut",
                                          V,
                                          [ Ty.tuple [] ],
                                          "call_mut",
                                          []
                                        |),
                                        [ to; Value.Tuple [] ]
                                      |);
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let v := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::convert::Into",
                                                          VR,
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::assigned::Assigned")
                                                              [ F ]
                                                          ],
                                                          "into",
                                                          []
                                                        |),
                                                        [ M.read (| v |) ]
                                                      |)))
                                                ]
                                              |)
                                            | _ => M.impossible (||)
                                            end))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assign_cell :
      forall (F : Ty.t),
      M.IsAssociatedFunction (Self F) "assign_cell" (assign_cell F).
  End Impl_halo2_proofs_circuit_Table_F.
  
  (* Trait *)
  Module Layouter.
    Definition namespace (F Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ NR; N ], [ self; name_fn ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let name_fn := M.alloc (| name_fn |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "halo2_proofs::circuit::Layouter",
                    Ty.associated,
                    [ F ],
                    "push_namespace",
                    [ NR; N ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "halo2_proofs::circuit::Layouter",
                        Self,
                        [ F ],
                        "get_root",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| name_fn |)
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructTuple
                "halo2_proofs::circuit::NamespacedLayouter"
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "halo2_proofs::circuit::Layouter",
                      Self,
                      [ F ],
                      "get_root",
                      []
                    |),
                    [ M.read (| self |) ]
                  |);
                  Value.StructTuple "core::marker::PhantomData" []
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_namespace :
      forall (F : Ty.t),
      M.IsProvidedMethod "halo2_proofs::circuit::Layouter" "namespace" (namespace F).
  End Layouter.
  
  (* StructTuple
    {
      name := "NamespacedLayouter";
      ty_params := [ "F"; "L" ];
      fields :=
        [ Ty.apply (Ty.path "&") [ L ]; Ty.apply (Ty.path "core::marker::PhantomData") [ F ] ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_where_core_clone_Clone_L_where_halo2_proofs_circuit_Layouter_L_F_for_halo2_proofs_circuit_NamespacedLayouter_F_L.
    Definition Self (F L : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::circuit::NamespacedLayouter") [ F; L ].
    
    (* Clone *)
    Definition clone (F L : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F L in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "halo2_proofs::circuit::NamespacedLayouter"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply (Ty.path "&") [ L ],
                  [],
                  "clone",
                  []
                |),
                [
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::NamespacedLayouter",
                    0
                  |)
                ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply (Ty.path "core::marker::PhantomData") [ F ],
                  [],
                  "clone",
                  []
                |),
                [
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::NamespacedLayouter",
                    1
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F L : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self F L)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone F L)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_where_core_clone_Clone_L_where_halo2_proofs_circuit_Layouter_L_F_for_halo2_proofs_circuit_NamespacedLayouter_F_L.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_where_core_fmt_Debug_L_where_halo2_proofs_circuit_Layouter_L_F_for_halo2_proofs_circuit_NamespacedLayouter_F_L.
    Definition Self (F L : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::circuit::NamespacedLayouter") [ F; L ].
    
    (* Debug *)
    Definition fmt (F L : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F L in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "NamespacedLayouter" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::NamespacedLayouter",
                  0
                |));
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::circuit::NamespacedLayouter",
                    1
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F L : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self F L)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F L)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_where_core_fmt_Debug_L_where_halo2_proofs_circuit_Layouter_L_F_for_halo2_proofs_circuit_NamespacedLayouter_F_L.
  
  Module Impl_core_marker_Send_where_ff_Field_F_where_halo2_proofs_circuit_Layouter_L_F_for_halo2_proofs_circuit_NamespacedLayouter_F_L.
    Definition Self (F L : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::circuit::NamespacedLayouter") [ F; L ].
    
    Axiom Implements :
      forall (F L : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (Self F L)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Send_where_ff_Field_F_where_halo2_proofs_circuit_Layouter_L_F_for_halo2_proofs_circuit_NamespacedLayouter_F_L.
  
  Module Impl_halo2_proofs_circuit_Layouter_where_ff_Field_F_where_halo2_proofs_circuit_Layouter_L_F_F_for_halo2_proofs_circuit_NamespacedLayouter_F_L.
    Definition Self (F L : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::circuit::NamespacedLayouter") [ F; L ].
    
    (*     type Root = L::Root; *)
    Definition _Root (F L : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn assign_region<A, AR, N, NR>(&self, name: N, assignment: A) -> Result<AR, Error>
        where
            A: Fn(&Region<'_, F>) -> Result<AR, Error>,
            N: Fn() -> NR,
            NR: Into<String>,
        {
            self.0.assign_region(name, assignment)
        }
    *)
    Definition assign_region (F L : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F L in
      match τ, α with
      | [ A; AR; N; NR ], [ self; name; assignment ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let name := M.alloc (| name |) in
          let assignment := M.alloc (| assignment |) in
          M.call_closure (|
            M.get_trait_method (|
              "halo2_proofs::circuit::Layouter",
              L,
              [ F ],
              "assign_region",
              [ A; AR; N; NR ]
            |),
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::NamespacedLayouter",
                  0
                |)
              |);
              M.read (| name |);
              M.read (| assignment |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn assign_table<A, N, NR>(&self, name: N, assignment: A) -> Result<(), Error>
        where
            A: Fn(Table<'_, F>) -> Result<(), Error>,
            N: Fn() -> NR,
            NR: Into<String>,
        {
            self.0.assign_table(name, assignment)
        }
    *)
    Definition assign_table (F L : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F L in
      match τ, α with
      | [ A; N; NR ], [ self; name; assignment ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let name := M.alloc (| name |) in
          let assignment := M.alloc (| assignment |) in
          M.call_closure (|
            M.get_trait_method (|
              "halo2_proofs::circuit::Layouter",
              L,
              [ F ],
              "assign_table",
              [ A; N; NR ]
            |),
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::NamespacedLayouter",
                  0
                |)
              |);
              M.read (| name |);
              M.read (| assignment |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn constrain_instance(
            &self,
            cell: Cell,
            column: Column<Instance>,
            row: usize,
        ) -> Result<(), Error> {
            self.0.constrain_instance(cell, column, row)
        }
    *)
    Definition constrain_instance (F L : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F L in
      match τ, α with
      | [], [ self; cell; column; row ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cell := M.alloc (| cell |) in
          let column := M.alloc (| column |) in
          let row := M.alloc (| row |) in
          M.call_closure (|
            M.get_trait_method (|
              "halo2_proofs::circuit::Layouter",
              L,
              [ F ],
              "constrain_instance",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::NamespacedLayouter",
                  0
                |)
              |);
              M.read (| cell |);
              M.read (| column |);
              M.read (| row |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn get_root(&self) -> &Self::Root {
            self.0.get_root()
        }
    *)
    Definition get_root (F L : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F L in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "halo2_proofs::circuit::Layouter", L, [ F ], "get_root", [] |),
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "halo2_proofs::circuit::NamespacedLayouter",
                  0
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn push_namespace<NR, N>(&self, _name_fn: N)
        where
            NR: Into<String>,
            N: FnOnce() -> NR,
        {
            panic!("Only the root's push_namespace should be called");
        }
    *)
    Definition push_namespace (F L : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F L in
      match τ, α with
      | [ NR; N ], [ self; _name_fn ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let _name_fn := M.alloc (| _name_fn |) in
          M.never_to_any (|
            M.call_closure (|
              M.get_function (|
                "std::panicking::begin_panic",
                [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
              |),
              [ M.read (| Value.String "Only the root's push_namespace should be called" |) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn pop_namespace(&self, _gadget_name: Option<String>) {
            panic!("Only the root's pop_namespace should be called");
        }
    *)
    Definition pop_namespace (F L : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F L in
      match τ, α with
      | [], [ self; _gadget_name ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let _gadget_name := M.alloc (| _gadget_name |) in
          M.never_to_any (|
            M.call_closure (|
              M.get_function (|
                "std::panicking::begin_panic",
                [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
              |),
              [ M.read (| Value.String "Only the root's pop_namespace should be called" |) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F L : Ty.t),
      M.IsTraitInstance
        "halo2_proofs::circuit::Layouter"
        (Self F L)
        (* Trait polymorphic types *) [ (* F *) F ]
        (* Instance *)
        [
          ("Root", InstanceField.Ty (_Root F L));
          ("assign_region", InstanceField.Method (assign_region F L));
          ("assign_table", InstanceField.Method (assign_table F L));
          ("constrain_instance", InstanceField.Method (constrain_instance F L));
          ("get_root", InstanceField.Method (get_root F L));
          ("push_namespace", InstanceField.Method (push_namespace F L));
          ("pop_namespace", InstanceField.Method (pop_namespace F L))
        ].
  End Impl_halo2_proofs_circuit_Layouter_where_ff_Field_F_where_halo2_proofs_circuit_Layouter_L_F_F_for_halo2_proofs_circuit_NamespacedLayouter_F_L.
  
  Module Impl_core_ops_drop_Drop_where_ff_Field_F_where_halo2_proofs_circuit_Layouter_L_F_for_halo2_proofs_circuit_NamespacedLayouter_F_L.
    Definition Self (F L : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::circuit::NamespacedLayouter") [ F; L ].
    
    (*
        fn drop(&mut self) {
            let gadget_name = {
                #[cfg(feature = "gadget-traces")]
                {
                    let mut gadget_name = None;
                    let mut is_second_frame = false;
                    backtrace::trace(|frame| {
                        if is_second_frame {
                            // Resolve this instruction pointer to a symbol name.
                            backtrace::resolve_frame(frame, |symbol| {
                                gadget_name = symbol.name().map(|name| format!("{:#}", name));
                            });
    
                            // We are done!
                            false
                        } else {
                            // We want the next frame.
                            is_second_frame = true;
                            true
                        }
                    });
                    gadget_name
                }
    
                #[cfg(not(feature = "gadget-traces"))]
                None
            };
    
            self.get_root().pop_namespace(gadget_name);
        }
    *)
    Definition drop (F L : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F L in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let gadget_name := M.alloc (| Value.StructTuple "core::option::Option::None" [] |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "halo2_proofs::circuit::Layouter",
                    Ty.associated,
                    [ F ],
                    "pop_namespace",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "halo2_proofs::circuit::Layouter",
                        Ty.apply (Ty.path "halo2_proofs::circuit::NamespacedLayouter") [ F; L ],
                        [ F ],
                        "get_root",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| gadget_name |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F L : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (Self F L)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("drop", InstanceField.Method (drop F L)) ].
  End Impl_core_ops_drop_Drop_where_ff_Field_F_where_halo2_proofs_circuit_Layouter_L_F_for_halo2_proofs_circuit_NamespacedLayouter_F_L.
End circuit.
