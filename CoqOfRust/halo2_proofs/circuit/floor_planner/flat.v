(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module circuit.
  Module floor_planner.
    Module flat.
      (* StructTuple
        {
          name := "FlatFloorPlanner";
          ty_params := [];
          fields := [];
        } *)
      
      Module Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_flat_FlatFloorPlanner.
        Definition Self : Ty.t :=
          Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatFloorPlanner".
        
        (* Debug *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
                [ M.read (| f |); M.read (| Value.String "FlatFloorPlanner" |) ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_flat_FlatFloorPlanner.
      
      Module Impl_halo2_proofs_plonk_circuit_FloorPlanner_for_halo2_proofs_circuit_floor_planner_flat_FlatFloorPlanner.
        Definition Self : Ty.t :=
          Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatFloorPlanner".
        
        (*
            fn synthesize<F: Field, CS: Assignment<F>, C: Circuit<F>>(
                cs: &CS,
                circuit: &C,
                config: C::Config,
                constants: Vec<Column<Fixed>>,
            ) -> Result<(), Error> {
                if !cs.is_in_prove_mode() {
                    let layouter = FlatShapeLayouter::new(cs)?;
                    circuit
                        .without_witnesses()
                        .synthesize(config.clone(), layouter.clone())?;
        
                    let mut constants_to_assign = Arc::try_unwrap(layouter.dynamic)
                        .unwrap()
                        .into_inner()
                        .unwrap()
                        .constants_to_assign;
        
                    constants_to_assign.sort_by(|(_, cell_a), (_, cell_b)| {
                        if cell_a.column != cell_b.column {
                            cell_a.column.cmp(&cell_b.column)
                        } else {
                            cell_a.row_offset.cmp(&cell_b.row_offset)
                        }
                    });
        
                    // Assign constants. For the simple floor planner, we assign constants in order in
                    // the first `constants` column.
                    // we assume the first constants starts at zero if constants_to_assign is not empty
                    if constants.is_empty() {
                        if !constants_to_assign.is_empty() {
                            return Err(Error::NotEnoughColumnsForConstants);
                        } else {
                            Ok::<(), Error>(())
                        }
                    } else {
                        let constants_column = constants[0];
                        let mut next_constant_row = 0;
                        for (constant, advice) in constants_to_assign {
                            cs.assign_fixed(
                                || format!("Constant({:?})", constant.evaluate()),
                                constants_column.clone(),
                                next_constant_row,
                                || Ok(constant),
                            )?;
                            cs.copy(
                                constants_column.into(),
                                next_constant_row,
                                advice.column,
                                advice.row_offset,
                            )?;
                            next_constant_row += 1;
                        }
                        Ok(())
                    }?;
                }
        
                let layouter = FlatChipLayouter::new(cs)?;
                circuit.synthesize(config, layouter)?;
                Ok(())
            }
        *)
        Definition synthesize (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ F; CS; C ], [ cs; circuit; config; constants ] =>
            ltac:(M.monadic
              (let cs := M.alloc (| cs |) in
              let circuit := M.alloc (| circuit |) in
              let config := M.alloc (| config |) in
              let constants := M.alloc (| constants |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.Pure.not
                                      (M.call_closure (|
                                        M.get_trait_method (|
                                          "halo2_proofs::plonk::circuit::Assignment",
                                          CS,
                                          [ F ],
                                          "is_in_prove_mode",
                                          []
                                        |),
                                        [ M.read (| cs |) ]
                                      |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let layouter :=
                                M.copy (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter")
                                                [ F; CS ];
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [],
                                          "branch",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter")
                                                [ F; CS ],
                                              "new",
                                              []
                                            |),
                                            [ M.read (| cs |) ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.tuple [];
                                                          Ty.path
                                                            "halo2_proofs::plonk::error::Error"
                                                        ],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.path "core::convert::Infallible";
                                                            Ty.path
                                                              "halo2_proofs::plonk::error::Error"
                                                          ]
                                                      ],
                                                      "from_residual",
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| γ0_0 |) in
                                          val))
                                    ]
                                  |)
                                |) in
                              let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "halo2_proofs::plonk::circuit::Circuit",
                                            C,
                                            [ F ],
                                            "synthesize",
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter")
                                                [ F; CS ]
                                            ]
                                          |),
                                          [
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "halo2_proofs::plonk::circuit::Circuit",
                                                  C,
                                                  [ F ],
                                                  "without_witnesses",
                                                  []
                                                |),
                                                [ M.read (| circuit |) ]
                                              |)
                                            |);
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                Ty.associated,
                                                [],
                                                "clone",
                                                []
                                              |),
                                              [ config ]
                                            |);
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter")
                                                  [ F; CS ],
                                                [],
                                                "clone",
                                                []
                                              |),
                                              [ layouter ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.tuple [];
                                                        Ty.path "halo2_proofs::plonk::error::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path
                                                            "halo2_proofs::plonk::error::Error"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |) in
                              let constants_to_assign :=
                                M.copy (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                                [ F ];
                                              Ty.apply
                                                (Ty.path "std::sync::poison::PoisonError")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                                    [ F ]
                                                ]
                                            ],
                                          "unwrap",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "std::sync::mutex::Mutex")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                                    [ F ]
                                                ],
                                              "into_inner",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "std::sync::mutex::Mutex")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                                            [ F ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path "alloc::sync::Arc")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "std::sync::mutex::Mutex")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                                                [ F ]
                                                            ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ],
                                                  "unwrap",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "alloc::sync::Arc")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "std::sync::mutex::Mutex")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                                                [ F ]
                                                            ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      "try_unwrap",
                                                      []
                                                    |),
                                                    [
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          layouter,
                                                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                                          "dynamic"
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                                    "constants_to_assign"
                                  |)
                                |) in
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                                [ F ];
                                              Ty.path "halo2_proofs::circuit::Cell"
                                            ]
                                        ],
                                      "sort_by",
                                      [
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                          [ F ];
                                                        Ty.path "halo2_proofs::circuit::Cell"
                                                      ]
                                                  ];
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                          [ F ];
                                                        Ty.path "halo2_proofs::circuit::Cell"
                                                      ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.path "core::cmp::Ordering")
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::DerefMut",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::plonk::assigned::Assigned")
                                                    [ F ];
                                                  Ty.path "halo2_proofs::circuit::Cell"
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "deref_mut",
                                          []
                                        |),
                                        [ constants_to_assign ]
                                      |);
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0; α1 ] =>
                                              M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ := M.read (| γ |) in
                                                      let γ1_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ1_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let cell_a := M.alloc (| γ1_1 |) in
                                                      M.match_operator (|
                                                        M.alloc (| α1 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ := M.read (| γ |) in
                                                              let γ1_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ1_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let cell_b := M.alloc (| γ1_1 |) in
                                                              M.read (|
                                                                M.match_operator (|
                                                                  M.alloc (| Value.Tuple [] |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ :=
                                                                          M.use
                                                                            (M.alloc (|
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "core::cmp::PartialEq",
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                                    [
                                                                                      Ty.path
                                                                                        "halo2_proofs::plonk::circuit::Any"
                                                                                    ],
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                                      [
                                                                                        Ty.path
                                                                                          "halo2_proofs::plonk::circuit::Any"
                                                                                      ]
                                                                                  ],
                                                                                  "ne",
                                                                                  []
                                                                                |),
                                                                                [
                                                                                  M.SubPointer.get_struct_record_field (|
                                                                                    M.read (|
                                                                                      cell_a
                                                                                    |),
                                                                                    "halo2_proofs::circuit::Cell",
                                                                                    "column"
                                                                                  |);
                                                                                  M.SubPointer.get_struct_record_field (|
                                                                                    M.read (|
                                                                                      cell_b
                                                                                    |),
                                                                                    "halo2_proofs::circuit::Cell",
                                                                                    "column"
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            |)) in
                                                                        let _ :=
                                                                          M.is_constant_or_break_match (|
                                                                            M.read (| γ |),
                                                                            Value.Bool true
                                                                          |) in
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::cmp::Ord",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                                [
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Any"
                                                                                ],
                                                                              [],
                                                                              "cmp",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.SubPointer.get_struct_record_field (|
                                                                                M.read (| cell_a |),
                                                                                "halo2_proofs::circuit::Cell",
                                                                                "column"
                                                                              |);
                                                                              M.SubPointer.get_struct_record_field (|
                                                                                M.read (| cell_b |),
                                                                                "halo2_proofs::circuit::Cell",
                                                                                "column"
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |)));
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::cmp::Ord",
                                                                              Ty.path "usize",
                                                                              [],
                                                                              "cmp",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.SubPointer.get_struct_record_field (|
                                                                                M.read (| cell_a |),
                                                                                "halo2_proofs::circuit::Cell",
                                                                                "row_offset"
                                                                              |);
                                                                              M.SubPointer.get_struct_record_field (|
                                                                                M.read (| cell_b |),
                                                                                "halo2_proofs::circuit::Cell",
                                                                                "row_offset"
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |)))
                                                                  ]
                                                                |)
                                                              |)))
                                                        ]
                                                      |)))
                                                ]
                                              |)
                                            | _ => M.impossible (||)
                                            end))
                                    ]
                                  |)
                                |) in
                              let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.use
                                                      (M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            "is_empty",
                                                            []
                                                          |),
                                                          [ constants ]
                                                        |)
                                                      |)) in
                                                  let _ :=
                                                    M.is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  M.match_operator (|
                                                    M.alloc (| Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use
                                                              (M.alloc (|
                                                                UnOp.Pure.not
                                                                  (M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        [
                                                                          Ty.tuple
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                                [ F ];
                                                                              Ty.path
                                                                                "halo2_proofs::circuit::Cell"
                                                                            ];
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ],
                                                                      "is_empty",
                                                                      []
                                                                    |),
                                                                    [ constants_to_assign ]
                                                                  |))
                                                              |)) in
                                                          let _ :=
                                                            M.is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (|
                                                                M.return_ (|
                                                                  Value.StructTuple
                                                                    "core::result::Result::Err"
                                                                    [
                                                                      Value.StructTuple
                                                                        "halo2_proofs::plonk::error::Error::NotEnoughColumnsForConstants"
                                                                        []
                                                                    ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (M.alloc (|
                                                            Value.StructTuple
                                                              "core::result::Result::Ok"
                                                              [ Value.Tuple [] ]
                                                          |)))
                                                    ]
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let constants_column :=
                                                    M.copy (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::index::Index",
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          [ Ty.path "usize" ],
                                                          "index",
                                                          []
                                                        |),
                                                        [ constants; Value.Integer 0 ]
                                                      |)
                                                    |) in
                                                  let next_constant_row :=
                                                    M.alloc (| Value.Integer 0 |) in
                                                  let _ :=
                                                    M.use
                                                      (M.match_operator (|
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::iter::traits::collect::IntoIterator",
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::assigned::Assigned")
                                                                        [ F ];
                                                                      Ty.path
                                                                        "halo2_proofs::circuit::Cell"
                                                                    ];
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              [],
                                                              "into_iter",
                                                              []
                                                            |),
                                                            [ M.read (| constants_to_assign |) ]
                                                          |)
                                                        |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let iter := M.copy (| γ |) in
                                                              M.loop (|
                                                                ltac:(M.monadic
                                                                  (let _ :=
                                                                    M.match_operator (|
                                                                      M.alloc (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::iter::traits::iterator::Iterator",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::vec::into_iter::IntoIter")
                                                                              [
                                                                                Ty.tuple
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                                                      [ F ];
                                                                                    Ty.path
                                                                                      "halo2_proofs::circuit::Cell"
                                                                                  ];
                                                                                Ty.path
                                                                                  "alloc::alloc::Global"
                                                                              ],
                                                                            [],
                                                                            "next",
                                                                            []
                                                                          |),
                                                                          [ iter ]
                                                                        |)
                                                                      |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.alloc (|
                                                                              M.never_to_any (|
                                                                                M.read (|
                                                                                  M.break (||)
                                                                                |)
                                                                              |)
                                                                            |)));
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let γ0_0 :=
                                                                              M.SubPointer.get_struct_tuple_field (|
                                                                                γ,
                                                                                "core::option::Option::Some",
                                                                                0
                                                                              |) in
                                                                            let γ1_0 :=
                                                                              M.SubPointer.get_tuple_field (|
                                                                                γ0_0,
                                                                                0
                                                                              |) in
                                                                            let γ1_1 :=
                                                                              M.SubPointer.get_tuple_field (|
                                                                                γ0_0,
                                                                                1
                                                                              |) in
                                                                            let constant :=
                                                                              M.copy (| γ1_0 |) in
                                                                            let advice :=
                                                                              M.copy (| γ1_1 |) in
                                                                            let _ :=
                                                                              M.match_operator (|
                                                                                M.alloc (|
                                                                                  M.call_closure (|
                                                                                    M.get_trait_method (|
                                                                                      "core::ops::try_trait::Try",
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "core::result::Result")
                                                                                        [
                                                                                          Ty.tuple
                                                                                            [];
                                                                                          Ty.path
                                                                                            "halo2_proofs::plonk::error::Error"
                                                                                        ],
                                                                                      [],
                                                                                      "branch",
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.call_closure (|
                                                                                        M.get_trait_method (|
                                                                                          "halo2_proofs::plonk::circuit::Assignment",
                                                                                          CS,
                                                                                          [ F ],
                                                                                          "assign_fixed",
                                                                                          [
                                                                                            Ty.function
                                                                                              [
                                                                                                Ty.tuple
                                                                                                  []
                                                                                              ]
                                                                                              (Ty.apply
                                                                                                (Ty.path
                                                                                                  "core::result::Result")
                                                                                                [
                                                                                                  Ty.apply
                                                                                                    (Ty.path
                                                                                                      "halo2_proofs::plonk::assigned::Assigned")
                                                                                                    [
                                                                                                      F
                                                                                                    ];
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::plonk::error::Error"
                                                                                                ]);
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "halo2_proofs::plonk::assigned::Assigned")
                                                                                              [ F ];
                                                                                            Ty.function
                                                                                              [
                                                                                                Ty.tuple
                                                                                                  []
                                                                                              ]
                                                                                              (Ty.path
                                                                                                "alloc::string::String");
                                                                                            Ty.path
                                                                                              "alloc::string::String"
                                                                                          ]
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            cs
                                                                                          |);
                                                                                          M.closure
                                                                                            (fun
                                                                                                γ =>
                                                                                              ltac:(M.monadic
                                                                                                match
                                                                                                  γ
                                                                                                with
                                                                                                | [
                                                                                                      α0
                                                                                                    ] =>
                                                                                                  M.match_operator (|
                                                                                                    M.alloc (|
                                                                                                      α0
                                                                                                    |),
                                                                                                    [
                                                                                                      fun
                                                                                                          γ =>
                                                                                                        ltac:(M.monadic
                                                                                                          (M.read (|
                                                                                                            let
                                                                                                                  res :=
                                                                                                              M.alloc (|
                                                                                                                M.call_closure (|
                                                                                                                  M.get_function (|
                                                                                                                    "alloc::fmt::format",
                                                                                                                    []
                                                                                                                  |),
                                                                                                                  [
                                                                                                                    M.call_closure (|
                                                                                                                      M.get_associated_function (|
                                                                                                                        Ty.path
                                                                                                                          "core::fmt::Arguments",
                                                                                                                        "new_v1",
                                                                                                                        []
                                                                                                                      |),
                                                                                                                      [
                                                                                                                        (* Unsize *)
                                                                                                                        M.pointer_coercion
                                                                                                                          (M.alloc (|
                                                                                                                            Value.Array
                                                                                                                              [
                                                                                                                                M.read (|
                                                                                                                                  Value.String
                                                                                                                                    "Constant("
                                                                                                                                |);
                                                                                                                                M.read (|
                                                                                                                                  Value.String
                                                                                                                                    ")"
                                                                                                                                |)
                                                                                                                              ]
                                                                                                                          |));
                                                                                                                        (* Unsize *)
                                                                                                                        M.pointer_coercion
                                                                                                                          (M.alloc (|
                                                                                                                            Value.Array
                                                                                                                              [
                                                                                                                                M.call_closure (|
                                                                                                                                  M.get_associated_function (|
                                                                                                                                    Ty.path
                                                                                                                                      "core::fmt::rt::Argument",
                                                                                                                                    "new_debug",
                                                                                                                                    [
                                                                                                                                      F
                                                                                                                                    ]
                                                                                                                                  |),
                                                                                                                                  [
                                                                                                                                    M.alloc (|
                                                                                                                                      M.call_closure (|
                                                                                                                                        M.get_associated_function (|
                                                                                                                                          Ty.apply
                                                                                                                                            (Ty.path
                                                                                                                                              "halo2_proofs::plonk::assigned::Assigned")
                                                                                                                                            [
                                                                                                                                              F
                                                                                                                                            ],
                                                                                                                                          "evaluate",
                                                                                                                                          []
                                                                                                                                        |),
                                                                                                                                        [
                                                                                                                                          M.read (|
                                                                                                                                            constant
                                                                                                                                          |)
                                                                                                                                        ]
                                                                                                                                      |)
                                                                                                                                    |)
                                                                                                                                  ]
                                                                                                                                |)
                                                                                                                              ]
                                                                                                                          |))
                                                                                                                      ]
                                                                                                                    |)
                                                                                                                  ]
                                                                                                                |)
                                                                                                              |) in
                                                                                                            res
                                                                                                          |)))
                                                                                                    ]
                                                                                                  |)
                                                                                                | _ =>
                                                                                                  M.impossible (||)
                                                                                                end));
                                                                                          M.call_closure (|
                                                                                            M.get_trait_method (|
                                                                                              "core::clone::Clone",
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                                                ],
                                                                                              [],
                                                                                              "clone",
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              constants_column
                                                                                            ]
                                                                                          |);
                                                                                          M.read (|
                                                                                            next_constant_row
                                                                                          |);
                                                                                          M.closure
                                                                                            (fun
                                                                                                γ =>
                                                                                              ltac:(M.monadic
                                                                                                match
                                                                                                  γ
                                                                                                with
                                                                                                | [
                                                                                                      α0
                                                                                                    ] =>
                                                                                                  M.match_operator (|
                                                                                                    M.alloc (|
                                                                                                      α0
                                                                                                    |),
                                                                                                    [
                                                                                                      fun
                                                                                                          γ =>
                                                                                                        ltac:(M.monadic
                                                                                                          (Value.StructTuple
                                                                                                            "core::result::Result::Ok"
                                                                                                            [
                                                                                                              M.read (|
                                                                                                                constant
                                                                                                              |)
                                                                                                            ]))
                                                                                                    ]
                                                                                                  |)
                                                                                                | _ =>
                                                                                                  M.impossible (||)
                                                                                                end))
                                                                                        ]
                                                                                      |)
                                                                                    ]
                                                                                  |)
                                                                                |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ0_0 :=
                                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                                          γ,
                                                                                          "core::ops::control_flow::ControlFlow::Break",
                                                                                          0
                                                                                        |) in
                                                                                      let
                                                                                            residual :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      M.alloc (|
                                                                                        M.never_to_any (|
                                                                                          M.read (|
                                                                                            M.return_ (|
                                                                                              M.call_closure (|
                                                                                                M.get_trait_method (|
                                                                                                  "core::ops::try_trait::FromResidual",
                                                                                                  Ty.apply
                                                                                                    (Ty.path
                                                                                                      "core::result::Result")
                                                                                                    [
                                                                                                      Ty.tuple
                                                                                                        [];
                                                                                                      Ty.path
                                                                                                        "halo2_proofs::plonk::error::Error"
                                                                                                    ],
                                                                                                  [
                                                                                                    Ty.apply
                                                                                                      (Ty.path
                                                                                                        "core::result::Result")
                                                                                                      [
                                                                                                        Ty.path
                                                                                                          "core::convert::Infallible";
                                                                                                        Ty.path
                                                                                                          "halo2_proofs::plonk::error::Error"
                                                                                                      ]
                                                                                                  ],
                                                                                                  "from_residual",
                                                                                                  []
                                                                                                |),
                                                                                                [
                                                                                                  M.read (|
                                                                                                    residual
                                                                                                  |)
                                                                                                ]
                                                                                              |)
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      |)));
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ0_0 :=
                                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                                          γ,
                                                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                                                          0
                                                                                        |) in
                                                                                      let val :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      val))
                                                                                ]
                                                                              |) in
                                                                            let _ :=
                                                                              M.match_operator (|
                                                                                M.alloc (|
                                                                                  M.call_closure (|
                                                                                    M.get_trait_method (|
                                                                                      "core::ops::try_trait::Try",
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "core::result::Result")
                                                                                        [
                                                                                          Ty.tuple
                                                                                            [];
                                                                                          Ty.path
                                                                                            "halo2_proofs::plonk::error::Error"
                                                                                        ],
                                                                                      [],
                                                                                      "branch",
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.call_closure (|
                                                                                        M.get_trait_method (|
                                                                                          "halo2_proofs::plonk::circuit::Assignment",
                                                                                          CS,
                                                                                          [ F ],
                                                                                          "copy",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            cs
                                                                                          |);
                                                                                          M.call_closure (|
                                                                                            M.get_trait_method (|
                                                                                              "core::convert::Into",
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                                                ],
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                                                  [
                                                                                                    Ty.path
                                                                                                      "halo2_proofs::plonk::circuit::Any"
                                                                                                  ]
                                                                                              ],
                                                                                              "into",
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              M.read (|
                                                                                                constants_column
                                                                                              |)
                                                                                            ]
                                                                                          |);
                                                                                          M.read (|
                                                                                            next_constant_row
                                                                                          |);
                                                                                          M.read (|
                                                                                            M.SubPointer.get_struct_record_field (|
                                                                                              advice,
                                                                                              "halo2_proofs::circuit::Cell",
                                                                                              "column"
                                                                                            |)
                                                                                          |);
                                                                                          M.read (|
                                                                                            M.SubPointer.get_struct_record_field (|
                                                                                              advice,
                                                                                              "halo2_proofs::circuit::Cell",
                                                                                              "row_offset"
                                                                                            |)
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    ]
                                                                                  |)
                                                                                |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ0_0 :=
                                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                                          γ,
                                                                                          "core::ops::control_flow::ControlFlow::Break",
                                                                                          0
                                                                                        |) in
                                                                                      let
                                                                                            residual :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      M.alloc (|
                                                                                        M.never_to_any (|
                                                                                          M.read (|
                                                                                            M.return_ (|
                                                                                              M.call_closure (|
                                                                                                M.get_trait_method (|
                                                                                                  "core::ops::try_trait::FromResidual",
                                                                                                  Ty.apply
                                                                                                    (Ty.path
                                                                                                      "core::result::Result")
                                                                                                    [
                                                                                                      Ty.tuple
                                                                                                        [];
                                                                                                      Ty.path
                                                                                                        "halo2_proofs::plonk::error::Error"
                                                                                                    ],
                                                                                                  [
                                                                                                    Ty.apply
                                                                                                      (Ty.path
                                                                                                        "core::result::Result")
                                                                                                      [
                                                                                                        Ty.path
                                                                                                          "core::convert::Infallible";
                                                                                                        Ty.path
                                                                                                          "halo2_proofs::plonk::error::Error"
                                                                                                      ]
                                                                                                  ],
                                                                                                  "from_residual",
                                                                                                  []
                                                                                                |),
                                                                                                [
                                                                                                  M.read (|
                                                                                                    residual
                                                                                                  |)
                                                                                                ]
                                                                                              |)
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      |)));
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ0_0 :=
                                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                                          γ,
                                                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                                                          0
                                                                                        |) in
                                                                                      let val :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      val))
                                                                                ]
                                                                              |) in
                                                                            let _ :=
                                                                              let β :=
                                                                                next_constant_row in
                                                                              M.write (|
                                                                                β,
                                                                                BinOp.Panic.add (|
                                                                                  Integer.Usize,
                                                                                  M.read (| β |),
                                                                                  Value.Integer 1
                                                                                |)
                                                                              |) in
                                                                            M.alloc (|
                                                                              Value.Tuple []
                                                                            |)))
                                                                      ]
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                              |)))
                                                        ]
                                                      |)) in
                                                  M.alloc (|
                                                    Value.StructTuple
                                                      "core::result::Result::Ok"
                                                      [ Value.Tuple [] ]
                                                  |)))
                                            ]
                                          |)
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.tuple [];
                                                        Ty.path "halo2_proofs::plonk::error::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path
                                                            "halo2_proofs::plonk::error::Error"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let layouter :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter")
                                      [ F; CS ];
                                    Ty.path "halo2_proofs::plonk::error::Error"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter")
                                      [ F; CS ],
                                    "new",
                                    []
                                  |),
                                  [ M.read (| cs |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.tuple [];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::plonk::circuit::Circuit",
                                  C,
                                  [ F ],
                                  "synthesize",
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter")
                                      [ F; CS ]
                                  ]
                                |),
                                [ M.read (| circuit |); M.read (| config |); M.read (| layouter |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.tuple [];
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "halo2_proofs::plonk::circuit::FloorPlanner"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("synthesize", InstanceField.Method synthesize) ].
      End Impl_halo2_proofs_plonk_circuit_FloorPlanner_for_halo2_proofs_circuit_floor_planner_flat_FlatFloorPlanner.
      
      (* StructRecord
        {
          name := "FlatShapeDynamic";
          ty_params := [ "F" ];
          fields :=
            [
              ("constants_to_assign",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
                        Ty.path "halo2_proofs::circuit::Cell"
                      ];
                    Ty.path "alloc::alloc::Global"
                  ]);
              ("nb_regions", Ty.path "usize");
              ("table_columns",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                    Ty.path "alloc::alloc::Global"
                  ]);
              ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ F ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeDynamic_F.
        Definition Self (F : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic") [ F ].
        
        (* Debug *)
        Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field4_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "FlatShapeDynamic" |);
                  M.read (| Value.String "constants_to_assign" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                      "constants_to_assign"
                    |));
                  M.read (| Value.String "nb_regions" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                      "nb_regions"
                    |));
                  M.read (| Value.String "table_columns" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                      "table_columns"
                    |));
                  M.read (| Value.String "_marker" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                        "_marker"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeDynamic_F.
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeDynamic_F.
        Definition Self (F : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic") [ F ].
        
        (* Clone *)
        Definition clone (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic"
                [
                  ("constants_to_assign",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
                                Ty.path "halo2_proofs::circuit::Cell"
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                          "constants_to_assign"
                        |)
                      ]
                    |));
                  ("nb_regions",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.path "usize",
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                          "nb_regions"
                        |)
                      ]
                    |));
                  ("table_columns",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                          "table_columns"
                        |)
                      ]
                    |));
                  ("_marker",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply (Ty.path "core::marker::PhantomData") [ F ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                          "_marker"
                        |)
                      ]
                    |))
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self F)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
      End Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeDynamic_F.
      
      (* StructRecord
        {
          name := "FlatShapeLayouter";
          ty_params := [ "F"; "CS" ];
          fields :=
            [
              ("cs", Ty.apply (Ty.path "&") [ CS ]);
              ("dynamic",
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  [
                    Ty.apply
                      (Ty.path "std::sync::mutex::Mutex")
                      [
                        Ty.apply
                          (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                          [ F ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ])
            ];
        } *)
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_where_core_clone_Clone_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter")
            [ F; CS ].
        
        (* Clone *)
        Definition clone (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter"
                [
                  ("cs",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply (Ty.path "&") [ CS ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                          "cs"
                        |)
                      ]
                    |));
                  ("dynamic",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          [
                            Ty.apply
                              (Ty.path "std::sync::mutex::Mutex")
                              [
                                Ty.apply
                                  (Ty.path
                                    "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                  [ F ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                          "dynamic"
                        |)
                      ]
                    |))
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone F CS)) ].
      End Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_where_core_clone_Clone_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeLayouter_F_CS.
      
      Module Impl_core_marker_Send_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter")
            [ F; CS ].
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::marker::Send"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Send_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeLayouter_F_CS.
      
      Module Impl_core_fmt_Debug_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter")
            [ F; CS ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                let dynamic = self.dynamic.lock().unwrap();
                f.debug_struct("FlatChipLayouter")
                    .field("nb_regions", &dynamic.nb_regions)
                    .finish()
            }
        *)
        Definition fmt (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let dynamic :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          [
                            Ty.apply
                              (Ty.path "std::sync::mutex::MutexGuard")
                              [
                                Ty.apply
                                  (Ty.path
                                    "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                  [ F ]
                              ];
                            Ty.apply
                              (Ty.path "std::sync::poison::PoisonError")
                              [
                                Ty.apply
                                  (Ty.path "std::sync::mutex::MutexGuard")
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                      [ F ]
                                  ]
                              ]
                          ],
                        "unwrap",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "std::sync::mutex::Mutex")
                              [
                                Ty.apply
                                  (Ty.path
                                    "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                  [ F ]
                              ],
                            "lock",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "alloc::sync::Arc")
                                  [
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::Mutex")
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                          [ F ]
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "deref",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                  "dynamic"
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      "finish",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugStruct",
                          "field",
                          []
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_struct",
                                []
                              |),
                              [ M.read (| f |); M.read (| Value.String "FlatChipLayouter" |) ]
                            |)
                          |);
                          M.read (| Value.String "nb_regions" |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::MutexGuard")
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                        [ F ]
                                    ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ dynamic ]
                              |),
                              "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                              "nb_regions"
                            |))
                        ]
                      |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F CS)) ].
      End Impl_core_fmt_Debug_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeLayouter_F_CS.
      
      Module Impl_halo2_proofs_circuit_floor_planner_flat_FlatShapeLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter")
            [ F; CS ].
        
        (*
            pub fn new(cs: &'a CS) -> Result<Self, Error> {
                let ret = FlatShapeLayouter {
                    cs,
                    dynamic: Arc::new(Mutex::new(FlatShapeDynamic {
                        nb_regions: 0,
                        table_columns: vec![],
                        constants_to_assign: vec![],
                        _marker: PhantomData,
                    })),
                };
                Ok(ret)
            }
        *)
        Definition new (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ cs ] =>
            ltac:(M.monadic
              (let cs := M.alloc (| cs |) in
              M.read (|
                let ret :=
                  M.alloc (|
                    Value.StructRecord
                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter"
                      [
                        ("cs", M.read (| cs |));
                        ("dynamic",
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                [
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::Mutex")
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                        [ F ]
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "new",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::Mutex")
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                        [ F ]
                                    ],
                                  "new",
                                  []
                                |),
                                [
                                  Value.StructRecord
                                    "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic"
                                    [
                                      ("nb_regions", Value.Integer 0);
                                      ("table_columns",
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            "new",
                                            []
                                          |),
                                          []
                                        |));
                                      ("constants_to_assign",
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ];
                                                    Ty.path "halo2_proofs::circuit::Cell"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            "new",
                                            []
                                          |),
                                          []
                                        |));
                                      ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                                    ]
                                ]
                              |)
                            ]
                          |))
                      ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| ret |) ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "new" (new F CS).
      End Impl_halo2_proofs_circuit_floor_planner_flat_FlatShapeLayouter_F_CS.
      
      Module Impl_halo2_proofs_circuit_Layouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter")
            [ F; CS ].
        
        (*     type Root = Self; *)
        Definition _Root (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter")
            [ F; CS ].
        
        (*
            fn assign_region<A, AR, N, NR>(&self, name: N, assignment: A) -> Result<AR, Error>
            where
                A: Fn(&Region<F>) -> Result<AR, Error>,
                N: Fn() -> NR,
                NR: Into<String>,
            {
                let mut dynamic = self.dynamic.lock().unwrap();
                let region_index = dynamic.nb_regions;
                dynamic.nb_regions += 1;
                drop(dynamic);
        
                let name = name().into();
        
                self.cs.enter_region(|| name.clone());
        
                // Get shape of the region.
                let shape = region::RegionSetup::new(region_index.into());
                let shared_region = Parallel::new(shape);
        
                let region: &dyn RegionLayouter<F> = &shared_region;
                let result = assignment(&region.into())?;
                self.cs.exit_region();
        
                let mut shape = shared_region.into_inner();
        
                let mut dynamic = self.dynamic.lock().unwrap();
                dynamic.constants_to_assign.append(&mut shape.constants);
        
                Ok(result)
            }
        *)
        Definition assign_region (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ A; AR; N; NR ], [ self; name; assignment ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name := M.alloc (| name |) in
              let assignment := M.alloc (| assignment |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let dynamic :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "std::sync::mutex::MutexGuard")
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                      [ F ]
                                  ];
                                Ty.apply
                                  (Ty.path "std::sync::poison::PoisonError")
                                  [
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::MutexGuard")
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                          [ F ]
                                      ]
                                  ]
                              ],
                            "unwrap",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "std::sync::mutex::Mutex")
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                      [ F ]
                                  ],
                                "lock",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "std::sync::mutex::Mutex")
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                              [ F ]
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                      "dynamic"
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let region_index :=
                      M.copy (|
                        M.SubPointer.get_struct_record_field (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "std::sync::mutex::MutexGuard")
                                [
                                  Ty.apply
                                    (Ty.path
                                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                    [ F ]
                                ],
                              [],
                              "deref",
                              []
                            |),
                            [ dynamic ]
                          |),
                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                          "nb_regions"
                        |)
                      |) in
                    let _ :=
                      let β :=
                        M.SubPointer.get_struct_record_field (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::DerefMut",
                              Ty.apply
                                (Ty.path "std::sync::mutex::MutexGuard")
                                [
                                  Ty.apply
                                    (Ty.path
                                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                    [ F ]
                                ],
                              [],
                              "deref_mut",
                              []
                            |),
                            [ dynamic ]
                          |),
                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                          "nb_regions"
                        |) in
                      M.write (|
                        β,
                        BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::mem::drop",
                            [
                              Ty.apply
                                (Ty.path "std::sync::mutex::MutexGuard")
                                [
                                  Ty.apply
                                    (Ty.path
                                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                    [ F ]
                                ]
                            ]
                          |),
                          [ M.read (| dynamic |) ]
                        |)
                      |) in
                    let name :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::convert::Into",
                            NR,
                            [ Ty.path "alloc::string::String" ],
                            "into",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::Fn",
                                N,
                                [ Ty.tuple [] ],
                                "call",
                                []
                              |),
                              [ name; Value.Tuple [] ]
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "halo2_proofs::plonk::circuit::Assignment",
                            CS,
                            [ F ],
                            "enter_region",
                            [
                              Ty.path "alloc::string::String";
                              Ty.function [ Ty.tuple [] ] (Ty.path "alloc::string::String")
                            ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                "cs"
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.call_closure (|
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                Ty.path "alloc::string::String",
                                                [],
                                                "clone",
                                                []
                                              |),
                                              [ name ]
                                            |)))
                                      ]
                                    |)
                                  | _ => M.impossible (||)
                                  end))
                          ]
                        |)
                      |) in
                    let shape :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path
                                "halo2_proofs::circuit::floor_planner::flat::region::RegionSetup")
                              [ F ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::convert::Into",
                                Ty.path "usize",
                                [ Ty.path "halo2_proofs::circuit::RegionIndex" ],
                                "into",
                                []
                              |),
                              [ M.read (| region_index |) ]
                            |)
                          ]
                        |)
                      |) in
                    let shared_region :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::parallel::Parallel")
                              [
                                Ty.apply
                                  (Ty.path
                                    "halo2_proofs::circuit::floor_planner::flat::region::RegionSetup")
                                  [ F ]
                              ],
                            "new",
                            []
                          |),
                          [ M.read (| shape |) ]
                        |)
                      |) in
                    let region := M.alloc (| (* Unsize *) M.pointer_coercion shared_region |) in
                    let result :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ AR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::function::Fn",
                                    A,
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::circuit::Region")
                                                [ F ]
                                            ]
                                        ]
                                    ],
                                    "call",
                                    []
                                  |),
                                  [
                                    assignment;
                                    Value.Tuple
                                      [
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::convert::Into",
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.dyn
                                                    [
                                                      ("halo2_proofs::circuit::layouter::RegionLayouter::Trait",
                                                        [])
                                                    ]
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::circuit::Region")
                                                  [ F ]
                                              ],
                                              "into",
                                              []
                                            |),
                                            [ M.read (| region |) ]
                                          |)
                                        |)
                                      ]
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ AR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "halo2_proofs::plonk::circuit::Assignment",
                            CS,
                            [ F ],
                            "exit_region",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                "cs"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let shape :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::parallel::Parallel")
                              [
                                Ty.apply
                                  (Ty.path
                                    "halo2_proofs::circuit::floor_planner::flat::region::RegionSetup")
                                  [ F ]
                              ],
                            "into_inner",
                            []
                          |),
                          [ M.read (| shared_region |) ]
                        |)
                      |) in
                    let dynamic :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "std::sync::mutex::MutexGuard")
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                      [ F ]
                                  ];
                                Ty.apply
                                  (Ty.path "std::sync::poison::PoisonError")
                                  [
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::MutexGuard")
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                          [ F ]
                                      ]
                                  ]
                              ],
                            "unwrap",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "std::sync::mutex::Mutex")
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                      [ F ]
                                  ],
                                "lock",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "std::sync::mutex::Mutex")
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                              [ F ]
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                      "dynamic"
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                      [ F ];
                                    Ty.path "halo2_proofs::circuit::Cell"
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "append",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::MutexGuard")
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                        [ F ]
                                    ],
                                  [],
                                  "deref_mut",
                                  []
                                |),
                                [ dynamic ]
                              |),
                              "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                              "constants_to_assign"
                            |);
                            M.SubPointer.get_struct_record_field (|
                              shape,
                              "halo2_proofs::circuit::floor_planner::flat::region::RegionSetup",
                              "constants"
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| result |) ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_table<A, N, NR>(&self, name: N, assignment: A) -> Result<(), Error>
            where
                A: Fn(Table<F>) -> Result<(), Error>,
                N: Fn() -> NR,
                NR: Into<String>,
            {
                // Maintenance hazard: there is near-duplicate code in `v1::AssignmentPass::assign_table`.
                // Assign table cells.
                let name = name().into();
        
                let mut dynamic = self.dynamic.lock().unwrap();
                self.cs.enter_region(|| name.clone());
                let table = SimpleTableLayouter::new(self.cs, &dynamic.table_columns);
                {
                    let table: &dyn TableLayouter<F> = &table;
                    assignment(table.into())
                }?;
        
                let default_and_assigned = table.default_and_assigned.lock().unwrap().clone();
                self.cs.exit_region();
        
                // Check that all table columns have the same length `first_unused`,
                // and all cells up to that length are assigned.
                let first_unused = {
                    match default_and_assigned
                        .values()
                        .map(|(_, assigned)| {
                            if assigned.iter().all(|b| *b) {
                                Some(assigned.len())
                            } else {
                                None
                            }
                        })
                        .reduce(|acc, item| match (acc, item) {
                            (Some(a), Some(b)) if a == b => Some(a),
                            _ => None,
                        }) {
                        Some(Some(len)) => len,
                        _ => return Err(Error::Synthesis), // TODO better error
                    }
                };
        
                // Record these columns so that we can prevent them from being used again.
                for column in default_and_assigned.keys() {
                    dynamic.table_columns.push( *column);
                }
        
                for (col, (default_val, _)) in default_and_assigned.iter() {
                    // default_val must be Some because we must have assigned
                    // at least one cell in each column, and in that case we checked
                    // that all cells up to first_unused were assigned.
                    self.cs
                        .fill_from_row(col.inner(), first_unused, default_val.unwrap())?;
                }
        
                Ok(())
            }
        *)
        Definition assign_table (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ A; N; NR ], [ self; name; assignment ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name := M.alloc (| name |) in
              let assignment := M.alloc (| assignment |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let name :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::convert::Into",
                            NR,
                            [ Ty.path "alloc::string::String" ],
                            "into",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::Fn",
                                N,
                                [ Ty.tuple [] ],
                                "call",
                                []
                              |),
                              [ name; Value.Tuple [] ]
                            |)
                          ]
                        |)
                      |) in
                    let dynamic :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "std::sync::mutex::MutexGuard")
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                      [ F ]
                                  ];
                                Ty.apply
                                  (Ty.path "std::sync::poison::PoisonError")
                                  [
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::MutexGuard")
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                          [ F ]
                                      ]
                                  ]
                              ],
                            "unwrap",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "std::sync::mutex::Mutex")
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                      [ F ]
                                  ],
                                "lock",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "std::sync::mutex::Mutex")
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                              [ F ]
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                      "dynamic"
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "halo2_proofs::plonk::circuit::Assignment",
                            CS,
                            [ F ],
                            "enter_region",
                            [
                              Ty.path "alloc::string::String";
                              Ty.function [ Ty.tuple [] ] (Ty.path "alloc::string::String")
                            ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                "cs"
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.call_closure (|
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                Ty.path "alloc::string::String",
                                                [],
                                                "clone",
                                                []
                                              |),
                                              [ name ]
                                            |)))
                                      ]
                                    |)
                                  | _ => M.impossible (||)
                                  end))
                          ]
                        |)
                      |) in
                    let table :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path
                                "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter")
                              [ F; CS ],
                            "new",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                "cs"
                              |)
                            |);
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "deref",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "std::sync::mutex::MutexGuard")
                                        [
                                          Ty.apply
                                            (Ty.path
                                              "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                            [ F ]
                                        ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [ dynamic ]
                                  |),
                                  "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                                  "table_columns"
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.read (|
                                let table := M.alloc (| (* Unsize *) M.pointer_coercion table |) in
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::function::Fn",
                                      A,
                                      [
                                        Ty.tuple
                                          [ Ty.apply (Ty.path "halo2_proofs::circuit::Table") [ F ]
                                          ]
                                      ],
                                      "call",
                                      []
                                    |),
                                    [
                                      assignment;
                                      Value.Tuple
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::convert::Into",
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.dyn
                                                    [
                                                      ("halo2_proofs::circuit::layouter::TableLayouter::Trait",
                                                        [])
                                                    ]
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::circuit::Table")
                                                  [ F ]
                                              ],
                                              "into",
                                              []
                                            |),
                                            [ M.read (| table |) ]
                                          |)
                                        ]
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.tuple [];
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    let default_and_assigned :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply
                              (Ty.path "std::collections::hash::map::HashMap")
                              [
                                Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                              [ F ]
                                          ]
                                      ];
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                  ];
                                Ty.path "std::hash::random::RandomState"
                              ],
                            [],
                            "clone",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "std::sync::mutex::MutexGuard")
                                  [
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ]
                                                  ]
                                              ];
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                          ];
                                        Ty.path "std::hash::random::RandomState"
                                      ]
                                  ],
                                [],
                                "deref",
                                []
                              |),
                              [
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.apply
                                            (Ty.path "std::sync::mutex::MutexGuard")
                                            [
                                              Ty.apply
                                                (Ty.path "std::collections::hash::map::HashMap")
                                                [
                                                  Ty.path
                                                    "halo2_proofs::plonk::circuit::TableColumn";
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                [ F ]
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "bool";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ];
                                                  Ty.path "std::hash::random::RandomState"
                                                ]
                                            ];
                                          Ty.apply
                                            (Ty.path "std::sync::poison::PoisonError")
                                            [
                                              Ty.apply
                                                (Ty.path "std::sync::mutex::MutexGuard")
                                                [
                                                  Ty.apply
                                                    (Ty.path "std::collections::hash::map::HashMap")
                                                    [
                                                      Ty.path
                                                        "halo2_proofs::plonk::circuit::TableColumn";
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::assigned::Assigned")
                                                                    [ F ]
                                                                ]
                                                            ];
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            [
                                                              Ty.path "bool";
                                                              Ty.path "alloc::alloc::Global"
                                                            ]
                                                        ];
                                                      Ty.path "std::hash::random::RandomState"
                                                    ]
                                                ]
                                            ]
                                        ],
                                      "unwrap",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "halo2_proofs::parallel::Parallel")
                                            [
                                              Ty.apply
                                                (Ty.path "std::collections::hash::map::HashMap")
                                                [
                                                  Ty.path
                                                    "halo2_proofs::plonk::circuit::TableColumn";
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                [ F ]
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "bool";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ];
                                                  Ty.path "std::hash::random::RandomState"
                                                ]
                                            ],
                                          "lock",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            table,
                                            "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter",
                                            "default_and_assigned"
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "halo2_proofs::plonk::circuit::Assignment",
                            CS,
                            [ F ],
                            "exit_region",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                "cs"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let first_unused :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::map::Map")
                                  [
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::Values")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ]
                                                  ]
                                              ];
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                          ]
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::assigned::Assigned")
                                                              [ F ]
                                                          ]
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [
                                                        Ty.path "bool";
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                          ]
                                      ]
                                      (Ty.apply
                                        (Ty.path "core::option::Option")
                                        [ Ty.path "usize" ])
                                  ],
                                [],
                                "reduce",
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "usize" ];
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "usize" ]
                                        ]
                                    ]
                                    (Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ])
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::Values")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ]
                                                  ]
                                              ];
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                          ]
                                      ],
                                    [],
                                    "map",
                                    [
                                      Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ];
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                [ F ]
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "bool";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                        (Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "usize" ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::HashMap")
                                          [
                                            Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                          [ F ]
                                                      ]
                                                  ];
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                              ];
                                            Ty.path "std::hash::random::RandomState"
                                          ],
                                        "values",
                                        []
                                      |),
                                      [ default_and_assigned ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ := M.read (| γ |) in
                                                    let γ1_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ1_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let assigned := M.alloc (| γ1_1 |) in
                                                    M.read (|
                                                      M.match_operator (|
                                                        M.alloc (| Value.Tuple [] |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ :=
                                                                M.use
                                                                  (M.alloc (|
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::iter::traits::iterator::Iterator",
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::slice::iter::Iter")
                                                                          [ Ty.path "bool" ],
                                                                        [],
                                                                        "all",
                                                                        [
                                                                          Ty.function
                                                                            [
                                                                              Ty.tuple
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path "&")
                                                                                    [ Ty.path "bool"
                                                                                    ]
                                                                                ]
                                                                            ]
                                                                            (Ty.path "bool")
                                                                        ]
                                                                      |),
                                                                      [
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.apply
                                                                                (Ty.path "slice")
                                                                                [ Ty.path "bool" ],
                                                                              "iter",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "core::ops::deref::Deref",
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::vec::Vec")
                                                                                    [
                                                                                      Ty.path
                                                                                        "bool";
                                                                                      Ty.path
                                                                                        "alloc::alloc::Global"
                                                                                    ],
                                                                                  [],
                                                                                  "deref",
                                                                                  []
                                                                                |),
                                                                                [
                                                                                  M.read (|
                                                                                    assigned
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |);
                                                                        M.closure
                                                                          (fun γ =>
                                                                            ltac:(M.monadic
                                                                              match γ with
                                                                              | [ α0 ] =>
                                                                                M.match_operator (|
                                                                                  M.alloc (| α0 |),
                                                                                  [
                                                                                    fun γ =>
                                                                                      ltac:(M.monadic
                                                                                        (let b :=
                                                                                          M.copy (|
                                                                                            γ
                                                                                          |) in
                                                                                        M.read (|
                                                                                          M.read (|
                                                                                            b
                                                                                          |)
                                                                                        |)))
                                                                                  ]
                                                                                |)
                                                                              | _ =>
                                                                                M.impossible (||)
                                                                              end))
                                                                      ]
                                                                    |)
                                                                  |)) in
                                                              let _ :=
                                                                M.is_constant_or_break_match (|
                                                                  M.read (| γ |),
                                                                  Value.Bool true
                                                                |) in
                                                              M.alloc (|
                                                                Value.StructTuple
                                                                  "core::option::Option::Some"
                                                                  [
                                                                    M.call_closure (|
                                                                      M.get_associated_function (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::vec::Vec")
                                                                          [
                                                                            Ty.path "bool";
                                                                            Ty.path
                                                                              "alloc::alloc::Global"
                                                                          ],
                                                                        "len",
                                                                        []
                                                                      |),
                                                                      [ M.read (| assigned |) ]
                                                                    |)
                                                                  ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.alloc (|
                                                                Value.StructTuple
                                                                  "core::option::Option::None"
                                                                  []
                                                              |)))
                                                        ]
                                                      |)
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0; α1 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let acc := M.copy (| γ |) in
                                                M.match_operator (|
                                                  M.alloc (| α1 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let item := M.copy (| γ |) in
                                                        M.read (|
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              Value.Tuple
                                                                [
                                                                  M.read (| acc |);
                                                                  M.read (| item |)
                                                                ]
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      0
                                                                    |) in
                                                                  let γ0_1 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      1
                                                                    |) in
                                                                  let γ1_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ0_0,
                                                                      "core::option::Option::Some",
                                                                      0
                                                                    |) in
                                                                  let a := M.copy (| γ1_0 |) in
                                                                  let γ1_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ0_1,
                                                                      "core::option::Option::Some",
                                                                      0
                                                                    |) in
                                                                  let b := M.copy (| γ1_0 |) in
                                                                  let γ :=
                                                                    M.alloc (|
                                                                      BinOp.Pure.eq
                                                                        (M.read (| a |))
                                                                        (M.read (| b |))
                                                                    |) in
                                                                  let _ :=
                                                                    M.is_constant_or_break_match (|
                                                                      M.read (| γ |),
                                                                      Value.Bool true
                                                                    |) in
                                                                  M.alloc (|
                                                                    Value.StructTuple
                                                                      "core::option::Option::Some"
                                                                      [ M.read (| a |) ]
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (M.alloc (|
                                                                    Value.StructTuple
                                                                      "core::option::Option::None"
                                                                      []
                                                                  |)))
                                                            ]
                                                          |)
                                                        |)))
                                                  ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end))
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ0_0,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let len := M.copy (| γ1_0 |) in
                                len));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [
                                            Value.StructTuple
                                              "halo2_proofs::plonk::error::Error::Synthesis"
                                              []
                                          ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "std::collections::hash::map::Keys")
                                  [
                                    Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                  [ F ]
                                              ]
                                          ];
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                      ]
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ]
                                                  ]
                                              ];
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                          ];
                                        Ty.path "std::hash::random::RandomState"
                                      ],
                                    "keys",
                                    []
                                  |),
                                  [ default_and_assigned ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "std::collections::hash::map::Keys")
                                                [
                                                  Ty.path
                                                    "halo2_proofs::plonk::circuit::TableColumn";
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                [ F ]
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "bool";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ]
                                                ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let column := M.copy (| γ0_0 |) in
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::plonk::circuit::TableColumn";
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      "push",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::DerefMut",
                                                            Ty.apply
                                                              (Ty.path
                                                                "std::sync::mutex::MutexGuard")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic")
                                                                  [ F ]
                                                              ],
                                                            [],
                                                            "deref_mut",
                                                            []
                                                          |),
                                                          [ dynamic ]
                                                        |),
                                                        "halo2_proofs::circuit::floor_planner::flat::FlatShapeDynamic",
                                                        "table_columns"
                                                      |);
                                                      M.read (| M.read (| column |) |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    let _ :=
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "std::collections::hash::map::Iter")
                                  [
                                    Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                  [ F ]
                                              ]
                                          ];
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                      ]
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ]
                                                  ]
                                              ];
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                          ];
                                        Ty.path "std::hash::random::RandomState"
                                      ],
                                    "iter",
                                    []
                                  |),
                                  [ default_and_assigned ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "std::collections::hash::map::Iter")
                                                [
                                                  Ty.path
                                                    "halo2_proofs::plonk::circuit::TableColumn";
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                [ F ]
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "bool";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ]
                                                ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                              let col := M.copy (| γ1_0 |) in
                                              let γ1_1 := M.read (| γ1_1 |) in
                                              let γ3_0 :=
                                                M.SubPointer.get_tuple_field (| γ1_1, 0 |) in
                                              let γ3_1 :=
                                                M.SubPointer.get_tuple_field (| γ1_1, 1 |) in
                                              let default_val := M.alloc (| γ3_0 |) in
                                              let _ :=
                                                M.match_operator (|
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::Try",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.tuple [];
                                                            Ty.path
                                                              "halo2_proofs::plonk::error::Error"
                                                          ],
                                                        [],
                                                        "branch",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "halo2_proofs::plonk::circuit::Assignment",
                                                            CS,
                                                            [ F ],
                                                            "fill_from_row",
                                                            []
                                                          |),
                                                          [
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.read (| self |),
                                                                "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                                                                "cs"
                                                              |)
                                                            |);
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::TableColumn",
                                                                "inner",
                                                                []
                                                              |),
                                                              [ M.read (| col |) ]
                                                            |);
                                                            M.read (| first_unused |);
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                                          [ F ]
                                                                      ]
                                                                  ],
                                                                "unwrap",
                                                                []
                                                              |),
                                                              [
                                                                M.read (|
                                                                  M.read (| default_val |)
                                                                |)
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ,
                                                            "core::ops::control_flow::ControlFlow::Break",
                                                            0
                                                          |) in
                                                        let residual := M.copy (| γ0_0 |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              M.return_ (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::try_trait::FromResidual",
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.tuple [];
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::error::Error"
                                                                      ],
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::result::Result")
                                                                        [
                                                                          Ty.path
                                                                            "core::convert::Infallible";
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::error::Error"
                                                                        ]
                                                                    ],
                                                                    "from_residual",
                                                                    []
                                                                  |),
                                                                  [ M.read (| residual |) ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ,
                                                            "core::ops::control_flow::ControlFlow::Continue",
                                                            0
                                                          |) in
                                                        let val := M.copy (| γ0_0 |) in
                                                        val))
                                                  ]
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn constrain_instance(
                &self,
                cell: Cell,
                instance: Column<Instance>,
                row: usize,
            ) -> Result<(), Error> {
                self.cs
                    .copy(cell.column, cell.row_offset, instance.into(), row)
            }
        *)
        Definition constrain_instance (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; cell; instance; row ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let cell := M.alloc (| cell |) in
              let instance := M.alloc (| instance |) in
              let row := M.alloc (| row |) in
              M.call_closure (|
                M.get_trait_method (|
                  "halo2_proofs::plonk::circuit::Assignment",
                  CS,
                  [ F ],
                  "copy",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                      "cs"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      cell,
                      "halo2_proofs::circuit::Cell",
                      "column"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      cell,
                      "halo2_proofs::circuit::Cell",
                      "row_offset"
                    |)
                  |);
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::Into",
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Instance" ],
                      [
                        Ty.apply
                          (Ty.path "halo2_proofs::plonk::circuit::Column")
                          [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                      ],
                      "into",
                      []
                    |),
                    [ M.read (| instance |) ]
                  |);
                  M.read (| row |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn get_root(&self) -> &Self::Root {
                self
            }
        *)
        Definition get_root (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| self |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn push_namespace<NR, N>(&self, name_fn: N)
            where
                NR: Into<String>,
                N: FnOnce() -> NR,
            {
                self.cs.push_namespace(name_fn)
            }
        *)
        Definition push_namespace (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ NR; N ], [ self; name_fn ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name_fn := M.alloc (| name_fn |) in
              M.call_closure (|
                M.get_trait_method (|
                  "halo2_proofs::plonk::circuit::Assignment",
                  CS,
                  [ F ],
                  "push_namespace",
                  [ NR; N ]
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                      "cs"
                    |)
                  |);
                  M.read (| name_fn |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn pop_namespace(&self, gadget_name: Option<String>) {
                self.cs.pop_namespace(gadget_name)
            }
        *)
        Definition pop_namespace (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; gadget_name ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let gadget_name := M.alloc (| gadget_name |) in
              M.call_closure (|
                M.get_trait_method (|
                  "halo2_proofs::plonk::circuit::Assignment",
                  CS,
                  [ F ],
                  "pop_namespace",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::flat::FlatShapeLayouter",
                      "cs"
                    |)
                  |);
                  M.read (| gadget_name |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "halo2_proofs::circuit::Layouter"
            (Self F CS)
            (* Trait polymorphic types *) [ (* F *) F ]
            (* Instance *)
            [
              ("Root", InstanceField.Ty (_Root F CS));
              ("assign_region", InstanceField.Method (assign_region F CS));
              ("assign_table", InstanceField.Method (assign_table F CS));
              ("constrain_instance", InstanceField.Method (constrain_instance F CS));
              ("get_root", InstanceField.Method (get_root F CS));
              ("push_namespace", InstanceField.Method (push_namespace F CS));
              ("pop_namespace", InstanceField.Method (pop_namespace F CS))
            ].
      End Impl_halo2_proofs_circuit_Layouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_flat_FlatShapeLayouter_F_CS.
      
      (* StructRecord
        {
          name := "FlatChipLayouter";
          ty_params := [ "F"; "CS" ];
          fields :=
            [
              ("cs", Ty.apply (Ty.path "&") [ CS ]);
              ("_mark", Ty.apply (Ty.path "core::marker::PhantomData") [ F ])
            ];
        } *)
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_where_core_clone_Clone_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter")
            [ F; CS ].
        
        (* Clone *)
        Definition clone (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter"
                [
                  ("cs",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply (Ty.path "&") [ CS ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter",
                          "cs"
                        |)
                      ]
                    |));
                  ("_mark",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply (Ty.path "core::marker::PhantomData") [ F ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter",
                          "_mark"
                        |)
                      ]
                    |))
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone F CS)) ].
      End Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_where_core_clone_Clone_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouter_F_CS.
      
      Module Impl_core_marker_Send_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter")
            [ F; CS ].
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::marker::Send"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Send_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouter_F_CS.
      
      Module Impl_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter")
            [ F; CS ].
        
        (*
            pub fn new(cs: &'a CS) -> Result<Self, Error> {
                let ret = FlatChipLayouter {
                    cs,
                    _mark: PhantomData,
                };
                Ok(ret)
            }
        *)
        Definition new (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ cs ] =>
            ltac:(M.monadic
              (let cs := M.alloc (| cs |) in
              M.read (|
                let ret :=
                  M.alloc (|
                    Value.StructRecord
                      "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter"
                      [
                        ("cs", M.read (| cs |));
                        ("_mark", Value.StructTuple "core::marker::PhantomData" [])
                      ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| ret |) ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "new" (new F CS).
      End Impl_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouter_F_CS.
      
      Module Impl_halo2_proofs_circuit_Layouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter")
            [ F; CS ].
        
        (*     type Root = Self; *)
        Definition _Root (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter")
            [ F; CS ].
        
        (*
            fn assign_region<A, AR, N, NR>(&self, _name: N, assignment: A) -> Result<AR, Error>
            where
                A: Fn(&Region<'_, F>) -> Result<AR, Error>,
                N: Fn() -> NR,
                NR: Into<String>,
            {
                let region = FlatChipLayouterRegion::new(self.cs);
                let result = {
                    let region: &dyn RegionLayouter<F> = &region;
                    assignment(&region.into())
                }?;
                Ok(result)
            }
        *)
        Definition assign_region (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ A; AR; N; NR ], [ self; _name; assignment ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let _name := M.alloc (| _name |) in
              let assignment := M.alloc (| assignment |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let region :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path
                                "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion")
                              [ F; CS ],
                            "new",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter",
                                "cs"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let result :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ AR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.read (|
                                  let region :=
                                    M.alloc (| (* Unsize *) M.pointer_coercion region |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::Fn",
                                        A,
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::circuit::Region")
                                                    [ F ]
                                                ]
                                            ]
                                        ],
                                        "call",
                                        []
                                      |),
                                      [
                                        assignment;
                                        Value.Tuple
                                          [
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::convert::Into",
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [
                                                      Ty.dyn
                                                        [
                                                          ("halo2_proofs::circuit::layouter::RegionLayouter::Trait",
                                                            [])
                                                        ]
                                                    ],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "halo2_proofs::circuit::Region")
                                                      [ F ]
                                                  ],
                                                  "into",
                                                  []
                                                |),
                                                [ M.read (| region |) ]
                                              |)
                                            |)
                                          ]
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ AR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| result |) ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_table<A, N, NR>(&self, _name: N, mut _assignment: A) -> Result<(), Error>
            where
                A: FnMut(Table<'_, F>) -> Result<(), Error>,
                N: Fn() -> NR,
                NR: Into<String>,
            {
                Ok(())
            }
        *)
        Definition assign_table (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ A; N; NR ], [ self; _name; _assignment ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let _name := M.alloc (| _name |) in
              let _assignment := M.alloc (| _assignment |) in
              Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]))
          | _, _ => M.impossible
          end.
        
        (*
            fn constrain_instance(
                &self,
                _cell: Cell,
                _instance: Column<Instance>,
                _row: usize,
            ) -> Result<(), Error> {
                Ok(())
            }
        *)
        Definition constrain_instance (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; _cell; _instance; _row ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let _cell := M.alloc (| _cell |) in
              let _instance := M.alloc (| _instance |) in
              let _row := M.alloc (| _row |) in
              Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]))
          | _, _ => M.impossible
          end.
        
        (*
            fn get_root(&self) -> &Self::Root {
                self
            }
        *)
        Definition get_root (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| self |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn push_namespace<NR, N>(&self, name_fn: N)
            where
                NR: Into<String>,
                N: FnOnce() -> NR,
            {
                self.cs.push_namespace(name_fn)
            }
        *)
        Definition push_namespace (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ NR; N ], [ self; name_fn ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name_fn := M.alloc (| name_fn |) in
              M.call_closure (|
                M.get_trait_method (|
                  "halo2_proofs::plonk::circuit::Assignment",
                  CS,
                  [ F ],
                  "push_namespace",
                  [ NR; N ]
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter",
                      "cs"
                    |)
                  |);
                  M.read (| name_fn |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn pop_namespace(&self, gadget_name: Option<String>) {
                self.cs.pop_namespace(gadget_name)
            }
        *)
        Definition pop_namespace (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; gadget_name ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let gadget_name := M.alloc (| gadget_name |) in
              M.call_closure (|
                M.get_trait_method (|
                  "halo2_proofs::plonk::circuit::Assignment",
                  CS,
                  [ F ],
                  "pop_namespace",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouter",
                      "cs"
                    |)
                  |);
                  M.read (| gadget_name |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "halo2_proofs::circuit::Layouter"
            (Self F CS)
            (* Trait polymorphic types *) [ (* F *) F ]
            (* Instance *)
            [
              ("Root", InstanceField.Ty (_Root F CS));
              ("assign_region", InstanceField.Method (assign_region F CS));
              ("assign_table", InstanceField.Method (assign_table F CS));
              ("constrain_instance", InstanceField.Method (constrain_instance F CS));
              ("get_root", InstanceField.Method (get_root F CS));
              ("push_namespace", InstanceField.Method (push_namespace F CS));
              ("pop_namespace", InstanceField.Method (pop_namespace F CS))
            ].
      End Impl_halo2_proofs_circuit_Layouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouter_F_CS.
      
      (* StructRecord
        {
          name := "FlatChipLayouterRegion";
          ty_params := [ "F"; "CS" ];
          fields :=
            [
              ("cs", Ty.apply (Ty.path "&") [ CS ]);
              ("_mark", Ty.apply (Ty.path "core::marker::PhantomData") [ F ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouterRegion_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion")
            [ F; CS ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("FlatChipLayouterRegion").finish()
            }
        *)
        Definition fmt (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugStruct",
                  "finish",
                  []
                |),
                [
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct",
                        []
                      |),
                      [ M.read (| f |); M.read (| Value.String "FlatChipLayouterRegion" |) ]
                    |)
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F CS)) ].
      End Impl_core_fmt_Debug_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouterRegion_F_CS.
      
      Module Impl_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouterRegion_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion")
            [ F; CS ].
        
        (*
            fn new(cs: &'a CS) -> Self {
                FlatChipLayouterRegion {
                    cs,
                    _mark: PhantomData,
                }
            }
        *)
        Definition new (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ cs ] =>
            ltac:(M.monadic
              (let cs := M.alloc (| cs |) in
              Value.StructRecord
                "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion"
                [
                  ("cs", M.read (| cs |));
                  ("_mark", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "new" (new F CS).
      End Impl_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouterRegion_F_CS.
      
      Module Impl_halo2_proofs_circuit_layouter_RegionLayouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouterRegion_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion")
            [ F; CS ].
        
        (*
            fn enable_selector<'v>(
                &'v self,
                annotation: &'v (dyn Fn() -> String + 'v),
                selector: &Selector,
                offset: usize,
            ) -> Result<(), Error> {
                self.cs.enable_selector(annotation, selector, offset)
            }
        *)
        Definition enable_selector (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; selector; offset ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let selector := M.alloc (| selector |) in
              let offset := M.alloc (| offset |) in
              M.call_closure (|
                M.get_trait_method (|
                  "halo2_proofs::plonk::circuit::Assignment",
                  CS,
                  [ F ],
                  "enable_selector",
                  [
                    Ty.apply (Ty.path "&") [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ];
                    Ty.path "alloc::string::String"
                  ]
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion",
                      "cs"
                    |)
                  |);
                  M.read (| annotation |);
                  M.read (| selector |);
                  M.read (| offset |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_advice<'v>(
                &'v self,
                annotation: &'v (dyn Fn() -> String + 'v),
                column: Column<Advice>,
                offset: usize,
                to: &'v mut (dyn FnMut() -> Result<Assigned<F>, Error> + 'v),
            ) -> Result<Cell, Error> {
                self.cs.assign_advice(annotation, column, offset, to)?;
        
                Ok(Cell {
                    //region_index: self.region_index,
                    region_index: RegionIndex(0), // no longer track the region index as in phase 2
                    row_offset: offset,
                    column: column.into(),
                })
            }
        *)
        Definition assign_advice (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; column; offset; to ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let column := M.alloc (| column |) in
              let offset := M.alloc (| offset |) in
              let to := M.alloc (| to |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::plonk::circuit::Assignment",
                                  CS,
                                  [ F ],
                                  "assign_advice",
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      [ Ty.dyn [ ("core::ops::function::FnMut::Trait", []) ] ];
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                      [ F ];
                                    Ty.apply
                                      (Ty.path "&")
                                      [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ];
                                    Ty.path "alloc::string::String"
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion",
                                      "cs"
                                    |)
                                  |);
                                  M.read (| annotation |);
                                  M.read (| column |);
                                  M.read (| offset |);
                                  M.read (| to |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "halo2_proofs::circuit::Cell";
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "halo2_proofs::circuit::Cell"
                            [
                              ("region_index",
                                Value.StructTuple
                                  "halo2_proofs::circuit::RegionIndex"
                                  [ Value.Integer 0 ]);
                              ("row_offset", M.read (| offset |));
                              ("column",
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::Into",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Advice" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "into",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |))
                            ]
                        ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_advice_from_constant<'v>(
                &'v self,
                annotation: &'v (dyn Fn() -> String + 'v),
                column: Column<Advice>,
                offset: usize,
                constant: Assigned<F>,
            ) -> Result<Cell, Error> {
                let advice = self.assign_advice(annotation, column, offset, &mut || Ok(constant))?;
                self.constrain_constant(advice, constant)?;
        
                Ok(advice)
            }
        *)
        Definition assign_advice_from_constant
            (F CS : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; column; offset; constant ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let column := M.alloc (| column |) in
              let offset := M.alloc (| offset |) in
              let constant := M.alloc (| constant |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let advice :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.path "halo2_proofs::circuit::Cell";
                                    Ty.path "halo2_proofs::plonk::error::Error"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::circuit::layouter::RegionLayouter",
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion")
                                      [ F; CS ],
                                    [ F ],
                                    "assign_advice",
                                    []
                                  |),
                                  [
                                    M.read (| self |);
                                    (* Unsize *) M.pointer_coercion (M.read (| annotation |));
                                    M.read (| column |);
                                    M.read (| offset |);
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.alloc (|
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                M.match_operator (|
                                                  M.alloc (| α0 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (Value.StructTuple
                                                          "core::result::Result::Ok"
                                                          [ M.read (| constant |) ]))
                                                  ]
                                                |)
                                              | _ => M.impossible (||)
                                              end))
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "halo2_proofs::circuit::Cell";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::circuit::layouter::RegionLayouter",
                                  Ty.apply
                                    (Ty.path
                                      "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion")
                                    [ F; CS ],
                                  [ F ],
                                  "constrain_constant",
                                  []
                                |),
                                [ M.read (| self |); M.read (| advice |); M.read (| constant |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "halo2_proofs::circuit::Cell";
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| advice |) ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_advice_from_instance<'v>(
                &self,
                annotation: &'v (dyn Fn() -> String + 'v),
                instance: Column<Instance>,
                row: usize,
                advice: Column<Advice>,
                offset: usize,
            ) -> Result<(Cell, Option<F>), Error> {
                let value = self.cs.query_instance(instance, row)?;
        
                let cell = self.assign_advice(annotation, advice, offset, &mut || {
                    value.ok_or(Error::Synthesis).map(|v| v.into())
                })?;
        
                self.cs
                    .copy(cell.column, cell.row_offset, instance.into(), row)?;
        
                Ok((cell, value))
            }
        *)
        Definition assign_advice_from_instance
            (F CS : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; instance; row; advice; offset ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let instance := M.alloc (| instance |) in
              let row := M.alloc (| row |) in
              let advice := M.alloc (| advice |) in
              let offset := M.alloc (| offset |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let value :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply (Ty.path "core::option::Option") [ F ];
                                    Ty.path "halo2_proofs::plonk::error::Error"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::plonk::circuit::Assignment",
                                    CS,
                                    [ F ],
                                    "query_instance",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion",
                                        "cs"
                                      |)
                                    |);
                                    M.read (| instance |);
                                    M.read (| row |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path "halo2_proofs::circuit::Cell";
                                                    Ty.apply (Ty.path "core::option::Option") [ F ]
                                                  ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let cell :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.path "halo2_proofs::circuit::Cell";
                                    Ty.path "halo2_proofs::plonk::error::Error"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::circuit::layouter::RegionLayouter",
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion")
                                      [ F; CS ],
                                    [ F ],
                                    "assign_advice",
                                    []
                                  |),
                                  [
                                    M.read (| self |);
                                    (* Unsize *) M.pointer_coercion (M.read (| annotation |));
                                    M.read (| advice |);
                                    M.read (| offset |);
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.alloc (|
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                M.match_operator (|
                                                  M.alloc (| α0 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              [
                                                                F;
                                                                Ty.path
                                                                  "halo2_proofs::plonk::error::Error"
                                                              ],
                                                            "map",
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                [ F ];
                                                              Ty.function
                                                                [ Ty.tuple [ F ] ]
                                                                (Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                                  [ F ])
                                                            ]
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  [ F ],
                                                                "ok_or",
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::error::Error"
                                                                ]
                                                              |),
                                                              [
                                                                M.read (| value |);
                                                                Value.StructTuple
                                                                  "halo2_proofs::plonk::error::Error::Synthesis"
                                                                  []
                                                              ]
                                                            |);
                                                            M.closure
                                                              (fun γ =>
                                                                ltac:(M.monadic
                                                                  match γ with
                                                                  | [ α0 ] =>
                                                                    M.match_operator (|
                                                                      M.alloc (| α0 |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let v :=
                                                                              M.copy (| γ |) in
                                                                            M.call_closure (|
                                                                              M.get_trait_method (|
                                                                                "core::convert::Into",
                                                                                F,
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "halo2_proofs::plonk::assigned::Assigned")
                                                                                    [ F ]
                                                                                ],
                                                                                "into",
                                                                                []
                                                                              |),
                                                                              [ M.read (| v |) ]
                                                                            |)))
                                                                      ]
                                                                    |)
                                                                  | _ => M.impossible (||)
                                                                  end))
                                                          ]
                                                        |)))
                                                  ]
                                                |)
                                              | _ => M.impossible (||)
                                              end))
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path "halo2_proofs::circuit::Cell";
                                                    Ty.apply (Ty.path "core::option::Option") [ F ]
                                                  ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::plonk::circuit::Assignment",
                                  CS,
                                  [ F ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion",
                                      "cs"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      cell,
                                      "halo2_proofs::circuit::Cell",
                                      "column"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      cell,
                                      "halo2_proofs::circuit::Cell",
                                      "row_offset"
                                    |)
                                  |);
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Instance" ],
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Column")
                                          [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                      ],
                                      "into",
                                      []
                                    |),
                                    [ M.read (| instance |) ]
                                  |);
                                  M.read (| row |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "halo2_proofs::circuit::Cell";
                                                  Ty.apply (Ty.path "core::option::Option") [ F ]
                                                ];
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.Tuple [ M.read (| cell |); M.read (| value |) ] ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_fixed<'v>(
                &'v self,
                annotation: &'v (dyn Fn() -> String + 'v),
                column: Column<Fixed>,
                offset: usize,
                to: &'v mut (dyn FnMut() -> Result<Assigned<F>, Error> + 'v),
            ) -> Result<Cell, Error> {
                self.cs.assign_fixed(annotation, column, offset, to)?;
                Ok(Cell {
                    //region_index: self.region_index,
                    region_index: RegionIndex(0), // no longer track the region index as in phase 2
                    row_offset: offset,
                    column: column.into(),
                })
            }
        *)
        Definition assign_fixed (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; column; offset; to ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let column := M.alloc (| column |) in
              let offset := M.alloc (| offset |) in
              let to := M.alloc (| to |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::plonk::circuit::Assignment",
                                  CS,
                                  [ F ],
                                  "assign_fixed",
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      [ Ty.dyn [ ("core::ops::function::FnMut::Trait", []) ] ];
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                      [ F ];
                                    Ty.apply
                                      (Ty.path "&")
                                      [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ];
                                    Ty.path "alloc::string::String"
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion",
                                      "cs"
                                    |)
                                  |);
                                  M.read (| annotation |);
                                  M.read (| column |);
                                  M.read (| offset |);
                                  M.read (| to |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "halo2_proofs::circuit::Cell";
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "halo2_proofs::circuit::Cell"
                            [
                              ("region_index",
                                Value.StructTuple
                                  "halo2_proofs::circuit::RegionIndex"
                                  [ Value.Integer 0 ]);
                              ("row_offset", M.read (| offset |));
                              ("column",
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::Into",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "into",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |))
                            ]
                        ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn constrain_constant(&self, _cell: Cell, _constant: Assigned<F>) -> Result<(), Error> {
                Ok(())
            }
        *)
        Definition constrain_constant (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; _cell; _constant ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let _cell := M.alloc (| _cell |) in
              let _constant := M.alloc (| _constant |) in
              Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]))
          | _, _ => M.impossible
          end.
        
        (*
            fn constrain_equal(&self, left: Cell, right: Cell) -> Result<(), Error> {
                self.cs
                    .copy(left.column, left.row_offset, right.column, right.row_offset)?;
        
                Ok(())
            }
        *)
        Definition constrain_equal (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; _ as left; _ as right ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let left := M.alloc (| left |) in
              let right := M.alloc (| right |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::plonk::circuit::Assignment",
                                  CS,
                                  [ F ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::flat::FlatChipLayouterRegion",
                                      "cs"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      left,
                                      "halo2_proofs::circuit::Cell",
                                      "column"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      left,
                                      "halo2_proofs::circuit::Cell",
                                      "row_offset"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      right,
                                      "halo2_proofs::circuit::Cell",
                                      "column"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      right,
                                      "halo2_proofs::circuit::Cell",
                                      "row_offset"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.tuple [];
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "halo2_proofs::circuit::layouter::RegionLayouter"
            (Self F CS)
            (* Trait polymorphic types *) [ (* F *) F ]
            (* Instance *)
            [
              ("enable_selector", InstanceField.Method (enable_selector F CS));
              ("assign_advice", InstanceField.Method (assign_advice F CS));
              ("assign_advice_from_constant",
                InstanceField.Method (assign_advice_from_constant F CS));
              ("assign_advice_from_instance",
                InstanceField.Method (assign_advice_from_instance F CS));
              ("assign_fixed", InstanceField.Method (assign_fixed F CS));
              ("constrain_constant", InstanceField.Method (constrain_constant F CS));
              ("constrain_equal", InstanceField.Method (constrain_equal F CS))
            ].
      End Impl_halo2_proofs_circuit_layouter_RegionLayouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_flat_FlatChipLayouterRegion_F_CS.
    End flat.
  End floor_planner.
End circuit.
