(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module circuit.
  Module floor_planner.
    Module single_pass.
      Axiom DefaultTableValue :
        forall (F : Ty.t),
        (Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::single_pass::DefaultTableValue")
            [ F ]) =
          (Ty.apply
            (Ty.path "core::option::Option")
            [
              Ty.apply
                (Ty.path "core::option::Option")
                [ Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ] ]
            ]).
      
      (* StructRecord
        {
          name := "SimpleTableLayouter";
          ty_params := [ "F"; "CS" ];
          fields :=
            [
              ("cs", Ty.apply (Ty.path "&") [ CS ]);
              ("used_columns",
                Ty.apply
                  (Ty.path "&")
                  [
                    Ty.apply
                      (Ty.path "slice")
                      [ Ty.path "halo2_proofs::plonk::circuit::TableColumn" ]
                  ]);
              ("default_and_assigned",
                Ty.apply
                  (Ty.path "halo2_proofs::parallel::Parallel")
                  [
                    Ty.apply
                      (Ty.path "std::collections::hash::map::HashMap")
                      [
                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "core::option::Option")
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                      [ F ]
                                  ]
                              ];
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "std::hash::random::RandomState"
                      ]
                  ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_single_pass_SimpleTableLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter")
            [ F; CS ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("SimpleTableLayouter")
                    .field("used_columns", &self.used_columns)
                    .field("default_and_assigned", &self.default_and_assigned)
                    .finish()
            }
        *)
        Definition fmt (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugStruct",
                  "finish",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      "field",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugStruct",
                          "field",
                          []
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_struct",
                                []
                              |),
                              [ M.read (| f |); M.read (| Value.String "SimpleTableLayouter" |) ]
                            |)
                          |);
                          M.read (| Value.String "used_columns" |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter",
                              "used_columns"
                            |))
                        ]
                      |);
                      M.read (| Value.String "default_and_assigned" |);
                      (* Unsize *)
                      M.pointer_coercion
                        (M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter",
                          "default_and_assigned"
                        |))
                    ]
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F CS)) ].
      End Impl_core_fmt_Debug_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_single_pass_SimpleTableLayouter_F_CS.
      
      Module Impl_halo2_proofs_circuit_floor_planner_single_pass_SimpleTableLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter")
            [ F; CS ].
        
        (*
            pub(crate) fn new(cs: &'a CS, used_columns: &'r [TableColumn]) -> Self {
                SimpleTableLayouter {
                    cs,
                    used_columns,
                    default_and_assigned: Parallel::new(HashMap::default()),
                }
            }
        *)
        Definition new (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ cs; used_columns ] =>
            ltac:(M.monadic
              (let cs := M.alloc (| cs |) in
              let used_columns := M.alloc (| used_columns |) in
              Value.StructRecord
                "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter"
                [
                  ("cs", M.read (| cs |));
                  ("used_columns", M.read (| used_columns |));
                  ("default_and_assigned",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "halo2_proofs::parallel::Parallel")
                          [
                            Ty.apply
                              (Ty.path "std::collections::hash::map::HashMap")
                              [
                                Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                              [ F ]
                                          ]
                                      ];
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                  ];
                                Ty.path "std::hash::random::RandomState"
                              ]
                          ],
                        "new",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::default::Default",
                            Ty.apply
                              (Ty.path "std::collections::hash::map::HashMap")
                              [
                                Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                              [ F ]
                                          ]
                                      ];
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                  ];
                                Ty.path "std::hash::random::RandomState"
                              ],
                            [],
                            "default",
                            []
                          |),
                          []
                        |)
                      ]
                    |))
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "new" (new F CS).
      End Impl_halo2_proofs_circuit_floor_planner_single_pass_SimpleTableLayouter_F_CS.
      
      Module Impl_halo2_proofs_circuit_layouter_TableLayouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_single_pass_SimpleTableLayouter_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter")
            [ F; CS ].
        
        (*
            fn assign_cell<'v>(
                &'v self,
                annotation: &'v (dyn Fn() -> String + 'v),
                column: TableColumn,
                offset: usize,
                to: &'v mut (dyn FnMut() -> Result<Assigned<F>, Error> + 'v),
            ) -> Result<(), Error> {
                if self.used_columns.contains(&column) {
                    return Err(Error::Synthesis); // TODO better error
                }
        
                let mut default_and_assigned = self.default_and_assigned.lock().unwrap();
                let entry = default_and_assigned.entry(column).or_default();
        
                let mut value = None;
                self.cs.assign_fixed(
                    annotation,
                    column.inner(),
                    offset, // tables are always assigned starting at row 0
                    || {
                        let res = to();
                        value = res.as_ref().ok().cloned();
                        res
                    },
                )?;
        
                match (entry.0.is_none(), offset) {
                    // Use the value at offset 0 as the default value for this table column.
                    (true, 0) => entry.0 = Some(value),
                    // Since there is already an existing default value for this table column,
                    // the caller should not be attempting to assign another value at offset 0.
                    (false, 0) => return Err(Error::Synthesis), // TODO better error
                    _ => (),
                }
                if entry.1.len() <= offset {
                    entry.1.resize(offset + 1, false);
                }
                entry.1[offset] = true;
        
                Ok(())
            }
        *)
        Definition assign_cell (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; column; offset; to ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let column := M.alloc (| column |) in
              let offset := M.alloc (| offset |) in
              let to := M.alloc (| to |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "slice")
                                          [ Ty.path "halo2_proofs::plonk::circuit::TableColumn" ],
                                        "contains",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter",
                                            "used_columns"
                                          |)
                                        |);
                                        column
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructTuple
                                        "core::result::Result::Err"
                                        [
                                          Value.StructTuple
                                            "halo2_proofs::plonk::error::Error::Synthesis"
                                            []
                                        ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let default_and_assigned :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "std::sync::mutex::MutexGuard")
                                  [
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ]
                                                  ]
                                              ];
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                          ];
                                        Ty.path "std::hash::random::RandomState"
                                      ]
                                  ];
                                Ty.apply
                                  (Ty.path "std::sync::poison::PoisonError")
                                  [
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::MutexGuard")
                                      [
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::HashMap")
                                          [
                                            Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                          [ F ]
                                                      ]
                                                  ];
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                              ];
                                            Ty.path "std::hash::random::RandomState"
                                          ]
                                      ]
                                  ]
                              ],
                            "unwrap",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "halo2_proofs::parallel::Parallel")
                                  [
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ]
                                                  ]
                                              ];
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                          ];
                                        Ty.path "std::hash::random::RandomState"
                                      ]
                                  ],
                                "lock",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter",
                                  "default_and_assigned"
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let entry :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "std::collections::hash::map::Entry")
                              [
                                Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                              [ F ]
                                          ]
                                      ];
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                  ]
                              ],
                            "or_default",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "std::collections::hash::map::HashMap")
                                  [
                                    Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                  [ F ]
                                              ]
                                          ];
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                      ];
                                    Ty.path "std::hash::random::RandomState"
                                  ],
                                "entry",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::DerefMut",
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::MutexGuard")
                                      [
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::HashMap")
                                          [
                                            Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                          [ F ]
                                                      ]
                                                  ];
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                              ];
                                            Ty.path "std::hash::random::RandomState"
                                          ]
                                      ],
                                    [],
                                    "deref_mut",
                                    []
                                  |),
                                  [ default_and_assigned ]
                                |);
                                M.read (| column |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let value := M.alloc (| Value.StructTuple "core::option::Option::None" [] |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::plonk::circuit::Assignment",
                                  CS,
                                  [ F ],
                                  "assign_fixed",
                                  [
                                    Ty.function
                                      [ Ty.tuple [] ]
                                      (Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                            [ F ];
                                          Ty.path "halo2_proofs::plonk::error::Error"
                                        ]);
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                      [ F ];
                                    Ty.apply
                                      (Ty.path "&")
                                      [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ];
                                    Ty.path "alloc::string::String"
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter",
                                      "cs"
                                    |)
                                  |);
                                  M.read (| annotation |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "halo2_proofs::plonk::circuit::TableColumn",
                                      "inner",
                                      []
                                    |),
                                    [ column ]
                                  |);
                                  M.read (| offset |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (M.read (|
                                                    let res :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::function::FnMut",
                                                            Ty.dyn
                                                              [
                                                                ("core::ops::function::FnMut::Trait",
                                                                  [])
                                                              ],
                                                            [ Ty.tuple [] ],
                                                            "call_mut",
                                                            []
                                                          |),
                                                          [ M.read (| to |); Value.Tuple [] ]
                                                        |)
                                                      |) in
                                                    let _ :=
                                                      M.write (|
                                                        value,
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                                      [ F ]
                                                                  ]
                                                              ],
                                                            "cloned",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "core::result::Result")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                                          [ F ]
                                                                      ];
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::error::Error"
                                                                      ]
                                                                  ],
                                                                "ok",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                                          [ F ];
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::error::Error"
                                                                      ],
                                                                    "as_ref",
                                                                    []
                                                                  |),
                                                                  [ res ]
                                                                |)
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      |) in
                                                    res
                                                  |)))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.tuple [];
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          Value.Tuple
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    [
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                            [ F ]
                                        ]
                                    ],
                                  "is_none",
                                  []
                                |),
                                [ M.SubPointer.get_tuple_field (| M.read (| entry |), 0 |) ]
                              |);
                              M.read (| offset |)
                            ]
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ0_0 |),
                                  Value.Bool true
                                |) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ0_1 |),
                                  Value.Integer 0
                                |) in
                              M.write (|
                                M.SubPointer.get_tuple_field (| M.read (| entry |), 0 |),
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| value |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ0_0 |),
                                  Value.Bool false
                                |) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ0_1 |),
                                  Value.Integer 0
                                |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructTuple
                                        "core::result::Result::Err"
                                        [
                                          Value.StructTuple
                                            "halo2_proofs::plonk::error::Error::Synthesis"
                                            []
                                        ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.le
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ],
                                          "len",
                                          []
                                        |),
                                        [ M.SubPointer.get_tuple_field (| M.read (| entry |), 1 |) ]
                                      |))
                                      (M.read (| offset |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ],
                                      "resize",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_tuple_field (| M.read (| entry |), 1 |);
                                      BinOp.Panic.add (|
                                        Integer.Usize,
                                        M.read (| offset |),
                                        Value.Integer 1
                                      |);
                                      Value.Bool false
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let _ :=
                      M.write (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::index::IndexMut",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ],
                            [ Ty.path "usize" ],
                            "index_mut",
                            []
                          |),
                          [
                            M.SubPointer.get_tuple_field (| M.read (| entry |), 1 |);
                            M.read (| offset |)
                          ]
                        |),
                        Value.Bool true
                      |) in
                    M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "halo2_proofs::circuit::layouter::TableLayouter"
            (Self F CS)
            (* Trait polymorphic types *) [ (* F *) F ]
            (* Instance *) [ ("assign_cell", InstanceField.Method (assign_cell F CS)) ].
      End Impl_halo2_proofs_circuit_layouter_TableLayouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_single_pass_SimpleTableLayouter_F_CS.
    End single_pass.
  End floor_planner.
End circuit.
