(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module circuit.
  Module floor_planner.
    Module v1.
      (* StructTuple
        {
          name := "V1";
          ty_params := [];
          fields := [];
        } *)
      
      Module Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_v1_V1.
        Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::floor_planner::v1::V1".
        
        (* Debug *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
                [ M.read (| f |); M.read (| Value.String "V1" |) ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_v1_V1.
      
      (* StructRecord
        {
          name := "V1Plan";
          ty_params := [ "F"; "CS" ];
          fields :=
            [
              ("cs", Ty.apply (Ty.path "&") [ CS ]);
              ("regions",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "halo2_proofs::circuit::RegionStart"; Ty.path "alloc::alloc::Global" ]);
              ("constants",
                Ty.apply
                  (Ty.path "halo2_proofs::parallel::Parallel")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
                            Ty.path "halo2_proofs::circuit::Cell"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ]);
              ("table_columns",
                Ty.apply
                  (Ty.path "halo2_proofs::parallel::Parallel")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_V1Plan_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Plan") [ F; CS ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("floor_planner::V1Plan").finish()
            }
        *)
        Definition fmt (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugStruct",
                  "finish",
                  []
                |),
                [
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct",
                        []
                      |),
                      [ M.read (| f |); M.read (| Value.String "floor_planner::V1Plan" |) ]
                    |)
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F CS)) ].
      End Impl_core_fmt_Debug_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_V1Plan_F_CS.
      
      Module Impl_halo2_proofs_circuit_floor_planner_v1_V1Plan_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Plan") [ F; CS ].
        
        (*
            pub fn new(cs: &'a CS) -> Result<Self, Error> {
                let ret = V1Plan {
                    cs,
                    regions: vec![],
                    constants: Parallel::new(vec![]),
                    table_columns: Parallel::new(vec![]),
                };
                Ok(ret)
            }
        *)
        Definition new (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ cs ] =>
            ltac:(M.monadic
              (let cs := M.alloc (| cs |) in
              M.read (|
                let ret :=
                  M.alloc (|
                    Value.StructRecord
                      "halo2_proofs::circuit::floor_planner::v1::V1Plan"
                      [
                        ("cs", M.read (| cs |));
                        ("regions",
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "new",
                              []
                            |),
                            []
                          |));
                        ("constants",
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "halo2_proofs::parallel::Parallel")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                            [ F ];
                                          Ty.path "halo2_proofs::circuit::Cell"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ],
                              "new",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                            [ F ];
                                          Ty.path "halo2_proofs::circuit::Cell"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "new",
                                  []
                                |),
                                []
                              |)
                            ]
                          |));
                        ("table_columns",
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "halo2_proofs::parallel::Parallel")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ],
                              "new",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "new",
                                  []
                                |),
                                []
                              |)
                            ]
                          |))
                      ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| ret |) ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "new" (new F CS).
      End Impl_halo2_proofs_circuit_floor_planner_v1_V1Plan_F_CS.
      
      Module Impl_halo2_proofs_plonk_circuit_FloorPlanner_for_halo2_proofs_circuit_floor_planner_v1_V1.
        Definition Self : Ty.t := Ty.path "halo2_proofs::circuit::floor_planner::v1::V1".
        
        (*
            fn synthesize<F: Field, CS: Assignment<F>, C: Circuit<F>>(
                cs: &CS,
                circuit: &C,
                config: C::Config,
                constants: Vec<Column<Fixed>>,
            ) -> Result<(), Error> {
                let mut plan = V1Plan::new(cs)?;
        
                // First pass: measure the regions within the circuit.
                let mut measure = MeasurementPassAssignment::new();
                {
                    let pass = &mut measure;
                    circuit
                        .without_witnesses()
                        .synthesize(config.clone(), V1Pass::<_, CS>::measure(pass))?;
                }
        
                let measure: MeasurementPass = measure.into();
        
                // Planning:
                // - Position the regions.
                let (regions, column_allocations) =
                    { strategy::slot_in_biggest_advice_first(measure.regions) };
                plan.regions = regions;
        
                // - Determine how many rows our planned circuit will require.
                let first_unassigned_row = column_allocations
                    .iter()
                    .map(|(_, a)| a.unbounded_interval_start())
                    .max()
                    .unwrap_or(0);
        
                // - Position the constants within those rows.
                let fixed_allocations: Vec<_> = constants
                    .into_iter()
                    .map(|c| {
                        (
                            c,
                            column_allocations
                                .get(&Column::<Any>::from(c).into())
                                .cloned()
                                .unwrap_or_default(),
                        )
                    })
                    .collect();
                let constant_positions = || {
                    fixed_allocations.iter().flat_map(|(c, a)| {
                        let c = *c;
                        a.free_intervals(0, Some(first_unassigned_row))
                            .flat_map(move |e| e.range().unwrap().map(move |i| (c, i)))
                    })
                };
        
                // Second pass:
                // - Assign the regions.
                let mut assign = AssignmentPass::new(&mut plan, measure.regions_name);
                {
                    let pass = &mut assign;
                    circuit.synthesize(config, V1Pass::assign(pass))?;
                }
        
                let mut constants = plan.constants.lock().unwrap();
        
                // - Assign the constants.
                if constant_positions().count() < constants.len() {
                    return Err(Error::NotEnoughColumnsForConstants);
                }
        
                constants.sort_by(|(_, cell_a), (_, cell_b)| {
                    if cell_a.column != cell_b.column {
                        cell_a.column.cmp(&cell_b.column)
                    } else {
                        cell_a.row_offset.cmp(&cell_b.row_offset)
                    }
                });
        
                for ((fixed_column, fixed_row), (value, advice)) in
                    constant_positions().zip(constants.iter())
                {
                    plan.cs.assign_fixed(
                        || format!("Constant({:?})", ( *value).evaluate()),
                        fixed_column,
                        fixed_row,
                        || Ok( *value),
                    )?;
                    plan.cs.copy(
                        fixed_column.into(),
                        fixed_row,
                        advice.column,
                        *plan.regions[*advice.region_index] + advice.row_offset,
                    )?;
                }
        
                Ok(())
            }
        *)
        Definition synthesize (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ F; CS; C ], [ cs; circuit; config; constants ] =>
            ltac:(M.monadic
              (let cs := M.alloc (| cs |) in
              let circuit := M.alloc (| circuit |) in
              let config := M.alloc (| config |) in
              let constants := M.alloc (| constants |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let plan :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Plan")
                                      [ F; CS ];
                                    Ty.path "halo2_proofs::plonk::error::Error"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Plan")
                                      [ F; CS ],
                                    "new",
                                    []
                                  |),
                                  [ M.read (| cs |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.tuple [];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let measure :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path
                              "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment",
                            "new",
                            []
                          |),
                          []
                        |)
                      |) in
                    let _ :=
                      let pass := M.alloc (| measure |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::plonk::circuit::Circuit",
                                    C,
                                    [ F ],
                                    "synthesize",
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Pass")
                                        [ F; CS ]
                                    ]
                                  |),
                                  [
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "halo2_proofs::plonk::circuit::Circuit",
                                          C,
                                          [ F ],
                                          "without_witnesses",
                                          []
                                        |),
                                        [ M.read (| circuit |) ]
                                      |)
                                    |);
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        Ty.associated,
                                        [],
                                        "clone",
                                        []
                                      |),
                                      [ config ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path
                                            "halo2_proofs::circuit::floor_planner::v1::V1Pass")
                                          [ F; CS ],
                                        "measure",
                                        []
                                      |),
                                      [ M.read (| pass |) ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.tuple [];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |) in
                    let measure :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::convert::Into",
                            Ty.path
                              "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment",
                            [ Ty.path "halo2_proofs::circuit::floor_planner::v1::MeasurementPass" ],
                            "into",
                            []
                          |),
                          [ M.read (| measure |) ]
                        |)
                      |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "halo2_proofs::circuit::floor_planner::v1::strategy::slot_in_biggest_advice_first",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                measure,
                                "halo2_proofs::circuit::floor_planner::v1::MeasurementPass",
                                "regions"
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let regions := M.copy (| γ0_0 |) in
                            let column_allocations := M.copy (| γ0_1 |) in
                            let _ :=
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  plan,
                                  "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                  "regions"
                                |),
                                M.read (| regions |)
                              |) in
                            let first_unassigned_row :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                    "unwrap_or",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::map::Map")
                                          [
                                            Ty.apply
                                              (Ty.path "std::collections::hash::map::Iter")
                                              [
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionColumn";
                                                Ty.path
                                                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                              ];
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::circuit::layouter::RegionColumn"
                                                          ];
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                          ]
                                                      ]
                                                  ]
                                              ]
                                              (Ty.path "usize")
                                          ],
                                        [],
                                        "max",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "std::collections::hash::map::Iter")
                                              [
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionColumn";
                                                Ty.path
                                                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                              ],
                                            [],
                                            "map",
                                            [
                                              Ty.path "usize";
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::circuit::layouter::RegionColumn"
                                                            ];
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                                (Ty.path "usize")
                                            ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "std::collections::hash::map::HashMap")
                                                  [
                                                    Ty.path
                                                      "halo2_proofs::circuit::layouter::RegionColumn";
                                                    Ty.path
                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations";
                                                    Ty.path "std::hash::random::RandomState"
                                                  ],
                                                "iter",
                                                []
                                              |),
                                              [ column_allocations ]
                                            |);
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    M.match_operator (|
                                                      M.alloc (| α0 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_tuple_field (|
                                                                γ,
                                                                0
                                                              |) in
                                                            let γ0_1 :=
                                                              M.SubPointer.get_tuple_field (|
                                                                γ,
                                                                1
                                                              |) in
                                                            let a := M.copy (| γ0_1 |) in
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path
                                                                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations",
                                                                "unbounded_interval_start",
                                                                []
                                                              |),
                                                              [ M.read (| a |) ]
                                                            |)))
                                                      ]
                                                    |)
                                                  | _ => M.impossible (||)
                                                  end))
                                          ]
                                        |)
                                      ]
                                    |);
                                    Value.Integer 0
                                  ]
                                |)
                              |) in
                            let fixed_allocations :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Column")
                                              [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                  [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                                              ]
                                          ]
                                          (Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                              Ty.path
                                                "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                            ])
                                      ],
                                    [],
                                    "collect",
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                              Ty.path
                                                "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Column")
                                              [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        "map",
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                              Ty.path
                                                "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                            ];
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                    [ Ty.path "halo2_proofs::plonk::circuit::Fixed"
                                                    ]
                                                ]
                                            ]
                                            (Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                  [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                                Ty.path
                                                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                              ])
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                  [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "into_iter",
                                            []
                                          |),
                                          [ M.read (| constants |) ]
                                        |);
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                M.match_operator (|
                                                  M.alloc (| α0 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let c := M.copy (| γ |) in
                                                        Value.Tuple
                                                          [
                                                            M.read (| c |);
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                  ],
                                                                "unwrap_or_default",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                          ]
                                                                      ],
                                                                    "cloned",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.call_closure (|
                                                                      M.get_associated_function (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "std::collections::hash::map::HashMap")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::circuit::layouter::RegionColumn";
                                                                            Ty.path
                                                                              "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations";
                                                                            Ty.path
                                                                              "std::hash::random::RandomState"
                                                                          ],
                                                                        "get",
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::circuit::layouter::RegionColumn"
                                                                        ]
                                                                      |),
                                                                      [
                                                                        column_allocations;
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::convert::Into",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                                [
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Any"
                                                                                ],
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::circuit::layouter::RegionColumn"
                                                                              ],
                                                                              "into",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "core::convert::From",
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                                    [
                                                                                      Ty.path
                                                                                        "halo2_proofs::plonk::circuit::Any"
                                                                                    ],
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                                      [
                                                                                        Ty.path
                                                                                          "halo2_proofs::plonk::circuit::Fixed"
                                                                                      ]
                                                                                  ],
                                                                                  "from",
                                                                                  []
                                                                                |),
                                                                                [ M.read (| c |) ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          ]))
                                                  ]
                                                |)
                                              | _ => M.impossible (||)
                                              end))
                                      ]
                                    |)
                                  ]
                                |)
                              |) in
                            let constant_positions :=
                              M.alloc (|
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Column")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::Fixed"
                                                              ];
                                                            Ty.path
                                                              "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                          ]
                                                      ],
                                                    [],
                                                    "flat_map",
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::flatten::FlatMap")
                                                        [
                                                          Ty.associated;
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::iter::adapters::map::Map")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::ops::range::Range")
                                                                [ Ty.path "usize" ];
                                                              Ty.function
                                                                [ Ty.tuple [ Ty.path "usize" ] ]
                                                                (Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::circuit::Fixed"
                                                                      ];
                                                                    Ty.path "usize"
                                                                  ])
                                                            ];
                                                          Ty.function
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                ]
                                                            ]
                                                            (Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::map::Map")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::Range")
                                                                  [ Ty.path "usize" ];
                                                                Ty.function
                                                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                                                  (Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path "usize"
                                                                    ])
                                                              ])
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.apply
                                                          (Ty.path
                                                            "core::iter::adapters::flatten::FlatMap")
                                                          [
                                                            Ty.associated;
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::map::Map")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::Range")
                                                                  [ Ty.path "usize" ];
                                                                Ty.function
                                                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                                                  (Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path "usize"
                                                                    ])
                                                              ];
                                                            Ty.function
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                  ]
                                                              ]
                                                              (Ty.apply
                                                                (Ty.path
                                                                  "core::iter::adapters::map::Map")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::ops::range::Range")
                                                                    [ Ty.path "usize" ];
                                                                  Ty.function
                                                                    [ Ty.tuple [ Ty.path "usize" ] ]
                                                                    (Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                                          ];
                                                                        Ty.path "usize"
                                                                      ])
                                                                ])
                                                          ])
                                                    ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ];
                                                                Ty.path
                                                                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                              ]
                                                          ],
                                                        "iter",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::circuit::Fixed"
                                                                      ];
                                                                    Ty.path
                                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                  ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ fixed_allocations ]
                                                        |)
                                                      ]
                                                    |);
                                                    M.closure
                                                      (fun γ =>
                                                        ltac:(M.monadic
                                                          match γ with
                                                          | [ α0 ] =>
                                                            M.match_operator (|
                                                              M.alloc (| α0 |),
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (let γ := M.read (| γ |) in
                                                                    let γ1_0 :=
                                                                      M.SubPointer.get_tuple_field (|
                                                                        γ,
                                                                        0
                                                                      |) in
                                                                    let γ1_1 :=
                                                                      M.SubPointer.get_tuple_field (|
                                                                        γ,
                                                                        1
                                                                      |) in
                                                                    let c := M.alloc (| γ1_0 |) in
                                                                    let a := M.alloc (| γ1_1 |) in
                                                                    M.read (|
                                                                      let c :=
                                                                        M.copy (|
                                                                          M.read (| c |)
                                                                        |) in
                                                                      M.alloc (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::iter::traits::iterator::Iterator",
                                                                            Ty.associated,
                                                                            [],
                                                                            "flat_map",
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::iter::adapters::map::Map")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "core::ops::range::Range")
                                                                                    [
                                                                                      Ty.path
                                                                                        "usize"
                                                                                    ];
                                                                                  Ty.function
                                                                                    [
                                                                                      Ty.tuple
                                                                                        [
                                                                                          Ty.path
                                                                                            "usize"
                                                                                        ]
                                                                                    ]
                                                                                    (Ty.tuple
                                                                                      [
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                                          [
                                                                                            Ty.path
                                                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                                                          ];
                                                                                        Ty.path
                                                                                          "usize"
                                                                                      ])
                                                                                ];
                                                                              Ty.function
                                                                                [
                                                                                  Ty.tuple
                                                                                    [
                                                                                      Ty.path
                                                                                        "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                                    ]
                                                                                ]
                                                                                (Ty.apply
                                                                                  (Ty.path
                                                                                    "core::iter::adapters::map::Map")
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::ops::range::Range")
                                                                                      [
                                                                                        Ty.path
                                                                                          "usize"
                                                                                      ];
                                                                                    Ty.function
                                                                                      [
                                                                                        Ty.tuple
                                                                                          [
                                                                                            Ty.path
                                                                                              "usize"
                                                                                          ]
                                                                                      ]
                                                                                      (Ty.tuple
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "halo2_proofs::plonk::circuit::Column")
                                                                                            [
                                                                                              Ty.path
                                                                                                "halo2_proofs::plonk::circuit::Fixed"
                                                                                            ];
                                                                                          Ty.path
                                                                                            "usize"
                                                                                        ])
                                                                                  ])
                                                                            ]
                                                                          |),
                                                                          [
                                                                            M.call_closure (|
                                                                              M.get_associated_function (|
                                                                                Ty.path
                                                                                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations",
                                                                                "free_intervals",
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.read (| a |);
                                                                                Value.Integer 0;
                                                                                Value.StructTuple
                                                                                  "core::option::Option::Some"
                                                                                  [
                                                                                    M.read (|
                                                                                      first_unassigned_row
                                                                                    |)
                                                                                  ]
                                                                              ]
                                                                            |);
                                                                            M.closure
                                                                              (fun γ =>
                                                                                ltac:(M.monadic
                                                                                  match γ with
                                                                                  | [ α0 ] =>
                                                                                    M.match_operator (|
                                                                                      M.alloc (|
                                                                                        α0
                                                                                      |),
                                                                                      [
                                                                                        fun γ =>
                                                                                          ltac:(M.monadic
                                                                                            (let
                                                                                                  e :=
                                                                                              M.copy (|
                                                                                                γ
                                                                                              |) in
                                                                                            M.call_closure (|
                                                                                              M.get_trait_method (|
                                                                                                "core::iter::traits::iterator::Iterator",
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "core::ops::range::Range")
                                                                                                  [
                                                                                                    Ty.path
                                                                                                      "usize"
                                                                                                  ],
                                                                                                [],
                                                                                                "map",
                                                                                                [
                                                                                                  Ty.tuple
                                                                                                    [
                                                                                                      Ty.apply
                                                                                                        (Ty.path
                                                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                                                        [
                                                                                                          Ty.path
                                                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                                                        ];
                                                                                                      Ty.path
                                                                                                        "usize"
                                                                                                    ];
                                                                                                  Ty.function
                                                                                                    [
                                                                                                      Ty.tuple
                                                                                                        [
                                                                                                          Ty.path
                                                                                                            "usize"
                                                                                                        ]
                                                                                                    ]
                                                                                                    (Ty.tuple
                                                                                                      [
                                                                                                        Ty.apply
                                                                                                          (Ty.path
                                                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                                                          [
                                                                                                            Ty.path
                                                                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                                                                          ];
                                                                                                        Ty.path
                                                                                                          "usize"
                                                                                                      ])
                                                                                                ]
                                                                                              |),
                                                                                              [
                                                                                                M.call_closure (|
                                                                                                  M.get_associated_function (|
                                                                                                    Ty.apply
                                                                                                      (Ty.path
                                                                                                        "core::option::Option")
                                                                                                      [
                                                                                                        Ty.apply
                                                                                                          (Ty.path
                                                                                                            "core::ops::range::Range")
                                                                                                          [
                                                                                                            Ty.path
                                                                                                              "usize"
                                                                                                          ]
                                                                                                      ],
                                                                                                    "unwrap",
                                                                                                    []
                                                                                                  |),
                                                                                                  [
                                                                                                    M.call_closure (|
                                                                                                      M.get_associated_function (|
                                                                                                        Ty.path
                                                                                                          "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace",
                                                                                                        "range",
                                                                                                        []
                                                                                                      |),
                                                                                                      [
                                                                                                        e
                                                                                                      ]
                                                                                                    |)
                                                                                                  ]
                                                                                                |);
                                                                                                M.closure
                                                                                                  (fun
                                                                                                      γ =>
                                                                                                    ltac:(M.monadic
                                                                                                      match
                                                                                                        γ
                                                                                                      with
                                                                                                      | [
                                                                                                            α0
                                                                                                          ] =>
                                                                                                        M.match_operator (|
                                                                                                          M.alloc (|
                                                                                                            α0
                                                                                                          |),
                                                                                                          [
                                                                                                            fun
                                                                                                                γ =>
                                                                                                              ltac:(M.monadic
                                                                                                                (let
                                                                                                                      i :=
                                                                                                                  M.copy (|
                                                                                                                    γ
                                                                                                                  |) in
                                                                                                                Value.Tuple
                                                                                                                  [
                                                                                                                    M.read (|
                                                                                                                      c
                                                                                                                    |);
                                                                                                                    M.read (|
                                                                                                                      i
                                                                                                                    |)
                                                                                                                  ]))
                                                                                                          ]
                                                                                                        |)
                                                                                                      | _ =>
                                                                                                        M.impossible (||)
                                                                                                      end))
                                                                                              ]
                                                                                            |)))
                                                                                      ]
                                                                                    |)
                                                                                  | _ =>
                                                                                    M.impossible (||)
                                                                                  end))
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |)))
                                                              ]
                                                            |)
                                                          | _ => M.impossible (||)
                                                          end))
                                                  ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end))
                              |) in
                            let assign :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path
                                        "halo2_proofs::circuit::floor_planner::v1::AssignmentPass")
                                      [ F; CS ],
                                    "new",
                                    []
                                  |),
                                  [
                                    plan;
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        measure,
                                        "halo2_proofs::circuit::floor_planner::v1::MeasurementPass",
                                        "regions_name"
                                      |)
                                    |)
                                  ]
                                |)
                              |) in
                            let _ :=
                              let pass := M.alloc (| assign |) in
                              let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "halo2_proofs::plonk::circuit::Circuit",
                                            C,
                                            [ F ],
                                            "synthesize",
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "halo2_proofs::circuit::floor_planner::v1::V1Pass")
                                                [ F; CS ]
                                            ]
                                          |),
                                          [
                                            M.read (| circuit |);
                                            M.read (| config |);
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::circuit::floor_planner::v1::V1Pass")
                                                  [ F; CS ],
                                                "assign",
                                                []
                                              |),
                                              [ M.read (| pass |) ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.tuple [];
                                                        Ty.path "halo2_proofs::plonk::error::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path
                                                            "halo2_proofs::plonk::error::Error"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |) in
                            let constants :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.apply
                                          (Ty.path "std::sync::mutex::MutexGuard")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ];
                                                    Ty.path "halo2_proofs::circuit::Cell"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ];
                                        Ty.apply
                                          (Ty.path "std::sync::poison::PoisonError")
                                          [
                                            Ty.apply
                                              (Ty.path "std::sync::mutex::MutexGuard")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                          [ F ];
                                                        Ty.path "halo2_proofs::circuit::Cell"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ]
                                          ]
                                      ],
                                    "unwrap",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "halo2_proofs::parallel::Parallel")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ];
                                                    Ty.path "halo2_proofs::circuit::Cell"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ],
                                        "lock",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          plan,
                                          "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                          "constants"
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            BinOp.Pure.lt
                                              (M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::flatten::FlatMap")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                ];
                                                              Ty.path
                                                                "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::flatten::FlatMap")
                                                        [
                                                          Ty.associated;
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::iter::adapters::map::Map")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::ops::range::Range")
                                                                [ Ty.path "usize" ];
                                                              Ty.function
                                                                [ Ty.tuple [ Ty.path "usize" ] ]
                                                                (Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::circuit::Fixed"
                                                                      ];
                                                                    Ty.path "usize"
                                                                  ])
                                                            ];
                                                          Ty.function
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                ]
                                                            ]
                                                            (Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::map::Map")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::Range")
                                                                  [ Ty.path "usize" ];
                                                                Ty.function
                                                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                                                  (Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path "usize"
                                                                    ])
                                                              ])
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.apply
                                                          (Ty.path
                                                            "core::iter::adapters::flatten::FlatMap")
                                                          [
                                                            Ty.associated;
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::map::Map")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::Range")
                                                                  [ Ty.path "usize" ];
                                                                Ty.function
                                                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                                                  (Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path "usize"
                                                                    ])
                                                              ];
                                                            Ty.function
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                  ]
                                                              ]
                                                              (Ty.apply
                                                                (Ty.path
                                                                  "core::iter::adapters::map::Map")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::ops::range::Range")
                                                                    [ Ty.path "usize" ];
                                                                  Ty.function
                                                                    [ Ty.tuple [ Ty.path "usize" ] ]
                                                                    (Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                                          ];
                                                                        Ty.path "usize"
                                                                      ])
                                                                ])
                                                          ])
                                                    ],
                                                  [],
                                                  "count",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::function::Fn",
                                                      Ty.function
                                                        [ Ty.tuple [] ]
                                                        (Ty.apply
                                                          (Ty.path
                                                            "core::iter::adapters::flatten::FlatMap")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::Iter")
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::circuit::Fixed"
                                                                      ];
                                                                    Ty.path
                                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                  ]
                                                              ];
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::flatten::FlatMap")
                                                              [
                                                                Ty.associated;
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::iter::adapters::map::Map")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::ops::range::Range")
                                                                      [ Ty.path "usize" ];
                                                                    Ty.function
                                                                      [ Ty.tuple [ Ty.path "usize" ]
                                                                      ]
                                                                      (Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::plonk::circuit::Column")
                                                                            [
                                                                              Ty.path
                                                                                "halo2_proofs::plonk::circuit::Fixed"
                                                                            ];
                                                                          Ty.path "usize"
                                                                        ])
                                                                  ];
                                                                Ty.function
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                      ]
                                                                  ]
                                                                  (Ty.apply
                                                                    (Ty.path
                                                                      "core::iter::adapters::map::Map")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::ops::range::Range")
                                                                        [ Ty.path "usize" ];
                                                                      Ty.function
                                                                        [
                                                                          Ty.tuple
                                                                            [ Ty.path "usize" ]
                                                                        ]
                                                                        (Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "halo2_proofs::plonk::circuit::Column")
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Fixed"
                                                                              ];
                                                                            Ty.path "usize"
                                                                          ])
                                                                    ])
                                                              ];
                                                            Ty.function
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "halo2_proofs::plonk::circuit::Column")
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Fixed"
                                                                              ];
                                                                            Ty.path
                                                                              "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                          ]
                                                                      ]
                                                                  ]
                                                              ]
                                                              (Ty.apply
                                                                (Ty.path
                                                                  "core::iter::adapters::flatten::FlatMap")
                                                                [
                                                                  Ty.associated;
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::iter::adapters::map::Map")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::ops::range::Range")
                                                                        [ Ty.path "usize" ];
                                                                      Ty.function
                                                                        [
                                                                          Ty.tuple
                                                                            [ Ty.path "usize" ]
                                                                        ]
                                                                        (Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "halo2_proofs::plonk::circuit::Column")
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Fixed"
                                                                              ];
                                                                            Ty.path "usize"
                                                                          ])
                                                                    ];
                                                                  Ty.function
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                        ]
                                                                    ]
                                                                    (Ty.apply
                                                                      (Ty.path
                                                                        "core::iter::adapters::map::Map")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::ops::range::Range")
                                                                          [ Ty.path "usize" ];
                                                                        Ty.function
                                                                          [
                                                                            Ty.tuple
                                                                              [ Ty.path "usize" ]
                                                                          ]
                                                                          (Ty.tuple
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                                [
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                                ];
                                                                              Ty.path "usize"
                                                                            ])
                                                                      ])
                                                                ])
                                                          ]),
                                                      [ Ty.tuple [] ],
                                                      "call",
                                                      []
                                                    |),
                                                    [ constant_positions; Value.Tuple [] ]
                                                  |)
                                                ]
                                              |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::assigned::Assigned")
                                                            [ F ];
                                                          Ty.path "halo2_proofs::circuit::Cell"
                                                        ];
                                                      Ty.path "alloc::alloc::Global"
                                                    ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "std::sync::mutex::MutexGuard")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::assigned::Assigned")
                                                                    [ F ];
                                                                  Ty.path
                                                                    "halo2_proofs::circuit::Cell"
                                                                ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ]
                                                        ],
                                                      [],
                                                      "deref",
                                                      []
                                                    |),
                                                    [ constants ]
                                                  |)
                                                ]
                                              |))
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              Value.StructTuple
                                                "core::result::Result::Err"
                                                [
                                                  Value.StructTuple
                                                    "halo2_proofs::plonk::error::Error::NotEnoughColumnsForConstants"
                                                    []
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                              [ F ];
                                            Ty.path "halo2_proofs::circuit::Cell"
                                          ]
                                      ],
                                    "sort_by",
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::assigned::Assigned")
                                                        [ F ];
                                                      Ty.path "halo2_proofs::circuit::Cell"
                                                    ]
                                                ];
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::assigned::Assigned")
                                                        [ F ];
                                                      Ty.path "halo2_proofs::circuit::Cell"
                                                    ]
                                                ]
                                            ]
                                        ]
                                        (Ty.path "core::cmp::Ordering")
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::deref::DerefMut",
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                  [ F ];
                                                Ty.path "halo2_proofs::circuit::Cell"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        "deref_mut",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::DerefMut",
                                            Ty.apply
                                              (Ty.path "std::sync::mutex::MutexGuard")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                          [ F ];
                                                        Ty.path "halo2_proofs::circuit::Cell"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ],
                                            [],
                                            "deref_mut",
                                            []
                                          |),
                                          [ constants ]
                                        |)
                                      ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0; α1 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ := M.read (| γ |) in
                                                    let γ1_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ1_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let cell_a := M.alloc (| γ1_1 |) in
                                                    M.match_operator (|
                                                      M.alloc (| α1 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ := M.read (| γ |) in
                                                            let γ1_0 :=
                                                              M.SubPointer.get_tuple_field (|
                                                                γ,
                                                                0
                                                              |) in
                                                            let γ1_1 :=
                                                              M.SubPointer.get_tuple_field (|
                                                                γ,
                                                                1
                                                              |) in
                                                            let cell_b := M.alloc (| γ1_1 |) in
                                                            M.read (|
                                                              M.match_operator (|
                                                                M.alloc (| Value.Tuple [] |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ :=
                                                                        M.use
                                                                          (M.alloc (|
                                                                            M.call_closure (|
                                                                              M.get_trait_method (|
                                                                                "core::cmp::PartialEq",
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                                  [
                                                                                    Ty.path
                                                                                      "halo2_proofs::plonk::circuit::Any"
                                                                                  ],
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                                    [
                                                                                      Ty.path
                                                                                        "halo2_proofs::plonk::circuit::Any"
                                                                                    ]
                                                                                ],
                                                                                "ne",
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.SubPointer.get_struct_record_field (|
                                                                                  M.read (|
                                                                                    cell_a
                                                                                  |),
                                                                                  "halo2_proofs::circuit::Cell",
                                                                                  "column"
                                                                                |);
                                                                                M.SubPointer.get_struct_record_field (|
                                                                                  M.read (|
                                                                                    cell_b
                                                                                  |),
                                                                                  "halo2_proofs::circuit::Cell",
                                                                                  "column"
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |)) in
                                                                      let _ :=
                                                                        M.is_constant_or_break_match (|
                                                                          M.read (| γ |),
                                                                          Value.Bool true
                                                                        |) in
                                                                      M.alloc (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::cmp::Ord",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "halo2_proofs::plonk::circuit::Column")
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Any"
                                                                              ],
                                                                            [],
                                                                            "cmp",
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.SubPointer.get_struct_record_field (|
                                                                              M.read (| cell_a |),
                                                                              "halo2_proofs::circuit::Cell",
                                                                              "column"
                                                                            |);
                                                                            M.SubPointer.get_struct_record_field (|
                                                                              M.read (| cell_b |),
                                                                              "halo2_proofs::circuit::Cell",
                                                                              "column"
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (M.alloc (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::cmp::Ord",
                                                                            Ty.path "usize",
                                                                            [],
                                                                            "cmp",
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.SubPointer.get_struct_record_field (|
                                                                              M.read (| cell_a |),
                                                                              "halo2_proofs::circuit::Cell",
                                                                              "row_offset"
                                                                            |);
                                                                            M.SubPointer.get_struct_record_field (|
                                                                              M.read (| cell_b |),
                                                                              "halo2_proofs::circuit::Cell",
                                                                              "row_offset"
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |)))
                                                                ]
                                                              |)
                                                            |)))
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  ]
                                |)
                              |) in
                            let _ :=
                              M.use
                                (M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::collect::IntoIterator",
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::zip::Zip")
                                          [
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::flatten::FlatMap")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Column")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                          ];
                                                        Ty.path
                                                          "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                      ]
                                                  ];
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::flatten::FlatMap")
                                                  [
                                                    Ty.associated;
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::ops::range::Range")
                                                          [ Ty.path "usize" ];
                                                        Ty.function
                                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                                          (Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                ];
                                                              Ty.path "usize"
                                                            ])
                                                      ];
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                          ]
                                                      ]
                                                      (Ty.apply
                                                        (Ty.path "core::iter::adapters::map::Map")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            [ Ty.path "usize" ];
                                                          Ty.function
                                                            [ Ty.tuple [ Ty.path "usize" ] ]
                                                            (Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ];
                                                                Ty.path "usize"
                                                              ])
                                                        ])
                                                  ];
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ];
                                                                Ty.path
                                                                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                              ]
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::flatten::FlatMap")
                                                    [
                                                      Ty.associated;
                                                      Ty.apply
                                                        (Ty.path "core::iter::adapters::map::Map")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            [ Ty.path "usize" ];
                                                          Ty.function
                                                            [ Ty.tuple [ Ty.path "usize" ] ]
                                                            (Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ];
                                                                Ty.path "usize"
                                                              ])
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                            ]
                                                        ]
                                                        (Ty.apply
                                                          (Ty.path "core::iter::adapters::map::Map")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::ops::range::Range")
                                                              [ Ty.path "usize" ];
                                                            Ty.function
                                                              [ Ty.tuple [ Ty.path "usize" ] ]
                                                              (Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::circuit::Fixed"
                                                                    ];
                                                                  Ty.path "usize"
                                                                ])
                                                          ])
                                                    ])
                                              ];
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Iter")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ];
                                                    Ty.path "halo2_proofs::circuit::Cell"
                                                  ]
                                              ]
                                          ],
                                        [],
                                        "into_iter",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::flatten::FlatMap")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Column")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                          ];
                                                        Ty.path
                                                          "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                      ]
                                                  ];
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::flatten::FlatMap")
                                                  [
                                                    Ty.associated;
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::ops::range::Range")
                                                          [ Ty.path "usize" ];
                                                        Ty.function
                                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                                          (Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                ];
                                                              Ty.path "usize"
                                                            ])
                                                      ];
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                          ]
                                                      ]
                                                      (Ty.apply
                                                        (Ty.path "core::iter::adapters::map::Map")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            [ Ty.path "usize" ];
                                                          Ty.function
                                                            [ Ty.tuple [ Ty.path "usize" ] ]
                                                            (Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ];
                                                                Ty.path "usize"
                                                              ])
                                                        ])
                                                  ];
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ];
                                                                Ty.path
                                                                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                              ]
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::flatten::FlatMap")
                                                    [
                                                      Ty.associated;
                                                      Ty.apply
                                                        (Ty.path "core::iter::adapters::map::Map")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            [ Ty.path "usize" ];
                                                          Ty.function
                                                            [ Ty.tuple [ Ty.path "usize" ] ]
                                                            (Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ];
                                                                Ty.path "usize"
                                                              ])
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                            ]
                                                        ]
                                                        (Ty.apply
                                                          (Ty.path "core::iter::adapters::map::Map")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::ops::range::Range")
                                                              [ Ty.path "usize" ];
                                                            Ty.function
                                                              [ Ty.tuple [ Ty.path "usize" ] ]
                                                              (Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::circuit::Fixed"
                                                                    ];
                                                                  Ty.path "usize"
                                                                ])
                                                          ])
                                                    ])
                                              ],
                                            [],
                                            "zip",
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::assigned::Assigned")
                                                        [ F ];
                                                      Ty.path "halo2_proofs::circuit::Cell"
                                                    ]
                                                ]
                                            ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::function::Fn",
                                                Ty.function
                                                  [ Ty.tuple [] ]
                                                  (Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::flatten::FlatMap")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                ];
                                                              Ty.path
                                                                "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::flatten::FlatMap")
                                                        [
                                                          Ty.associated;
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::iter::adapters::map::Map")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::ops::range::Range")
                                                                [ Ty.path "usize" ];
                                                              Ty.function
                                                                [ Ty.tuple [ Ty.path "usize" ] ]
                                                                (Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::circuit::Fixed"
                                                                      ];
                                                                    Ty.path "usize"
                                                                  ])
                                                            ];
                                                          Ty.function
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                ]
                                                            ]
                                                            (Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::map::Map")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::Range")
                                                                  [ Ty.path "usize" ];
                                                                Ty.function
                                                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                                                  (Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path "usize"
                                                                    ])
                                                              ])
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.apply
                                                          (Ty.path
                                                            "core::iter::adapters::flatten::FlatMap")
                                                          [
                                                            Ty.associated;
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::map::Map")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::Range")
                                                                  [ Ty.path "usize" ];
                                                                Ty.function
                                                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                                                  (Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path "usize"
                                                                    ])
                                                              ];
                                                            Ty.function
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                  ]
                                                              ]
                                                              (Ty.apply
                                                                (Ty.path
                                                                  "core::iter::adapters::map::Map")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::ops::range::Range")
                                                                    [ Ty.path "usize" ];
                                                                  Ty.function
                                                                    [ Ty.tuple [ Ty.path "usize" ] ]
                                                                    (Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                                          ];
                                                                        Ty.path "usize"
                                                                      ])
                                                                ])
                                                          ])
                                                    ]),
                                                [ Ty.tuple [] ],
                                                "call",
                                                []
                                              |),
                                              [ constant_positions; Value.Tuple [] ]
                                            |);
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                          [ F ];
                                                        Ty.path "halo2_proofs::circuit::Cell"
                                                      ]
                                                  ],
                                                "iter",
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::assigned::Assigned")
                                                              [ F ];
                                                            Ty.path "halo2_proofs::circuit::Cell"
                                                          ];
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    [],
                                                    "deref",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::deref::Deref",
                                                        Ty.apply
                                                          (Ty.path "std::sync::mutex::MutexGuard")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                                      [ F ];
                                                                    Ty.path
                                                                      "halo2_proofs::circuit::Cell"
                                                                  ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ]
                                                          ],
                                                        [],
                                                        "deref",
                                                        []
                                                      |),
                                                      [ constants ]
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let iter := M.copy (| γ |) in
                                        M.loop (|
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path "core::iter::adapters::zip::Zip")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::iter::adapters::flatten::FlatMap")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::slice::iter::Iter")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                    ]
                                                                ];
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::iter::adapters::flatten::FlatMap")
                                                                [
                                                                  Ty.associated;
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::iter::adapters::map::Map")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::ops::range::Range")
                                                                        [ Ty.path "usize" ];
                                                                      Ty.function
                                                                        [
                                                                          Ty.tuple
                                                                            [ Ty.path "usize" ]
                                                                        ]
                                                                        (Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "halo2_proofs::plonk::circuit::Column")
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Fixed"
                                                                              ];
                                                                            Ty.path "usize"
                                                                          ])
                                                                    ];
                                                                  Ty.function
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                        ]
                                                                    ]
                                                                    (Ty.apply
                                                                      (Ty.path
                                                                        "core::iter::adapters::map::Map")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::ops::range::Range")
                                                                          [ Ty.path "usize" ];
                                                                        Ty.function
                                                                          [
                                                                            Ty.tuple
                                                                              [ Ty.path "usize" ]
                                                                          ]
                                                                          (Ty.tuple
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                                [
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                                ];
                                                                              Ty.path "usize"
                                                                            ])
                                                                      ])
                                                                ];
                                                              Ty.function
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        [
                                                                          Ty.tuple
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                                [
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                                ];
                                                                              Ty.path
                                                                                "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                            ]
                                                                        ]
                                                                    ]
                                                                ]
                                                                (Ty.apply
                                                                  (Ty.path
                                                                    "core::iter::adapters::flatten::FlatMap")
                                                                  [
                                                                    Ty.associated;
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::iter::adapters::map::Map")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::ops::range::Range")
                                                                          [ Ty.path "usize" ];
                                                                        Ty.function
                                                                          [
                                                                            Ty.tuple
                                                                              [ Ty.path "usize" ]
                                                                          ]
                                                                          (Ty.tuple
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                                [
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                                ];
                                                                              Ty.path "usize"
                                                                            ])
                                                                      ];
                                                                    Ty.function
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                          ]
                                                                      ]
                                                                      (Ty.apply
                                                                        (Ty.path
                                                                          "core::iter::adapters::map::Map")
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::ops::range::Range")
                                                                            [ Ty.path "usize" ];
                                                                          Ty.function
                                                                            [
                                                                              Ty.tuple
                                                                                [ Ty.path "usize" ]
                                                                            ]
                                                                            (Ty.tuple
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                                  [
                                                                                    Ty.path
                                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                                  ];
                                                                                Ty.path "usize"
                                                                              ])
                                                                        ])
                                                                  ])
                                                            ];
                                                          Ty.apply
                                                            (Ty.path "core::slice::iter::Iter")
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::assigned::Assigned")
                                                                    [ F ];
                                                                  Ty.path
                                                                    "halo2_proofs::circuit::Cell"
                                                                ]
                                                            ]
                                                        ],
                                                      [],
                                                      "next",
                                                      []
                                                    |),
                                                    [ iter ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (| M.break (||) |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let γ1_0 :=
                                                        M.SubPointer.get_tuple_field (|
                                                          γ0_0,
                                                          0
                                                        |) in
                                                      let γ1_1 :=
                                                        M.SubPointer.get_tuple_field (|
                                                          γ0_0,
                                                          1
                                                        |) in
                                                      let γ2_0 :=
                                                        M.SubPointer.get_tuple_field (|
                                                          γ1_0,
                                                          0
                                                        |) in
                                                      let γ2_1 :=
                                                        M.SubPointer.get_tuple_field (|
                                                          γ1_0,
                                                          1
                                                        |) in
                                                      let fixed_column := M.copy (| γ2_0 |) in
                                                      let fixed_row := M.copy (| γ2_1 |) in
                                                      let γ1_1 := M.read (| γ1_1 |) in
                                                      let γ3_0 :=
                                                        M.SubPointer.get_tuple_field (|
                                                          γ1_1,
                                                          0
                                                        |) in
                                                      let γ3_1 :=
                                                        M.SubPointer.get_tuple_field (|
                                                          γ1_1,
                                                          1
                                                        |) in
                                                      let value := M.alloc (| γ3_0 |) in
                                                      let advice := M.alloc (| γ3_1 |) in
                                                      let _ :=
                                                        M.match_operator (|
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::try_trait::Try",
                                                                Ty.apply
                                                                  (Ty.path "core::result::Result")
                                                                  [
                                                                    Ty.tuple [];
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::error::Error"
                                                                  ],
                                                                [],
                                                                "branch",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "halo2_proofs::plonk::circuit::Assignment",
                                                                    CS,
                                                                    [ F ],
                                                                    "assign_fixed",
                                                                    [
                                                                      Ty.function
                                                                        [ Ty.tuple [] ]
                                                                        (Ty.apply
                                                                          (Ty.path
                                                                            "core::result::Result")
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "halo2_proofs::plonk::assigned::Assigned")
                                                                              [ F ];
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::error::Error"
                                                                          ]);
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::assigned::Assigned")
                                                                        [ F ];
                                                                      Ty.function
                                                                        [ Ty.tuple [] ]
                                                                        (Ty.path
                                                                          "alloc::string::String");
                                                                      Ty.path
                                                                        "alloc::string::String"
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.read (|
                                                                      M.SubPointer.get_struct_record_field (|
                                                                        plan,
                                                                        "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                                                        "cs"
                                                                      |)
                                                                    |);
                                                                    M.closure
                                                                      (fun γ =>
                                                                        ltac:(M.monadic
                                                                          match γ with
                                                                          | [ α0 ] =>
                                                                            M.match_operator (|
                                                                              M.alloc (| α0 |),
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (M.read (|
                                                                                      let res :=
                                                                                        M.alloc (|
                                                                                          M.call_closure (|
                                                                                            M.get_function (|
                                                                                              "alloc::fmt::format",
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              M.call_closure (|
                                                                                                M.get_associated_function (|
                                                                                                  Ty.path
                                                                                                    "core::fmt::Arguments",
                                                                                                  "new_v1",
                                                                                                  []
                                                                                                |),
                                                                                                [
                                                                                                  (* Unsize *)
                                                                                                  M.pointer_coercion
                                                                                                    (M.alloc (|
                                                                                                      Value.Array
                                                                                                        [
                                                                                                          M.read (|
                                                                                                            Value.String
                                                                                                              "Constant("
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            Value.String
                                                                                                              ")"
                                                                                                          |)
                                                                                                        ]
                                                                                                    |));
                                                                                                  (* Unsize *)
                                                                                                  M.pointer_coercion
                                                                                                    (M.alloc (|
                                                                                                      Value.Array
                                                                                                        [
                                                                                                          M.call_closure (|
                                                                                                            M.get_associated_function (|
                                                                                                              Ty.path
                                                                                                                "core::fmt::rt::Argument",
                                                                                                              "new_debug",
                                                                                                              [
                                                                                                                F
                                                                                                              ]
                                                                                                            |),
                                                                                                            [
                                                                                                              M.alloc (|
                                                                                                                M.call_closure (|
                                                                                                                  M.get_associated_function (|
                                                                                                                    Ty.apply
                                                                                                                      (Ty.path
                                                                                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                                                                                      [
                                                                                                                        F
                                                                                                                      ],
                                                                                                                    "evaluate",
                                                                                                                    []
                                                                                                                  |),
                                                                                                                  [
                                                                                                                    M.read (|
                                                                                                                      M.read (|
                                                                                                                        value
                                                                                                                      |)
                                                                                                                    |)
                                                                                                                  ]
                                                                                                                |)
                                                                                                              |)
                                                                                                            ]
                                                                                                          |)
                                                                                                        ]
                                                                                                    |))
                                                                                                ]
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        |) in
                                                                                      res
                                                                                    |)))
                                                                              ]
                                                                            |)
                                                                          | _ => M.impossible (||)
                                                                          end));
                                                                    M.read (| fixed_column |);
                                                                    M.read (| fixed_row |);
                                                                    M.closure
                                                                      (fun γ =>
                                                                        ltac:(M.monadic
                                                                          match γ with
                                                                          | [ α0 ] =>
                                                                            M.match_operator (|
                                                                              M.alloc (| α0 |),
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (Value.StructTuple
                                                                                      "core::result::Result::Ok"
                                                                                      [
                                                                                        M.read (|
                                                                                          M.read (|
                                                                                            value
                                                                                          |)
                                                                                        |)
                                                                                      ]))
                                                                              ]
                                                                            |)
                                                                          | _ => M.impossible (||)
                                                                          end))
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Break",
                                                                    0
                                                                  |) in
                                                                let residual := M.copy (| γ0_0 |) in
                                                                M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (|
                                                                      M.return_ (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::ops::try_trait::FromResidual",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::result::Result")
                                                                              [
                                                                                Ty.tuple [];
                                                                                Ty.path
                                                                                  "halo2_proofs::plonk::error::Error"
                                                                              ],
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.path
                                                                                    "core::convert::Infallible";
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::error::Error"
                                                                                ]
                                                                            ],
                                                                            "from_residual",
                                                                            []
                                                                          |),
                                                                          [ M.read (| residual |) ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                                    0
                                                                  |) in
                                                                let val := M.copy (| γ0_0 |) in
                                                                val))
                                                          ]
                                                        |) in
                                                      let _ :=
                                                        M.match_operator (|
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::try_trait::Try",
                                                                Ty.apply
                                                                  (Ty.path "core::result::Result")
                                                                  [
                                                                    Ty.tuple [];
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::error::Error"
                                                                  ],
                                                                [],
                                                                "branch",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "halo2_proofs::plonk::circuit::Assignment",
                                                                    CS,
                                                                    [ F ],
                                                                    "copy",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.read (|
                                                                      M.SubPointer.get_struct_record_field (|
                                                                        plan,
                                                                        "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                                                        "cs"
                                                                      |)
                                                                    |);
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::convert::Into",
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                                          ],
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::plonk::circuit::Column")
                                                                            [
                                                                              Ty.path
                                                                                "halo2_proofs::plonk::circuit::Any"
                                                                            ]
                                                                        ],
                                                                        "into",
                                                                        []
                                                                      |),
                                                                      [ M.read (| fixed_column |) ]
                                                                    |);
                                                                    M.read (| fixed_row |);
                                                                    M.read (|
                                                                      M.SubPointer.get_struct_record_field (|
                                                                        M.read (| advice |),
                                                                        "halo2_proofs::circuit::Cell",
                                                                        "column"
                                                                      |)
                                                                    |);
                                                                    BinOp.Panic.add (|
                                                                      Integer.Usize,
                                                                      M.read (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::ops::deref::Deref",
                                                                            Ty.path
                                                                              "halo2_proofs::circuit::RegionStart",
                                                                            [],
                                                                            "deref",
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.call_closure (|
                                                                              M.get_trait_method (|
                                                                                "core::ops::index::Index",
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "alloc::vec::Vec")
                                                                                  [
                                                                                    Ty.path
                                                                                      "halo2_proofs::circuit::RegionStart";
                                                                                    Ty.path
                                                                                      "alloc::alloc::Global"
                                                                                  ],
                                                                                [ Ty.path "usize" ],
                                                                                "index",
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.SubPointer.get_struct_record_field (|
                                                                                  plan,
                                                                                  "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                                                                  "regions"
                                                                                |);
                                                                                M.read (|
                                                                                  M.call_closure (|
                                                                                    M.get_trait_method (|
                                                                                      "core::ops::deref::Deref",
                                                                                      Ty.path
                                                                                        "halo2_proofs::circuit::RegionIndex",
                                                                                      [],
                                                                                      "deref",
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.SubPointer.get_struct_record_field (|
                                                                                        M.read (|
                                                                                          advice
                                                                                        |),
                                                                                        "halo2_proofs::circuit::Cell",
                                                                                        "region_index"
                                                                                      |)
                                                                                    ]
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |),
                                                                      M.read (|
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.read (| advice |),
                                                                          "halo2_proofs::circuit::Cell",
                                                                          "row_offset"
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Break",
                                                                    0
                                                                  |) in
                                                                let residual := M.copy (| γ0_0 |) in
                                                                M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (|
                                                                      M.return_ (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::ops::try_trait::FromResidual",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::result::Result")
                                                                              [
                                                                                Ty.tuple [];
                                                                                Ty.path
                                                                                  "halo2_proofs::plonk::error::Error"
                                                                              ],
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.path
                                                                                    "core::convert::Infallible";
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::error::Error"
                                                                                ]
                                                                            ],
                                                                            "from_residual",
                                                                            []
                                                                          |),
                                                                          [ M.read (| residual |) ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                                    0
                                                                  |) in
                                                                let val := M.copy (| γ0_0 |) in
                                                                val))
                                                          ]
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                        |)))
                                  ]
                                |)) in
                            M.alloc (|
                              Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "halo2_proofs::plonk::circuit::FloorPlanner"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("synthesize", InstanceField.Method synthesize) ].
      End Impl_halo2_proofs_plonk_circuit_FloorPlanner_for_halo2_proofs_circuit_floor_planner_v1_V1.
      
      (*
      Enum Pass
      {
        ty_params := [ "F"; "CS" ];
        variants :=
          [
            {
              name := "Measurement";
              item :=
                StructTuple
                  [
                    Ty.apply
                      (Ty.path "&")
                      [
                        Ty.path
                          "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment"
                      ]
                  ];
              discriminant := None;
            };
            {
              name := "Assignment";
              item :=
                StructTuple
                  [
                    Ty.apply
                      (Ty.path "&")
                      [
                        Ty.apply
                          (Ty.path "halo2_proofs::circuit::floor_planner::v1::AssignmentPass")
                          [ F; CS ]
                      ]
                  ];
              discriminant := None;
            }
          ];
      }
      *)
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_where_core_clone_Clone_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_Pass_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::Pass") [ F; CS ].
        
        (* Clone *)
        Definition clone (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Measurement",
                            0
                          |) in
                        let __self_0 := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Measurement"
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.apply
                                    (Ty.path "&")
                                    [
                                      Ty.path
                                        "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment"
                                    ],
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_0 |) ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Assignment",
                            0
                          |) in
                        let __self_0 := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Assignment"
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.apply
                                    (Ty.path "&")
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "halo2_proofs::circuit::floor_planner::v1::AssignmentPass")
                                        [ F; CS ]
                                    ],
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_0 |) ]
                              |)
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone F CS)) ].
      End Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_where_core_clone_Clone_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_Pass_F_CS.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_where_core_fmt_Debug_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_Pass_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::Pass") [ F; CS ].
        
        (* Debug *)
        Definition fmt (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Measurement",
                            0
                          |) in
                        let __self_0 := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Formatter",
                              "debug_tuple_field1_finish",
                              []
                            |),
                            [
                              M.read (| f |);
                              M.read (| Value.String "Measurement" |);
                              (* Unsize *) M.pointer_coercion __self_0
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Assignment",
                            0
                          |) in
                        let __self_0 := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Formatter",
                              "debug_tuple_field1_finish",
                              []
                            |),
                            [
                              M.read (| f |);
                              M.read (| Value.String "Assignment" |);
                              (* Unsize *) M.pointer_coercion __self_0
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F CS)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_where_core_fmt_Debug_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_Pass_F_CS.
      
      (* StructTuple
        {
          name := "V1Pass";
          ty_params := [ "F"; "CS" ];
          fields :=
            [ Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::Pass") [ F; CS ] ];
        } *)
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_where_core_clone_Clone_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_V1Pass_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Pass") [ F; CS ].
        
        (* Clone *)
        Definition clone (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructTuple
                "halo2_proofs::circuit::floor_planner::v1::V1Pass"
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::Pass") [ F; CS ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_tuple_field (|
                        M.read (| self |),
                        "halo2_proofs::circuit::floor_planner::v1::V1Pass",
                        0
                      |)
                    ]
                  |)
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone F CS)) ].
      End Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_where_core_clone_Clone_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_V1Pass_F_CS.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_where_core_fmt_Debug_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_V1Pass_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Pass") [ F; CS ].
        
        (* Debug *)
        Definition fmt (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "V1Pass" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.read (| self |),
                        "halo2_proofs::circuit::floor_planner::v1::V1Pass",
                        0
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F CS)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_where_core_fmt_Debug_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_V1Pass_F_CS.
      
      Module Impl_core_marker_Send_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_V1Pass_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Pass") [ F; CS ].
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::marker::Send"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Send_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_V1Pass_F_CS.
      
      Module Impl_halo2_proofs_circuit_floor_planner_v1_V1Pass_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Pass") [ F; CS ].
        
        (*
            fn measure(pass: &'p mut MeasurementPassAssignment) -> Self {
                V1Pass(Pass::Measurement(pass))
            }
        *)
        Definition measure (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ pass ] =>
            ltac:(M.monadic
              (let pass := M.alloc (| pass |) in
              Value.StructTuple
                "halo2_proofs::circuit::floor_planner::v1::V1Pass"
                [
                  Value.StructTuple
                    "halo2_proofs::circuit::floor_planner::v1::Pass::Measurement"
                    [ M.read (| pass |) ]
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_measure :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "measure" (measure F CS).
        
        (*
            fn assign(pass: &'p mut AssignmentPass<'p, 'a, F, CS>) -> Self {
                V1Pass(Pass::Assignment(pass))
            }
        *)
        Definition assign (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ pass ] =>
            ltac:(M.monadic
              (let pass := M.alloc (| pass |) in
              Value.StructTuple
                "halo2_proofs::circuit::floor_planner::v1::V1Pass"
                [
                  Value.StructTuple
                    "halo2_proofs::circuit::floor_planner::v1::Pass::Assignment"
                    [ M.read (| pass |) ]
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_assign :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "assign" (assign F CS).
      End Impl_halo2_proofs_circuit_floor_planner_v1_V1Pass_F_CS.
      
      Module Impl_halo2_proofs_circuit_Layouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_v1_V1Pass_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Pass") [ F; CS ].
        
        (*     type Root = Self; *)
        Definition _Root (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Pass") [ F; CS ].
        
        (*
            fn assign_region<A, AR, N, NR>(&self, name: N, assignment: A) -> Result<AR, Error>
            where
                A: Fn(&Region<'_, F>) -> Result<AR, Error>,
                N: Fn() -> NR,
                NR: Into<String>,
            {
                match &self.0 {
                    Pass::Measurement(pass) => pass.assign_region(name, assignment),
                    Pass::Assignment(pass) => pass.assign_region(name, assignment),
                }
            }
        *)
        Definition assign_region (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ A; AR; N; NR ], [ self; name; assignment ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name := M.alloc (| name |) in
              let assignment := M.alloc (| assignment |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::v1::V1Pass",
                      0
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Measurement",
                            0
                          |) in
                        let pass := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path
                                "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment",
                              "assign_region",
                              [ F; A; AR; N; NR ]
                            |),
                            [
                              M.read (| M.read (| pass |) |);
                              M.read (| name |);
                              M.read (| assignment |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Assignment",
                            0
                          |) in
                        let pass := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "halo2_proofs::circuit::floor_planner::v1::AssignmentPass")
                                [ F; CS ],
                              "assign_region",
                              [ A; AR; N; NR ]
                            |),
                            [
                              M.read (| M.read (| pass |) |);
                              M.read (| name |);
                              M.read (| assignment |)
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_table<A, N, NR>(&self, name: N, assignment: A) -> Result<(), Error>
            where
                A: Fn(Table<'_, F>) -> Result<(), Error>,
                N: Fn() -> NR,
                NR: Into<String>,
            {
                match &self.0 {
                    Pass::Measurement(_) => Ok(()),
                    Pass::Assignment(pass) => pass.assign_table(name, assignment),
                }
            }
        *)
        Definition assign_table (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ A; N; NR ], [ self; name; assignment ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name := M.alloc (| name |) in
              let assignment := M.alloc (| assignment |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::v1::V1Pass",
                      0
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Measurement",
                            0
                          |) in
                        M.alloc (|
                          Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Assignment",
                            0
                          |) in
                        let pass := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "halo2_proofs::circuit::floor_planner::v1::AssignmentPass")
                                [ F; CS ],
                              "assign_table",
                              [ A; Ty.tuple []; N; NR ]
                            |),
                            [
                              M.read (| M.read (| pass |) |);
                              M.read (| name |);
                              M.read (| assignment |)
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn constrain_instance(
                &self,
                cell: Cell,
                instance: Column<Instance>,
                row: usize,
            ) -> Result<(), Error> {
                match &self.0 {
                    Pass::Measurement(_) => Ok(()),
                    Pass::Assignment(pass) => pass.constrain_instance(cell, instance, row),
                }
            }
        *)
        Definition constrain_instance (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; cell; instance; row ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let cell := M.alloc (| cell |) in
              let instance := M.alloc (| instance |) in
              let row := M.alloc (| row |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::v1::V1Pass",
                      0
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Measurement",
                            0
                          |) in
                        M.alloc (|
                          Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Assignment",
                            0
                          |) in
                        let pass := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "halo2_proofs::circuit::floor_planner::v1::AssignmentPass")
                                [ F; CS ],
                              "constrain_instance",
                              []
                            |),
                            [
                              M.read (| M.read (| pass |) |);
                              M.read (| cell |);
                              M.read (| instance |);
                              M.read (| row |)
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn get_root(&self) -> &Self::Root {
                self
            }
        *)
        Definition get_root (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| self |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn push_namespace<NR, N>(&self, name_fn: N)
            where
                NR: Into<String>,
                N: FnOnce() -> NR,
            {
                if let Pass::Assignment(pass) = &self.0 {
                    pass.plan.cs.push_namespace(name_fn);
                }
            }
        *)
        Definition push_namespace (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ NR; N ], [ self; name_fn ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name_fn := M.alloc (| name_fn |) in
              M.read (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.alloc (|
                            M.SubPointer.get_struct_tuple_field (|
                              M.read (| self |),
                              "halo2_proofs::circuit::floor_planner::v1::V1Pass",
                              0
                            |)
                          |) in
                        let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Assignment",
                            0
                          |) in
                        let pass := M.alloc (| γ1_0 |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "halo2_proofs::plonk::circuit::Assignment",
                                CS,
                                [ F ],
                                "push_namespace",
                                [ NR; N ]
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| M.read (| pass |) |),
                                        "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                        "plan"
                                      |)
                                    |),
                                    "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                    "cs"
                                  |)
                                |);
                                M.read (| name_fn |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn pop_namespace(&self, gadget_name: Option<String>) {
                if let Pass::Assignment(pass) = &self.0 {
                    pass.plan.cs.pop_namespace(gadget_name);
                }
            }
        *)
        Definition pop_namespace (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; gadget_name ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let gadget_name := M.alloc (| gadget_name |) in
              M.read (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.alloc (|
                            M.SubPointer.get_struct_tuple_field (|
                              M.read (| self |),
                              "halo2_proofs::circuit::floor_planner::v1::V1Pass",
                              0
                            |)
                          |) in
                        let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "halo2_proofs::circuit::floor_planner::v1::Pass::Assignment",
                            0
                          |) in
                        let pass := M.alloc (| γ1_0 |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "halo2_proofs::plonk::circuit::Assignment",
                                CS,
                                [ F ],
                                "pop_namespace",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| M.read (| pass |) |),
                                        "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                        "plan"
                                      |)
                                    |),
                                    "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                    "cs"
                                  |)
                                |);
                                M.read (| gadget_name |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "halo2_proofs::circuit::Layouter"
            (Self F CS)
            (* Trait polymorphic types *) [ (* F *) F ]
            (* Instance *)
            [
              ("Root", InstanceField.Ty (_Root F CS));
              ("assign_region", InstanceField.Method (assign_region F CS));
              ("assign_table", InstanceField.Method (assign_table F CS));
              ("constrain_instance", InstanceField.Method (constrain_instance F CS));
              ("get_root", InstanceField.Method (get_root F CS));
              ("push_namespace", InstanceField.Method (push_namespace F CS));
              ("pop_namespace", InstanceField.Method (pop_namespace F CS))
            ].
      End Impl_halo2_proofs_circuit_Layouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_v1_V1Pass_F_CS.
      
      (* StructRecord
        {
          name := "MeasurementPass";
          ty_params := [];
          fields :=
            [
              ("regions",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                    Ty.path "alloc::alloc::Global"
                  ]);
              ("regions_name",
                Ty.apply
                  (Ty.path "std::collections::hash::map::HashMap")
                  [
                    Ty.path "alloc::string::String";
                    Ty.path "halo2_proofs::circuit::RegionIndex";
                    Ty.path "std::hash::random::RandomState"
                  ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_v1_MeasurementPass.
        Definition Self : Ty.t :=
          Ty.path "halo2_proofs::circuit::floor_planner::v1::MeasurementPass".
        
        (* Debug *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field2_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "MeasurementPass" |);
                  M.read (| Value.String "regions" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::v1::MeasurementPass",
                      "regions"
                    |));
                  M.read (| Value.String "regions_name" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::circuit::floor_planner::v1::MeasurementPass",
                        "regions_name"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_v1_MeasurementPass.
      
      (* StructRecord
        {
          name := "MeasurementPassAssignment";
          ty_params := [];
          fields :=
            [
              ("regions",
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  [
                    Ty.apply
                      (Ty.path "std::sync::mutex::Mutex")
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ];
                                Ty.path "alloc::alloc::Global"
                              ];
                            Ty.apply
                              (Ty.path "std::collections::hash::map::HashMap")
                              [
                                Ty.path "alloc::string::String";
                                Ty.path "halo2_proofs::circuit::RegionIndex";
                                Ty.path "std::hash::random::RandomState"
                              ]
                          ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_v1_MeasurementPassAssignment.
        Definition Self : Ty.t :=
          Ty.path "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment".
        
        (* Debug *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field1_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "MeasurementPassAssignment" |);
                  M.read (| Value.String "regions" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment",
                        "regions"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_v1_MeasurementPassAssignment.
      
      Module Impl_core_convert_Into_halo2_proofs_circuit_floor_planner_v1_MeasurementPass_for_halo2_proofs_circuit_floor_planner_v1_MeasurementPassAssignment.
        Definition Self : Ty.t :=
          Ty.path "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment".
        
        (*
            fn into(self) -> MeasurementPass {
                let (regions, regions_name) = Arc::try_unwrap(self.regions).unwrap().into_inner().unwrap();
        
                assert!(regions.iter().all(|region| region.is_some()));
        
                MeasurementPass {
                    regions: regions.into_iter().map(Option::unwrap).collect(),
                    regions_name,
                }
            }
        *)
        Definition into (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ];
                                    Ty.path "alloc::alloc::Global"
                                  ];
                                Ty.apply
                                  (Ty.path "std::collections::hash::map::HashMap")
                                  [
                                    Ty.path "alloc::string::String";
                                    Ty.path "halo2_proofs::circuit::RegionIndex";
                                    Ty.path "std::hash::random::RandomState"
                                  ]
                              ];
                            Ty.apply
                              (Ty.path "std::sync::poison::PoisonError")
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ];
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "alloc::string::String";
                                        Ty.path "halo2_proofs::circuit::RegionIndex";
                                        Ty.path "std::hash::random::RandomState"
                                      ]
                                  ]
                              ]
                          ],
                        "unwrap",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "std::sync::mutex::Mutex")
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ];
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "alloc::string::String";
                                        Ty.path "halo2_proofs::circuit::RegionIndex";
                                        Ty.path "std::hash::random::RandomState"
                                      ]
                                  ]
                              ],
                            "into_inner",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::Mutex")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.path
                                                      "halo2_proofs::circuit::layouter::RegionShape"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ];
                                            Ty.apply
                                              (Ty.path "std::collections::hash::map::HashMap")
                                              [
                                                Ty.path "alloc::string::String";
                                                Ty.path "halo2_proofs::circuit::RegionIndex";
                                                Ty.path "std::hash::random::RandomState"
                                              ]
                                          ]
                                      ];
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "std::sync::mutex::Mutex")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.path
                                                          "halo2_proofs::circuit::layouter::RegionShape"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.apply
                                                  (Ty.path "std::collections::hash::map::HashMap")
                                                  [
                                                    Ty.path "alloc::string::String";
                                                    Ty.path "halo2_proofs::circuit::RegionIndex";
                                                    Ty.path "std::hash::random::RandomState"
                                                  ]
                                              ]
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                "unwrap",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "std::sync::mutex::Mutex")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.path
                                                          "halo2_proofs::circuit::layouter::RegionShape"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.apply
                                                  (Ty.path "std::collections::hash::map::HashMap")
                                                  [
                                                    Ty.path "alloc::string::String";
                                                    Ty.path "halo2_proofs::circuit::RegionIndex";
                                                    Ty.path "std::hash::random::RandomState"
                                                  ]
                                              ]
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_unwrap",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment",
                                        "regions"
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let regions := M.copy (| γ0_0 |) in
                        let regions_name := M.copy (| γ0_1 |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    [
                                                      Ty.path
                                                        "halo2_proofs::circuit::layouter::RegionShape"
                                                    ]
                                                ],
                                              [],
                                              "all",
                                              [
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                                              ]
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.path "bool")
                                              ]
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "slice")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::circuit::layouter::RegionShape"
                                                          ]
                                                      ],
                                                    "iter",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::deref::Deref",
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                                              ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        [],
                                                        "deref",
                                                        []
                                                      |),
                                                      [ regions ]
                                                    |)
                                                  ]
                                                |)
                                              |);
                                              M.closure
                                                (fun γ =>
                                                  ltac:(M.monadic
                                                    match γ with
                                                    | [ α0 ] =>
                                                      M.match_operator (|
                                                        M.alloc (| α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let region := M.copy (| γ |) in
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::circuit::layouter::RegionShape"
                                                                    ],
                                                                  "is_some",
                                                                  []
                                                                |),
                                                                [ M.read (| region |) ]
                                                              |)))
                                                        ]
                                                      |)
                                                    | _ => M.impossible (||)
                                                    end))
                                            ]
                                          |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String
                                              "assertion failed: regions.iter().all(|region| region.is_some())"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (|
                          Value.StructRecord
                            "halo2_proofs::circuit::floor_planner::v1::MeasurementPass"
                            [
                              ("regions",
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.function
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                              ]
                                          ]
                                          (Ty.path "halo2_proofs::circuit::layouter::RegionShape")
                                      ],
                                    [],
                                    "collect",
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        "map",
                                        [
                                          Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                                          Ty.function
                                            [
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [
                                                  Ty.path
                                                    "halo2_proofs::circuit::layouter::RegionShape"
                                                ]
                                            ]
                                            (Ty.path "halo2_proofs::circuit::layouter::RegionShape")
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.path
                                                      "halo2_proofs::circuit::layouter::RegionShape"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "into_iter",
                                            []
                                          |),
                                          [ M.read (| regions |) ]
                                        |);
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                            ],
                                          "unwrap",
                                          []
                                        |)
                                      ]
                                    |)
                                  ]
                                |));
                              ("regions_name", M.read (| regions_name |))
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::Into"
            Self
            (* Trait polymorphic types *)
            [ (* T *) Ty.path "halo2_proofs::circuit::floor_planner::v1::MeasurementPass" ]
            (* Instance *) [ ("into", InstanceField.Method into) ].
      End Impl_core_convert_Into_halo2_proofs_circuit_floor_planner_v1_MeasurementPass_for_halo2_proofs_circuit_floor_planner_v1_MeasurementPassAssignment.
      
      Module Impl_halo2_proofs_circuit_floor_planner_v1_MeasurementPassAssignment.
        Definition Self : Ty.t :=
          Ty.path "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment".
        
        (*
            fn new() -> Self {
                MeasurementPassAssignment {
                    regions: Arc::new(Mutex::new((vec![], HashMap::default()))),
                }
            }
        *)
        Definition new (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [] =>
            ltac:(M.monadic
              (Value.StructRecord
                "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment"
                [
                  ("regions",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          [
                            Ty.apply
                              (Ty.path "std::sync::mutex::Mutex")
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ];
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "alloc::string::String";
                                        Ty.path "halo2_proofs::circuit::RegionIndex";
                                        Ty.path "std::hash::random::RandomState"
                                      ]
                                  ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "new",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "std::sync::mutex::Mutex")
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ];
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "alloc::string::String";
                                        Ty.path "halo2_proofs::circuit::RegionIndex";
                                        Ty.path "std::hash::random::RandomState"
                                      ]
                                  ]
                              ],
                            "new",
                            []
                          |),
                          [
                            Value.Tuple
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "new",
                                    []
                                  |),
                                  []
                                |);
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::default::Default",
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "alloc::string::String";
                                        Ty.path "halo2_proofs::circuit::RegionIndex";
                                        Ty.path "std::hash::random::RandomState"
                                      ],
                                    [],
                                    "default",
                                    []
                                  |),
                                  []
                                |)
                              ]
                          ]
                        |)
                      ]
                    |))
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
        
        (*
            fn assign_region<F: Field, A, AR, N, NR>(&self, name: N, assignment: A) -> Result<AR, Error>
            where
                A: Fn(&Region<'_, F>) -> Result<AR, Error>,
                N: Fn() -> NR,
                NR: Into<String>,
            {
                let name: String = name().into();
        
                let mut regions = self.regions.lock().unwrap();
                let region_index = regions.0.len();
                regions.0.resize(region_index + 1, None);
                assert!(
                    regions
                        .1
                        .insert(name.clone(), region_index.into())
                        .is_none(),
                    "The region name {} is already exist.",
                    name
                );
                drop(regions);
        
                // Get shape of the region.
                let shape = Parallel::new(RegionShape::new(region_index.into()));
                let result = {
                    let region: &dyn RegionLayouter<F> = &shape;
                    assignment(&region.into())
                }?;
        
                let shape = shape.into_inner();
        
                let mut regions = self.regions.lock().unwrap();
                regions.0[region_index] = Some(shape);
                drop(regions);
        
                Ok(result)
            }
        *)
        Definition assign_region (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ F; A; AR; N; NR ], [ self; name; assignment ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name := M.alloc (| name |) in
              let assignment := M.alloc (| assignment |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let name :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::convert::Into",
                            NR,
                            [ Ty.path "alloc::string::String" ],
                            "into",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::Fn",
                                N,
                                [ Ty.tuple [] ],
                                "call",
                                []
                              |),
                              [ name; Value.Tuple [] ]
                            |)
                          ]
                        |)
                      |) in
                    let regions :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "std::sync::mutex::MutexGuard")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::HashMap")
                                          [
                                            Ty.path "alloc::string::String";
                                            Ty.path "halo2_proofs::circuit::RegionIndex";
                                            Ty.path "std::hash::random::RandomState"
                                          ]
                                      ]
                                  ];
                                Ty.apply
                                  (Ty.path "std::sync::poison::PoisonError")
                                  [
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::MutexGuard")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.path
                                                      "halo2_proofs::circuit::layouter::RegionShape"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ];
                                            Ty.apply
                                              (Ty.path "std::collections::hash::map::HashMap")
                                              [
                                                Ty.path "alloc::string::String";
                                                Ty.path "halo2_proofs::circuit::RegionIndex";
                                                Ty.path "std::hash::random::RandomState"
                                              ]
                                          ]
                                      ]
                                  ]
                              ],
                            "unwrap",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "std::sync::mutex::Mutex")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::HashMap")
                                          [
                                            Ty.path "alloc::string::String";
                                            Ty.path "halo2_proofs::circuit::RegionIndex";
                                            Ty.path "std::hash::random::RandomState"
                                          ]
                                      ]
                                  ],
                                "lock",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "std::sync::mutex::Mutex")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.path
                                                          "halo2_proofs::circuit::layouter::RegionShape"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.apply
                                                  (Ty.path "std::collections::hash::map::HashMap")
                                                  [
                                                    Ty.path "alloc::string::String";
                                                    Ty.path "halo2_proofs::circuit::RegionIndex";
                                                    Ty.path "std::hash::random::RandomState"
                                                  ]
                                              ]
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment",
                                      "regions"
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let region_index :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "len",
                            []
                          |),
                          [
                            M.SubPointer.get_tuple_field (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::MutexGuard")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [
                                                  Ty.path
                                                    "halo2_proofs::circuit::layouter::RegionShape"
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ];
                                          Ty.apply
                                            (Ty.path "std::collections::hash::map::HashMap")
                                            [
                                              Ty.path "alloc::string::String";
                                              Ty.path "halo2_proofs::circuit::RegionIndex";
                                              Ty.path "std::hash::random::RandomState"
                                            ]
                                        ]
                                    ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ regions ]
                              |),
                              0
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "resize",
                            []
                          |),
                          [
                            M.SubPointer.get_tuple_field (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::MutexGuard")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [
                                                  Ty.path
                                                    "halo2_proofs::circuit::layouter::RegionShape"
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ];
                                          Ty.apply
                                            (Ty.path "std::collections::hash::map::HashMap")
                                            [
                                              Ty.path "alloc::string::String";
                                              Ty.path "halo2_proofs::circuit::RegionIndex";
                                              Ty.path "std::hash::random::RandomState"
                                            ]
                                        ]
                                    ],
                                  [],
                                  "deref_mut",
                                  []
                                |),
                                [ regions ]
                              |),
                              0
                            |);
                            BinOp.Panic.add (|
                              Integer.Usize,
                              M.read (| region_index |),
                              Value.Integer 1
                            |);
                            Value.StructTuple "core::option::Option::None" []
                          ]
                        |)
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.Pure.not
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "halo2_proofs::circuit::RegionIndex" ],
                                          "is_none",
                                          []
                                        |),
                                        [
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "std::collections::hash::map::HashMap")
                                                  [
                                                    Ty.path "alloc::string::String";
                                                    Ty.path "halo2_proofs::circuit::RegionIndex";
                                                    Ty.path "std::hash::random::RandomState"
                                                  ],
                                                "insert",
                                                []
                                              |),
                                              [
                                                M.SubPointer.get_tuple_field (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::deref::DerefMut",
                                                      Ty.apply
                                                        (Ty.path "std::sync::mutex::MutexGuard")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::circuit::layouter::RegionShape"
                                                                    ];
                                                                  Ty.path "alloc::alloc::Global"
                                                                ];
                                                              Ty.apply
                                                                (Ty.path
                                                                  "std::collections::hash::map::HashMap")
                                                                [
                                                                  Ty.path "alloc::string::String";
                                                                  Ty.path
                                                                    "halo2_proofs::circuit::RegionIndex";
                                                                  Ty.path
                                                                    "std::hash::random::RandomState"
                                                                ]
                                                            ]
                                                        ],
                                                      [],
                                                      "deref_mut",
                                                      []
                                                    |),
                                                    [ regions ]
                                                  |),
                                                  1
                                                |);
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::clone::Clone",
                                                    Ty.path "alloc::string::String",
                                                    [],
                                                    "clone",
                                                    []
                                                  |),
                                                  [ name ]
                                                |);
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::convert::Into",
                                                    Ty.path "usize",
                                                    [ Ty.path "halo2_proofs::circuit::RegionIndex"
                                                    ],
                                                    "into",
                                                    []
                                                  |),
                                                  [ M.read (| region_index |) ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        ]
                                      |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    M.get_function (| "core::panicking::panic_fmt", [] |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::Arguments",
                                          "new_v1",
                                          []
                                        |),
                                        [
                                          (* Unsize *)
                                          M.pointer_coercion
                                            (M.alloc (|
                                              Value.Array
                                                [
                                                  M.read (| Value.String "The region name " |);
                                                  M.read (| Value.String " is already exist." |)
                                                ]
                                            |));
                                          (* Unsize *)
                                          M.pointer_coercion
                                            (M.alloc (|
                                              Value.Array
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_display",
                                                      [ Ty.path "alloc::string::String" ]
                                                    |),
                                                    [ name ]
                                                  |)
                                                ]
                                            |))
                                        ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::mem::drop",
                            [
                              Ty.apply
                                (Ty.path "std::sync::mutex::MutexGuard")
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ];
                                      Ty.apply
                                        (Ty.path "std::collections::hash::map::HashMap")
                                        [
                                          Ty.path "alloc::string::String";
                                          Ty.path "halo2_proofs::circuit::RegionIndex";
                                          Ty.path "std::hash::random::RandomState"
                                        ]
                                    ]
                                ]
                            ]
                          |),
                          [ M.read (| regions |) ]
                        |)
                      |) in
                    let shape :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::parallel::Parallel")
                              [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "halo2_proofs::circuit::layouter::RegionShape",
                                "new",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::Into",
                                    Ty.path "usize",
                                    [ Ty.path "halo2_proofs::circuit::RegionIndex" ],
                                    "into",
                                    []
                                  |),
                                  [ M.read (| region_index |) ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let result :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ AR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.read (|
                                  let region :=
                                    M.alloc (| (* Unsize *) M.pointer_coercion shape |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::Fn",
                                        A,
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::circuit::Region")
                                                    [ F ]
                                                ]
                                            ]
                                        ],
                                        "call",
                                        []
                                      |),
                                      [
                                        assignment;
                                        Value.Tuple
                                          [
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::convert::Into",
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [
                                                      Ty.dyn
                                                        [
                                                          ("halo2_proofs::circuit::layouter::RegionLayouter::Trait",
                                                            [])
                                                        ]
                                                    ],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "halo2_proofs::circuit::Region")
                                                      [ F ]
                                                  ],
                                                  "into",
                                                  []
                                                |),
                                                [ M.read (| region |) ]
                                              |)
                                            |)
                                          ]
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ AR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let shape :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::parallel::Parallel")
                              [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ],
                            "into_inner",
                            []
                          |),
                          [ M.read (| shape |) ]
                        |)
                      |) in
                    let regions :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "std::sync::mutex::MutexGuard")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::HashMap")
                                          [
                                            Ty.path "alloc::string::String";
                                            Ty.path "halo2_proofs::circuit::RegionIndex";
                                            Ty.path "std::hash::random::RandomState"
                                          ]
                                      ]
                                  ];
                                Ty.apply
                                  (Ty.path "std::sync::poison::PoisonError")
                                  [
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::MutexGuard")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.path
                                                      "halo2_proofs::circuit::layouter::RegionShape"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ];
                                            Ty.apply
                                              (Ty.path "std::collections::hash::map::HashMap")
                                              [
                                                Ty.path "alloc::string::String";
                                                Ty.path "halo2_proofs::circuit::RegionIndex";
                                                Ty.path "std::hash::random::RandomState"
                                              ]
                                          ]
                                      ]
                                  ]
                              ],
                            "unwrap",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "std::sync::mutex::Mutex")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::HashMap")
                                          [
                                            Ty.path "alloc::string::String";
                                            Ty.path "halo2_proofs::circuit::RegionIndex";
                                            Ty.path "std::hash::random::RandomState"
                                          ]
                                      ]
                                  ],
                                "lock",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "std::sync::mutex::Mutex")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.path
                                                          "halo2_proofs::circuit::layouter::RegionShape"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.apply
                                                  (Ty.path "std::collections::hash::map::HashMap")
                                                  [
                                                    Ty.path "alloc::string::String";
                                                    Ty.path "halo2_proofs::circuit::RegionIndex";
                                                    Ty.path "std::hash::random::RandomState"
                                                  ]
                                              ]
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::v1::MeasurementPassAssignment",
                                      "regions"
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.write (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::index::IndexMut",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [ Ty.path "usize" ],
                            "index_mut",
                            []
                          |),
                          [
                            M.SubPointer.get_tuple_field (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::MutexGuard")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [
                                                  Ty.path
                                                    "halo2_proofs::circuit::layouter::RegionShape"
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ];
                                          Ty.apply
                                            (Ty.path "std::collections::hash::map::HashMap")
                                            [
                                              Ty.path "alloc::string::String";
                                              Ty.path "halo2_proofs::circuit::RegionIndex";
                                              Ty.path "std::hash::random::RandomState"
                                            ]
                                        ]
                                    ],
                                  [],
                                  "deref_mut",
                                  []
                                |),
                                [ regions ]
                              |),
                              0
                            |);
                            M.read (| region_index |)
                          ]
                        |),
                        Value.StructTuple "core::option::Option::Some" [ M.read (| shape |) ]
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::mem::drop",
                            [
                              Ty.apply
                                (Ty.path "std::sync::mutex::MutexGuard")
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ];
                                      Ty.apply
                                        (Ty.path "std::collections::hash::map::HashMap")
                                        [
                                          Ty.path "alloc::string::String";
                                          Ty.path "halo2_proofs::circuit::RegionIndex";
                                          Ty.path "std::hash::random::RandomState"
                                        ]
                                    ]
                                ]
                            ]
                          |),
                          [ M.read (| regions |) ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| result |) ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_assign_region :
          M.IsAssociatedFunction Self "assign_region" assign_region.
      End Impl_halo2_proofs_circuit_floor_planner_v1_MeasurementPassAssignment.
      
      (* StructRecord
        {
          name := "AssignmentPass";
          ty_params := [ "F"; "CS" ];
          fields :=
            [
              ("plan",
                Ty.apply
                  (Ty.path "&mut")
                  [ Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Plan") [ F; CS ]
                  ]);
              ("regions_name",
                Ty.apply
                  (Ty.path "std::collections::hash::map::HashMap")
                  [
                    Ty.path "alloc::string::String";
                    Ty.path "halo2_proofs::circuit::RegionIndex";
                    Ty.path "std::hash::random::RandomState"
                  ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_where_core_fmt_Debug_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_AssignmentPass_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::AssignmentPass") [ F; CS ].
        
        (* Debug *)
        Definition fmt (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field2_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "AssignmentPass" |);
                  M.read (| Value.String "plan" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                      "plan"
                    |));
                  M.read (| Value.String "regions_name" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                        "regions_name"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F CS)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_where_core_fmt_Debug_CS_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_AssignmentPass_F_CS.
      
      Module Impl_halo2_proofs_circuit_floor_planner_v1_AssignmentPass_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::AssignmentPass") [ F; CS ].
        
        (*
            fn new(plan: &'p mut V1Plan<'a, F, CS>, regions_name: HashMap<String, RegionIndex>) -> Self {
                AssignmentPass { plan, regions_name }
            }
        *)
        Definition new (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ plan; regions_name ] =>
            ltac:(M.monadic
              (let plan := M.alloc (| plan |) in
              let regions_name := M.alloc (| regions_name |) in
              Value.StructRecord
                "halo2_proofs::circuit::floor_planner::v1::AssignmentPass"
                [ ("plan", M.read (| plan |)); ("regions_name", M.read (| regions_name |)) ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "new" (new F CS).
        
        (*
            fn region_from_name(&self, name: &str) -> usize {
                *self.regions_name.get(name).unwrap().clone()
            }
        *)
        Definition region_from_name (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; name ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name := M.alloc (| name |) in
              M.read (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.path "halo2_proofs::circuit::RegionIndex",
                    [],
                    "deref",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.path "halo2_proofs::circuit::RegionIndex",
                          [],
                          "clone",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [ Ty.path "halo2_proofs::circuit::RegionIndex" ]
                                ],
                              "unwrap",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "std::collections::hash::map::HashMap")
                                    [
                                      Ty.path "alloc::string::String";
                                      Ty.path "halo2_proofs::circuit::RegionIndex";
                                      Ty.path "std::hash::random::RandomState"
                                    ],
                                  "get",
                                  [ Ty.path "str" ]
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                    "regions_name"
                                  |);
                                  M.read (| name |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_region_from_name :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "region_from_name" (region_from_name F CS).
        
        (*
            fn assign_region<A, AR, N, NR>(&self, name: N, assignment: A) -> Result<AR, Error>
            where
                A: Fn(&Region<'_, F>) -> Result<AR, Error>,
                N: Fn() -> NR,
                NR: Into<String>,
            {
                // Get the next region we are assigning.
                let region_index = self.region_from_name(&name().into());
        
                self.plan.cs.enter_region(name);
                let region = V1Region::new(self.plan, region_index.into());
                let result = {
                    let region: &dyn RegionLayouter<F> = &region;
                    assignment(&region.into())
                }?;
                self.plan.cs.exit_region();
        
                Ok(result)
            }
        *)
        Definition assign_region (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ A; AR; N; NR ], [ self; name; assignment ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name := M.alloc (| name |) in
              let assignment := M.alloc (| assignment |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let region_index :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::circuit::floor_planner::v1::AssignmentPass")
                              [ F; CS ],
                            "region_from_name",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.path "alloc::string::String",
                                [],
                                "deref",
                                []
                              |),
                              [
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      NR,
                                      [ Ty.path "alloc::string::String" ],
                                      "into",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::function::Fn",
                                          N,
                                          [ Ty.tuple [] ],
                                          "call",
                                          []
                                        |),
                                        [ name; Value.Tuple [] ]
                                      |)
                                    ]
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "halo2_proofs::plonk::circuit::Assignment",
                            CS,
                            [ F ],
                            "enter_region",
                            [ NR; N ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                    "plan"
                                  |)
                                |),
                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                "cs"
                              |)
                            |);
                            M.read (| name |)
                          ]
                        |)
                      |) in
                    let region :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Region")
                              [ F; CS ],
                            "new",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                "plan"
                              |)
                            |);
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::convert::Into",
                                Ty.path "usize",
                                [ Ty.path "halo2_proofs::circuit::RegionIndex" ],
                                "into",
                                []
                              |),
                              [ M.read (| region_index |) ]
                            |)
                          ]
                        |)
                      |) in
                    let result :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ AR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.read (|
                                  let region :=
                                    M.alloc (| (* Unsize *) M.pointer_coercion region |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::Fn",
                                        A,
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::circuit::Region")
                                                    [ F ]
                                                ]
                                            ]
                                        ],
                                        "call",
                                        []
                                      |),
                                      [
                                        assignment;
                                        Value.Tuple
                                          [
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::convert::Into",
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [
                                                      Ty.dyn
                                                        [
                                                          ("halo2_proofs::circuit::layouter::RegionLayouter::Trait",
                                                            [])
                                                        ]
                                                    ],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "halo2_proofs::circuit::Region")
                                                      [ F ]
                                                  ],
                                                  "into",
                                                  []
                                                |),
                                                [ M.read (| region |) ]
                                              |)
                                            |)
                                          ]
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ AR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "halo2_proofs::plonk::circuit::Assignment",
                            CS,
                            [ F ],
                            "exit_region",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                    "plan"
                                  |)
                                |),
                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                "cs"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| result |) ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_assign_region :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "assign_region" (assign_region F CS).
        
        (*
            fn assign_table<A, AR, N, NR>(&self, name: N, assignment: A) -> Result<AR, Error>
            where
                A: Fn(Table<'_, F>) -> Result<AR, Error>,
                N: Fn() -> NR,
                NR: Into<String>,
            {
                let mut table_columns = self.plan.table_columns.lock().unwrap();
        
                // Maintenance hazard: there is near-duplicate code in `SingleChipLayouter::assign_table`.
        
                // Assign table cells.
                self.plan.cs.enter_region(name);
                let table = SimpleTableLayouter::new(self.plan.cs, &table_columns);
                let result = {
                    let table: &dyn TableLayouter<F> = &table;
                    assignment(table.into())
                }?;
                let default_and_assigned = table.default_and_assigned.into_inner();
                self.plan.cs.exit_region();
        
                // Check that all table columns have the same length `first_unused`,
                // and all cells up to that length are assigned.
                let first_unused = {
                    match default_and_assigned
                        .values()
                        .map(|(_, assigned)| {
                            if assigned.iter().all(|b| *b) {
                                Some(assigned.len())
                            } else {
                                None
                            }
                        })
                        .reduce(|acc, item| match (acc, item) {
                            (Some(a), Some(b)) if a == b => Some(a),
                            _ => None,
                        }) {
                        Some(Some(len)) => len,
                        _ => return Err(Error::Synthesis), // TODO better error
                    }
                };
        
                // Record these columns so that we can prevent them from being used again.
                for column in default_and_assigned.keys() {
                    table_columns.push( *column);
                }
        
                for (col, (default_val, _)) in default_and_assigned {
                    // default_val must be Some because we must have assigned
                    // at least one cell in each column, and in that case we checked
                    // that all cells up to first_unused were assigned.
                    self.plan
                        .cs
                        .fill_from_row(col.inner(), first_unused, default_val.unwrap())?;
                }
        
                Ok(result)
            }
        *)
        Definition assign_table (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [ A; AR; N; NR ], [ self; name; assignment ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let name := M.alloc (| name |) in
              let assignment := M.alloc (| assignment |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let table_columns :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "std::sync::mutex::MutexGuard")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ];
                                Ty.apply
                                  (Ty.path "std::sync::poison::PoisonError")
                                  [
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::MutexGuard")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ]
                                  ]
                              ],
                            "unwrap",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "halo2_proofs::parallel::Parallel")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                "lock",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                      "plan"
                                    |)
                                  |),
                                  "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                  "table_columns"
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "halo2_proofs::plonk::circuit::Assignment",
                            CS,
                            [ F ],
                            "enter_region",
                            [ NR; N ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                    "plan"
                                  |)
                                |),
                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                "cs"
                              |)
                            |);
                            M.read (| name |)
                          ]
                        |)
                      |) in
                    let table :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path
                                "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter")
                              [ F; CS ],
                            "new",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                    "plan"
                                  |)
                                |),
                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                "cs"
                              |)
                            |);
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "deref",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::MutexGuard")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [ table_columns ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let result :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ AR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.read (|
                                  let table :=
                                    M.alloc (| (* Unsize *) M.pointer_coercion table |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::function::Fn",
                                        A,
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::circuit::Table")
                                                [ F ]
                                            ]
                                        ],
                                        "call",
                                        []
                                      |),
                                      [
                                        assignment;
                                        Value.Tuple
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::convert::Into",
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.dyn
                                                      [
                                                        ("halo2_proofs::circuit::layouter::TableLayouter::Trait",
                                                          [])
                                                      ]
                                                  ],
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::circuit::Table")
                                                    [ F ]
                                                ],
                                                "into",
                                                []
                                              |),
                                              [ M.read (| table |) ]
                                            |)
                                          ]
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ AR; Ty.path "halo2_proofs::plonk::error::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let default_and_assigned :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::parallel::Parallel")
                              [
                                Ty.apply
                                  (Ty.path "std::collections::hash::map::HashMap")
                                  [
                                    Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                  [ F ]
                                              ]
                                          ];
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                      ];
                                    Ty.path "std::hash::random::RandomState"
                                  ]
                              ],
                            "into_inner",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                table,
                                "halo2_proofs::circuit::floor_planner::single_pass::SimpleTableLayouter",
                                "default_and_assigned"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "halo2_proofs::plonk::circuit::Assignment",
                            CS,
                            [ F ],
                            "exit_region",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                    "plan"
                                  |)
                                |),
                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                "cs"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let first_unused :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::map::Map")
                                  [
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::Values")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ]
                                                  ]
                                              ];
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                          ]
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::assigned::Assigned")
                                                              [ F ]
                                                          ]
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [
                                                        Ty.path "bool";
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                          ]
                                      ]
                                      (Ty.apply
                                        (Ty.path "core::option::Option")
                                        [ Ty.path "usize" ])
                                  ],
                                [],
                                "reduce",
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "usize" ];
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "usize" ]
                                        ]
                                    ]
                                    (Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ])
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::Values")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ]
                                                  ]
                                              ];
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                          ]
                                      ],
                                    [],
                                    "map",
                                    [
                                      Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ];
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                [ F ]
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "bool";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ]
                                                ]
                                            ]
                                        ]
                                        (Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "usize" ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::HashMap")
                                          [
                                            Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                          [ F ]
                                                      ]
                                                  ];
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                              ];
                                            Ty.path "std::hash::random::RandomState"
                                          ],
                                        "values",
                                        []
                                      |),
                                      [ default_and_assigned ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ := M.read (| γ |) in
                                                    let γ1_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ1_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let assigned := M.alloc (| γ1_1 |) in
                                                    M.read (|
                                                      M.match_operator (|
                                                        M.alloc (| Value.Tuple [] |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ :=
                                                                M.use
                                                                  (M.alloc (|
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::iter::traits::iterator::Iterator",
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::slice::iter::Iter")
                                                                          [ Ty.path "bool" ],
                                                                        [],
                                                                        "all",
                                                                        [
                                                                          Ty.function
                                                                            [
                                                                              Ty.tuple
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path "&")
                                                                                    [ Ty.path "bool"
                                                                                    ]
                                                                                ]
                                                                            ]
                                                                            (Ty.path "bool")
                                                                        ]
                                                                      |),
                                                                      [
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.apply
                                                                                (Ty.path "slice")
                                                                                [ Ty.path "bool" ],
                                                                              "iter",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "core::ops::deref::Deref",
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::vec::Vec")
                                                                                    [
                                                                                      Ty.path
                                                                                        "bool";
                                                                                      Ty.path
                                                                                        "alloc::alloc::Global"
                                                                                    ],
                                                                                  [],
                                                                                  "deref",
                                                                                  []
                                                                                |),
                                                                                [
                                                                                  M.read (|
                                                                                    assigned
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |);
                                                                        M.closure
                                                                          (fun γ =>
                                                                            ltac:(M.monadic
                                                                              match γ with
                                                                              | [ α0 ] =>
                                                                                M.match_operator (|
                                                                                  M.alloc (| α0 |),
                                                                                  [
                                                                                    fun γ =>
                                                                                      ltac:(M.monadic
                                                                                        (let b :=
                                                                                          M.copy (|
                                                                                            γ
                                                                                          |) in
                                                                                        M.read (|
                                                                                          M.read (|
                                                                                            b
                                                                                          |)
                                                                                        |)))
                                                                                  ]
                                                                                |)
                                                                              | _ =>
                                                                                M.impossible (||)
                                                                              end))
                                                                      ]
                                                                    |)
                                                                  |)) in
                                                              let _ :=
                                                                M.is_constant_or_break_match (|
                                                                  M.read (| γ |),
                                                                  Value.Bool true
                                                                |) in
                                                              M.alloc (|
                                                                Value.StructTuple
                                                                  "core::option::Option::Some"
                                                                  [
                                                                    M.call_closure (|
                                                                      M.get_associated_function (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::vec::Vec")
                                                                          [
                                                                            Ty.path "bool";
                                                                            Ty.path
                                                                              "alloc::alloc::Global"
                                                                          ],
                                                                        "len",
                                                                        []
                                                                      |),
                                                                      [ M.read (| assigned |) ]
                                                                    |)
                                                                  ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.alloc (|
                                                                Value.StructTuple
                                                                  "core::option::Option::None"
                                                                  []
                                                              |)))
                                                        ]
                                                      |)
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0; α1 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let acc := M.copy (| γ |) in
                                                M.match_operator (|
                                                  M.alloc (| α1 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let item := M.copy (| γ |) in
                                                        M.read (|
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              Value.Tuple
                                                                [
                                                                  M.read (| acc |);
                                                                  M.read (| item |)
                                                                ]
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      0
                                                                    |) in
                                                                  let γ0_1 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      1
                                                                    |) in
                                                                  let γ1_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ0_0,
                                                                      "core::option::Option::Some",
                                                                      0
                                                                    |) in
                                                                  let a := M.copy (| γ1_0 |) in
                                                                  let γ1_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ0_1,
                                                                      "core::option::Option::Some",
                                                                      0
                                                                    |) in
                                                                  let b := M.copy (| γ1_0 |) in
                                                                  let γ :=
                                                                    M.alloc (|
                                                                      BinOp.Pure.eq
                                                                        (M.read (| a |))
                                                                        (M.read (| b |))
                                                                    |) in
                                                                  let _ :=
                                                                    M.is_constant_or_break_match (|
                                                                      M.read (| γ |),
                                                                      Value.Bool true
                                                                    |) in
                                                                  M.alloc (|
                                                                    Value.StructTuple
                                                                      "core::option::Option::Some"
                                                                      [ M.read (| a |) ]
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (M.alloc (|
                                                                    Value.StructTuple
                                                                      "core::option::Option::None"
                                                                      []
                                                                  |)))
                                                            ]
                                                          |)
                                                        |)))
                                                  ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end))
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ0_0,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let len := M.copy (| γ1_0 |) in
                                len));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [
                                            Value.StructTuple
                                              "halo2_proofs::plonk::error::Error::Synthesis"
                                              []
                                          ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "std::collections::hash::map::Keys")
                                  [
                                    Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                  [ F ]
                                              ]
                                          ];
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                      ]
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::HashMap")
                                      [
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                      [ F ]
                                                  ]
                                              ];
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                          ];
                                        Ty.path "std::hash::random::RandomState"
                                      ],
                                    "keys",
                                    []
                                  |),
                                  [ default_and_assigned ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "std::collections::hash::map::Keys")
                                                [
                                                  Ty.path
                                                    "halo2_proofs::plonk::circuit::TableColumn";
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                [ F ]
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "bool";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ]
                                                ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let column := M.copy (| γ0_0 |) in
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::plonk::circuit::TableColumn";
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      "push",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::deref::DerefMut",
                                                          Ty.apply
                                                            (Ty.path "std::sync::mutex::MutexGuard")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::TableColumn";
                                                                  Ty.path "alloc::alloc::Global"
                                                                ]
                                                            ],
                                                          [],
                                                          "deref_mut",
                                                          []
                                                        |),
                                                        [ table_columns ]
                                                      |);
                                                      M.read (| M.read (| column |) |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    let _ :=
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "std::collections::hash::map::HashMap")
                                  [
                                    Ty.path "halo2_proofs::plonk::circuit::TableColumn";
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                  [ F ]
                                              ]
                                          ];
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                      ];
                                    Ty.path "std::hash::random::RandomState"
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [ M.read (| default_and_assigned |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "std::collections::hash::map::IntoIter")
                                                [
                                                  Ty.path
                                                    "halo2_proofs::plonk::circuit::TableColumn";
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                [ F ]
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "bool";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ]
                                                ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                              let col := M.copy (| γ1_0 |) in
                                              let γ2_0 :=
                                                M.SubPointer.get_tuple_field (| γ1_1, 0 |) in
                                              let γ2_1 :=
                                                M.SubPointer.get_tuple_field (| γ1_1, 1 |) in
                                              let default_val := M.copy (| γ2_0 |) in
                                              let _ :=
                                                M.match_operator (|
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::Try",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.tuple [];
                                                            Ty.path
                                                              "halo2_proofs::plonk::error::Error"
                                                          ],
                                                        [],
                                                        "branch",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "halo2_proofs::plonk::circuit::Assignment",
                                                            CS,
                                                            [ F ],
                                                            "fill_from_row",
                                                            []
                                                          |),
                                                          [
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.read (|
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.read (| self |),
                                                                    "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                                                    "plan"
                                                                  |)
                                                                |),
                                                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                                                "cs"
                                                              |)
                                                            |);
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::TableColumn",
                                                                "inner",
                                                                []
                                                              |),
                                                              [ col ]
                                                            |);
                                                            M.read (| first_unused |);
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::assigned::Assigned")
                                                                          [ F ]
                                                                      ]
                                                                  ],
                                                                "unwrap",
                                                                []
                                                              |),
                                                              [ M.read (| default_val |) ]
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ,
                                                            "core::ops::control_flow::ControlFlow::Break",
                                                            0
                                                          |) in
                                                        let residual := M.copy (| γ0_0 |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              M.return_ (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::try_trait::FromResidual",
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        AR;
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::error::Error"
                                                                      ],
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::result::Result")
                                                                        [
                                                                          Ty.path
                                                                            "core::convert::Infallible";
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::error::Error"
                                                                        ]
                                                                    ],
                                                                    "from_residual",
                                                                    []
                                                                  |),
                                                                  [ M.read (| residual |) ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ,
                                                            "core::ops::control_flow::ControlFlow::Continue",
                                                            0
                                                          |) in
                                                        let val := M.copy (| γ0_0 |) in
                                                        val))
                                                  ]
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| result |) ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_assign_table :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "assign_table" (assign_table F CS).
        
        (*
            fn constrain_instance(
                &self,
                cell: Cell,
                instance: Column<Instance>,
                row: usize,
            ) -> Result<(), Error> {
                self.plan.cs.copy(
                    cell.column,
                    *self.plan.regions[*cell.region_index] + cell.row_offset,
                    instance.into(),
                    row,
                )
            }
        *)
        Definition constrain_instance (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; cell; instance; row ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let cell := M.alloc (| cell |) in
              let instance := M.alloc (| instance |) in
              let row := M.alloc (| row |) in
              M.call_closure (|
                M.get_trait_method (|
                  "halo2_proofs::plonk::circuit::Assignment",
                  CS,
                  [ F ],
                  "copy",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                          "plan"
                        |)
                      |),
                      "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                      "cs"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      cell,
                      "halo2_proofs::circuit::Cell",
                      "column"
                    |)
                  |);
                  BinOp.Panic.add (|
                    Integer.Usize,
                    M.read (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.path "halo2_proofs::circuit::RegionStart",
                          [],
                          "deref",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [ Ty.path "usize" ],
                              "index",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::floor_planner::v1::AssignmentPass",
                                    "plan"
                                  |)
                                |),
                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                "regions"
                              |);
                              M.read (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.path "halo2_proofs::circuit::RegionIndex",
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      cell,
                                      "halo2_proofs::circuit::Cell",
                                      "region_index"
                                    |)
                                  ]
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        cell,
                        "halo2_proofs::circuit::Cell",
                        "row_offset"
                      |)
                    |)
                  |);
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::Into",
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Instance" ],
                      [
                        Ty.apply
                          (Ty.path "halo2_proofs::plonk::circuit::Column")
                          [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                      ],
                      "into",
                      []
                    |),
                    [ M.read (| instance |) ]
                  |);
                  M.read (| row |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_constrain_instance :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "constrain_instance" (constrain_instance F CS).
      End Impl_halo2_proofs_circuit_floor_planner_v1_AssignmentPass_F_CS.
      
      (* StructRecord
        {
          name := "V1Region";
          ty_params := [ "F"; "CS" ];
          fields :=
            [
              ("plan",
                Ty.apply
                  (Ty.path "&")
                  [ Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Plan") [ F; CS ]
                  ]);
              ("region_index", Ty.path "halo2_proofs::circuit::RegionIndex")
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_V1Region_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Region") [ F; CS ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_struct("V1Region")
                    .field("plan", &self.plan)
                    .field("region_index", &self.region_index)
                    .finish()
            }
        *)
        Definition fmt (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugStruct",
                  "finish",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      "field",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugStruct",
                          "field",
                          []
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_struct",
                                []
                              |),
                              [ M.read (| f |); M.read (| Value.String "V1Region" |) ]
                            |)
                          |);
                          M.read (| Value.String "plan" |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::circuit::floor_planner::v1::V1Region",
                              "plan"
                            |))
                        ]
                      |);
                      M.read (| Value.String "region_index" |);
                      (* Unsize *)
                      M.pointer_coercion
                        (M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::v1::V1Region",
                          "region_index"
                        |))
                    ]
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F CS)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F CS)) ].
      End Impl_core_fmt_Debug_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_for_halo2_proofs_circuit_floor_planner_v1_V1Region_F_CS.
      
      Module Impl_halo2_proofs_circuit_floor_planner_v1_V1Region_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Region") [ F; CS ].
        
        (*
            fn new(plan: &'r V1Plan<'a, F, CS>, region_index: RegionIndex) -> Self {
                V1Region { plan, region_index }
            }
        *)
        Definition new (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ plan; region_index ] =>
            ltac:(M.monadic
              (let plan := M.alloc (| plan |) in
              let region_index := M.alloc (| region_index |) in
              Value.StructRecord
                "halo2_proofs::circuit::floor_planner::v1::V1Region"
                [ ("plan", M.read (| plan |)); ("region_index", M.read (| region_index |)) ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (F CS : Ty.t),
          M.IsAssociatedFunction (Self F CS) "new" (new F CS).
      End Impl_halo2_proofs_circuit_floor_planner_v1_V1Region_F_CS.
      
      Module Impl_halo2_proofs_circuit_layouter_RegionLayouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_v1_V1Region_F_CS.
        Definition Self (F CS : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Region") [ F; CS ].
        
        (*
            fn enable_selector<'v>(
                &'v self,
                annotation: &'v (dyn Fn() -> String + 'v),
                selector: &Selector,
                offset: usize,
            ) -> Result<(), Error> {
                self.plan.cs.enable_selector(
                    annotation,
                    selector,
                    *self.plan.regions[*self.region_index] + offset,
                )
            }
        *)
        Definition enable_selector (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; selector; offset ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let selector := M.alloc (| selector |) in
              let offset := M.alloc (| offset |) in
              M.call_closure (|
                M.get_trait_method (|
                  "halo2_proofs::plonk::circuit::Assignment",
                  CS,
                  [ F ],
                  "enable_selector",
                  [
                    Ty.apply (Ty.path "&") [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ];
                    Ty.path "alloc::string::String"
                  ]
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::v1::V1Region",
                          "plan"
                        |)
                      |),
                      "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                      "cs"
                    |)
                  |);
                  M.read (| annotation |);
                  M.read (| selector |);
                  BinOp.Panic.add (|
                    Integer.Usize,
                    M.read (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.path "halo2_proofs::circuit::RegionStart",
                          [],
                          "deref",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [ Ty.path "usize" ],
                              "index",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                    "plan"
                                  |)
                                |),
                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                "regions"
                              |);
                              M.read (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.path "halo2_proofs::circuit::RegionIndex",
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                      "region_index"
                                    |)
                                  ]
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    M.read (| offset |)
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_advice<'v>(
                &'v self,
                annotation: &'v (dyn Fn() -> String + 'v),
                column: Column<Advice>,
                offset: usize,
                to: &'v mut (dyn FnMut() -> Result<Assigned<F>, Error> + 'v),
            ) -> Result<Cell, Error> {
                self.plan.cs.assign_advice(
                    annotation,
                    column,
                    *self.plan.regions[*self.region_index] + offset,
                    to,
                )?;
        
                Ok(Cell {
                    region_index: self.region_index,
                    row_offset: offset,
                    column: column.into(),
                })
            }
        *)
        Definition assign_advice (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; column; offset; to ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let column := M.alloc (| column |) in
              let offset := M.alloc (| offset |) in
              let to := M.alloc (| to |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::plonk::circuit::Assignment",
                                  CS,
                                  [ F ],
                                  "assign_advice",
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      [ Ty.dyn [ ("core::ops::function::FnMut::Trait", []) ] ];
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                      [ F ];
                                    Ty.apply
                                      (Ty.path "&")
                                      [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ];
                                    Ty.path "alloc::string::String"
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                          "plan"
                                        |)
                                      |),
                                      "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                      "cs"
                                    |)
                                  |);
                                  M.read (| annotation |);
                                  M.read (| column |);
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "halo2_proofs::circuit::RegionStart",
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [ Ty.path "usize" ],
                                              "index",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                                    "plan"
                                                  |)
                                                |),
                                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                                "regions"
                                              |);
                                              M.read (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.path "halo2_proofs::circuit::RegionIndex",
                                                    [],
                                                    "deref",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                                      "region_index"
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    M.read (| offset |)
                                  |);
                                  M.read (| to |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "halo2_proofs::circuit::Cell";
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "halo2_proofs::circuit::Cell"
                            [
                              ("region_index",
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                    "region_index"
                                  |)
                                |));
                              ("row_offset", M.read (| offset |));
                              ("column",
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::Into",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Advice" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "into",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |))
                            ]
                        ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_advice_from_constant<'v>(
                &'v self,
                annotation: &'v (dyn Fn() -> String + 'v),
                column: Column<Advice>,
                offset: usize,
                constant: Assigned<F>,
            ) -> Result<Cell, Error> {
                let advice = self.assign_advice(annotation, column, offset, &mut || Ok(constant))?;
                self.constrain_constant(advice, constant)?;
        
                Ok(advice)
            }
        *)
        Definition assign_advice_from_constant
            (F CS : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; column; offset; constant ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let column := M.alloc (| column |) in
              let offset := M.alloc (| offset |) in
              let constant := M.alloc (| constant |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let advice :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.path "halo2_proofs::circuit::Cell";
                                    Ty.path "halo2_proofs::plonk::error::Error"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::circuit::layouter::RegionLayouter",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Region")
                                      [ F; CS ],
                                    [ F ],
                                    "assign_advice",
                                    []
                                  |),
                                  [
                                    M.read (| self |);
                                    (* Unsize *) M.pointer_coercion (M.read (| annotation |));
                                    M.read (| column |);
                                    M.read (| offset |);
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.alloc (|
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                M.match_operator (|
                                                  M.alloc (| α0 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (Value.StructTuple
                                                          "core::result::Result::Ok"
                                                          [ M.read (| constant |) ]))
                                                  ]
                                                |)
                                              | _ => M.impossible (||)
                                              end))
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "halo2_proofs::circuit::Cell";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::circuit::layouter::RegionLayouter",
                                  Ty.apply
                                    (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Region")
                                    [ F; CS ],
                                  [ F ],
                                  "constrain_constant",
                                  []
                                |),
                                [ M.read (| self |); M.read (| advice |); M.read (| constant |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "halo2_proofs::circuit::Cell";
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| advice |) ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_advice_from_instance<'v>(
                &self,
                annotation: &'v (dyn Fn() -> String + 'v),
                instance: Column<Instance>,
                row: usize,
                advice: Column<Advice>,
                offset: usize,
            ) -> Result<(Cell, Option<F>), Error> {
                let value = self.plan.cs.query_instance(instance, row)?;
        
                let cell = self.assign_advice(annotation, advice, offset, &mut || {
                    value.ok_or(Error::Synthesis).map(|v| v.into())
                })?;
        
                self.plan.cs.copy(
                    cell.column,
                    *self.plan.regions[*cell.region_index] + cell.row_offset,
                    instance.into(),
                    row,
                )?;
        
                Ok((cell, value))
            }
        *)
        Definition assign_advice_from_instance
            (F CS : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; instance; row; advice; offset ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let instance := M.alloc (| instance |) in
              let row := M.alloc (| row |) in
              let advice := M.alloc (| advice |) in
              let offset := M.alloc (| offset |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let value :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply (Ty.path "core::option::Option") [ F ];
                                    Ty.path "halo2_proofs::plonk::error::Error"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::plonk::circuit::Assignment",
                                    CS,
                                    [ F ],
                                    "query_instance",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                            "plan"
                                          |)
                                        |),
                                        "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                        "cs"
                                      |)
                                    |);
                                    M.read (| instance |);
                                    M.read (| row |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path "halo2_proofs::circuit::Cell";
                                                    Ty.apply (Ty.path "core::option::Option") [ F ]
                                                  ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let cell :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.path "halo2_proofs::circuit::Cell";
                                    Ty.path "halo2_proofs::plonk::error::Error"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::circuit::layouter::RegionLayouter",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::circuit::floor_planner::v1::V1Region")
                                      [ F; CS ],
                                    [ F ],
                                    "assign_advice",
                                    []
                                  |),
                                  [
                                    M.read (| self |);
                                    (* Unsize *) M.pointer_coercion (M.read (| annotation |));
                                    M.read (| advice |);
                                    M.read (| offset |);
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.alloc (|
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                M.match_operator (|
                                                  M.alloc (| α0 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              [
                                                                F;
                                                                Ty.path
                                                                  "halo2_proofs::plonk::error::Error"
                                                              ],
                                                            "map",
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::assigned::Assigned")
                                                                [ F ];
                                                              Ty.function
                                                                [ Ty.tuple [ F ] ]
                                                                (Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                                  [ F ])
                                                            ]
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  [ F ],
                                                                "ok_or",
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::error::Error"
                                                                ]
                                                              |),
                                                              [
                                                                M.read (| value |);
                                                                Value.StructTuple
                                                                  "halo2_proofs::plonk::error::Error::Synthesis"
                                                                  []
                                                              ]
                                                            |);
                                                            M.closure
                                                              (fun γ =>
                                                                ltac:(M.monadic
                                                                  match γ with
                                                                  | [ α0 ] =>
                                                                    M.match_operator (|
                                                                      M.alloc (| α0 |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let v :=
                                                                              M.copy (| γ |) in
                                                                            M.call_closure (|
                                                                              M.get_trait_method (|
                                                                                "core::convert::Into",
                                                                                F,
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "halo2_proofs::plonk::assigned::Assigned")
                                                                                    [ F ]
                                                                                ],
                                                                                "into",
                                                                                []
                                                                              |),
                                                                              [ M.read (| v |) ]
                                                                            |)))
                                                                      ]
                                                                    |)
                                                                  | _ => M.impossible (||)
                                                                  end))
                                                          ]
                                                        |)))
                                                  ]
                                                |)
                                              | _ => M.impossible (||)
                                              end))
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path "halo2_proofs::circuit::Cell";
                                                    Ty.apply (Ty.path "core::option::Option") [ F ]
                                                  ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "halo2_proofs::plonk::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::plonk::circuit::Assignment",
                                  CS,
                                  [ F ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                          "plan"
                                        |)
                                      |),
                                      "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                      "cs"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      cell,
                                      "halo2_proofs::circuit::Cell",
                                      "column"
                                    |)
                                  |);
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "halo2_proofs::circuit::RegionStart",
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [ Ty.path "usize" ],
                                              "index",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                                    "plan"
                                                  |)
                                                |),
                                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                                "regions"
                                              |);
                                              M.read (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.path "halo2_proofs::circuit::RegionIndex",
                                                    [],
                                                    "deref",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      cell,
                                                      "halo2_proofs::circuit::Cell",
                                                      "region_index"
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        cell,
                                        "halo2_proofs::circuit::Cell",
                                        "row_offset"
                                      |)
                                    |)
                                  |);
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Instance" ],
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Column")
                                          [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                      ],
                                      "into",
                                      []
                                    |),
                                    [ M.read (| instance |) ]
                                  |);
                                  M.read (| row |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "halo2_proofs::circuit::Cell";
                                                  Ty.apply (Ty.path "core::option::Option") [ F ]
                                                ];
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.Tuple [ M.read (| cell |); M.read (| value |) ] ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn assign_fixed<'v>(
                &'v self,
                annotation: &'v (dyn Fn() -> String + 'v),
                column: Column<Fixed>,
                offset: usize,
                to: &'v mut (dyn FnMut() -> Result<Assigned<F>, Error> + 'v),
            ) -> Result<Cell, Error> {
                self.plan.cs.assign_fixed(
                    annotation,
                    column,
                    *self.plan.regions[*self.region_index] + offset,
                    to,
                )?;
        
                Ok(Cell {
                    region_index: self.region_index,
                    row_offset: offset,
                    column: column.into(),
                })
            }
        *)
        Definition assign_fixed (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; annotation; column; offset; to ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let annotation := M.alloc (| annotation |) in
              let column := M.alloc (| column |) in
              let offset := M.alloc (| offset |) in
              let to := M.alloc (| to |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::plonk::circuit::Assignment",
                                  CS,
                                  [ F ],
                                  "assign_fixed",
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      [ Ty.dyn [ ("core::ops::function::FnMut::Trait", []) ] ];
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                      [ F ];
                                    Ty.apply
                                      (Ty.path "&")
                                      [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ];
                                    Ty.path "alloc::string::String"
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                          "plan"
                                        |)
                                      |),
                                      "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                      "cs"
                                    |)
                                  |);
                                  M.read (| annotation |);
                                  M.read (| column |);
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "halo2_proofs::circuit::RegionStart",
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [ Ty.path "usize" ],
                                              "index",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                                    "plan"
                                                  |)
                                                |),
                                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                                "regions"
                                              |);
                                              M.read (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.path "halo2_proofs::circuit::RegionIndex",
                                                    [],
                                                    "deref",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                                      "region_index"
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    M.read (| offset |)
                                  |);
                                  M.read (| to |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "halo2_proofs::circuit::Cell";
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "halo2_proofs::circuit::Cell"
                            [
                              ("region_index",
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                    "region_index"
                                  |)
                                |));
                              ("row_offset", M.read (| offset |));
                              ("column",
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::Into",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "into",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |))
                            ]
                        ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn constrain_constant(&self, cell: Cell, constant: Assigned<F>) -> Result<(), Error> {
                let mut constants = self.plan.constants.lock().unwrap();
                constants.push((constant, cell));
                Ok(())
            }
        *)
        Definition constrain_constant (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; cell; constant ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let cell := M.alloc (| cell |) in
              let constant := M.alloc (| constant |) in
              M.read (|
                let constants :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          [
                            Ty.apply
                              (Ty.path "std::sync::mutex::MutexGuard")
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                          [ F ];
                                        Ty.path "halo2_proofs::circuit::Cell"
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ];
                            Ty.apply
                              (Ty.path "std::sync::poison::PoisonError")
                              [
                                Ty.apply
                                  (Ty.path "std::sync::mutex::MutexGuard")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                              [ F ];
                                            Ty.path "halo2_proofs::circuit::Cell"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ]
                              ]
                          ],
                        "unwrap",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::parallel::Parallel")
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                          [ F ];
                                        Ty.path "halo2_proofs::circuit::Cell"
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ],
                            "lock",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                  "plan"
                                |)
                              |),
                              "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                              "constants"
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
                                Ty.path "halo2_proofs::circuit::Cell"
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "push",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::DerefMut",
                            Ty.apply
                              (Ty.path "std::sync::mutex::MutexGuard")
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                          [ F ];
                                        Ty.path "halo2_proofs::circuit::Cell"
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ],
                            [],
                            "deref_mut",
                            []
                          |),
                          [ constants ]
                        |);
                        Value.Tuple [ M.read (| constant |); M.read (| cell |) ]
                      ]
                    |)
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        (*
            fn constrain_equal(&self, left: Cell, right: Cell) -> Result<(), Error> {
                self.plan.cs.copy(
                    left.column,
                    *self.plan.regions[*left.region_index] + left.row_offset,
                    right.column,
                    *self.plan.regions[*right.region_index] + right.row_offset,
                )?;
        
                Ok(())
            }
        *)
        Definition constrain_equal (F CS : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F CS in
          match τ, α with
          | [], [ self; _ as left; _ as right ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let left := M.alloc (| left |) in
              let right := M.alloc (| right |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "halo2_proofs::plonk::circuit::Assignment",
                                  CS,
                                  [ F ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                          "plan"
                                        |)
                                      |),
                                      "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                      "cs"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      left,
                                      "halo2_proofs::circuit::Cell",
                                      "column"
                                    |)
                                  |);
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "halo2_proofs::circuit::RegionStart",
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [ Ty.path "usize" ],
                                              "index",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                                    "plan"
                                                  |)
                                                |),
                                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                                "regions"
                                              |);
                                              M.read (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.path "halo2_proofs::circuit::RegionIndex",
                                                    [],
                                                    "deref",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      left,
                                                      "halo2_proofs::circuit::Cell",
                                                      "region_index"
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        left,
                                        "halo2_proofs::circuit::Cell",
                                        "row_offset"
                                      |)
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      right,
                                      "halo2_proofs::circuit::Cell",
                                      "column"
                                    |)
                                  |);
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "halo2_proofs::circuit::RegionStart",
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [ Ty.path "usize" ],
                                              "index",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "halo2_proofs::circuit::floor_planner::v1::V1Region",
                                                    "plan"
                                                  |)
                                                |),
                                                "halo2_proofs::circuit::floor_planner::v1::V1Plan",
                                                "regions"
                                              |);
                                              M.read (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.path "halo2_proofs::circuit::RegionIndex",
                                                    [],
                                                    "deref",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      right,
                                                      "halo2_proofs::circuit::Cell",
                                                      "region_index"
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        right,
                                        "halo2_proofs::circuit::Cell",
                                        "row_offset"
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.tuple [];
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F CS : Ty.t),
          M.IsTraitInstance
            "halo2_proofs::circuit::layouter::RegionLayouter"
            (Self F CS)
            (* Trait polymorphic types *) [ (* F *) F ]
            (* Instance *)
            [
              ("enable_selector", InstanceField.Method (enable_selector F CS));
              ("assign_advice", InstanceField.Method (assign_advice F CS));
              ("assign_advice_from_constant",
                InstanceField.Method (assign_advice_from_constant F CS));
              ("assign_advice_from_instance",
                InstanceField.Method (assign_advice_from_instance F CS));
              ("assign_fixed", InstanceField.Method (assign_fixed F CS));
              ("constrain_constant", InstanceField.Method (constrain_constant F CS));
              ("constrain_equal", InstanceField.Method (constrain_equal F CS))
            ].
      End Impl_halo2_proofs_circuit_layouter_RegionLayouter_where_ff_Field_F_where_halo2_proofs_plonk_circuit_Assignment_CS_F_F_for_halo2_proofs_circuit_floor_planner_v1_V1Region_F_CS.
    End v1.
  End floor_planner.
End circuit.
