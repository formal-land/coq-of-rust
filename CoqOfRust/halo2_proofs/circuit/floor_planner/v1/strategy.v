(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module circuit.
  Module floor_planner.
    Module v1.
      Module strategy.
        (* StructRecord
          {
            name := "AllocatedRegion";
            ty_params := [];
            fields := [ ("start", Ty.path "usize"); ("length", Ty.path "usize") ];
          } *)
        
        Module Impl_core_clone_Clone_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion".
          
          (* Clone *)
          Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                Value.StructRecord
                  "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                  [
                    ("start",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.path "usize",
                          [],
                          "clone",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                            "start"
                          |)
                        ]
                      |));
                    ("length",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.path "usize",
                          [],
                          "clone",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                            "length"
                          |)
                        ]
                      |))
                  ]))
            | _, _ => M.impossible
            end.
          
          Axiom Implements :
            M.IsTraitInstance
              "core::clone::Clone"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [ ("clone", InstanceField.Method clone) ].
        End Impl_core_clone_Clone_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
        
        Module Impl_core_default_Default_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion".
          
          (* Default *)
          Definition default (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [] =>
              ltac:(M.monadic
                (Value.StructRecord
                  "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                  [
                    ("start",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::default::Default",
                          Ty.path "usize",
                          [],
                          "default",
                          []
                        |),
                        []
                      |));
                    ("length",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::default::Default",
                          Ty.path "usize",
                          [],
                          "default",
                          []
                        |),
                        []
                      |))
                  ]))
            | _, _ => M.impossible
            end.
          
          Axiom Implements :
            M.IsTraitInstance
              "core::default::Default"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [ ("default", InstanceField.Method default) ].
        End Impl_core_default_Default_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
        
        Module Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion".
          
          (* Debug *)
          Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self; f ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let f := M.alloc (| f |) in
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "debug_struct_field2_finish",
                    []
                  |),
                  [
                    M.read (| f |);
                    M.read (| Value.String "AllocatedRegion" |);
                    M.read (| Value.String "start" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                        "start"
                      |));
                    M.read (| Value.String "length" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                          "length"
                        |)
                      |))
                  ]
                |)))
            | _, _ => M.impossible
            end.
          
          Axiom Implements :
            M.IsTraitInstance
              "core::fmt::Debug"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
        End Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
        
        Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion".
          
          Axiom Implements :
            M.IsTraitInstance
              "core::marker::StructuralPartialEq"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [].
        End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
        
        Module Impl_core_cmp_PartialEq_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion".
          
          (* PartialEq *)
          Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self; other ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let other := M.alloc (| other |) in
                LogicalOp.and (|
                  BinOp.Pure.eq
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                        "start"
                      |)
                    |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                        "start"
                      |)
                    |)),
                  ltac:(M.monadic
                    (BinOp.Pure.eq
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                          "length"
                        |)
                      |))
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| other |),
                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                          "length"
                        |)
                      |))))
                |)))
            | _, _ => M.impossible
            end.
          
          Axiom Implements :
            M.IsTraitInstance
              "core::cmp::PartialEq"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [ ("eq", InstanceField.Method eq) ].
        End Impl_core_cmp_PartialEq_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
        
        Module Impl_core_marker_StructuralEq_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion".
          
          Axiom Implements :
            M.IsTraitInstance
              "core::marker::StructuralEq"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [].
        End Impl_core_marker_StructuralEq_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
        
        Module Impl_core_cmp_Eq_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion".
          
          (* Eq *)
          Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.read (|
                  M.match_operator (|
                    Value.DeclaredButUndefined,
                    [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                  |)
                |)))
            | _, _ => M.impossible
            end.
          
          Axiom Implements :
            M.IsTraitInstance
              "core::cmp::Eq"
              Self
              (* Trait polymorphic types *) []
              (* Instance *)
              [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
        End Impl_core_cmp_Eq_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
        
        Module Impl_core_cmp_Ord_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion".
          
          (*
              fn cmp(&self, other: &Self) -> cmp::Ordering {
                  self.start.cmp(&other.start)
              }
          *)
          Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self; other ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let other := M.alloc (| other |) in
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], "cmp", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                      "start"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                      "start"
                    |)
                  ]
                |)))
            | _, _ => M.impossible
            end.
          
          Axiom Implements :
            M.IsTraitInstance
              "core::cmp::Ord"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
        End Impl_core_cmp_Ord_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
        
        Module Impl_core_cmp_PartialOrd_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion".
          
          (*
              fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
                  Some(self.cmp(other))
              }
          *)
          Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self; other ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let other := M.alloc (| other |) in
                Value.StructTuple
                  "core::option::Option::Some"
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::cmp::Ord",
                        Ty.path
                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                        [],
                        "cmp",
                        []
                      |),
                      [ M.read (| self |); M.read (| other |) ]
                    |)
                  ]))
            | _, _ => M.impossible
            end.
          
          Axiom Implements :
            M.IsTraitInstance
              "core::cmp::PartialOrd"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
        End Impl_core_cmp_PartialOrd_for_halo2_proofs_circuit_floor_planner_v1_strategy_AllocatedRegion.
        
        (* StructRecord
          {
            name := "EmptySpace";
            ty_params := [];
            fields :=
              [
                ("start", Ty.path "usize");
                ("end_", Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ])
              ];
          } *)
        
        Module Impl_halo2_proofs_circuit_floor_planner_v1_strategy_EmptySpace.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace".
          
          (*
              pub(crate) fn range(&self) -> Option<Range<usize>> {
                  self.end.map(|end| self.start..end)
              }
          *)
          Definition range (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                    "map",
                    [
                      Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ];
                      Ty.function
                        [ Ty.tuple [ Ty.path "usize" ] ]
                        (Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ])
                    ]
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace",
                        "end"
                      |)
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let end_ := M.copy (| γ |) in
                                    Value.StructRecord
                                      "core::ops::range::Range"
                                      [
                                        ("start",
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace",
                                              "start"
                                            |)
                                          |));
                                        ("end_", M.read (| end_ |))
                                      ]))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end))
                  ]
                |)))
            | _, _ => M.impossible
            end.
          
          Axiom AssociatedFunction_range : M.IsAssociatedFunction Self "range" range.
        End Impl_halo2_proofs_circuit_floor_planner_v1_strategy_EmptySpace.
        
        (* StructTuple
          {
            name := "Allocations";
            ty_params := [];
            fields :=
              [
                Ty.apply
                  (Ty.path "alloc::collections::btree::set::BTreeSet")
                  [
                    Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion";
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
          } *)
        
        Module Impl_core_clone_Clone_for_halo2_proofs_circuit_floor_planner_v1_strategy_Allocations.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations".
          
          (* Clone *)
          Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                Value.StructTuple
                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::BTreeSet")
                          [
                            Ty.path
                              "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion";
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_tuple_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations",
                          0
                        |)
                      ]
                    |)
                  ]))
            | _, _ => M.impossible
            end.
          
          Axiom Implements :
            M.IsTraitInstance
              "core::clone::Clone"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [ ("clone", InstanceField.Method clone) ].
        End Impl_core_clone_Clone_for_halo2_proofs_circuit_floor_planner_v1_strategy_Allocations.
        
        Module Impl_core_default_Default_for_halo2_proofs_circuit_floor_planner_v1_strategy_Allocations.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations".
          
          (* Default *)
          Definition default (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [] =>
              ltac:(M.monadic
                (Value.StructTuple
                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::BTreeSet")
                          [
                            Ty.path
                              "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion";
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        "default",
                        []
                      |),
                      []
                    |)
                  ]))
            | _, _ => M.impossible
            end.
          
          Axiom Implements :
            M.IsTraitInstance
              "core::default::Default"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [ ("default", InstanceField.Method default) ].
        End Impl_core_default_Default_for_halo2_proofs_circuit_floor_planner_v1_strategy_Allocations.
        
        Module Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_v1_strategy_Allocations.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations".
          
          (* Debug *)
          Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self; f ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let f := M.alloc (| f |) in
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "debug_tuple_field1_finish",
                    []
                  |),
                  [
                    M.read (| f |);
                    M.read (| Value.String "Allocations" |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        M.SubPointer.get_struct_tuple_field (|
                          M.read (| self |),
                          "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations",
                          0
                        |)
                      |))
                  ]
                |)))
            | _, _ => M.impossible
            end.
          
          Axiom Implements :
            M.IsTraitInstance
              "core::fmt::Debug"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
        End Impl_core_fmt_Debug_for_halo2_proofs_circuit_floor_planner_v1_strategy_Allocations.
        
        Module Impl_halo2_proofs_circuit_floor_planner_v1_strategy_Allocations.
          Definition Self : Ty.t :=
            Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations".
          
          (*
              pub(crate) fn unbounded_interval_start(&self) -> usize {
                  self.0
                      .iter()
                      .last()
                      .map(|r| r.start + r.length)
                      .unwrap_or(0)
              }
          *)
          Definition unbounded_interval_start (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                    "unwrap_or",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          [
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.path
                                  "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                              ]
                          ],
                        "map",
                        [
                          Ty.path "usize";
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [
                                      Ty.path
                                        "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                    ]
                                ]
                            ]
                            (Ty.path "usize")
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "alloc::collections::btree::set::Iter")
                              [
                                Ty.path
                                  "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                              ],
                            [],
                            "last",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::set::BTreeSet")
                                  [
                                    Ty.path
                                      "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "iter",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_tuple_field (|
                                  M.read (| self |),
                                  "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations",
                                  0
                                |)
                              ]
                            |)
                          ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let r := M.copy (| γ |) in
                                        BinOp.Panic.add (|
                                          Integer.Usize,
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| r |),
                                              "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                                              "start"
                                            |)
                                          |),
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| r |),
                                              "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                                              "length"
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |);
                    Value.Integer 0
                  ]
                |)))
            | _, _ => M.impossible
            end.
          
          Axiom AssociatedFunction_unbounded_interval_start :
            M.IsAssociatedFunction Self "unbounded_interval_start" unbounded_interval_start.
          
          (*
              pub(crate) fn free_intervals(
                  &self,
                  start: usize,
                  end: Option<usize>,
              ) -> impl Iterator<Item = EmptySpace> + '_ {
                  self.0
                      .iter()
                      .map(Some)
                      .chain(Some(None))
                      .scan(start, move |row, region| {
                          Some(if let Some(region) = region {
                              if end.map(|end| region.start >= end).unwrap_or(false) {
                                  None
                              } else {
                                  let ret = if *row < region.start {
                                      Some(EmptySpace {
                                          start: *row,
                                          end: Some(region.start),
                                      })
                                  } else {
                                      None
                                  };
          
                                  *row = cmp::max( *row, region.start + region.length);
          
                                  ret
                              }
                          } else if end.map(|end| *row < end).unwrap_or(true) {
                              Some(EmptySpace { start: *row, end })
                          } else {
                              None
                          })
                      })
                      .flatten()
              }
          *)
          Definition free_intervals (τ : list Ty.t) (α : list Value.t) : M :=
            match τ, α with
            | [], [ self; start; end_ ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let start := M.alloc (| start |) in
                let end_ := M.alloc (| end_ |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::scan::Scan")
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::chain::Chain")
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::set::Iter")
                                  [
                                    Ty.path
                                      "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                  ];
                                Ty.function
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.path
                                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                      ]
                                  ]
                                  (Ty.apply
                                    (Ty.path "core::option::Option")
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.path
                                            "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                        ]
                                    ])
                              ];
                            Ty.apply
                              (Ty.path "core::option::IntoIter")
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.path
                                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                      ]
                                  ]
                              ]
                          ];
                        Ty.path "usize";
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&mut") [ Ty.path "usize" ];
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.path
                                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                      ]
                                  ]
                              ]
                          ]
                          (Ty.apply
                            (Ty.path "core::option::Option")
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                [
                                  Ty.path
                                    "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                ]
                            ])
                      ],
                    [],
                    "flatten",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::chain::Chain")
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::set::Iter")
                                  [
                                    Ty.path
                                      "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                  ];
                                Ty.function
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.path
                                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                      ]
                                  ]
                                  (Ty.apply
                                    (Ty.path "core::option::Option")
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.path
                                            "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                        ]
                                    ])
                              ];
                            Ty.apply
                              (Ty.path "core::option::IntoIter")
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.path
                                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                      ]
                                  ]
                              ]
                          ],
                        [],
                        "scan",
                        [
                          Ty.path "usize";
                          Ty.apply
                            (Ty.path "core::option::Option")
                            [
                              Ty.path
                                "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                            ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply (Ty.path "&mut") [ Ty.path "usize" ];
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.path
                                            "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                        ]
                                    ]
                                ]
                            ]
                            (Ty.apply
                              (Ty.path "core::option::Option")
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.path
                                      "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                  ]
                              ])
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::set::Iter")
                                  [
                                    Ty.path
                                      "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                  ];
                                Ty.function
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.path
                                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                      ]
                                  ]
                                  (Ty.apply
                                    (Ty.path "core::option::Option")
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.path
                                            "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                        ]
                                    ])
                              ],
                            [],
                            "chain",
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                [
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.path
                                            "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                        ]
                                    ]
                                ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::set::Iter")
                                  [
                                    Ty.path
                                      "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                  ],
                                [],
                                "map",
                                [
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.path
                                            "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                        ]
                                    ];
                                  Ty.function
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.path
                                            "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          [
                                            Ty.path
                                              "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                          ]
                                      ])
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::set::BTreeSet")
                                      [
                                        Ty.path
                                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion";
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "iter",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_tuple_field (|
                                      M.read (| self |),
                                      "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations",
                                      0
                                    |)
                                  ]
                                |);
                                M.constructor_as_closure "core::option::Option::Some"
                              ]
                            |);
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.StructTuple "core::option::Option::None" [] ]
                          ]
                        |);
                        M.read (| start |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0; α1 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let row := M.copy (| γ |) in
                                        M.match_operator (|
                                          M.alloc (| α1 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let region := M.copy (| γ |) in
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [
                                                    M.read (|
                                                      M.match_operator (|
                                                        M.alloc (| Value.Tuple [] |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ := region in
                                                              let γ0_0 :=
                                                                M.SubPointer.get_struct_tuple_field (|
                                                                  γ,
                                                                  "core::option::Option::Some",
                                                                  0
                                                                |) in
                                                              let region := M.copy (| γ0_0 |) in
                                                              M.match_operator (|
                                                                M.alloc (| Value.Tuple [] |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ :=
                                                                        M.use
                                                                          (M.alloc (|
                                                                            M.call_closure (|
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::option::Option")
                                                                                  [ Ty.path "bool"
                                                                                  ],
                                                                                "unwrap_or",
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.call_closure (|
                                                                                  M.get_associated_function (|
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::option::Option")
                                                                                      [
                                                                                        Ty.path
                                                                                          "usize"
                                                                                      ],
                                                                                    "map",
                                                                                    [
                                                                                      Ty.path
                                                                                        "bool";
                                                                                      Ty.function
                                                                                        [
                                                                                          Ty.tuple
                                                                                            [
                                                                                              Ty.path
                                                                                                "usize"
                                                                                            ]
                                                                                        ]
                                                                                        (Ty.path
                                                                                          "bool")
                                                                                    ]
                                                                                  |),
                                                                                  [
                                                                                    M.read (|
                                                                                      end_
                                                                                    |);
                                                                                    M.closure
                                                                                      (fun γ =>
                                                                                        ltac:(M.monadic
                                                                                          match γ
                                                                                          with
                                                                                          | [ α0
                                                                                              ] =>
                                                                                            M.match_operator (|
                                                                                              M.alloc (|
                                                                                                α0
                                                                                              |),
                                                                                              [
                                                                                                fun
                                                                                                    γ =>
                                                                                                  ltac:(M.monadic
                                                                                                    (let
                                                                                                          end_ :=
                                                                                                      M.copy (|
                                                                                                        γ
                                                                                                      |) in
                                                                                                    BinOp.Pure.ge
                                                                                                      (M.read (|
                                                                                                        M.SubPointer.get_struct_record_field (|
                                                                                                          M.read (|
                                                                                                            region
                                                                                                          |),
                                                                                                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                                                                                                          "start"
                                                                                                        |)
                                                                                                      |))
                                                                                                      (M.read (|
                                                                                                        end_
                                                                                                      |))))
                                                                                              ]
                                                                                            |)
                                                                                          | _ =>
                                                                                            M.impossible (||)
                                                                                          end))
                                                                                  ]
                                                                                |);
                                                                                Value.Bool false
                                                                              ]
                                                                            |)
                                                                          |)) in
                                                                      let _ :=
                                                                        M.is_constant_or_break_match (|
                                                                          M.read (| γ |),
                                                                          Value.Bool true
                                                                        |) in
                                                                      M.alloc (|
                                                                        Value.StructTuple
                                                                          "core::option::Option::None"
                                                                          []
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let ret :=
                                                                        M.copy (|
                                                                          M.match_operator (|
                                                                            M.alloc (|
                                                                              Value.Tuple []
                                                                            |),
                                                                            [
                                                                              fun γ =>
                                                                                ltac:(M.monadic
                                                                                  (let γ :=
                                                                                    M.use
                                                                                      (M.alloc (|
                                                                                        BinOp.Pure.lt
                                                                                          (M.read (|
                                                                                            M.read (|
                                                                                              row
                                                                                            |)
                                                                                          |))
                                                                                          (M.read (|
                                                                                            M.SubPointer.get_struct_record_field (|
                                                                                              M.read (|
                                                                                                region
                                                                                              |),
                                                                                              "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                                                                                              "start"
                                                                                            |)
                                                                                          |))
                                                                                      |)) in
                                                                                  let _ :=
                                                                                    M.is_constant_or_break_match (|
                                                                                      M.read (|
                                                                                        γ
                                                                                      |),
                                                                                      Value.Bool
                                                                                        true
                                                                                    |) in
                                                                                  M.alloc (|
                                                                                    Value.StructTuple
                                                                                      "core::option::Option::Some"
                                                                                      [
                                                                                        Value.StructRecord
                                                                                          "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                                          [
                                                                                            ("start",
                                                                                              M.read (|
                                                                                                M.read (|
                                                                                                  row
                                                                                                |)
                                                                                              |));
                                                                                            ("end_",
                                                                                              Value.StructTuple
                                                                                                "core::option::Option::Some"
                                                                                                [
                                                                                                  M.read (|
                                                                                                    M.SubPointer.get_struct_record_field (|
                                                                                                      M.read (|
                                                                                                        region
                                                                                                      |),
                                                                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                                                                                                      "start"
                                                                                                    |)
                                                                                                  |)
                                                                                                ])
                                                                                          ]
                                                                                      ]
                                                                                  |)));
                                                                              fun γ =>
                                                                                ltac:(M.monadic
                                                                                  (M.alloc (|
                                                                                    Value.StructTuple
                                                                                      "core::option::Option::None"
                                                                                      []
                                                                                  |)))
                                                                            ]
                                                                          |)
                                                                        |) in
                                                                      let _ :=
                                                                        M.write (|
                                                                          M.read (| row |),
                                                                          M.call_closure (|
                                                                            M.get_function (|
                                                                              "core::cmp::max",
                                                                              [ Ty.path "usize" ]
                                                                            |),
                                                                            [
                                                                              M.read (|
                                                                                M.read (| row |)
                                                                              |);
                                                                              BinOp.Panic.add (|
                                                                                Integer.Usize,
                                                                                M.read (|
                                                                                  M.SubPointer.get_struct_record_field (|
                                                                                    M.read (|
                                                                                      region
                                                                                    |),
                                                                                    "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                                                                                    "start"
                                                                                  |)
                                                                                |),
                                                                                M.read (|
                                                                                  M.SubPointer.get_struct_record_field (|
                                                                                    M.read (|
                                                                                      region
                                                                                    |),
                                                                                    "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion",
                                                                                    "length"
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |) in
                                                                      ret))
                                                                ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.match_operator (|
                                                                M.alloc (| Value.Tuple [] |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ :=
                                                                        M.use
                                                                          (M.alloc (|
                                                                            M.call_closure (|
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::option::Option")
                                                                                  [ Ty.path "bool"
                                                                                  ],
                                                                                "unwrap_or",
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.call_closure (|
                                                                                  M.get_associated_function (|
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::option::Option")
                                                                                      [
                                                                                        Ty.path
                                                                                          "usize"
                                                                                      ],
                                                                                    "map",
                                                                                    [
                                                                                      Ty.path
                                                                                        "bool";
                                                                                      Ty.function
                                                                                        [
                                                                                          Ty.tuple
                                                                                            [
                                                                                              Ty.path
                                                                                                "usize"
                                                                                            ]
                                                                                        ]
                                                                                        (Ty.path
                                                                                          "bool")
                                                                                    ]
                                                                                  |),
                                                                                  [
                                                                                    M.read (|
                                                                                      end_
                                                                                    |);
                                                                                    M.closure
                                                                                      (fun γ =>
                                                                                        ltac:(M.monadic
                                                                                          match γ
                                                                                          with
                                                                                          | [ α0
                                                                                              ] =>
                                                                                            M.match_operator (|
                                                                                              M.alloc (|
                                                                                                α0
                                                                                              |),
                                                                                              [
                                                                                                fun
                                                                                                    γ =>
                                                                                                  ltac:(M.monadic
                                                                                                    (let
                                                                                                          end_ :=
                                                                                                      M.copy (|
                                                                                                        γ
                                                                                                      |) in
                                                                                                    BinOp.Pure.lt
                                                                                                      (M.read (|
                                                                                                        M.read (|
                                                                                                          row
                                                                                                        |)
                                                                                                      |))
                                                                                                      (M.read (|
                                                                                                        end_
                                                                                                      |))))
                                                                                              ]
                                                                                            |)
                                                                                          | _ =>
                                                                                            M.impossible (||)
                                                                                          end))
                                                                                  ]
                                                                                |);
                                                                                Value.Bool true
                                                                              ]
                                                                            |)
                                                                          |)) in
                                                                      let _ :=
                                                                        M.is_constant_or_break_match (|
                                                                          M.read (| γ |),
                                                                          Value.Bool true
                                                                        |) in
                                                                      M.alloc (|
                                                                        Value.StructTuple
                                                                          "core::option::Option::Some"
                                                                          [
                                                                            Value.StructRecord
                                                                              "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace"
                                                                              [
                                                                                ("start",
                                                                                  M.read (|
                                                                                    M.read (| row |)
                                                                                  |));
                                                                                ("end_",
                                                                                  M.read (| end_ |))
                                                                              ]
                                                                          ]
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (M.alloc (|
                                                                        Value.StructTuple
                                                                          "core::option::Option::None"
                                                                          []
                                                                      |)))
                                                                ]
                                                              |)))
                                                        ]
                                                      |)
                                                    |)
                                                  ]))
                                          ]
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  ]
                |)))
            | _, _ => M.impossible
            end.
          
          Axiom AssociatedFunction_free_intervals :
            M.IsAssociatedFunction Self "free_intervals" free_intervals.
        End Impl_halo2_proofs_circuit_floor_planner_v1_strategy_Allocations.
        
        Axiom CircuitAllocations :
          (Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::CircuitAllocations") =
            (Ty.apply
              (Ty.path "std::collections::hash::map::HashMap")
              [
                Ty.path "halo2_proofs::circuit::layouter::RegionColumn";
                Ty.path "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations";
                Ty.path "std::hash::random::RandomState"
              ]).
        
        (*
        fn first_fit_region(
            column_allocations: &mut CircuitAllocations,
            region_columns: &[RegionColumn],
            region_length: usize,
            start: usize,
            slack: Option<usize>,
        ) -> Option<usize> {
            let (c, remaining_columns) = match region_columns.split_first() {
                Some(cols) => cols,
                None => return Some(start),
            };
            let end = slack.map(|slack| start + region_length + slack);
        
            // Iterate over the unallocated non-empty intervals in c that intersect [start, end).
            for space in column_allocations
                .entry( *c)
                .or_default()
                .clone()
                .free_intervals(start, end)
            {
                // Do we have enough room for this column of the region in this interval?
                let s_slack = space
                    .end
                    .map(|end| (end as isize - space.start as isize) - region_length as isize);
                if let Some((slack, s_slack)) = slack.zip(s_slack) {
                    assert!(s_slack <= slack as isize);
                }
                if s_slack.unwrap_or(0) >= 0 {
                    let row = first_fit_region(
                        column_allocations,
                        remaining_columns,
                        region_length,
                        space.start,
                        s_slack.map(|s| s as usize),
                    );
                    if let Some(row) = row {
                        if let Some(end) = end {
                            assert!(row + region_length <= end);
                        }
                        column_allocations
                            .get_mut(c)
                            .unwrap()
                            .0
                            .insert(AllocatedRegion {
                                start: row,
                                length: region_length,
                            });
                        return Some(row);
                    }
                }
            }
        
            // No placement worked; the caller will need to try other possibilities.
            None
        }
        *)
        Definition first_fit_region (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ column_allocations; region_columns; region_length; start; slack ] =>
            ltac:(M.monadic
              (let column_allocations := M.alloc (| column_allocations |) in
              let region_columns := M.alloc (| region_columns |) in
              let region_length := M.alloc (| region_length |) in
              let start := M.alloc (| start |) in
              let slack := M.alloc (| slack |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.path "halo2_proofs::circuit::layouter::RegionColumn" ],
                              "split_first",
                              []
                            |),
                            [ M.read (| region_columns |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let cols := M.copy (| γ0_0 |) in
                              cols));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructTuple
                                        "core::option::Option::Some"
                                        [ M.read (| start |) ]
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let c := M.copy (| γ0_0 |) in
                            let remaining_columns := M.copy (| γ0_1 |) in
                            let end_ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                    "map",
                                    [
                                      Ty.path "usize";
                                      Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                                    ]
                                  |),
                                  [
                                    M.read (| slack |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let slack := M.copy (| γ |) in
                                                    BinOp.Panic.add (|
                                                      Integer.Usize,
                                                      BinOp.Panic.add (|
                                                        Integer.Usize,
                                                        M.read (| start |),
                                                        M.read (| region_length |)
                                                      |),
                                                      M.read (| slack |)
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  ]
                                |)
                              |) in
                            let _ :=
                              M.use
                                (M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::collect::IntoIterator",
                                        Ty.associated,
                                        [],
                                        "into_iter",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path
                                              "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations",
                                            "free_intervals",
                                            []
                                          |),
                                          [
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::clone::Clone",
                                                  Ty.path
                                                    "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations",
                                                  [],
                                                  "clone",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "std::collections::hash::map::Entry")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::circuit::layouter::RegionColumn";
                                                          Ty.path
                                                            "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                        ],
                                                      "or_default",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "std::collections::hash::map::HashMap")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::circuit::layouter::RegionColumn";
                                                              Ty.path
                                                                "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations";
                                                              Ty.path
                                                                "std::hash::random::RandomState"
                                                            ],
                                                          "entry",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| column_allocations |);
                                                          M.read (| M.read (| c |) |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |);
                                            M.read (| start |);
                                            M.read (| end_ |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let iter := M.copy (| γ |) in
                                        M.loop (|
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.associated,
                                                      [],
                                                      "next",
                                                      []
                                                    |),
                                                    [ iter ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (| M.break (||) |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let space := M.copy (| γ0_0 |) in
                                                      let s_slack :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                [ Ty.path "usize" ],
                                                              "map",
                                                              [
                                                                Ty.path "isize";
                                                                Ty.function
                                                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                                                  (Ty.path "isize")
                                                              ]
                                                            |),
                                                            [
                                                              M.read (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  space,
                                                                  "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace",
                                                                  "end"
                                                                |)
                                                              |);
                                                              M.closure
                                                                (fun γ =>
                                                                  ltac:(M.monadic
                                                                    match γ with
                                                                    | [ α0 ] =>
                                                                      M.match_operator (|
                                                                        M.alloc (| α0 |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let end_ :=
                                                                                M.copy (| γ |) in
                                                                              BinOp.Panic.sub (|
                                                                                Integer.Isize,
                                                                                BinOp.Panic.sub (|
                                                                                  Integer.Isize,
                                                                                  M.rust_cast
                                                                                    (M.read (|
                                                                                      end_
                                                                                    |)),
                                                                                  M.rust_cast
                                                                                    (M.read (|
                                                                                      M.SubPointer.get_struct_record_field (|
                                                                                        space,
                                                                                        "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace",
                                                                                        "start"
                                                                                      |)
                                                                                    |))
                                                                                |),
                                                                                M.rust_cast
                                                                                  (M.read (|
                                                                                    region_length
                                                                                  |))
                                                                              |)))
                                                                        ]
                                                                      |)
                                                                    | _ => M.impossible (||)
                                                                    end))
                                                            ]
                                                          |)
                                                        |) in
                                                      let _ :=
                                                        M.match_operator (|
                                                          M.alloc (| Value.Tuple [] |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ :=
                                                                  M.alloc (|
                                                                    M.call_closure (|
                                                                      M.get_associated_function (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::option::Option")
                                                                          [ Ty.path "usize" ],
                                                                        "zip",
                                                                        [ Ty.path "isize" ]
                                                                      |),
                                                                      [
                                                                        M.read (| slack |);
                                                                        M.read (| s_slack |)
                                                                      ]
                                                                    |)
                                                                  |) in
                                                                let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::option::Option::Some",
                                                                    0
                                                                  |) in
                                                                let γ1_0 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ0_0,
                                                                    0
                                                                  |) in
                                                                let γ1_1 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ0_0,
                                                                    1
                                                                  |) in
                                                                let slack := M.copy (| γ1_0 |) in
                                                                let s_slack := M.copy (| γ1_1 |) in
                                                                let _ :=
                                                                  M.match_operator (|
                                                                    M.alloc (| Value.Tuple [] |),
                                                                    [
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (let γ :=
                                                                            M.use
                                                                              (M.alloc (|
                                                                                UnOp.Pure.not
                                                                                  (BinOp.Pure.le
                                                                                    (M.read (|
                                                                                      s_slack
                                                                                    |))
                                                                                    (M.rust_cast
                                                                                      (M.read (|
                                                                                        slack
                                                                                      |))))
                                                                              |)) in
                                                                          let _ :=
                                                                            M.is_constant_or_break_match (|
                                                                              M.read (| γ |),
                                                                              Value.Bool true
                                                                            |) in
                                                                          M.alloc (|
                                                                            M.never_to_any (|
                                                                              M.call_closure (|
                                                                                M.get_function (|
                                                                                  "core::panicking::panic",
                                                                                  []
                                                                                |),
                                                                                [
                                                                                  M.read (|
                                                                                    Value.String
                                                                                      "assertion failed: s_slack <= slack as isize"
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            |)
                                                                          |)));
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (M.alloc (|
                                                                            Value.Tuple []
                                                                          |)))
                                                                    ]
                                                                  |) in
                                                                M.alloc (| Value.Tuple [] |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.alloc (| Value.Tuple [] |)))
                                                          ]
                                                        |) in
                                                      M.match_operator (|
                                                        M.alloc (| Value.Tuple [] |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ :=
                                                                M.use
                                                                  (M.alloc (|
                                                                    BinOp.Pure.ge
                                                                      (M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::option::Option")
                                                                            [ Ty.path "isize" ],
                                                                          "unwrap_or",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.read (| s_slack |);
                                                                          Value.Integer 0
                                                                        ]
                                                                      |))
                                                                      (Value.Integer 0)
                                                                  |)) in
                                                              let _ :=
                                                                M.is_constant_or_break_match (|
                                                                  M.read (| γ |),
                                                                  Value.Bool true
                                                                |) in
                                                              let row :=
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_function (|
                                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::first_fit_region",
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.read (|
                                                                        column_allocations
                                                                      |);
                                                                      M.read (|
                                                                        remaining_columns
                                                                      |);
                                                                      M.read (| region_length |);
                                                                      M.read (|
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          space,
                                                                          "halo2_proofs::circuit::floor_planner::v1::strategy::EmptySpace",
                                                                          "start"
                                                                        |)
                                                                      |);
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::option::Option")
                                                                            [ Ty.path "isize" ],
                                                                          "map",
                                                                          [
                                                                            Ty.path "usize";
                                                                            Ty.function
                                                                              [
                                                                                Ty.tuple
                                                                                  [ Ty.path "isize"
                                                                                  ]
                                                                              ]
                                                                              (Ty.path "usize")
                                                                          ]
                                                                        |),
                                                                        [
                                                                          M.read (| s_slack |);
                                                                          M.closure
                                                                            (fun γ =>
                                                                              ltac:(M.monadic
                                                                                match γ with
                                                                                | [ α0 ] =>
                                                                                  M.match_operator (|
                                                                                    M.alloc (|
                                                                                      α0
                                                                                    |),
                                                                                    [
                                                                                      fun γ =>
                                                                                        ltac:(M.monadic
                                                                                          (let s :=
                                                                                            M.copy (|
                                                                                              γ
                                                                                            |) in
                                                                                          M.rust_cast
                                                                                            (M.read (|
                                                                                              s
                                                                                            |))))
                                                                                    ]
                                                                                  |)
                                                                                | _ =>
                                                                                  M.impossible (||)
                                                                                end))
                                                                        ]
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |) in
                                                              M.match_operator (|
                                                                M.alloc (| Value.Tuple [] |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ := row in
                                                                      let γ0_0 :=
                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                          γ,
                                                                          "core::option::Option::Some",
                                                                          0
                                                                        |) in
                                                                      let row :=
                                                                        M.copy (| γ0_0 |) in
                                                                      M.alloc (|
                                                                        M.never_to_any (|
                                                                          M.read (|
                                                                            let _ :=
                                                                              M.match_operator (|
                                                                                M.alloc (|
                                                                                  Value.Tuple []
                                                                                |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ :=
                                                                                        end_ in
                                                                                      let γ0_0 :=
                                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                                          γ,
                                                                                          "core::option::Option::Some",
                                                                                          0
                                                                                        |) in
                                                                                      let end_ :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      let _ :=
                                                                                        M.match_operator (|
                                                                                          M.alloc (|
                                                                                            Value.Tuple
                                                                                              []
                                                                                          |),
                                                                                          [
                                                                                            fun γ =>
                                                                                              ltac:(M.monadic
                                                                                                (let
                                                                                                      γ :=
                                                                                                  M.use
                                                                                                    (M.alloc (|
                                                                                                      UnOp.Pure.not
                                                                                                        (BinOp.Pure.le
                                                                                                          (BinOp.Panic.add (|
                                                                                                            Integer.Usize,
                                                                                                            M.read (|
                                                                                                              row
                                                                                                            |),
                                                                                                            M.read (|
                                                                                                              region_length
                                                                                                            |)
                                                                                                          |))
                                                                                                          (M.read (|
                                                                                                            end_
                                                                                                          |)))
                                                                                                    |)) in
                                                                                                let
                                                                                                      _ :=
                                                                                                  M.is_constant_or_break_match (|
                                                                                                    M.read (|
                                                                                                      γ
                                                                                                    |),
                                                                                                    Value.Bool
                                                                                                      true
                                                                                                  |) in
                                                                                                M.alloc (|
                                                                                                  M.never_to_any (|
                                                                                                    M.call_closure (|
                                                                                                      M.get_function (|
                                                                                                        "core::panicking::panic",
                                                                                                        []
                                                                                                      |),
                                                                                                      [
                                                                                                        M.read (|
                                                                                                          Value.String
                                                                                                            "assertion failed: row + region_length <= end"
                                                                                                        |)
                                                                                                      ]
                                                                                                    |)
                                                                                                  |)
                                                                                                |)));
                                                                                            fun γ =>
                                                                                              ltac:(M.monadic
                                                                                                (M.alloc (|
                                                                                                  Value.Tuple
                                                                                                    []
                                                                                                |)))
                                                                                          ]
                                                                                        |) in
                                                                                      M.alloc (|
                                                                                        Value.Tuple
                                                                                          []
                                                                                      |)));
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (M.alloc (|
                                                                                        Value.Tuple
                                                                                          []
                                                                                      |)))
                                                                                ]
                                                                              |) in
                                                                            let _ :=
                                                                              M.alloc (|
                                                                                M.call_closure (|
                                                                                  M.get_associated_function (|
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "alloc::collections::btree::set::BTreeSet")
                                                                                      [
                                                                                        Ty.path
                                                                                          "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion";
                                                                                        Ty.path
                                                                                          "alloc::alloc::Global"
                                                                                      ],
                                                                                    "insert",
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                                      M.call_closure (|
                                                                                        M.get_associated_function (|
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "core::option::Option")
                                                                                            [
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "&mut")
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations"
                                                                                                ]
                                                                                            ],
                                                                                          "unwrap",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            M.get_associated_function (|
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "std::collections::hash::map::HashMap")
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::circuit::layouter::RegionColumn";
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations";
                                                                                                  Ty.path
                                                                                                    "std::hash::random::RandomState"
                                                                                                ],
                                                                                              "get_mut",
                                                                                              [
                                                                                                Ty.path
                                                                                                  "halo2_proofs::circuit::layouter::RegionColumn"
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.read (|
                                                                                                column_allocations
                                                                                              |);
                                                                                              M.read (|
                                                                                                c
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                      |),
                                                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations",
                                                                                      0
                                                                                    |);
                                                                                    Value.StructRecord
                                                                                      "halo2_proofs::circuit::floor_planner::v1::strategy::AllocatedRegion"
                                                                                      [
                                                                                        ("start",
                                                                                          M.read (|
                                                                                            row
                                                                                          |));
                                                                                        ("length",
                                                                                          M.read (|
                                                                                            region_length
                                                                                          |))
                                                                                      ]
                                                                                  ]
                                                                                |)
                                                                              |) in
                                                                            M.return_ (|
                                                                              Value.StructTuple
                                                                                "core::option::Option::Some"
                                                                                [ M.read (| row |) ]
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (M.alloc (|
                                                                        Value.Tuple []
                                                                      |)))
                                                                ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.alloc (| Value.Tuple [] |)))
                                                        ]
                                                      |)))
                                                ]
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                        |)))
                                  ]
                                |)) in
                            M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        (*
        fn slot_in(
            region_shapes: Vec<RegionShape>,
        ) -> (Vec<(RegionStart, RegionShape)>, CircuitAllocations) {
            // Tracks the empty regions for each column.
            let mut column_allocations: CircuitAllocations = Default::default();
        
            let regions = region_shapes
                .into_iter()
                .map(|region| {
                    // Sort the region's columns to ensure determinism.
                    // - An unstable sort is fine, because region.columns() returns a set.
                    // - The sort order relies on Column's Ord implementation!
                    let mut region_columns: Vec<_> = region.columns().iter().cloned().collect();
                    region_columns.sort_unstable();
        
                    let region_start = first_fit_region(
                        &mut column_allocations,
                        &region_columns,
                        region.row_count(),
                        0,
                        None,
                    )
                    .expect("We can always fit a region somewhere");
        
                    (region_start.into(), region)
                })
                .collect();
        
            // Return the column allocations for potential further processing.
            (regions, column_allocations)
        }
        *)
        Definition slot_in (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ region_shapes ] =>
            ltac:(M.monadic
              (let region_shapes := M.alloc (| region_shapes |) in
              M.read (|
                let column_allocations :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.apply
                          (Ty.path "std::collections::hash::map::HashMap")
                          [
                            Ty.path "halo2_proofs::circuit::layouter::RegionColumn";
                            Ty.path
                              "halo2_proofs::circuit::floor_planner::v1::strategy::Allocations";
                            Ty.path "std::hash::random::RandomState"
                          ],
                        [],
                        "default",
                        []
                      |),
                      []
                    |)
                  |) in
                let regions :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::map::Map")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::into_iter::IntoIter")
                              [
                                Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                                Ty.path "alloc::alloc::Global"
                              ];
                            Ty.function
                              [ Ty.tuple [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ]
                              ]
                              (Ty.tuple
                                [
                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                  Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                ])
                          ],
                        [],
                        "collect",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.tuple
                                [
                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                  Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "alloc::vec::into_iter::IntoIter")
                              [
                                Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            "map",
                            [
                              Ty.tuple
                                [
                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                  Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                ];
                              Ty.function
                                [
                                  Ty.tuple
                                    [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ]
                                ]
                                (Ty.tuple
                                  [
                                    Ty.path "halo2_proofs::circuit::RegionStart";
                                    Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                  ])
                            ]
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [ M.read (| region_shapes |) ]
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let region := M.copy (| γ |) in
                                            M.read (|
                                              let region_columns :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::cloned::Cloned")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "std::collections::hash::set::Iter")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::circuit::layouter::RegionColumn"
                                                            ]
                                                        ],
                                                      [],
                                                      "collect",
                                                      [
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::circuit::layouter::RegionColumn";
                                                            Ty.path "alloc::alloc::Global"
                                                          ]
                                                      ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::iter::traits::iterator::Iterator",
                                                          Ty.apply
                                                            (Ty.path
                                                              "std::collections::hash::set::Iter")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::circuit::layouter::RegionColumn"
                                                            ],
                                                          [],
                                                          "cloned",
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::circuit::layouter::RegionColumn"
                                                          ]
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "std::collections::hash::set::HashSet")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::circuit::layouter::RegionColumn";
                                                                  Ty.path
                                                                    "std::hash::random::RandomState"
                                                                ],
                                                              "iter",
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path
                                                                    "halo2_proofs::circuit::layouter::RegionShape",
                                                                  "columns",
                                                                  []
                                                                |),
                                                                [ region ]
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::circuit::layouter::RegionColumn"
                                                        ],
                                                      "sort_unstable",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::deref::DerefMut",
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::circuit::layouter::RegionColumn";
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          [],
                                                          "deref_mut",
                                                          []
                                                        |),
                                                        [ region_columns ]
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              let region_start :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [ Ty.path "usize" ],
                                                      "expect",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_function (|
                                                          "halo2_proofs::circuit::floor_planner::v1::strategy::first_fit_region",
                                                          []
                                                        |),
                                                        [
                                                          column_allocations;
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::deref::Deref",
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::circuit::layouter::RegionColumn";
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              [],
                                                              "deref",
                                                              []
                                                            |),
                                                            [ region_columns ]
                                                          |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path
                                                                "halo2_proofs::circuit::layouter::RegionShape",
                                                              "row_count",
                                                              []
                                                            |),
                                                            [ region ]
                                                          |);
                                                          Value.Integer 0;
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                        ]
                                                      |);
                                                      M.read (|
                                                        Value.String
                                                          "We can always fit a region somewhere"
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (|
                                                Value.Tuple
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::convert::Into",
                                                        Ty.path "usize",
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::circuit::RegionStart"
                                                        ],
                                                        "into",
                                                        []
                                                      |),
                                                      [ M.read (| region_start |) ]
                                                    |);
                                                    M.read (| region |)
                                                  ]
                                              |)
                                            |)))
                                      ]
                                    |)
                                  | _ => M.impossible (||)
                                  end))
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [ M.read (| regions |); M.read (| column_allocations |) ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        (*
        pub fn slot_in_biggest_advice_first(
            region_shapes: Vec<RegionShape>,
        ) -> (Vec<RegionStart>, CircuitAllocations) {
            let mut sorted_regions: Vec<_> = region_shapes.into_iter().collect();
            sorted_regions.sort_unstable_by_key(|shape| {
                // Count the number of advice columns
                let advice_cols = shape
                    .columns()
                    .iter()
                    .filter(|c| match c {
                        RegionColumn::Column(c) => matches!(c.column_type(), Any::Advice),
                        _ => false,
                    })
                    .count();
                // Sort by advice area (since this has the most contention).
                advice_cols * shape.row_count()
            });
            sorted_regions.reverse();
        
            // Lay out the sorted regions.
            let (mut regions, column_allocations) = slot_in(sorted_regions);
        
            // Un-sort the regions so they match the original indexing.
            regions.sort_unstable_by_key(|(_, region)| region.region_index().0);
            let regions = regions.into_iter().map(|(start, _)| start).collect();
        
            (regions, column_allocations)
        }
        *)
        Definition slot_in_biggest_advice_first (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ region_shapes ] =>
            ltac:(M.monadic
              (let region_shapes := M.alloc (| region_shapes |) in
              M.read (|
                let sorted_regions :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "alloc::vec::into_iter::IntoIter")
                          [
                            Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        "collect",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            "into_iter",
                            []
                          |),
                          [ M.read (| region_shapes |) ]
                        |)
                      ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "slice")
                          [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ],
                        "sort_unstable_by_key",
                        [
                          Ty.path "usize";
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ]
                                ]
                            ]
                            (Ty.path "usize")
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::DerefMut",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            "deref_mut",
                            []
                          |),
                          [ sorted_regions ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let shape := M.copy (| γ |) in
                                        M.read (|
                                          let advice_cols :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::iter::adapters::filter::Filter")
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "std::collections::hash::set::Iter")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::circuit::layouter::RegionColumn"
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::circuit::layouter::RegionColumn"
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.path "bool")
                                                    ],
                                                  [],
                                                  "count",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "std::collections::hash::set::Iter")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::circuit::layouter::RegionColumn"
                                                        ],
                                                      [],
                                                      "filter",
                                                      [
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::circuit::layouter::RegionColumn"
                                                                      ]
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.path "bool")
                                                      ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "std::collections::hash::set::HashSet")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::circuit::layouter::RegionColumn";
                                                              Ty.path
                                                                "std::hash::random::RandomState"
                                                            ],
                                                          "iter",
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path
                                                                "halo2_proofs::circuit::layouter::RegionShape",
                                                              "columns",
                                                              []
                                                            |),
                                                            [ M.read (| shape |) ]
                                                          |)
                                                        ]
                                                      |);
                                                      M.closure
                                                        (fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [ α0 ] =>
                                                              M.match_operator (|
                                                                M.alloc (| α0 |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let c := M.copy (| γ |) in
                                                                      M.read (|
                                                                        M.match_operator (|
                                                                          c,
                                                                          [
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ :=
                                                                                  M.read (| γ |) in
                                                                                let γ :=
                                                                                  M.read (| γ |) in
                                                                                let γ2_0 :=
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    γ,
                                                                                    "halo2_proofs::circuit::layouter::RegionColumn::Column",
                                                                                    0
                                                                                  |) in
                                                                                let c :=
                                                                                  M.alloc (|
                                                                                    γ2_0
                                                                                  |) in
                                                                                M.match_operator (|
                                                                                  M.alloc (|
                                                                                    M.call_closure (|
                                                                                      M.get_associated_function (|
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                                          [
                                                                                            Ty.path
                                                                                              "halo2_proofs::plonk::circuit::Any"
                                                                                          ],
                                                                                        "column_type",
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.read (|
                                                                                          c
                                                                                        |)
                                                                                      ]
                                                                                    |)
                                                                                  |),
                                                                                  [
                                                                                    fun γ =>
                                                                                      ltac:(M.monadic
                                                                                        (let γ :=
                                                                                          M.read (|
                                                                                            γ
                                                                                          |) in
                                                                                        M.alloc (|
                                                                                          Value.Bool
                                                                                            true
                                                                                        |)));
                                                                                    fun γ =>
                                                                                      ltac:(M.monadic
                                                                                        (M.alloc (|
                                                                                          Value.Bool
                                                                                            false
                                                                                        |)))
                                                                                  ]
                                                                                |)));
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (M.alloc (|
                                                                                  Value.Bool false
                                                                                |)))
                                                                          ]
                                                                        |)
                                                                      |)))
                                                                ]
                                                              |)
                                                            | _ => M.impossible (||)
                                                            end))
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          M.alloc (|
                                            BinOp.Panic.mul (|
                                              Integer.Usize,
                                              M.read (| advice_cols |),
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path
                                                    "halo2_proofs::circuit::layouter::RegionShape",
                                                  "row_count",
                                                  []
                                                |),
                                                [ M.read (| shape |) ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "slice")
                          [ Ty.path "halo2_proofs::circuit::layouter::RegionShape" ],
                        "reverse",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::DerefMut",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.path "halo2_proofs::circuit::layouter::RegionShape";
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            "deref_mut",
                            []
                          |),
                          [ sorted_regions ]
                        |)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (|
                        "halo2_proofs::circuit::floor_planner::v1::strategy::slot_in",
                        []
                      |),
                      [ M.read (| sorted_regions |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let regions := M.copy (| γ0_0 |) in
                        let column_allocations := M.copy (| γ0_1 |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "halo2_proofs::circuit::RegionStart";
                                        Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                      ]
                                  ],
                                "sort_unstable_by_key",
                                [
                                  Ty.path "usize";
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                                  Ty.path
                                                    "halo2_proofs::circuit::layouter::RegionShape"
                                                ]
                                            ]
                                        ]
                                    ]
                                    (Ty.path "usize")
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::DerefMut",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "halo2_proofs::circuit::RegionStart";
                                            Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref_mut",
                                    []
                                  |),
                                  [ regions ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ := M.read (| γ |) in
                                                let γ1_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ1_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let region := M.alloc (| γ1_1 |) in
                                                M.read (|
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path
                                                            "halo2_proofs::circuit::layouter::RegionShape",
                                                          "region_index",
                                                          []
                                                        |),
                                                        [ M.read (| region |) ]
                                                      |)
                                                    |),
                                                    "halo2_proofs::circuit::RegionIndex",
                                                    0
                                                  |)
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end))
                              ]
                            |)
                          |) in
                        let regions :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::map::Map")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "halo2_proofs::circuit::RegionStart";
                                            Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "halo2_proofs::circuit::RegionStart";
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                              ]
                                          ]
                                      ]
                                      (Ty.path "halo2_proofs::circuit::RegionStart")
                                  ],
                                [],
                                "collect",
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.path "halo2_proofs::circuit::RegionStart";
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "halo2_proofs::circuit::RegionStart";
                                            Ty.path "halo2_proofs::circuit::layouter::RegionShape"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "map",
                                    [
                                      Ty.path "halo2_proofs::circuit::RegionStart";
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "halo2_proofs::circuit::RegionStart";
                                                  Ty.path
                                                    "halo2_proofs::circuit::layouter::RegionShape"
                                                ]
                                            ]
                                        ]
                                        (Ty.path "halo2_proofs::circuit::RegionStart")
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::collect::IntoIterator",
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "halo2_proofs::circuit::RegionStart";
                                                Ty.path
                                                  "halo2_proofs::circuit::layouter::RegionShape"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        "into_iter",
                                        []
                                      |),
                                      [ M.read (| regions |) ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let start := M.copy (| γ0_0 |) in
                                                    M.read (| start |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  ]
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (|
                          Value.Tuple [ M.read (| regions |); M.read (| column_allocations |) ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
      End strategy.
    End v1.
  End floor_planner.
End circuit.
