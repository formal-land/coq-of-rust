(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module dev.
  Module cost.
    (* StructRecord
      {
        name := "CircuitCost";
        ty_params := [ "G"; "ConcreteCircuit" ];
        fields :=
          [
            ("k", Ty.path "usize");
            ("max_deg", Ty.path "usize");
            ("advice_columns", Ty.path "usize");
            ("instance_queries", Ty.path "usize");
            ("advice_queries", Ty.path "usize");
            ("fixed_queries", Ty.path "usize");
            ("lookups", Ty.path "usize");
            ("permutation_cols", Ty.path "usize");
            ("point_sets", Ty.path "usize");
            ("_marker",
              Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.tuple [ G; ConcreteCircuit ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_G_where_group_prime_PrimeGroup_G_where_core_fmt_Debug_ConcreteCircuit_where_halo2_proofs_plonk_circuit_Circuit_ConcreteCircuit_associated_type_for_halo2_proofs_dev_cost_CircuitCost_G_ConcreteCircuit.
      Definition Self (G ConcreteCircuit : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::dev::cost::CircuitCost") [ G; ConcreteCircuit ].
      
      (* Debug *)
      Definition fmt (G ConcreteCircuit : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self G ConcreteCircuit in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let names :=
                M.alloc (|
                  M.alloc (|
                    Value.Array
                      [
                        M.read (| Value.String "k" |);
                        M.read (| Value.String "max_deg" |);
                        M.read (| Value.String "advice_columns" |);
                        M.read (| Value.String "instance_queries" |);
                        M.read (| Value.String "advice_queries" |);
                        M.read (| Value.String "fixed_queries" |);
                        M.read (| Value.String "lookups" |);
                        M.read (| Value.String "permutation_cols" |);
                        M.read (| Value.String "point_sets" |);
                        M.read (| Value.String "_marker" |)
                      ]
                  |)
                |) in
              let values :=
                M.alloc (|
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "k"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "max_deg"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "advice_columns"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "instance_queries"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "advice_queries"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "fixed_queries"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "lookups"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "permutation_cols"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "point_sets"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.alloc (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::dev::cost::CircuitCost",
                                "_marker"
                              |)
                            |))
                        ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "debug_struct_fields_finish",
                    []
                  |),
                  [
                    M.read (| f |);
                    M.read (| Value.String "CircuitCost" |);
                    (* Unsize *) M.pointer_coercion (M.read (| names |));
                    M.read (| values |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (G ConcreteCircuit : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self G ConcreteCircuit)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt G ConcreteCircuit)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_G_where_group_prime_PrimeGroup_G_where_core_fmt_Debug_ConcreteCircuit_where_halo2_proofs_plonk_circuit_Circuit_ConcreteCircuit_associated_type_for_halo2_proofs_dev_cost_CircuitCost_G_ConcreteCircuit.
    
    (* StructRecord
      {
        name := "Assembly";
        ty_params := [];
        fields :=
          [
            ("selectors",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    (* StructRecord
      {
        name := "AssemblyAssigner";
        ty_params := [];
        fields :=
          [
            ("selectors",
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [
                  Ty.apply
                    (Ty.path "std::sync::mutex::Mutex")
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_halo2_proofs_dev_cost_AssemblyAssigner.
      Definition Self : Ty.t := Ty.path "halo2_proofs::dev::cost::AssemblyAssigner".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::dev::cost::AssemblyAssigner"
              [
                ("selectors",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        [
                          Ty.apply
                            (Ty.path "std::sync::mutex::Mutex")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::dev::cost::AssemblyAssigner",
                        "selectors"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_halo2_proofs_dev_cost_AssemblyAssigner.
    
    Module Impl_core_convert_Into_halo2_proofs_dev_cost_Assembly_for_halo2_proofs_dev_cost_AssemblyAssigner.
      Definition Self : Ty.t := Ty.path "halo2_proofs::dev::cost::AssemblyAssigner".
      
      (*
          fn into(self) -> Assembly {
              Assembly {
                  selectors: Arc::try_unwrap(self.selectors)
                      .unwrap()
                      .into_inner()
                      .unwrap(),
              }
          }
      *)
      Definition into (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::dev::cost::Assembly"
              [
                ("selectors",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                              Ty.path "alloc::alloc::Global"
                            ];
                          Ty.apply
                            (Ty.path "std::sync::poison::PoisonError")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                        ],
                      "unwrap",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "std::sync::mutex::Mutex")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ],
                          "into_inner",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::Mutex")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ];
                                  Ty.apply
                                    (Ty.path "alloc::sync::Arc")
                                    [
                                      Ty.apply
                                        (Ty.path "std::sync::mutex::Mutex")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ],
                              "unwrap",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::sync::Arc")
                                    [
                                      Ty.apply
                                        (Ty.path "std::sync::mutex::Mutex")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "try_unwrap",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "halo2_proofs::dev::cost::AssemblyAssigner",
                                      "selectors"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::Into"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "halo2_proofs::dev::cost::Assembly" ]
          (* Instance *) [ ("into", InstanceField.Method into) ].
    End Impl_core_convert_Into_halo2_proofs_dev_cost_Assembly_for_halo2_proofs_dev_cost_AssemblyAssigner.
    
    Module Impl_halo2_proofs_plonk_circuit_Assignment_where_ff_Field_F_F_for_halo2_proofs_dev_cost_AssemblyAssigner.
      Definition Self (F : Ty.t) : Ty.t := Ty.path "halo2_proofs::dev::cost::AssemblyAssigner".
      
      (*
          fn is_in_prove_mode(&self) -> bool {
              false
          }
      *)
      Definition is_in_prove_mode (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Bool false))
        | _, _ => M.impossible
        end.
      
      (*
          fn enter_region<NR, N>(&self, _: N)
          where
              NR: Into<String>,
              N: FnOnce() -> NR,
          {
              // Do nothing; we don't care about regions in this context.
          }
      *)
      Definition enter_region (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [ NR; N ], [ self; β1 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (| β1, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn exit_region(&self) {
              // Do nothing; we don't care about regions in this context.
          }
      *)
      Definition exit_region (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      (*
          fn enable_selector<A, AR>(&self, _: A, selector: &Selector, row: usize) -> Result<(), Error>
          where
              A: FnOnce() -> AR,
              AR: Into<String>,
          {
              let mut selectors = self.selectors.lock().unwrap();
      
              selectors[selector.0][row] = true;
      
              Ok(())
          }
      *)
      Definition enable_selector (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [ A; AR ], [ self; β1; selector; row ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            let selector := M.alloc (| selector |) in
            let row := M.alloc (| row |) in
            M.match_operator (|
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.read (|
                      let selectors :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::MutexGuard")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ];
                                  Ty.apply
                                    (Ty.path "std::sync::poison::PoisonError")
                                    [
                                      Ty.apply
                                        (Ty.path "std::sync::mutex::MutexGuard")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ]
                                    ]
                                ],
                              "unwrap",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::Mutex")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                  "lock",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "alloc::sync::Arc")
                                        [
                                          Ty.apply
                                            (Ty.path "std::sync::mutex::Mutex")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    [ Ty.path "bool"; Ty.path "alloc::alloc::Global"
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "halo2_proofs::dev::cost::AssemblyAssigner",
                                        "selectors"
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.write (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::IndexMut",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ],
                              [ Ty.path "usize" ],
                              "index_mut",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::index::IndexMut",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [ Ty.path "usize" ],
                                  "index_mut",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::DerefMut",
                                      Ty.apply
                                        (Ty.path "std::sync::mutex::MutexGuard")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ],
                                      [],
                                      "deref_mut",
                                      []
                                    |),
                                    [ selectors ]
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_tuple_field (|
                                      M.read (| selector |),
                                      "halo2_proofs::plonk::circuit::Selector",
                                      0
                                    |)
                                  |)
                                ]
                              |);
                              M.read (| row |)
                            ]
                          |),
                          Value.Bool true
                        |) in
                      M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn query_instance(&self, _: Column<Instance>, _: usize) -> Result<Option<F>, Error> {
              Ok(None)
          }
      *)
      Definition query_instance (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; β1; β2 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            let β2 := M.alloc (| β2 |) in
            M.match_operator (|
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      β2,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (Value.StructTuple
                              "core::result::Result::Ok"
                              [ Value.StructTuple "core::option::Option::None" [] ]))
                      ]
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn assign_advice<V, VR, A, AR>(
              &self,
              _: A,
              _: Column<Advice>,
              _: usize,
              _: V,
          ) -> Result<(), Error>
          where
              V: FnOnce() -> Result<VR, Error>,
              VR: Into<Assigned<F>>,
              A: FnOnce() -> AR,
              AR: Into<String>,
          {
              Ok(())
          }
      *)
      Definition assign_advice (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [ V; VR; A; AR ], [ self; β1; β2; β3; β4 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            let β2 := M.alloc (| β2 |) in
            let β3 := M.alloc (| β3 |) in
            let β4 := M.alloc (| β4 |) in
            M.match_operator (|
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      β2,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              β3,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      β4,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (Value.StructTuple
                                              "core::result::Result::Ok"
                                              [ Value.Tuple [] ]))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn assign_fixed<V, VR, A, AR>(
              &self,
              _: A,
              _: Column<Fixed>,
              _: usize,
              _: V,
          ) -> Result<(), Error>
          where
              V: FnOnce() -> Result<VR, Error>,
              VR: Into<Assigned<F>>,
              A: FnOnce() -> AR,
              AR: Into<String>,
          {
              Ok(())
          }
      *)
      Definition assign_fixed (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [ V; VR; A; AR ], [ self; β1; β2; β3; β4 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            let β2 := M.alloc (| β2 |) in
            let β3 := M.alloc (| β3 |) in
            let β4 := M.alloc (| β4 |) in
            M.match_operator (|
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      β2,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              β3,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      β4,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (Value.StructTuple
                                              "core::result::Result::Ok"
                                              [ Value.Tuple [] ]))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn copy(&self, _: Column<Any>, _: usize, _: Column<Any>, _: usize) -> Result<(), Error> {
              Ok(())
          }
      *)
      Definition copy (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; β1; β2; β3; β4 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            let β2 := M.alloc (| β2 |) in
            let β3 := M.alloc (| β3 |) in
            let β4 := M.alloc (| β4 |) in
            M.match_operator (|
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      β2,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              β3,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      β4,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (Value.StructTuple
                                              "core::result::Result::Ok"
                                              [ Value.Tuple [] ]))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn fill_from_row(
              &self,
              _: Column<Fixed>,
              _: usize,
              _: Option<Assigned<F>>,
          ) -> Result<(), Error> {
              Ok(())
          }
      *)
      Definition fill_from_row (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; β1; β2; β3 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            let β2 := M.alloc (| β2 |) in
            let β3 := M.alloc (| β3 |) in
            M.match_operator (|
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      β2,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              β3,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (Value.StructTuple
                                      "core::result::Result::Ok"
                                      [ Value.Tuple [] ]))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn push_namespace<NR, N>(&self, _: N)
          where
              NR: Into<String>,
              N: FnOnce() -> NR,
          {
              // Do nothing; we don't care about namespaces in this context.
          }
      *)
      Definition push_namespace (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [ NR; N ], [ self; β1 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (| β1, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn pop_namespace(&self, _: Option<String>) {
              // Do nothing; we don't care about namespaces in this context.
          }
      *)
      Definition pop_namespace (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; β1 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (| β1, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "halo2_proofs::plonk::circuit::Assignment"
          (Self F)
          (* Trait polymorphic types *) [ (* F *) F ]
          (* Instance *)
          [
            ("is_in_prove_mode", InstanceField.Method (is_in_prove_mode F));
            ("enter_region", InstanceField.Method (enter_region F));
            ("exit_region", InstanceField.Method (exit_region F));
            ("enable_selector", InstanceField.Method (enable_selector F));
            ("query_instance", InstanceField.Method (query_instance F));
            ("assign_advice", InstanceField.Method (assign_advice F));
            ("assign_fixed", InstanceField.Method (assign_fixed F));
            ("copy", InstanceField.Method (copy F));
            ("fill_from_row", InstanceField.Method (fill_from_row F));
            ("push_namespace", InstanceField.Method (push_namespace F));
            ("pop_namespace", InstanceField.Method (pop_namespace F))
          ].
    End Impl_halo2_proofs_plonk_circuit_Assignment_where_ff_Field_F_F_for_halo2_proofs_dev_cost_AssemblyAssigner.
    
    Module Impl_halo2_proofs_dev_cost_CircuitCost_G_ConcreteCircuit.
      Definition Self (G ConcreteCircuit : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::dev::cost::CircuitCost") [ G; ConcreteCircuit ].
      
      (*
          pub fn measure(k: usize, circuit: &ConcreteCircuit) -> Self {
              // Collect the layout details.
              let mut cs = ConstraintSystem::default();
              let config = ConcreteCircuit::configure(&mut cs);
              let mut assembly = AssemblyAssigner {
                  selectors: Arc::new(Mutex::new(vec![vec![false; 1 << k]; cs.num_selectors])),
              };
              ConcreteCircuit::FloorPlanner::synthesize(
                  &mut assembly,
                  circuit,
                  config,
                  cs.constants.clone(),
              )
              .unwrap();
      
              let assembly: Assembly = assembly.into();
      
              let (cs, _) = cs.compress_selectors(assembly.selectors);
      
              assert!((1 << k) >= cs.minimum_rows());
      
              // Figure out how many point sets we have due to queried cells.
              let mut column_queries: HashMap<Column<Any>, HashSet<i32>> = HashMap::new();
              for (c, r) in iter::empty()
                  .chain(
                      cs.advice_queries
                          .iter()
                          .map(|(c, r)| (Column::<Any>::from( *c), *r)),
                  )
                  .chain(cs.instance_queries.iter().map(|(c, r)| (( *c).into(), *r)))
                  .chain(cs.fixed_queries.iter().map(|(c, r)| (( *c).into(), *r)))
                  .chain(
                      cs.permutation
                          .get_columns()
                          .into_iter()
                          .map(|c| (c, Rotation::cur())),
                  )
              {
                  column_queries.entry(c).or_default().insert(r.0);
              }
              let mut point_sets: HashSet<Vec<i32>> = HashSet::new();
              for (_, r) in column_queries {
                  // Sort the query sets so we merge duplicates.
                  let mut query_set: Vec<_> = r.into_iter().collect();
                  query_set.sort_unstable();
                  point_sets.insert(query_set);
              }
      
              // Include lookup polynomials in point sets:
              point_sets.insert(vec![0, 1]); // product_poly
              point_sets.insert(vec![-1, 0]); // permuted_input_poly
              point_sets.insert(vec![0]); // permuted_table_poly
      
              // Include permutation polynomials in point sets.
              point_sets.insert(vec![0, 1]); // permutation_product_poly
              let max_deg = cs.degree();
              let permutation_cols = cs.permutation.get_columns().len();
              if permutation_cols > max_deg - 2 {
                  // permutation_product_poly for chaining chunks.
                  point_sets.insert(vec![-((cs.blinding_factors() + 1) as i32), 0, 1]);
              }
      
              CircuitCost {
                  k,
                  max_deg,
                  advice_columns: cs.num_advice_columns,
                  instance_queries: cs.instance_queries.len(),
                  advice_queries: cs.advice_queries.len(),
                  fixed_queries: cs.fixed_queries.len(),
                  lookups: cs.lookups.len(),
                  permutation_cols,
                  point_sets: point_sets.len(),
                  _marker: PhantomData::default(),
              }
          }
      *)
      Definition measure (G ConcreteCircuit : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self G ConcreteCircuit in
        match τ, α with
        | [], [ k; circuit ] =>
          ltac:(M.monadic
            (let k := M.alloc (| k |) in
            let circuit := M.alloc (| circuit |) in
            M.read (|
              let cs :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                        [ Ty.associated ],
                      [],
                      "default",
                      []
                    |),
                    []
                  |)
                |) in
              let config :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "halo2_proofs::plonk::circuit::Circuit",
                      ConcreteCircuit,
                      [ Ty.associated ],
                      "configure",
                      []
                    |),
                    [ cs ]
                  |)
                |) in
              let assembly :=
                M.alloc (|
                  Value.StructRecord
                    "halo2_proofs::dev::cost::AssemblyAssigner"
                    [
                      ("selectors",
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              [
                                Ty.apply
                                  (Ty.path "std::sync::mutex::Mutex")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "std::sync::mutex::Mutex")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                "new",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_function (|
                                    "alloc::vec::from_elem",
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ]
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_function (|
                                        "alloc::vec::from_elem",
                                        [ Ty.path "bool" ]
                                      |),
                                      [
                                        Value.Bool false;
                                        BinOp.Panic.shl (| Value.Integer 1, M.read (| k |) |)
                                      ]
                                    |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        cs,
                                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                                        "num_selectors"
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |))
                    ]
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [ Ty.tuple []; Ty.path "halo2_proofs::plonk::error::Error" ],
                      "unwrap",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "halo2_proofs::plonk::circuit::FloorPlanner",
                          Ty.associated,
                          [],
                          "synthesize",
                          [
                            Ty.associated;
                            Ty.path "halo2_proofs::dev::cost::AssemblyAssigner";
                            ConcreteCircuit
                          ]
                        |),
                        [
                          assembly;
                          M.read (| circuit |);
                          M.read (| config |);
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "clone",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                cs,
                                "halo2_proofs::plonk::circuit::ConstraintSystem",
                                "constants"
                              |)
                            ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              let assembly :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::Into",
                      Ty.path "halo2_proofs::dev::cost::AssemblyAssigner",
                      [ Ty.path "halo2_proofs::dev::cost::Assembly" ],
                      "into",
                      []
                    |),
                    [ M.read (| assembly |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                        [ Ty.associated ],
                      "compress_selectors",
                      []
                    |),
                    [
                      M.read (| cs |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          assembly,
                          "halo2_proofs::dev::cost::Assembly",
                          "selectors"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let cs := M.copy (| γ0_0 |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (BinOp.Pure.ge
                                          (BinOp.Panic.shl (| Value.Integer 1, M.read (| k |) |))
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "halo2_proofs::plonk::circuit::ConstraintSystem")
                                                [ Ty.associated ],
                                              "minimum_rows",
                                              []
                                            |),
                                            [ cs ]
                                          |)))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [] |),
                                      [
                                        M.read (|
                                          Value.String
                                            "assertion failed: (1 << k) >= cs.minimum_rows()"
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      let column_queries :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "std::collections::hash::map::HashMap")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                  Ty.apply
                                    (Ty.path "std::collections::hash::set::HashSet")
                                    [ Ty.path "i32"; Ty.path "std::hash::random::RandomState" ];
                                  Ty.path "std::hash::random::RandomState"
                                ],
                              "new",
                              []
                            |),
                            []
                          |)
                        |) in
                      let _ :=
                        M.use
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::chain::Chain")
                                        [
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::chain::Chain")
                                            [
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::chain::Chain")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::iter::sources::empty::Empty")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Any"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ];
                                                  Ty.apply
                                                    (Ty.path "core::iter::adapters::map::Map")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Advice"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ]
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Advice"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation"
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Column")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::Any"
                                                              ];
                                                            Ty.path "halo2_proofs::poly::Rotation"
                                                          ])
                                                    ]
                                                ];
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::map::Map")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Instance"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ];
                                                  Ty.function
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::circuit::Instance"
                                                                    ];
                                                                  Ty.path
                                                                    "halo2_proofs::poly::Rotation"
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                    (Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Column")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::plonk::circuit::Any"
                                                          ];
                                                        Ty.path "halo2_proofs::poly::Rotation"
                                                      ])
                                                ]
                                            ];
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::map::Map")
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::circuit::Column")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                        ];
                                                      Ty.path "halo2_proofs::poly::Rotation"
                                                    ]
                                                ];
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                                (Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [ Ty.path "halo2_proofs::plonk::circuit::Any"
                                                      ];
                                                    Ty.path "halo2_proofs::poly::Rotation"
                                                  ])
                                            ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::map::Map")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::into_iter::IntoIter")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                              Ty.path "alloc::alloc::Global"
                                            ];
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                                ]
                                            ]
                                            (Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                  [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                                Ty.path "halo2_proofs::poly::Rotation"
                                              ])
                                        ]
                                    ],
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::chain::Chain")
                                        [
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::chain::Chain")
                                            [
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::chain::Chain")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::iter::sources::empty::Empty")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Any"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ];
                                                  Ty.apply
                                                    (Ty.path "core::iter::adapters::map::Map")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Advice"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ]
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Advice"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation"
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Column")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::Any"
                                                              ];
                                                            Ty.path "halo2_proofs::poly::Rotation"
                                                          ])
                                                    ]
                                                ];
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::map::Map")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Instance"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ];
                                                  Ty.function
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::circuit::Instance"
                                                                    ];
                                                                  Ty.path
                                                                    "halo2_proofs::poly::Rotation"
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                    (Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Column")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::plonk::circuit::Any"
                                                          ];
                                                        Ty.path "halo2_proofs::poly::Rotation"
                                                      ])
                                                ]
                                            ];
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::map::Map")
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::circuit::Column")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                        ];
                                                      Ty.path "halo2_proofs::poly::Rotation"
                                                    ]
                                                ];
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                                (Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [ Ty.path "halo2_proofs::plonk::circuit::Any"
                                                      ];
                                                    Ty.path "halo2_proofs::poly::Rotation"
                                                  ])
                                            ]
                                        ],
                                      [],
                                      "chain",
                                      [
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::map::Map")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::into_iter::IntoIter")
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                  [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                                Ty.path "alloc::alloc::Global"
                                              ];
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [ Ty.path "halo2_proofs::plonk::circuit::Any"
                                                      ]
                                                  ]
                                              ]
                                              (Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                                  Ty.path "halo2_proofs::poly::Rotation"
                                                ])
                                          ]
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::chain::Chain")
                                            [
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::chain::Chain")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::iter::sources::empty::Empty")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Any"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ];
                                                  Ty.apply
                                                    (Ty.path "core::iter::adapters::map::Map")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Advice"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ]
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Advice"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation"
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Column")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::Any"
                                                              ];
                                                            Ty.path "halo2_proofs::poly::Rotation"
                                                          ])
                                                    ]
                                                ];
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::map::Map")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Instance"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ];
                                                  Ty.function
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::circuit::Instance"
                                                                    ];
                                                                  Ty.path
                                                                    "halo2_proofs::poly::Rotation"
                                                                ]
                                                            ]
                                                        ]
                                                    ]
                                                    (Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Column")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::plonk::circuit::Any"
                                                          ];
                                                        Ty.path "halo2_proofs::poly::Rotation"
                                                      ])
                                                ]
                                            ],
                                          [],
                                          "chain",
                                          [
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::map::Map")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Column")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                          ];
                                                        Ty.path "halo2_proofs::poly::Rotation"
                                                      ]
                                                  ];
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ];
                                                                Ty.path
                                                                  "halo2_proofs::poly::Rotation"
                                                              ]
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::circuit::Column")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::plonk::circuit::Any"
                                                        ];
                                                      Ty.path "halo2_proofs::poly::Rotation"
                                                    ])
                                              ]
                                          ]
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::chain::Chain")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::iter::sources::empty::Empty")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Any"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ];
                                                  Ty.apply
                                                    (Ty.path "core::iter::adapters::map::Map")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Advice"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ]
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Advice"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation"
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Column")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::Any"
                                                              ];
                                                            Ty.path "halo2_proofs::poly::Rotation"
                                                          ])
                                                    ]
                                                ],
                                              [],
                                              "chain",
                                              [
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::map::Map")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Column")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::Instance"
                                                              ];
                                                            Ty.path "halo2_proofs::poly::Rotation"
                                                          ]
                                                      ];
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::circuit::Instance"
                                                                      ];
                                                                    Ty.path
                                                                      "halo2_proofs::poly::Rotation"
                                                                  ]
                                                              ]
                                                          ]
                                                      ]
                                                      (Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Any"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ])
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::iter::sources::empty::Empty")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Any"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ],
                                                  [],
                                                  "chain",
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::Iter")
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Advice"
                                                                  ];
                                                                Ty.path
                                                                  "halo2_proofs::poly::Rotation"
                                                              ]
                                                          ];
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Advice"
                                                                          ];
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Any"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ])
                                                      ]
                                                  ]
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_function (|
                                                      "core::iter::sources::empty::empty",
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Column")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::Any"
                                                              ];
                                                            Ty.path "halo2_proofs::poly::Rotation"
                                                          ]
                                                      ]
                                                    |),
                                                    []
                                                  |);
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Advice"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ]
                                                        ],
                                                      [],
                                                      "map",
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Column")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::Any"
                                                              ];
                                                            Ty.path "halo2_proofs::poly::Rotation"
                                                          ];
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Advice"
                                                                          ];
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Any"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ])
                                                      ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "slice")
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::circuit::Advice"
                                                                    ];
                                                                  Ty.path
                                                                    "halo2_proofs::poly::Rotation"
                                                                ]
                                                            ],
                                                          "iter",
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::deref::Deref",
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Advice"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation"
                                                                    ];
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              [],
                                                              "deref",
                                                              []
                                                            |),
                                                            [
                                                              M.SubPointer.get_struct_record_field (|
                                                                cs,
                                                                "halo2_proofs::plonk::circuit::ConstraintSystem",
                                                                "advice_queries"
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |);
                                                      M.closure
                                                        (fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [ α0 ] =>
                                                              M.match_operator (|
                                                                M.alloc (| α0 |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ := M.read (| γ |) in
                                                                      let γ1_0 :=
                                                                        M.SubPointer.get_tuple_field (|
                                                                          γ,
                                                                          0
                                                                        |) in
                                                                      let γ1_1 :=
                                                                        M.SubPointer.get_tuple_field (|
                                                                          γ,
                                                                          1
                                                                        |) in
                                                                      let c := M.alloc (| γ1_0 |) in
                                                                      let r := M.alloc (| γ1_1 |) in
                                                                      Value.Tuple
                                                                        [
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::convert::From",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                                [
                                                                                  Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Any"
                                                                                ],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                                  [
                                                                                    Ty.path
                                                                                      "halo2_proofs::plonk::circuit::Advice"
                                                                                  ]
                                                                              ],
                                                                              "from",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.read (|
                                                                                M.read (| c |)
                                                                              |)
                                                                            ]
                                                                          |);
                                                                          M.read (|
                                                                            M.read (| r |)
                                                                          |)
                                                                        ]))
                                                                ]
                                                              |)
                                                            | _ => M.impossible (||)
                                                            end))
                                                    ]
                                                  |)
                                                ]
                                              |);
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Instance"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ],
                                                  [],
                                                  "map",
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Column")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::plonk::circuit::Any"
                                                          ];
                                                        Ty.path "halo2_proofs::poly::Rotation"
                                                      ];
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::circuit::Instance"
                                                                      ];
                                                                    Ty.path
                                                                      "halo2_proofs::poly::Rotation"
                                                                  ]
                                                              ]
                                                          ]
                                                      ]
                                                      (Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Any"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ])
                                                  ]
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Instance"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ]
                                                        ],
                                                      "iter",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::circuit::Instance"
                                                                    ];
                                                                  Ty.path
                                                                    "halo2_proofs::poly::Rotation"
                                                                ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          [],
                                                          "deref",
                                                          []
                                                        |),
                                                        [
                                                          M.SubPointer.get_struct_record_field (|
                                                            cs,
                                                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                                                            "instance_queries"
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |);
                                                  M.closure
                                                    (fun γ =>
                                                      ltac:(M.monadic
                                                        match γ with
                                                        | [ α0 ] =>
                                                          M.match_operator (|
                                                            M.alloc (| α0 |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ := M.read (| γ |) in
                                                                  let γ1_0 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      0
                                                                    |) in
                                                                  let γ1_1 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      1
                                                                    |) in
                                                                  let c := M.alloc (| γ1_0 |) in
                                                                  let r := M.alloc (| γ1_1 |) in
                                                                  Value.Tuple
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::convert::Into",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::plonk::circuit::Column")
                                                                            [
                                                                              Ty.path
                                                                                "halo2_proofs::plonk::circuit::Instance"
                                                                            ],
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "halo2_proofs::plonk::circuit::Column")
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Any"
                                                                              ]
                                                                          ],
                                                                          "into",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.read (|
                                                                            M.read (| c |)
                                                                          |)
                                                                        ]
                                                                      |);
                                                                      M.read (| M.read (| r |) |)
                                                                    ]))
                                                            ]
                                                          |)
                                                        | _ => M.impossible (||)
                                                        end))
                                                ]
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::circuit::Column")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                        ];
                                                      Ty.path "halo2_proofs::poly::Rotation"
                                                    ]
                                                ],
                                              [],
                                              "map",
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [ Ty.path "halo2_proofs::plonk::circuit::Any"
                                                      ];
                                                    Ty.path "halo2_proofs::poly::Rotation"
                                                  ];
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ];
                                                                Ty.path
                                                                  "halo2_proofs::poly::Rotation"
                                                              ]
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::circuit::Column")
                                                        [
                                                          Ty.path
                                                            "halo2_proofs::plonk::circuit::Any"
                                                        ];
                                                      Ty.path "halo2_proofs::poly::Rotation"
                                                    ])
                                              ]
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "slice")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Fixed"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ],
                                                  "iter",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Fixed"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      [],
                                                      "deref",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        cs,
                                                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                                                        "fixed_queries"
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |);
                                              M.closure
                                                (fun γ =>
                                                  ltac:(M.monadic
                                                    match γ with
                                                    | [ α0 ] =>
                                                      M.match_operator (|
                                                        M.alloc (| α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ := M.read (| γ |) in
                                                              let γ1_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ1_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let c := M.alloc (| γ1_0 |) in
                                                              let r := M.alloc (| γ1_1 |) in
                                                              Value.Tuple
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::convert::Into",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ],
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Any"
                                                                          ]
                                                                      ],
                                                                      "into",
                                                                      []
                                                                    |),
                                                                    [ M.read (| M.read (| c |) |) ]
                                                                  |);
                                                                  M.read (| M.read (| r |) |)
                                                                ]))
                                                        ]
                                                      |)
                                                    | _ => M.impossible (||)
                                                    end))
                                            ]
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "alloc::vec::into_iter::IntoIter")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "map",
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                  [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                                Ty.path "halo2_proofs::poly::Rotation"
                                              ];
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [ Ty.path "halo2_proofs::plonk::circuit::Any"
                                                      ]
                                                  ]
                                              ]
                                              (Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                                  Ty.path "halo2_proofs::poly::Rotation"
                                                ])
                                          ]
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::collect::IntoIterator",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              "into_iter",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path
                                                    "halo2_proofs::plonk::permutation::Argument",
                                                  "get_columns",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    cs,
                                                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                                                    "permutation"
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |);
                                          M.closure
                                            (fun γ =>
                                              ltac:(M.monadic
                                                match γ with
                                                | [ α0 ] =>
                                                  M.match_operator (|
                                                    M.alloc (| α0 |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let c := M.copy (| γ |) in
                                                          Value.Tuple
                                                            [
                                                              M.read (| c |);
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path
                                                                    "halo2_proofs::poly::Rotation",
                                                                  "cur",
                                                                  []
                                                                |),
                                                                []
                                                              |)
                                                            ]))
                                                    ]
                                                  |)
                                                | _ => M.impossible (||)
                                                end))
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::chain::Chain")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::chain::Chain")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::iter::adapters::chain::Chain")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::chain::Chain")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::iter::sources::empty::Empty")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Any"
                                                                          ];
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ];
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::iter::adapters::map::Map")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::slice::iter::Iter")
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "halo2_proofs::plonk::circuit::Column")
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Advice"
                                                                              ];
                                                                            Ty.path
                                                                              "halo2_proofs::poly::Rotation"
                                                                          ]
                                                                      ];
                                                                    Ty.function
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              [
                                                                                Ty.tuple
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                                      [
                                                                                        Ty.path
                                                                                          "halo2_proofs::plonk::circuit::Advice"
                                                                                      ];
                                                                                    Ty.path
                                                                                      "halo2_proofs::poly::Rotation"
                                                                                  ]
                                                                              ]
                                                                          ]
                                                                      ]
                                                                      (Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::plonk::circuit::Column")
                                                                            [
                                                                              Ty.path
                                                                                "halo2_proofs::plonk::circuit::Any"
                                                                            ];
                                                                          Ty.path
                                                                            "halo2_proofs::poly::Rotation"
                                                                        ])
                                                                  ]
                                                              ];
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::map::Map")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::slice::iter::Iter")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Instance"
                                                                          ];
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ];
                                                                Ty.function
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          [
                                                                            Ty.tuple
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                                  [
                                                                                    Ty.path
                                                                                      "halo2_proofs::plonk::circuit::Instance"
                                                                                  ];
                                                                                Ty.path
                                                                                  "halo2_proofs::poly::Rotation"
                                                                              ]
                                                                          ]
                                                                      ]
                                                                  ]
                                                                  (Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Any"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation"
                                                                    ])
                                                              ]
                                                          ];
                                                        Ty.apply
                                                          (Ty.path "core::iter::adapters::map::Map")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::Iter")
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::circuit::Fixed"
                                                                      ];
                                                                    Ty.path
                                                                      "halo2_proofs::poly::Rotation"
                                                                  ]
                                                              ];
                                                            Ty.function
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "halo2_proofs::plonk::circuit::Column")
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Fixed"
                                                                              ];
                                                                            Ty.path
                                                                              "halo2_proofs::poly::Rotation"
                                                                          ]
                                                                      ]
                                                                  ]
                                                              ]
                                                              (Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::circuit::Any"
                                                                    ];
                                                                  Ty.path
                                                                    "halo2_proofs::poly::Rotation"
                                                                ])
                                                          ]
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::vec::into_iter::IntoIter")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Column")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::plonk::circuit::Any"
                                                              ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ];
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Any"
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Column")
                                                                [
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::circuit::Any"
                                                                ];
                                                              Ty.path "halo2_proofs::poly::Rotation"
                                                            ])
                                                      ]
                                                  ],
                                                [],
                                                "next",
                                                []
                                              |),
                                              [ iter ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let γ1_0 :=
                                                  M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                                let γ1_1 :=
                                                  M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                                let c := M.copy (| γ1_0 |) in
                                                let r := M.copy (| γ1_1 |) in
                                                let _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "std::collections::hash::set::HashSet")
                                                          [
                                                            Ty.path "i32";
                                                            Ty.path "std::hash::random::RandomState"
                                                          ],
                                                        "insert",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "std::collections::hash::map::Entry")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Any"
                                                                  ];
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "std::collections::hash::set::HashSet")
                                                                  [
                                                                    Ty.path "i32";
                                                                    Ty.path
                                                                      "std::hash::random::RandomState"
                                                                  ]
                                                              ],
                                                            "or_default",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "std::collections::hash::map::HashMap")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Column")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::plonk::circuit::Any"
                                                                      ];
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "std::collections::hash::set::HashSet")
                                                                      [
                                                                        Ty.path "i32";
                                                                        Ty.path
                                                                          "std::hash::random::RandomState"
                                                                      ];
                                                                    Ty.path
                                                                      "std::hash::random::RandomState"
                                                                  ],
                                                                "entry",
                                                                []
                                                              |),
                                                              [ column_queries; M.read (| c |) ]
                                                            |)
                                                          ]
                                                        |);
                                                        M.read (|
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            r,
                                                            "halo2_proofs::poly::Rotation",
                                                            0
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |)) in
                      let point_sets :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "std::collections::hash::set::HashSet")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "std::hash::random::RandomState"
                                ],
                              "new",
                              []
                            |),
                            []
                          |)
                        |) in
                      let _ :=
                        M.use
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "std::collections::hash::map::HashMap")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                      Ty.apply
                                        (Ty.path "std::collections::hash::set::HashSet")
                                        [ Ty.path "i32"; Ty.path "std::hash::random::RandomState" ];
                                      Ty.path "std::hash::random::RandomState"
                                    ],
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [ M.read (| column_queries |) ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "std::collections::hash::map::IntoIter")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [ Ty.path "halo2_proofs::plonk::circuit::Any"
                                                      ];
                                                    Ty.apply
                                                      (Ty.path
                                                        "std::collections::hash::set::HashSet")
                                                      [
                                                        Ty.path "i32";
                                                        Ty.path "std::hash::random::RandomState"
                                                      ]
                                                  ],
                                                [],
                                                "next",
                                                []
                                              |),
                                              [ iter ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let γ1_0 :=
                                                  M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                                let γ1_1 :=
                                                  M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                                let r := M.copy (| γ1_1 |) in
                                                let query_set :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path
                                                            "std::collections::hash::set::IntoIter")
                                                          [ Ty.path "i32" ],
                                                        [],
                                                        "collect",
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            [
                                                              Ty.path "i32";
                                                              Ty.path "alloc::alloc::Global"
                                                            ]
                                                        ]
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::iter::traits::collect::IntoIterator",
                                                            Ty.apply
                                                              (Ty.path
                                                                "std::collections::hash::set::HashSet")
                                                              [
                                                                Ty.path "i32";
                                                                Ty.path
                                                                  "std::hash::random::RandomState"
                                                              ],
                                                            [],
                                                            "into_iter",
                                                            []
                                                          |),
                                                          [ M.read (| r |) ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                let _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          [ Ty.path "i32" ],
                                                        "sort_unstable",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::DerefMut",
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [
                                                                Ty.path "i32";
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            [],
                                                            "deref_mut",
                                                            []
                                                          |),
                                                          [ query_set ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                let _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "std::collections::hash::set::HashSet")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [
                                                                Ty.path "i32";
                                                                Ty.path "alloc::alloc::Global"
                                                              ];
                                                            Ty.path "std::hash::random::RandomState"
                                                          ],
                                                        "insert",
                                                        []
                                                      |),
                                                      [ point_sets; M.read (| query_set |) ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |)) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "std::collections::hash::set::HashSet")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "std::hash::random::RandomState"
                                ],
                              "insert",
                              []
                            |),
                            [
                              point_sets;
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ Ty.path "i32" ],
                                  "into_vec",
                                  [ Ty.path "alloc::alloc::Global" ]
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.read (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            [
                                              Ty.apply (Ty.path "array") [ Ty.path "i32" ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          []
                                        |),
                                        [
                                          M.alloc (|
                                            Value.Array [ Value.Integer 0; Value.Integer 1 ]
                                          |)
                                        ]
                                      |)
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "std::collections::hash::set::HashSet")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "std::hash::random::RandomState"
                                ],
                              "insert",
                              []
                            |),
                            [
                              point_sets;
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ Ty.path "i32" ],
                                  "into_vec",
                                  [ Ty.path "alloc::alloc::Global" ]
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.read (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            [
                                              Ty.apply (Ty.path "array") [ Ty.path "i32" ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          []
                                        |),
                                        [
                                          M.alloc (|
                                            Value.Array [ Value.Integer (-1); Value.Integer 0 ]
                                          |)
                                        ]
                                      |)
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "std::collections::hash::set::HashSet")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "std::hash::random::RandomState"
                                ],
                              "insert",
                              []
                            |),
                            [
                              point_sets;
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ Ty.path "i32" ],
                                  "into_vec",
                                  [ Ty.path "alloc::alloc::Global" ]
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.read (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            [
                                              Ty.apply (Ty.path "array") [ Ty.path "i32" ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          []
                                        |),
                                        [ M.alloc (| Value.Array [ Value.Integer 0 ] |) ]
                                      |)
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "std::collections::hash::set::HashSet")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "std::hash::random::RandomState"
                                ],
                              "insert",
                              []
                            |),
                            [
                              point_sets;
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ Ty.path "i32" ],
                                  "into_vec",
                                  [ Ty.path "alloc::alloc::Global" ]
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.read (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            [
                                              Ty.apply (Ty.path "array") [ Ty.path "i32" ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          []
                                        |),
                                        [
                                          M.alloc (|
                                            Value.Array [ Value.Integer 0; Value.Integer 1 ]
                                          |)
                                        ]
                                      |)
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let max_deg :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                                [ Ty.associated ],
                              "degree",
                              []
                            |),
                            [ cs ]
                          |)
                        |) in
                      let permutation_cols :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "len",
                              []
                            |),
                            [
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "halo2_proofs::plonk::permutation::Argument",
                                    "get_columns",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      cs,
                                      "halo2_proofs::plonk::circuit::ConstraintSystem",
                                      "permutation"
                                    |)
                                  ]
                                |)
                              |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      BinOp.Pure.gt
                                        (M.read (| permutation_cols |))
                                        (BinOp.Panic.sub (|
                                          Integer.Usize,
                                          M.read (| max_deg |),
                                          Value.Integer 2
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "std::collections::hash::set::HashSet")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ];
                                            Ty.path "std::hash::random::RandomState"
                                          ],
                                        "insert",
                                        []
                                      |),
                                      [
                                        point_sets;
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ Ty.path "i32" ],
                                            "into_vec",
                                            [ Ty.path "alloc::alloc::Global" ]
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.read (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::boxed::Box")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "array")
                                                          [ Ty.path "i32" ];
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "new",
                                                    []
                                                  |),
                                                  [
                                                    M.alloc (|
                                                      Value.Array
                                                        [
                                                          UnOp.Panic.neg (|
                                                            Integer.I32,
                                                            M.rust_cast
                                                              (BinOp.Panic.add (|
                                                                Integer.Usize,
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::ConstraintSystem")
                                                                      [ Ty.associated ],
                                                                    "blinding_factors",
                                                                    []
                                                                  |),
                                                                  [ cs ]
                                                                |),
                                                                Value.Integer 1
                                                              |))
                                                          |);
                                                          Value.Integer 0;
                                                          Value.Integer 1
                                                        ]
                                                    |)
                                                  ]
                                                |)
                                              |))
                                          ]
                                        |)
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (|
                        Value.StructRecord
                          "halo2_proofs::dev::cost::CircuitCost"
                          [
                            ("k", M.read (| k |));
                            ("max_deg", M.read (| max_deg |));
                            ("advice_columns",
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  cs,
                                  "halo2_proofs::plonk::circuit::ConstraintSystem",
                                  "num_advice_columns"
                                |)
                              |));
                            ("instance_queries",
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                                          Ty.path "halo2_proofs::poly::Rotation"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "len",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    cs,
                                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                                    "instance_queries"
                                  |)
                                ]
                              |));
                            ("advice_queries",
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                          Ty.path "halo2_proofs::poly::Rotation"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "len",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    cs,
                                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                                    "advice_queries"
                                  |)
                                ]
                              |));
                            ("fixed_queries",
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                          Ty.path "halo2_proofs::poly::Rotation"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "len",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    cs,
                                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                                    "fixed_queries"
                                  |)
                                ]
                              |));
                            ("lookups",
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                        [ Ty.associated ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "len",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    cs,
                                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                                    "lookups"
                                  |)
                                ]
                              |));
                            ("permutation_cols", M.read (| permutation_cols |));
                            ("point_sets",
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "std::collections::hash::set::HashSet")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [ Ty.path "i32"; Ty.path "alloc::alloc::Global" ];
                                      Ty.path "std::hash::random::RandomState"
                                    ],
                                  "len",
                                  []
                                |),
                                [ point_sets ]
                              |));
                            ("_marker",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::default::Default",
                                  Ty.apply
                                    (Ty.path "core::marker::PhantomData")
                                    [ Ty.tuple [ G; ConcreteCircuit ] ],
                                  [],
                                  "default",
                                  []
                                |),
                                []
                              |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_measure :
        forall (G ConcreteCircuit : Ty.t),
        M.IsAssociatedFunction (Self G ConcreteCircuit) "measure" (measure G ConcreteCircuit).
      
      (*
          fn permutation_chunks(&self) -> usize {
              let chunk_size = self.max_deg - 2;
              (self.permutation_cols + chunk_size - 1) / chunk_size
          }
      *)
      Definition permutation_chunks
          (G ConcreteCircuit : Ty.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self G ConcreteCircuit in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let chunk_size :=
                M.alloc (|
                  BinOp.Panic.sub (|
                    Integer.Usize,
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::dev::cost::CircuitCost",
                        "max_deg"
                      |)
                    |),
                    Value.Integer 2
                  |)
                |) in
              M.alloc (|
                BinOp.Panic.div (|
                  Integer.Usize,
                  BinOp.Panic.sub (|
                    Integer.Usize,
                    BinOp.Panic.add (|
                      Integer.Usize,
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::dev::cost::CircuitCost",
                          "permutation_cols"
                        |)
                      |),
                      M.read (| chunk_size |)
                    |),
                    Value.Integer 1
                  |),
                  M.read (| chunk_size |)
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_permutation_chunks :
        forall (G ConcreteCircuit : Ty.t),
        M.IsAssociatedFunction
          (Self G ConcreteCircuit)
          "permutation_chunks"
          (permutation_chunks G ConcreteCircuit).
      
      (*
          pub fn marginal_proof_size(&self) -> MarginalProofSize<G> {
              let chunks = self.permutation_chunks();
      
              MarginalProofSize {
                  // Cells:
                  // - 1 commitment per advice column per instance
                  // - 1 eval per instance column query per instance
                  // - 1 eval per advice column query per instance
                  instance: ProofContribution::new(0, self.instance_queries),
                  advice: ProofContribution::new(self.advice_columns, self.advice_queries),
      
                  // Lookup arguments:
                  // - 3 commitments per lookup argument per instance
                  // - 5 evals per lookup argument per instance
                  lookups: ProofContribution::new(3 * self.lookups, 5 * self.lookups),
      
                  // Global permutation argument:
                  // - chunks commitments per instance
                  // - 2*chunks + (chunks - 1) evals per instance
                  equality: ProofContribution::new(chunks, 3 * chunks - 1),
      
                  _marker: PhantomData::default(),
              }
          }
      *)
      Definition marginal_proof_size
          (G ConcreteCircuit : Ty.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self G ConcreteCircuit in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let chunks :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::dev::cost::CircuitCost")
                        [ G; ConcreteCircuit ],
                      "permutation_chunks",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "halo2_proofs::dev::cost::MarginalProofSize"
                  [
                    ("instance",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "new",
                          []
                        |),
                        [
                          Value.Integer 0;
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "instance_queries"
                            |)
                          |)
                        ]
                      |));
                    ("advice",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "new",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "advice_columns"
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "advice_queries"
                            |)
                          |)
                        ]
                      |));
                    ("lookups",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "new",
                          []
                        |),
                        [
                          BinOp.Panic.mul (|
                            Integer.Usize,
                            Value.Integer 3,
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::dev::cost::CircuitCost",
                                "lookups"
                              |)
                            |)
                          |);
                          BinOp.Panic.mul (|
                            Integer.Usize,
                            Value.Integer 5,
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::dev::cost::CircuitCost",
                                "lookups"
                              |)
                            |)
                          |)
                        ]
                      |));
                    ("equality",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "new",
                          []
                        |),
                        [
                          M.read (| chunks |);
                          BinOp.Panic.sub (|
                            Integer.Usize,
                            BinOp.Panic.mul (|
                              Integer.Usize,
                              Value.Integer 3,
                              M.read (| chunks |)
                            |),
                            Value.Integer 1
                          |)
                        ]
                      |));
                    ("_marker",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::default::Default",
                          Ty.apply (Ty.path "core::marker::PhantomData") [ G ],
                          [],
                          "default",
                          []
                        |),
                        []
                      |))
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_marginal_proof_size :
        forall (G ConcreteCircuit : Ty.t),
        M.IsAssociatedFunction
          (Self G ConcreteCircuit)
          "marginal_proof_size"
          (marginal_proof_size G ConcreteCircuit).
      
      (*
          pub fn proof_size(&self, instances: usize) -> ProofSize<G> {
              let marginal = self.marginal_proof_size();
      
              ProofSize {
                  // Cells:
                  // - marginal cost per instance
                  // - 1 eval per fixed column query
                  instance: marginal.instance * instances,
                  advice: marginal.advice * instances,
                  fixed: ProofContribution::new(0, self.fixed_queries),
      
                  // Lookup arguments:
                  // - marginal cost per instance
                  lookups: marginal.lookups * instances,
      
                  // Global permutation argument:
                  // - marginal cost per instance
                  // - 1 eval per column
                  equality: marginal.equality * instances
                      + ProofContribution::new(0, self.permutation_cols),
      
                  // Vanishing argument:
                  // - 1 + (max_deg - 1) commitments
                  // - 1 random_poly eval
                  vanishing: ProofContribution::new(self.max_deg, 1),
      
                  // Multiopening argument:
                  // - f_commitment
                  // - 1 eval per set of points in multiopen argument
                  multiopen: ProofContribution::new(1, self.point_sets),
      
                  // Polycommit:
                  // - s_poly commitment
                  // - inner product argument (2 * k round commitments)
                  // - a
                  // - xi
                  polycomm: ProofContribution::new(1 + 2 * self.k, 2),
      
                  _marker: PhantomData::default(),
              }
          }
      *)
      Definition proof_size (G ConcreteCircuit : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self G ConcreteCircuit in
        match τ, α with
        | [], [ self; instances ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let instances := M.alloc (| instances |) in
            M.read (|
              let marginal :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::dev::cost::CircuitCost")
                        [ G; ConcreteCircuit ],
                      "marginal_proof_size",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "halo2_proofs::dev::cost::ProofSize"
                  [
                    ("instance",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::arith::Mul",
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          [ Ty.path "usize" ],
                          "mul",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              marginal,
                              "halo2_proofs::dev::cost::MarginalProofSize",
                              "instance"
                            |)
                          |);
                          M.read (| instances |)
                        ]
                      |));
                    ("advice",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::arith::Mul",
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          [ Ty.path "usize" ],
                          "mul",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              marginal,
                              "halo2_proofs::dev::cost::MarginalProofSize",
                              "advice"
                            |)
                          |);
                          M.read (| instances |)
                        ]
                      |));
                    ("fixed",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "new",
                          []
                        |),
                        [
                          Value.Integer 0;
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "fixed_queries"
                            |)
                          |)
                        ]
                      |));
                    ("lookups",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::arith::Mul",
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          [ Ty.path "usize" ],
                          "mul",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              marginal,
                              "halo2_proofs::dev::cost::MarginalProofSize",
                              "lookups"
                            |)
                          |);
                          M.read (| instances |)
                        ]
                      |));
                    ("equality",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::arith::Add",
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          [ Ty.path "halo2_proofs::dev::cost::ProofContribution" ],
                          "add",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              Ty.path "halo2_proofs::dev::cost::ProofContribution",
                              [ Ty.path "usize" ],
                              "mul",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  marginal,
                                  "halo2_proofs::dev::cost::MarginalProofSize",
                                  "equality"
                                |)
                              |);
                              M.read (| instances |)
                            ]
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "halo2_proofs::dev::cost::ProofContribution",
                              "new",
                              []
                            |),
                            [
                              Value.Integer 0;
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::dev::cost::CircuitCost",
                                  "permutation_cols"
                                |)
                              |)
                            ]
                          |)
                        ]
                      |));
                    ("vanishing",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "new",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "max_deg"
                            |)
                          |);
                          Value.Integer 1
                        ]
                      |));
                    ("multiopen",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "new",
                          []
                        |),
                        [
                          Value.Integer 1;
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::CircuitCost",
                              "point_sets"
                            |)
                          |)
                        ]
                      |));
                    ("polycomm",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "new",
                          []
                        |),
                        [
                          BinOp.Panic.add (|
                            Integer.Usize,
                            Value.Integer 1,
                            BinOp.Panic.mul (|
                              Integer.Usize,
                              Value.Integer 2,
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::dev::cost::CircuitCost",
                                  "k"
                                |)
                              |)
                            |)
                          |);
                          Value.Integer 2
                        ]
                      |));
                    ("_marker",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::default::Default",
                          Ty.apply (Ty.path "core::marker::PhantomData") [ G ],
                          [],
                          "default",
                          []
                        |),
                        []
                      |))
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_proof_size :
        forall (G ConcreteCircuit : Ty.t),
        M.IsAssociatedFunction (Self G ConcreteCircuit) "proof_size" (proof_size G ConcreteCircuit).
    End Impl_halo2_proofs_dev_cost_CircuitCost_G_ConcreteCircuit.
    
    (* StructRecord
      {
        name := "ProofContribution";
        ty_params := [];
        fields := [ ("commitments", Ty.path "usize"); ("evaluations", Ty.path "usize") ];
      } *)
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_dev_cost_ProofContribution.
      Definition Self : Ty.t := Ty.path "halo2_proofs::dev::cost::ProofContribution".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "ProofContribution" |);
                M.read (| Value.String "commitments" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::dev::cost::ProofContribution",
                    "commitments"
                  |));
                M.read (| Value.String "evaluations" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::dev::cost::ProofContribution",
                      "evaluations"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_dev_cost_ProofContribution.
    
    Module Impl_halo2_proofs_dev_cost_ProofContribution.
      Definition Self : Ty.t := Ty.path "halo2_proofs::dev::cost::ProofContribution".
      
      (*
          fn new(commitments: usize, evaluations: usize) -> Self {
              ProofContribution {
                  commitments,
                  evaluations,
              }
          }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ commitments; evaluations ] =>
          ltac:(M.monadic
            (let commitments := M.alloc (| commitments |) in
            let evaluations := M.alloc (| evaluations |) in
            Value.StructRecord
              "halo2_proofs::dev::cost::ProofContribution"
              [ ("commitments", M.read (| commitments |)); ("evaluations", M.read (| evaluations |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
          fn len(&self, point: usize, scalar: usize) -> usize {
              self.commitments * point + self.evaluations * scalar
          }
      *)
      Definition len (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; point; scalar ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let point := M.alloc (| point |) in
            let scalar := M.alloc (| scalar |) in
            BinOp.Panic.add (|
              Integer.Usize,
              BinOp.Panic.mul (|
                Integer.Usize,
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::dev::cost::ProofContribution",
                    "commitments"
                  |)
                |),
                M.read (| point |)
              |),
              BinOp.Panic.mul (|
                Integer.Usize,
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::dev::cost::ProofContribution",
                    "evaluations"
                  |)
                |),
                M.read (| scalar |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_len : M.IsAssociatedFunction Self "len" len.
    End Impl_halo2_proofs_dev_cost_ProofContribution.
    
    Module Impl_core_ops_arith_Add_for_halo2_proofs_dev_cost_ProofContribution.
      Definition Self : Ty.t := Ty.path "halo2_proofs::dev::cost::ProofContribution".
      
      (*     type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "halo2_proofs::dev::cost::ProofContribution".
      
      (*
          fn add(self, rhs: Self) -> Self::Output {
              Self {
                  commitments: self.commitments + rhs.commitments,
                  evaluations: self.evaluations + rhs.evaluations,
              }
          }
      *)
      Definition add (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructRecord
              "halo2_proofs::dev::cost::ProofContribution"
              [
                ("commitments",
                  BinOp.Panic.add (|
                    Integer.Usize,
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "halo2_proofs::dev::cost::ProofContribution",
                        "commitments"
                      |)
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        rhs,
                        "halo2_proofs::dev::cost::ProofContribution",
                        "commitments"
                      |)
                    |)
                  |));
                ("evaluations",
                  BinOp.Panic.add (|
                    Integer.Usize,
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "halo2_proofs::dev::cost::ProofContribution",
                        "evaluations"
                      |)
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        rhs,
                        "halo2_proofs::dev::cost::ProofContribution",
                        "evaluations"
                      |)
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_halo2_proofs_dev_cost_ProofContribution.
    
    Module Impl_core_ops_arith_Mul_usize_for_halo2_proofs_dev_cost_ProofContribution.
      Definition Self : Ty.t := Ty.path "halo2_proofs::dev::cost::ProofContribution".
      
      (*     type Output = Self; *)
      Definition _Output : Ty.t := Ty.path "halo2_proofs::dev::cost::ProofContribution".
      
      (*
          fn mul(self, instances: usize) -> Self::Output {
              Self {
                  commitments: self.commitments * instances,
                  evaluations: self.evaluations * instances,
              }
          }
      *)
      Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; instances ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let instances := M.alloc (| instances |) in
            Value.StructRecord
              "halo2_proofs::dev::cost::ProofContribution"
              [
                ("commitments",
                  BinOp.Panic.mul (|
                    Integer.Usize,
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "halo2_proofs::dev::cost::ProofContribution",
                        "commitments"
                      |)
                    |),
                    M.read (| instances |)
                  |));
                ("evaluations",
                  BinOp.Panic.mul (|
                    Integer.Usize,
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "halo2_proofs::dev::cost::ProofContribution",
                        "evaluations"
                      |)
                    |),
                    M.read (| instances |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Mul"
          Self
          (* Trait polymorphic types *) [ (* Rhs *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
    End Impl_core_ops_arith_Mul_usize_for_halo2_proofs_dev_cost_ProofContribution.
    
    (* StructRecord
      {
        name := "MarginalProofSize";
        ty_params := [ "G" ];
        fields :=
          [
            ("instance", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("advice", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("lookups", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("equality", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ G ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_G_where_group_prime_PrimeGroup_G_for_halo2_proofs_dev_cost_MarginalProofSize_G.
      Definition Self (G : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::dev::cost::MarginalProofSize") [ G ].
      
      (* Debug *)
      Definition fmt (G : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self G in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field5_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "MarginalProofSize" |);
                M.read (| Value.String "instance" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::dev::cost::MarginalProofSize",
                    "instance"
                  |));
                M.read (| Value.String "advice" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::dev::cost::MarginalProofSize",
                    "advice"
                  |));
                M.read (| Value.String "lookups" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::dev::cost::MarginalProofSize",
                    "lookups"
                  |));
                M.read (| Value.String "equality" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::dev::cost::MarginalProofSize",
                    "equality"
                  |));
                M.read (| Value.String "_marker" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::dev::cost::MarginalProofSize",
                      "_marker"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (G : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self G)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt G)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_G_where_group_prime_PrimeGroup_G_for_halo2_proofs_dev_cost_MarginalProofSize_G.
    
    Module Impl_core_convert_From_where_group_prime_PrimeGroup_G_halo2_proofs_dev_cost_MarginalProofSize_G_for_usize.
      Definition Self (G : Ty.t) : Ty.t := Ty.path "usize".
      
      (*
          fn from(proof: MarginalProofSize<G>) -> Self {
              let point = G::Repr::default().as_ref().len();
              let scalar = <G::Scalar as PrimeField>::Repr::default().as_ref().len();
      
              proof.instance.len(point, scalar)
                  + proof.advice.len(point, scalar)
                  + proof.lookups.len(point, scalar)
                  + proof.equality.len(point, scalar)
          }
      *)
      Definition from (G : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self G in
        match τ, α with
        | [], [ proof ] =>
          ltac:(M.monadic
            (let proof := M.alloc (| proof |) in
            M.read (|
              let point :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                      "len",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::AsRef",
                          Ty.associated,
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                          "as_ref",
                          []
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::default::Default",
                                Ty.associated,
                                [],
                                "default",
                                []
                              |),
                              []
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              let scalar :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                      "len",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::AsRef",
                          Ty.associated,
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                          "as_ref",
                          []
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::default::Default",
                                Ty.associated,
                                [],
                                "default",
                                []
                              |),
                              []
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                BinOp.Panic.add (|
                  Integer.Usize,
                  BinOp.Panic.add (|
                    Integer.Usize,
                    BinOp.Panic.add (|
                      Integer.Usize,
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "len",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            proof,
                            "halo2_proofs::dev::cost::MarginalProofSize",
                            "instance"
                          |);
                          M.read (| point |);
                          M.read (| scalar |)
                        ]
                      |),
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "len",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            proof,
                            "halo2_proofs::dev::cost::MarginalProofSize",
                            "advice"
                          |);
                          M.read (| point |);
                          M.read (| scalar |)
                        ]
                      |)
                    |),
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "halo2_proofs::dev::cost::ProofContribution",
                        "len",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          proof,
                          "halo2_proofs::dev::cost::MarginalProofSize",
                          "lookups"
                        |);
                        M.read (| point |);
                        M.read (| scalar |)
                      ]
                    |)
                  |),
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "halo2_proofs::dev::cost::ProofContribution",
                      "len",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        proof,
                        "halo2_proofs::dev::cost::MarginalProofSize",
                        "equality"
                      |);
                      M.read (| point |);
                      M.read (| scalar |)
                    ]
                  |)
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (G : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self G)
          (* Trait polymorphic types *)
          [ (* T *) Ty.apply (Ty.path "halo2_proofs::dev::cost::MarginalProofSize") [ G ] ]
          (* Instance *) [ ("from", InstanceField.Method (from G)) ].
    End Impl_core_convert_From_where_group_prime_PrimeGroup_G_halo2_proofs_dev_cost_MarginalProofSize_G_for_usize.
    
    (* StructRecord
      {
        name := "ProofSize";
        ty_params := [ "G" ];
        fields :=
          [
            ("instance", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("advice", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("fixed", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("lookups", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("equality", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("vanishing", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("multiopen", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("polycomm", Ty.path "halo2_proofs::dev::cost::ProofContribution");
            ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ G ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_G_where_group_prime_PrimeGroup_G_for_halo2_proofs_dev_cost_ProofSize_G.
      Definition Self (G : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::dev::cost::ProofSize") [ G ].
      
      (* Debug *)
      Definition fmt (G : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self G in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let names :=
                M.alloc (|
                  M.alloc (|
                    Value.Array
                      [
                        M.read (| Value.String "instance" |);
                        M.read (| Value.String "advice" |);
                        M.read (| Value.String "fixed" |);
                        M.read (| Value.String "lookups" |);
                        M.read (| Value.String "equality" |);
                        M.read (| Value.String "vanishing" |);
                        M.read (| Value.String "multiopen" |);
                        M.read (| Value.String "polycomm" |);
                        M.read (| Value.String "_marker" |)
                      ]
                  |)
                |) in
              let values :=
                M.alloc (|
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::ProofSize",
                              "instance"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::ProofSize",
                              "advice"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::ProofSize",
                              "fixed"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::ProofSize",
                              "lookups"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::ProofSize",
                              "equality"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::ProofSize",
                              "vanishing"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::ProofSize",
                              "multiopen"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::dev::cost::ProofSize",
                              "polycomm"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.alloc (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::dev::cost::ProofSize",
                                "_marker"
                              |)
                            |))
                        ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "debug_struct_fields_finish",
                    []
                  |),
                  [
                    M.read (| f |);
                    M.read (| Value.String "ProofSize" |);
                    (* Unsize *) M.pointer_coercion (M.read (| names |));
                    M.read (| values |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (G : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self G)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt G)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_G_where_group_prime_PrimeGroup_G_for_halo2_proofs_dev_cost_ProofSize_G.
    
    Module Impl_core_convert_From_where_group_prime_PrimeGroup_G_halo2_proofs_dev_cost_ProofSize_G_for_usize.
      Definition Self (G : Ty.t) : Ty.t := Ty.path "usize".
      
      (*
          fn from(proof: ProofSize<G>) -> Self {
              let point = G::Repr::default().as_ref().len();
              let scalar = <G::Scalar as PrimeField>::Repr::default().as_ref().len();
      
              proof.instance.len(point, scalar)
                  + proof.advice.len(point, scalar)
                  + proof.fixed.len(point, scalar)
                  + proof.lookups.len(point, scalar)
                  + proof.equality.len(point, scalar)
                  + proof.vanishing.len(point, scalar)
                  + proof.multiopen.len(point, scalar)
                  + proof.polycomm.len(point, scalar)
          }
      *)
      Definition from (G : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self G in
        match τ, α with
        | [], [ proof ] =>
          ltac:(M.monadic
            (let proof := M.alloc (| proof |) in
            M.read (|
              let point :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                      "len",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::AsRef",
                          Ty.associated,
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                          "as_ref",
                          []
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::default::Default",
                                Ty.associated,
                                [],
                                "default",
                                []
                              |),
                              []
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              let scalar :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                      "len",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::AsRef",
                          Ty.associated,
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                          "as_ref",
                          []
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::default::Default",
                                Ty.associated,
                                [],
                                "default",
                                []
                              |),
                              []
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                BinOp.Panic.add (|
                  Integer.Usize,
                  BinOp.Panic.add (|
                    Integer.Usize,
                    BinOp.Panic.add (|
                      Integer.Usize,
                      BinOp.Panic.add (|
                        Integer.Usize,
                        BinOp.Panic.add (|
                          Integer.Usize,
                          BinOp.Panic.add (|
                            Integer.Usize,
                            BinOp.Panic.add (|
                              Integer.Usize,
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "halo2_proofs::dev::cost::ProofContribution",
                                  "len",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    proof,
                                    "halo2_proofs::dev::cost::ProofSize",
                                    "instance"
                                  |);
                                  M.read (| point |);
                                  M.read (| scalar |)
                                ]
                              |),
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "halo2_proofs::dev::cost::ProofContribution",
                                  "len",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    proof,
                                    "halo2_proofs::dev::cost::ProofSize",
                                    "advice"
                                  |);
                                  M.read (| point |);
                                  M.read (| scalar |)
                                ]
                              |)
                            |),
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "halo2_proofs::dev::cost::ProofContribution",
                                "len",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  proof,
                                  "halo2_proofs::dev::cost::ProofSize",
                                  "fixed"
                                |);
                                M.read (| point |);
                                M.read (| scalar |)
                              ]
                            |)
                          |),
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "halo2_proofs::dev::cost::ProofContribution",
                              "len",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                proof,
                                "halo2_proofs::dev::cost::ProofSize",
                                "lookups"
                              |);
                              M.read (| point |);
                              M.read (| scalar |)
                            ]
                          |)
                        |),
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "halo2_proofs::dev::cost::ProofContribution",
                            "len",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              proof,
                              "halo2_proofs::dev::cost::ProofSize",
                              "equality"
                            |);
                            M.read (| point |);
                            M.read (| scalar |)
                          ]
                        |)
                      |),
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::dev::cost::ProofContribution",
                          "len",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            proof,
                            "halo2_proofs::dev::cost::ProofSize",
                            "vanishing"
                          |);
                          M.read (| point |);
                          M.read (| scalar |)
                        ]
                      |)
                    |),
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "halo2_proofs::dev::cost::ProofContribution",
                        "len",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          proof,
                          "halo2_proofs::dev::cost::ProofSize",
                          "multiopen"
                        |);
                        M.read (| point |);
                        M.read (| scalar |)
                      ]
                    |)
                  |),
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "halo2_proofs::dev::cost::ProofContribution",
                      "len",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        proof,
                        "halo2_proofs::dev::cost::ProofSize",
                        "polycomm"
                      |);
                      M.read (| point |);
                      M.read (| scalar |)
                    ]
                  |)
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (G : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self G)
          (* Trait polymorphic types *)
          [ (* T *) Ty.apply (Ty.path "halo2_proofs::dev::cost::ProofSize") [ G ] ]
          (* Instance *) [ ("from", InstanceField.Method (from G)) ].
    End Impl_core_convert_From_where_group_prime_PrimeGroup_G_halo2_proofs_dev_cost_ProofSize_G_for_usize.
  End cost.
End dev.
