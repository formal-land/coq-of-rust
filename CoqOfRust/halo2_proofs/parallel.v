(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module parallel.
  (* StructTuple
    {
      name := "Parallel";
      ty_params := [ "T" ];
      fields :=
        [
          Ty.apply
            (Ty.path "alloc::sync::Arc")
            [ Ty.apply (Ty.path "std::sync::mutex::Mutex") [ T ]; Ty.path "alloc::alloc::Global" ]
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_T_for_halo2_proofs_parallel_Parallel_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::parallel::Parallel") [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "Parallel" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::parallel::Parallel",
                    0
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_T_for_halo2_proofs_parallel_Parallel_T.
  
  Module Impl_core_clone_Clone_where_core_fmt_Debug_T_for_halo2_proofs_parallel_Parallel_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::parallel::Parallel") [ T ].
    
    (*
        fn clone(&self) -> Self {
            Self(self.0.clone())
        }
    *)
    Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "halo2_proofs::parallel::Parallel"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply (Ty.path "std::sync::mutex::Mutex") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  "clone",
                  []
                |),
                [
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::parallel::Parallel",
                    0
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
  End Impl_core_clone_Clone_where_core_fmt_Debug_T_for_halo2_proofs_parallel_Parallel_T.
  
  Module Impl_halo2_proofs_parallel_Parallel_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::parallel::Parallel") [ T ].
    
    (*
        pub(crate) fn new(v: T) -> Self {
            Parallel(Arc::new(Mutex::new(v)))
        }
    *)
    Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          Value.StructTuple
            "halo2_proofs::parallel::Parallel"
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply (Ty.path "std::sync::mutex::Mutex") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "std::sync::mutex::Mutex") [ T ],
                      "new",
                      []
                    |),
                    [ M.read (| v |) ]
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "new" (new T).
    
    (*
        pub(crate) fn into_inner(self) -> T {
            Arc::try_unwrap(self.0).unwrap().into_inner().unwrap()
        }
    *)
    Definition into_inner (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                [ T; Ty.apply (Ty.path "std::sync::poison::PoisonError") [ T ] ],
              "unwrap",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "std::sync::mutex::Mutex") [ T ],
                  "into_inner",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply (Ty.path "std::sync::mutex::Mutex") [ T ];
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            [
                              Ty.apply (Ty.path "std::sync::mutex::Mutex") [ T ];
                              Ty.path "alloc::alloc::Global"
                            ]
                        ],
                      "unwrap",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            [
                              Ty.apply (Ty.path "std::sync::mutex::Mutex") [ T ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "try_unwrap",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_tuple_field (|
                              self,
                              "halo2_proofs::parallel::Parallel",
                              0
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_inner :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "into_inner" (into_inner T).
    
    (*
        pub(crate) fn lock(&self) -> Result<MutexGuard<'_, T>, PoisonError<MutexGuard<'_, T>>> {
            self.0.lock()
        }
    *)
    Definition lock (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "std::sync::mutex::Mutex") [ T ],
              "lock",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply (Ty.path "std::sync::mutex::Mutex") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  "deref",
                  []
                |),
                [
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::parallel::Parallel",
                    0
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_lock :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "lock" (lock T).
  End Impl_halo2_proofs_parallel_Parallel_T.
End parallel.
