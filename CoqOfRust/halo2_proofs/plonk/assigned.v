(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module plonk.
  Module assigned.
    (*
    Enum Assigned
    {
      ty_params := [ "F" ];
      variants :=
        [
          {
            name := "Zero";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Trivial";
            item := StructTuple [ F ];
            discriminant := None;
          };
          {
            name := "Rational";
            item := StructTuple [ F; F ];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (* Clone *)
      Definition clone (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        Value.StructTuple "halo2_proofs::plonk::assigned::Assigned::Zero" []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::assigned::Assigned::Trivial"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", F, [], "clone", [] |),
                              [ M.read (| __self_0 |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::assigned::Assigned::Rational"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", F, [], "clone", [] |),
                              [ M.read (| __self_0 |) ]
                            |);
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", F, [], "clone", [] |),
                              [ M.read (| __self_1 |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "Zero" |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Trivial" |);
                            (* Unsize *) M.pointer_coercion __self_0
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field2_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Rational" |);
                            (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                            (* Unsize *) M.pointer_coercion __self_1
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_convert_From_where_ff_Field_F_ref__F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          fn from(numerator: &F) -> Self {
              Assigned::Trivial( *numerator)
          }
      *)
      Definition from (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ numerator ] =>
          ltac:(M.monadic
            (let numerator := M.alloc (| numerator |) in
            Value.StructTuple
              "halo2_proofs::plonk::assigned::Assigned::Trivial"
              [ M.read (| M.read (| numerator |) |) ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self F)
          (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "&") [ F ] ]
          (* Instance *) [ ("from", InstanceField.Method (from F)) ].
    End Impl_core_convert_From_where_ff_Field_F_ref__F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_convert_From_where_ff_Field_F_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          fn from(numerator: F) -> Self {
              Assigned::Trivial(numerator)
          }
      *)
      Definition from (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ numerator ] =>
          ltac:(M.monadic
            (let numerator := M.alloc (| numerator |) in
            Value.StructTuple
              "halo2_proofs::plonk::assigned::Assigned::Trivial"
              [ M.read (| numerator |) ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self F)
          (* Trait polymorphic types *) [ (* T *) F ]
          (* Instance *) [ ("from", InstanceField.Method (from F)) ].
    End Impl_core_convert_From_where_ff_Field_F_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_convert_From_where_ff_Field_F_Tuple_F_F__for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          fn from((numerator, denominator): (F, F)) -> Self {
              Assigned::Rational(numerator, denominator)
          }
      *)
      Definition from (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ β0 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let numerator := M.copy (| γ0_0 |) in
                    let denominator := M.copy (| γ0_1 |) in
                    Value.StructTuple
                      "halo2_proofs::plonk::assigned::Assigned::Rational"
                      [ M.read (| numerator |); M.read (| denominator |) ]))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self F)
          (* Trait polymorphic types *) [ (* T *) Ty.tuple [ F; F ] ]
          (* Instance *) [ ("from", InstanceField.Method (from F)) ].
    End Impl_core_convert_From_where_ff_Field_F_Tuple_F_F__for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_ops_arith_Neg_where_ff_Field_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*     type Output = Assigned<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          fn neg(self) -> Self::Output {
              match self {
                  Self::Zero => Self::Zero,
                  Self::Trivial(numerator) => Self::Trivial(-numerator),
                  Self::Rational(numerator, denominator) => Self::Rational(-numerator, denominator),
              }
          }
      *)
      Definition neg (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple "halo2_proofs::plonk::assigned::Assigned::Zero" []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      let numerator := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::assigned::Assigned::Trivial"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::ops::arith::Neg", F, [], "neg", [] |),
                              [ M.read (| numerator |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ0_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let numerator := M.copy (| γ0_0 |) in
                      let denominator := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::assigned::Assigned::Rational"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::ops::arith::Neg", F, [], "neg", [] |),
                              [ M.read (| numerator |) ]
                            |);
                            M.read (| denominator |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("neg", InstanceField.Method (neg F)) ].
    End Impl_core_ops_arith_Neg_where_ff_Field_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_ops_arith_Add_where_ff_Field_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*     type Output = Assigned<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          fn add(self, rhs: Assigned<F>) -> Assigned<F> {
              match (self, rhs) {
                  // One side is directly zero.
                  (Self::Zero, _) => rhs,
                  (_, Self::Zero) => self,
      
                  // One side is x/0 which maps to zero.
                  (Self::Rational(_, denominator), other) | (other, Self::Rational(_, denominator))
                      if denominator.is_zero_vartime() =>
                  {
                      other
                  }
      
                  // Okay, we need to do some actual math...
                  (Self::Trivial(lhs), Self::Trivial(rhs)) => Self::Trivial(lhs + rhs),
                  (Self::Rational(numerator, denominator), Self::Trivial(other))
                  | (Self::Trivial(other), Self::Rational(numerator, denominator)) => {
                      Self::Rational(numerator + denominator * other, denominator)
                  }
                  (
                      Self::Rational(lhs_numerator, lhs_denominator),
                      Self::Rational(rhs_numerator, rhs_denominator),
                  ) => Self::Rational(
                      lhs_numerator * rhs_denominator + lhs_denominator * rhs_numerator,
                      lhs_denominator * rhs_denominator,
                  ),
              }
          }
      *)
      Definition add (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [ M.read (| self |); M.read (| rhs |) ] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      rhs));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      self));
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  0
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  1
                                |) in
                              let denominator := M.copy (| γ1_1 |) in
                              let other := M.copy (| γ0_1 |) in
                              Value.Tuple [ denominator; other ]));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let other := M.copy (| γ0_0 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  0
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  1
                                |) in
                              let denominator := M.copy (| γ1_1 |) in
                              Value.Tuple [ denominator; other ]))
                        ],
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ denominator; other ] =>
                                let γ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "ff::Field",
                                        F,
                                        [],
                                        "is_zero_vartime",
                                        []
                                      |),
                                      [ denominator ]
                                    |)
                                  |) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                other
                              | _ => M.impossible (||)
                              end))
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      let lhs := M.copy (| γ1_0 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      let rhs := M.copy (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::assigned::Assigned::Trivial"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::ops::arith::Add", F, [ F ], "add", [] |),
                              [ M.read (| lhs |); M.read (| rhs |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  0
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  1
                                |) in
                              let numerator := M.copy (| γ1_0 |) in
                              let denominator := M.copy (| γ1_1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "halo2_proofs::plonk::assigned::Assigned::Trivial",
                                  0
                                |) in
                              let other := M.copy (| γ1_0 |) in
                              Value.Tuple [ numerator; denominator; other ]));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "halo2_proofs::plonk::assigned::Assigned::Trivial",
                                  0
                                |) in
                              let other := M.copy (| γ1_0 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  0
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  1
                                |) in
                              let numerator := M.copy (| γ1_0 |) in
                              let denominator := M.copy (| γ1_1 |) in
                              Value.Tuple [ numerator; denominator; other ]))
                        ],
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ numerator; denominator; other ] =>
                                M.alloc (|
                                  Value.StructTuple
                                    "halo2_proofs::plonk::assigned::Assigned::Rational"
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::arith::Add",
                                          F,
                                          [ F ],
                                          "add",
                                          []
                                        |),
                                        [
                                          M.read (| numerator |);
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              F,
                                              [ F ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| denominator |); M.read (| other |) ]
                                          |)
                                        ]
                                      |);
                                      M.read (| denominator |)
                                    ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let lhs_numerator := M.copy (| γ1_0 |) in
                      let lhs_denominator := M.copy (| γ1_1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let rhs_numerator := M.copy (| γ1_0 |) in
                      let rhs_denominator := M.copy (| γ1_1 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::assigned::Assigned::Rational"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::ops::arith::Add", F, [ F ], "add", [] |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::arith::Mul",
                                    F,
                                    [ F ],
                                    "mul",
                                    []
                                  |),
                                  [ M.read (| lhs_numerator |); M.read (| rhs_denominator |) ]
                                |);
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::arith::Mul",
                                    F,
                                    [ F ],
                                    "mul",
                                    []
                                  |),
                                  [ M.read (| lhs_denominator |); M.read (| rhs_numerator |) ]
                                |)
                              ]
                            |);
                            M.call_closure (|
                              M.get_trait_method (| "core::ops::arith::Mul", F, [ F ], "mul", [] |),
                              [ M.read (| lhs_denominator |); M.read (| rhs_denominator |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("add", InstanceField.Method (add F)) ].
    End Impl_core_ops_arith_Add_where_ff_Field_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_ops_arith_Add_where_ff_Field_F_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*     type Output = Assigned<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          fn add(self, rhs: F) -> Assigned<F> {
              self + Self::Trivial(rhs)
          }
      *)
      Definition add (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Add",
                Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ],
                [ Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ] ],
                "add",
                []
              |),
              [
                M.read (| self |);
                Value.StructTuple
                  "halo2_proofs::plonk::assigned::Assigned::Trivial"
                  [ M.read (| rhs |) ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (Self F)
          (* Trait polymorphic types *) [ (* Rhs *) F ]
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("add", InstanceField.Method (add F)) ].
    End Impl_core_ops_arith_Add_where_ff_Field_F_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_ops_arith_Sub_where_ff_Field_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*     type Output = Assigned<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          fn sub(self, rhs: Assigned<F>) -> Assigned<F> {
              self + (-rhs)
          }
      *)
      Definition sub (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Add",
                Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ],
                [ Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ] ],
                "add",
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Neg",
                    Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ],
                    [],
                    "neg",
                    []
                  |),
                  [ M.read (| rhs |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("sub", InstanceField.Method (sub F)) ].
    End Impl_core_ops_arith_Sub_where_ff_Field_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_ops_arith_Sub_where_ff_Field_F_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*     type Output = Assigned<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          fn sub(self, rhs: F) -> Assigned<F> {
              self + (-rhs)
          }
      *)
      Definition sub (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Add",
                Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ],
                [ F ],
                "add",
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_trait_method (| "core::ops::arith::Neg", F, [], "neg", [] |),
                  [ M.read (| rhs |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (Self F)
          (* Trait polymorphic types *) [ (* Rhs *) F ]
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("sub", InstanceField.Method (sub F)) ].
    End Impl_core_ops_arith_Sub_where_ff_Field_F_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_ops_arith_Mul_where_ff_Field_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*     type Output = Assigned<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          fn mul(self, rhs: Assigned<F>) -> Assigned<F> {
              match (self, rhs) {
                  (Self::Zero, _) | (_, Self::Zero) => Self::Zero,
                  (Self::Trivial(lhs), Self::Trivial(rhs)) => Self::Trivial(lhs * rhs),
                  (Self::Rational(numerator, denominator), Self::Trivial(other))
                  | (Self::Trivial(other), Self::Rational(numerator, denominator)) => {
                      Self::Rational(numerator * other, denominator)
                  }
                  (
                      Self::Rational(lhs_numerator, lhs_denominator),
                      Self::Rational(rhs_numerator, rhs_denominator),
                  ) => Self::Rational(
                      lhs_numerator * rhs_numerator,
                      lhs_denominator * rhs_denominator,
                  ),
              }
          }
      *)
      Definition mul (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [ M.read (| self |); M.read (| rhs |) ] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              Value.Tuple []))
                        ],
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [] =>
                                M.alloc (|
                                  Value.StructTuple
                                    "halo2_proofs::plonk::assigned::Assigned::Zero"
                                    []
                                |)
                              | _ => M.impossible (||)
                              end))
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      let lhs := M.copy (| γ1_0 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      let rhs := M.copy (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::assigned::Assigned::Trivial"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::ops::arith::Mul", F, [ F ], "mul", [] |),
                              [ M.read (| lhs |); M.read (| rhs |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  0
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  1
                                |) in
                              let numerator := M.copy (| γ1_0 |) in
                              let denominator := M.copy (| γ1_1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "halo2_proofs::plonk::assigned::Assigned::Trivial",
                                  0
                                |) in
                              let other := M.copy (| γ1_0 |) in
                              Value.Tuple [ numerator; denominator; other ]));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "halo2_proofs::plonk::assigned::Assigned::Trivial",
                                  0
                                |) in
                              let other := M.copy (| γ1_0 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  0
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "halo2_proofs::plonk::assigned::Assigned::Rational",
                                  1
                                |) in
                              let numerator := M.copy (| γ1_0 |) in
                              let denominator := M.copy (| γ1_1 |) in
                              Value.Tuple [ numerator; denominator; other ]))
                        ],
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ numerator; denominator; other ] =>
                                M.alloc (|
                                  Value.StructTuple
                                    "halo2_proofs::plonk::assigned::Assigned::Rational"
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::arith::Mul",
                                          F,
                                          [ F ],
                                          "mul",
                                          []
                                        |),
                                        [ M.read (| numerator |); M.read (| other |) ]
                                      |);
                                      M.read (| denominator |)
                                    ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let lhs_numerator := M.copy (| γ1_0 |) in
                      let lhs_denominator := M.copy (| γ1_1 |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let rhs_numerator := M.copy (| γ1_0 |) in
                      let rhs_denominator := M.copy (| γ1_1 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::assigned::Assigned::Rational"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::ops::arith::Mul", F, [ F ], "mul", [] |),
                              [ M.read (| lhs_numerator |); M.read (| rhs_numerator |) ]
                            |);
                            M.call_closure (|
                              M.get_trait_method (| "core::ops::arith::Mul", F, [ F ], "mul", [] |),
                              [ M.read (| lhs_denominator |); M.read (| rhs_denominator |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("mul", InstanceField.Method (mul F)) ].
    End Impl_core_ops_arith_Mul_where_ff_Field_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_core_ops_arith_Mul_where_ff_Field_F_F_for_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*     type Output = Assigned<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          fn mul(self, rhs: F) -> Assigned<F> {
              self * Self::Trivial(rhs)
          }
      *)
      Definition mul (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Mul",
                Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ],
                [ Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ] ],
                "mul",
                []
              |),
              [
                M.read (| self |);
                Value.StructTuple
                  "halo2_proofs::plonk::assigned::Assigned::Trivial"
                  [ M.read (| rhs |) ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (Self F)
          (* Trait polymorphic types *) [ (* Rhs *) F ]
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("mul", InstanceField.Method (mul F)) ].
    End Impl_core_ops_arith_Mul_where_ff_Field_F_F_for_halo2_proofs_plonk_assigned_Assigned_F.
    
    Module Impl_halo2_proofs_plonk_assigned_Assigned_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ].
      
      (*
          pub fn numerator(&self) -> F {
              match self {
                  Self::Zero => F::zero(),
                  Self::Trivial(x) => *x,
                  Self::Rational(numerator, _) => *numerator,
              }
          }
      *)
      Definition numerator (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (| "ff::Field", F, [], "zero", [] |),
                          []
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      let x := M.alloc (| γ1_0 |) in
                      M.read (| x |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let numerator := M.alloc (| γ1_0 |) in
                      M.read (| numerator |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_numerator :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "numerator" (numerator F).
      
      (*
          pub fn denominator(&self) -> Option<F> {
              match self {
                  Self::Zero => None,
                  Self::Trivial(_) => None,
                  Self::Rational(_, denominator) => Some( *denominator),
              }
          }
      *)
      Definition denominator (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let denominator := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ M.read (| M.read (| denominator |) |) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_denominator :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "denominator" (denominator F).
      
      (*
          pub fn invert(&self) -> Self {
              match self {
                  Self::Zero => Self::Zero,
                  Self::Trivial(x) => Self::Rational(F::one(), *x),
                  Self::Rational(numerator, denominator) => Self::Rational( *denominator, *numerator),
              }
          }
      *)
      Definition invert (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        Value.StructTuple "halo2_proofs::plonk::assigned::Assigned::Zero" []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      let x := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::assigned::Assigned::Rational"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "ff::Field", F, [], "one", [] |),
                              []
                            |);
                            M.read (| M.read (| x |) |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let numerator := M.alloc (| γ1_0 |) in
                      let denominator := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::assigned::Assigned::Rational"
                          [
                            M.read (| M.read (| denominator |) |);
                            M.read (| M.read (| numerator |) |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_invert :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "invert" (invert F).
      
      (*
          pub fn evaluate(self) -> F {
              match self {
                  Self::Zero => F::zero(),
                  Self::Trivial(x) => x,
                  Self::Rational(numerator, denominator) => {
                      if denominator == F::one() {
                          numerator
                      } else {
                          numerator * denominator.invert().unwrap_or(F::zero())
                      }
                  }
              }
          }
      *)
      Definition evaluate (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (| "ff::Field", F, [], "zero", [] |),
                          []
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Trivial",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          0
                        |) in
                      let γ0_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::assigned::Assigned::Rational",
                          1
                        |) in
                      let numerator := M.copy (| γ0_0 |) in
                      let denominator := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        F,
                                        [ F ],
                                        "eq",
                                        []
                                      |),
                                      [
                                        denominator;
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (| "ff::Field", F, [], "one", [] |),
                                            []
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              numerator));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::arith::Mul",
                                    F,
                                    [ F ],
                                    "mul",
                                    []
                                  |),
                                  [
                                    M.read (| numerator |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "subtle::CtOption") [ F ],
                                        "unwrap_or",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (| "ff::Field", F, [], "invert", [] |),
                                          [ denominator ]
                                        |);
                                        M.call_closure (|
                                          M.get_trait_method (| "ff::Field", F, [], "zero", [] |),
                                          []
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_evaluate :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "evaluate" (evaluate F).
    End Impl_halo2_proofs_plonk_assigned_Assigned_F.
  End assigned.
End plonk.
