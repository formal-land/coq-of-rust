(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module plonk.
  Module circuit.
    (* Trait *)
    (* Empty module 'ColumnType' *)
    
    (* StructRecord
      {
        name := "Column";
        ty_params := [ "C" ];
        fields := [ ("index", Ty.path "usize"); ("column_type", C) ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      (* Clone *)
      Definition clone (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::Column"
              [
                ("index",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Ty.path "usize", [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::Column",
                        "index"
                      |)
                    ]
                  |));
                ("column_type",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", C, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::Column",
                        "column_type"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone C)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      (* Debug *)
      Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Column" |);
                M.read (| Value.String "index" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::Column",
                    "index"
                  |));
                M.read (| Value.String "column_type" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::Column",
                      "column_type"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
    
    Module Impl_core_marker_StructuralEq_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralEq"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq C)) ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
    
    Module Impl_core_marker_StructuralPartialEq_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      (* PartialEq *)
      Definition eq (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              BinOp.Pure.eq
                (M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::Column",
                    "index"
                  |)
                |))
                (M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "halo2_proofs::plonk::circuit::Column",
                    "index"
                  |)
                |)),
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (| "core::cmp::PartialEq", C, [ C ], "eq", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::Column",
                      "column_type"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "halo2_proofs::plonk::circuit::Column",
                      "column_type"
                    |)
                  ]
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq C)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      (* Hash *)
      Definition hash (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::hash::Hash",
                      Ty.path "usize",
                      [],
                      "hash",
                      [ __H ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::Column",
                        "index"
                      |);
                      M.read (| state |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::Column",
                      "column_type"
                    |);
                    M.read (| state |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash C)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_C_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
    
    Module Impl_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      (*
          pub fn new(index: usize, column_type: C) -> Self {
              Column { index, column_type }
          }
      *)
      Definition new (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ index; column_type ] =>
          ltac:(M.monadic
            (let index := M.alloc (| index |) in
            let column_type := M.alloc (| column_type |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::Column"
              [ ("index", M.read (| index |)); ("column_type", M.read (| column_type |)) ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (C : Ty.t),
        M.IsAssociatedFunction (Self C) "new" (new C).
      
      (*
          pub fn index(&self) -> usize {
              self.index
          }
      *)
      Definition index (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::plonk::circuit::Column",
                "index"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_index :
        forall (C : Ty.t),
        M.IsAssociatedFunction (Self C) "index" (index C).
      
      (*
          pub fn column_type(&self) -> &C {
              &self.column_type
          }
      *)
      Definition column_type (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "halo2_proofs::plonk::circuit::Column",
              "column_type"
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_column_type :
        forall (C : Ty.t),
        M.IsAssociatedFunction (Self C) "column_type" (column_type C).
    End Impl_halo2_proofs_plonk_circuit_Column_C.
    
    Module Impl_core_cmp_Ord_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      (*
          fn cmp(&self, other: &Self) -> std::cmp::Ordering {
              // This ordering is consensus-critical! The layouters rely on deterministic column
              // orderings.
              match self.column_type.into().cmp(&other.column_type.into()) {
                  // Indices are assigned within column types.
                  std::cmp::Ordering::Equal => self.index.cmp(&other.index),
                  order => order,
              }
          }
      *)
      Definition cmp (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::cmp::Ord",
                      Ty.path "halo2_proofs::plonk::circuit::Any",
                      [],
                      "cmp",
                      []
                    |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::convert::Into",
                            C,
                            [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                            "into",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::circuit::Column",
                                "column_type"
                              |)
                            |)
                          ]
                        |)
                      |);
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::convert::Into",
                            C,
                            [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                            "into",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| other |),
                                "halo2_proofs::plonk::circuit::Column",
                                "column_type"
                              |)
                            |)
                          ]
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], "cmp", [] |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::Column",
                              "index"
                            |);
                            M.SubPointer.get_struct_record_field (|
                              M.read (| other |),
                              "halo2_proofs::plonk::circuit::Column",
                              "index"
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let order := M.copy (| γ |) in
                      order))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method (cmp C)) ].
    End Impl_core_cmp_Ord_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
    
    Module Impl_core_cmp_PartialOrd_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ].
      
      (*
          fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
              Some(self.cmp(other))
          }
      *)
      Definition partial_cmp (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Column") [ C ],
                    [],
                    "cmp",
                    []
                  |),
                  [ M.read (| self |); M.read (| other |) ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp C)) ].
    End Impl_core_cmp_PartialOrd_where_halo2_proofs_plonk_circuit_ColumnType_C_for_halo2_proofs_plonk_circuit_Column_C.
    
    (* StructTuple
      {
        name := "Advice";
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_Advice.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Advice".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.read (| self |) |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_Advice.
    
    Module Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_Advice.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Advice".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_Advice.
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_Advice.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Advice".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
              [ M.read (| f |); M.read (| Value.String "Advice" |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_Advice.
    
    Module Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_Advice.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Advice".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_Advice.
    
    Module Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_Advice.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Advice".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_Advice.
    
    Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_Advice.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Advice".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_Advice.
    
    Module Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_Advice.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Advice".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.Bool true))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_Advice.
    
    Module Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_Advice.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Advice".
      
      (* Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_Advice.
    
    (* StructTuple
      {
        name := "Fixed";
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_Fixed.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Fixed".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.read (| self |) |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_Fixed.
    
    Module Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_Fixed.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Fixed".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_Fixed.
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_Fixed.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Fixed".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
              [ M.read (| f |); M.read (| Value.String "Fixed" |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_Fixed.
    
    Module Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_Fixed.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Fixed".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_Fixed.
    
    Module Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_Fixed.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Fixed".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_Fixed.
    
    Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_Fixed.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Fixed".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_Fixed.
    
    Module Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_Fixed.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Fixed".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.Bool true))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_Fixed.
    
    Module Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_Fixed.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Fixed".
      
      (* Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_Fixed.
    
    (* StructTuple
      {
        name := "Instance";
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_Instance.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Instance".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.read (| self |) |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_Instance.
    
    Module Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_Instance.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Instance".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_Instance.
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_Instance.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Instance".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
              [ M.read (| f |); M.read (| Value.String "Instance" |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_Instance.
    
    Module Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_Instance.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Instance".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_Instance.
    
    Module Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_Instance.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Instance".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_Instance.
    
    Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_Instance.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Instance".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_Instance.
    
    Module Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_Instance.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Instance".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.Bool true))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_Instance.
    
    Module Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_Instance.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Instance".
      
      (* Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_Instance.
    
    (*
    Enum Any
    {
      ty_params := [];
      variants :=
        [
          {
            name := "Advice";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Fixed";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Instance";
            item := StructTuple [];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.read (| self |) |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
              [
                M.read (| f |);
                M.read (|
                  M.match_operator (|
                    self,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          M.alloc (| M.read (| Value.String "Advice" |) |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          M.alloc (| M.read (| Value.String "Fixed" |) |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          M.alloc (| M.read (| Value.String "Instance" |) |)))
                    ]
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let __self_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let __arg1_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                    |),
                    [ M.read (| other |) ]
                  |)
                |) in
              M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      (* Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let __self_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_cmp_Ord_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      (*
          fn cmp(&self, other: &Self) -> std::cmp::Ordering {
              // This ordering is consensus-critical! The layouters rely on deterministic column
              // orderings.
              match (self, other) {
                  (Any::Instance, Any::Instance)
                  | (Any::Advice, Any::Advice)
                  | (Any::Fixed, Any::Fixed) => std::cmp::Ordering::Equal,
                  // Across column types, sort Instance < Advice < Fixed.
                  (Any::Instance, Any::Advice)
                  | (Any::Advice, Any::Fixed)
                  | (Any::Instance, Any::Fixed) => std::cmp::Ordering::Less,
                  (Any::Fixed, Any::Instance)
                  | (Any::Fixed, Any::Advice)
                  | (Any::Advice, Any::Instance) => std::cmp::Ordering::Greater,
              }
          }
      *)
      Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              Value.Tuple []))
                        ],
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [] =>
                                M.alloc (| Value.StructTuple "core::cmp::Ordering::Equal" [] |)
                              | _ => M.impossible (||)
                              end))
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              Value.Tuple []))
                        ],
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [] => M.alloc (| Value.StructTuple "core::cmp::Ordering::Less" [] |)
                              | _ => M.impossible (||)
                              end))
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              Value.Tuple []))
                        ],
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [] =>
                                M.alloc (| Value.StructTuple "core::cmp::Ordering::Greater" [] |)
                              | _ => M.impossible (||)
                              end))
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_cmp_PartialOrd_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      (*
          fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
              Some(self.cmp(other))
          }
      *)
      Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.path "halo2_proofs::plonk::circuit::Any",
                    [],
                    "cmp",
                    []
                  |),
                  [ M.read (| self |); M.read (| other |) ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_halo2_proofs_plonk_circuit_ColumnType_for_halo2_proofs_plonk_circuit_Advice.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Advice".
      
      Axiom Implements :
        M.IsTraitInstance
          "halo2_proofs::plonk::circuit::ColumnType"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_halo2_proofs_plonk_circuit_ColumnType_for_halo2_proofs_plonk_circuit_Advice.
    
    Module Impl_halo2_proofs_plonk_circuit_ColumnType_for_halo2_proofs_plonk_circuit_Fixed.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Fixed".
      
      Axiom Implements :
        M.IsTraitInstance
          "halo2_proofs::plonk::circuit::ColumnType"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_halo2_proofs_plonk_circuit_ColumnType_for_halo2_proofs_plonk_circuit_Fixed.
    
    Module Impl_halo2_proofs_plonk_circuit_ColumnType_for_halo2_proofs_plonk_circuit_Instance.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Instance".
      
      Axiom Implements :
        M.IsTraitInstance
          "halo2_proofs::plonk::circuit::ColumnType"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_halo2_proofs_plonk_circuit_ColumnType_for_halo2_proofs_plonk_circuit_Instance.
    
    Module Impl_halo2_proofs_plonk_circuit_ColumnType_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      Axiom Implements :
        M.IsTraitInstance
          "halo2_proofs::plonk::circuit::ColumnType"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_halo2_proofs_plonk_circuit_ColumnType_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_convert_From_halo2_proofs_plonk_circuit_Advice_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      (*
          fn from(_: Advice) -> Any {
              Any::Advice
          }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ β0 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple "halo2_proofs::plonk::circuit::Any::Advice" []))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "halo2_proofs::plonk::circuit::Advice" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_halo2_proofs_plonk_circuit_Advice_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_convert_From_halo2_proofs_plonk_circuit_Fixed_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      (*
          fn from(_: Fixed) -> Any {
              Any::Fixed
          }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ β0 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic (Value.StructTuple "halo2_proofs::plonk::circuit::Any::Fixed" []))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_halo2_proofs_plonk_circuit_Fixed_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_convert_From_halo2_proofs_plonk_circuit_Instance_for_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Any".
      
      (*
          fn from(_: Instance) -> Any {
              Any::Instance
          }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ β0 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple "halo2_proofs::plonk::circuit::Any::Instance" []))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "halo2_proofs::plonk::circuit::Instance" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_halo2_proofs_plonk_circuit_Instance_for_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_convert_From_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Advice_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "halo2_proofs::plonk::circuit::Column")
          [ Ty.path "halo2_proofs::plonk::circuit::Any" ].
      
      (*
          fn from(advice: Column<Advice>) -> Column<Any> {
              Column {
                  index: advice.index(),
                  column_type: Any::Advice,
              }
          }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ advice ] =>
          ltac:(M.monadic
            (let advice := M.alloc (| advice |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::Column"
              [
                ("index",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Advice" ],
                      "index",
                      []
                    |),
                    [ advice ]
                  |));
                ("column_type", Value.StructTuple "halo2_proofs::plonk::circuit::Any::Advice" [])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *)
          [
            (* T *)
            Ty.apply
              (Ty.path "halo2_proofs::plonk::circuit::Column")
              [ Ty.path "halo2_proofs::plonk::circuit::Advice" ]
          ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Advice_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_convert_From_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Fixed_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "halo2_proofs::plonk::circuit::Column")
          [ Ty.path "halo2_proofs::plonk::circuit::Any" ].
      
      (*
          fn from(advice: Column<Fixed>) -> Column<Any> {
              Column {
                  index: advice.index(),
                  column_type: Any::Fixed,
              }
          }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ advice ] =>
          ltac:(M.monadic
            (let advice := M.alloc (| advice |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::Column"
              [
                ("index",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ],
                      "index",
                      []
                    |),
                    [ advice ]
                  |));
                ("column_type", Value.StructTuple "halo2_proofs::plonk::circuit::Any::Fixed" [])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *)
          [
            (* T *)
            Ty.apply
              (Ty.path "halo2_proofs::plonk::circuit::Column")
              [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
          ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Fixed_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_convert_From_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Instance_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "halo2_proofs::plonk::circuit::Column")
          [ Ty.path "halo2_proofs::plonk::circuit::Any" ].
      
      (*
          fn from(advice: Column<Instance>) -> Column<Any> {
              Column {
                  index: advice.index(),
                  column_type: Any::Instance,
              }
          }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ advice ] =>
          ltac:(M.monadic
            (let advice := M.alloc (| advice |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::Column"
              [
                ("index",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Instance" ],
                      "index",
                      []
                    |),
                    [ advice ]
                  |));
                ("column_type", Value.StructTuple "halo2_proofs::plonk::circuit::Any::Instance" [])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *)
          [
            (* T *)
            Ty.apply
              (Ty.path "halo2_proofs::plonk::circuit::Column")
              [ Ty.path "halo2_proofs::plonk::circuit::Instance" ]
          ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Instance_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any.
    
    Module Impl_core_convert_TryFrom_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Advice.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "halo2_proofs::plonk::circuit::Column")
          [ Ty.path "halo2_proofs::plonk::circuit::Advice" ].
      
      (*     type Error = &'static str; *)
      Definition _Error : Ty.t := Ty.apply (Ty.path "&") [ Ty.path "str" ].
      
      (*
          fn try_from(any: Column<Any>) -> Result<Self, Self::Error> {
              match any.column_type() {
                  Any::Advice => Ok(Column {
                      index: any.index(),
                      column_type: Advice,
                  }),
                  _ => Err("Cannot convert into Column<Advice>"),
              }
          }
      *)
      Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ any ] =>
          ltac:(M.monadic
            (let any := M.alloc (| any |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                      "column_type",
                      []
                    |),
                    [ any ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [
                            Value.StructRecord
                              "halo2_proofs::plonk::circuit::Column"
                              [
                                ("index",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                                      "index",
                                      []
                                    |),
                                    [ any ]
                                  |));
                                ("column_type",
                                  Value.StructTuple "halo2_proofs::plonk::circuit::Advice" [])
                              ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ M.read (| Value.String "Cannot convert into Column<Advice>" |) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          Self
          (* Trait polymorphic types *)
          [
            (* T *)
            Ty.apply
              (Ty.path "halo2_proofs::plonk::circuit::Column")
              [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
          ]
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Advice.
    
    Module Impl_core_convert_TryFrom_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Fixed.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "halo2_proofs::plonk::circuit::Column")
          [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ].
      
      (*     type Error = &'static str; *)
      Definition _Error : Ty.t := Ty.apply (Ty.path "&") [ Ty.path "str" ].
      
      (*
          fn try_from(any: Column<Any>) -> Result<Self, Self::Error> {
              match any.column_type() {
                  Any::Fixed => Ok(Column {
                      index: any.index(),
                      column_type: Fixed,
                  }),
                  _ => Err("Cannot convert into Column<Fixed>"),
              }
          }
      *)
      Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ any ] =>
          ltac:(M.monadic
            (let any := M.alloc (| any |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                      "column_type",
                      []
                    |),
                    [ any ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [
                            Value.StructRecord
                              "halo2_proofs::plonk::circuit::Column"
                              [
                                ("index",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                                      "index",
                                      []
                                    |),
                                    [ any ]
                                  |));
                                ("column_type",
                                  Value.StructTuple "halo2_proofs::plonk::circuit::Fixed" [])
                              ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ M.read (| Value.String "Cannot convert into Column<Fixed>" |) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          Self
          (* Trait polymorphic types *)
          [
            (* T *)
            Ty.apply
              (Ty.path "halo2_proofs::plonk::circuit::Column")
              [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
          ]
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Fixed.
    
    Module Impl_core_convert_TryFrom_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Instance.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "halo2_proofs::plonk::circuit::Column")
          [ Ty.path "halo2_proofs::plonk::circuit::Instance" ].
      
      (*     type Error = &'static str; *)
      Definition _Error : Ty.t := Ty.apply (Ty.path "&") [ Ty.path "str" ].
      
      (*
          fn try_from(any: Column<Any>) -> Result<Self, Self::Error> {
              match any.column_type() {
                  Any::Instance => Ok(Column {
                      index: any.index(),
                      column_type: Instance,
                  }),
                  _ => Err("Cannot convert into Column<Instance>"),
              }
          }
      *)
      Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ any ] =>
          ltac:(M.monadic
            (let any := M.alloc (| any |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                      "column_type",
                      []
                    |),
                    [ any ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [
                            Value.StructRecord
                              "halo2_proofs::plonk::circuit::Column"
                              [
                                ("index",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                                      "index",
                                      []
                                    |),
                                    [ any ]
                                  |));
                                ("column_type",
                                  Value.StructTuple "halo2_proofs::plonk::circuit::Instance" [])
                              ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ M.read (| Value.String "Cannot convert into Column<Instance>" |) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          Self
          (* Trait polymorphic types *)
          [
            (* T *)
            Ty.apply
              (Ty.path "halo2_proofs::plonk::circuit::Column")
              [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
          ]
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any_for_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Instance.
    
    (* StructTuple
      {
        name := "Selector";
        ty_params := [];
        fields := [ Ty.path "usize"; Ty.path "bool" ];
      } *)
    
    Module Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_Selector.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Selector".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_Selector.
    
    Module Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_Selector.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Selector".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_Selector.
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_Selector.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Selector".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_tuple_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Selector" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::Selector",
                    0
                  |));
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::Selector",
                      1
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_Selector.
    
    Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_Selector.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Selector".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_Selector.
    
    Module Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_Selector.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Selector".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              BinOp.Pure.eq
                (M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::Selector",
                    0
                  |)
                |))
                (M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| other |),
                    "halo2_proofs::plonk::circuit::Selector",
                    0
                  |)
                |)),
              ltac:(M.monadic
                (BinOp.Pure.eq
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::Selector",
                      1
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| other |),
                      "halo2_proofs::plonk::circuit::Selector",
                      1
                    |)
                  |))))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_Selector.
    
    Module Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_Selector.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Selector".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_Selector.
    
    Module Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_Selector.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Selector".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_Selector.
    
    Module Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_Selector.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Selector".
      
      (* Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::hash::Hash",
                      Ty.path "usize",
                      [],
                      "hash",
                      [ __H ]
                    |),
                    [
                      M.SubPointer.get_struct_tuple_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::Selector",
                        0
                      |);
                      M.read (| state |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "bool", [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::Selector",
                      1
                    |);
                    M.read (| state |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_Selector.
    
    Module Impl_halo2_proofs_plonk_circuit_Selector.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::Selector".
      
      (*
          pub fn enable<F: Field>(&self, region: &Region<F>, offset: usize) -> Result<(), Error> {
              region.enable_selector(|| "", self, offset)
          }
      *)
      Definition enable (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ self; region; offset ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let region := M.alloc (| region |) in
            let offset := M.alloc (| offset |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ],
                "enable_selector",
                [
                  Ty.function [ Ty.tuple [] ] (Ty.apply (Ty.path "&") [ Ty.path "str" ]);
                  Ty.apply (Ty.path "&") [ Ty.path "str" ]
                ]
              |),
              [
                M.read (| region |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        M.match_operator (|
                          M.alloc (| α0 |),
                          [ fun γ => ltac:(M.monadic (M.read (| Value.String "" |))) ]
                        |)
                      | _ => M.impossible (||)
                      end));
                M.read (| self |);
                M.read (| offset |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_enable : M.IsAssociatedFunction Self "enable" enable.
      
      (*
          pub fn is_simple(&self) -> bool {
              self.1
          }
      *)
      Definition is_simple (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "halo2_proofs::plonk::circuit::Selector",
                1
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_simple : M.IsAssociatedFunction Self "is_simple" is_simple.
    End Impl_halo2_proofs_plonk_circuit_Selector.
    
    (* StructRecord
      {
        name := "TableColumn";
        ty_params := [];
        fields :=
          [
            ("inner",
              Ty.apply
                (Ty.path "halo2_proofs::plonk::circuit::Column")
                [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_TableColumn.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::TableColumn".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_TableColumn.
    
    Module Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_TableColumn.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::TableColumn".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_TableColumn.
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_TableColumn.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::TableColumn".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "TableColumn" |);
                M.read (| Value.String "inner" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::TableColumn",
                      "inner"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_TableColumn.
    
    Module Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_TableColumn.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::TableColumn".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_halo2_proofs_plonk_circuit_TableColumn.
    
    Module Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_TableColumn.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::TableColumn".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_halo2_proofs_plonk_circuit_TableColumn.
    
    Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_TableColumn.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::TableColumn".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_plonk_circuit_TableColumn.
    
    Module Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_TableColumn.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::TableColumn".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                  [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ],
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                    [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                ],
                "eq",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::plonk::circuit::TableColumn",
                  "inner"
                |);
                M.SubPointer.get_struct_record_field (|
                  M.read (| other |),
                  "halo2_proofs::plonk::circuit::TableColumn",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_halo2_proofs_plonk_circuit_TableColumn.
    
    Module Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_TableColumn.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::TableColumn".
      
      (* Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.apply
                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                  [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ],
                [],
                "hash",
                [ __H ]
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::plonk::circuit::TableColumn",
                  "inner"
                |);
                M.read (| state |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_halo2_proofs_plonk_circuit_TableColumn.
    
    Module Impl_halo2_proofs_plonk_circuit_TableColumn.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::TableColumn".
      
      (*
          pub(crate) fn inner(&self) -> Column<Fixed> {
              self.inner
          }
      *)
      Definition inner (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::plonk::circuit::TableColumn",
                "inner"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_inner : M.IsAssociatedFunction Self "inner" inner.
    End Impl_halo2_proofs_plonk_circuit_TableColumn.
    
    (* Trait *)
    (* Empty module 'Assignment' *)
    
    (* Trait *)
    (* Empty module 'FloorPlanner' *)
    
    (* Trait *)
    (* Empty module 'Circuit' *)
    
    (*
    Enum Expression
    {
      ty_params := [ "F" ];
      variants :=
        [
          {
            name := "Constant";
            item := StructTuple [ F ];
            discriminant := None;
          };
          {
            name := "Selector";
            item := StructTuple [ Ty.path "halo2_proofs::plonk::circuit::Selector" ];
            discriminant := None;
          };
          {
            name := "Fixed";
            item :=
              StructRecord
                [
                  ("query_index", Ty.path "usize");
                  ("column_index", Ty.path "usize");
                  ("rotation", Ty.path "halo2_proofs::poly::Rotation")
                ];
            discriminant := None;
          };
          {
            name := "Advice";
            item :=
              StructRecord
                [
                  ("query_index", Ty.path "usize");
                  ("column_index", Ty.path "usize");
                  ("rotation", Ty.path "halo2_proofs::poly::Rotation")
                ];
            discriminant := None;
          };
          {
            name := "Instance";
            item :=
              StructRecord
                [
                  ("query_index", Ty.path "usize");
                  ("column_index", Ty.path "usize");
                  ("rotation", Ty.path "halo2_proofs::poly::Rotation")
                ];
            discriminant := None;
          };
          {
            name := "Negated";
            item :=
              StructTuple
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ];
            discriminant := None;
          };
          {
            name := "Sum";
            item :=
              StructTuple
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                      Ty.path "alloc::alloc::Global"
                    ];
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ];
            discriminant := None;
          };
          {
            name := "Product";
            item :=
              StructTuple
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                      Ty.path "alloc::alloc::Global"
                    ];
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ];
            discriminant := None;
          };
          {
            name := "Scaled";
            item :=
              StructTuple
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                      Ty.path "alloc::alloc::Global"
                    ];
                  F
                ];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_halo2_proofs_plonk_circuit_Expression_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (* Clone *)
      Definition clone (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Constant",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::circuit::Expression::Constant"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", F, [], "clone", [] |),
                              [ M.read (| __self_0 |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Selector",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::circuit::Expression::Selector"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "halo2_proofs::plonk::circuit::Selector",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "rotation"
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      let __self_2 := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        Value.StructRecord
                          "halo2_proofs::plonk::circuit::Expression::Fixed"
                          [
                            ("query_index",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.path "usize",
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_0 |) ]
                              |));
                            ("column_index",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.path "usize",
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_1 |) ]
                              |));
                            ("rotation",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.path "halo2_proofs::poly::Rotation",
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_2 |) ]
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "rotation"
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      let __self_2 := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        Value.StructRecord
                          "halo2_proofs::plonk::circuit::Expression::Advice"
                          [
                            ("query_index",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.path "usize",
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_0 |) ]
                              |));
                            ("column_index",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.path "usize",
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_1 |) ]
                              |));
                            ("rotation",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.path "halo2_proofs::poly::Rotation",
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_2 |) ]
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "rotation"
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      let __self_2 := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        Value.StructRecord
                          "halo2_proofs::plonk::circuit::Expression::Instance"
                          [
                            ("query_index",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.path "usize",
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_0 |) ]
                              |));
                            ("column_index",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.path "usize",
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_1 |) ]
                              |));
                            ("rotation",
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  Ty.path "halo2_proofs::poly::Rotation",
                                  [],
                                  "clone",
                                  []
                                |),
                                [ M.read (| __self_2 |) ]
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Negated",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::circuit::Expression::Negated"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          1
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::circuit::Expression::Sum"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |);
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          1
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::circuit::Expression::Product"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |);
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          1
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::plonk::circuit::Expression::Scaled"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |);
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", F, [], "clone", [] |),
                              [ M.read (| __self_1 |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_for_halo2_proofs_plonk_circuit_Expression_F.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_halo2_proofs_plonk_circuit_Expression_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Constant",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Constant" |);
                            (* Unsize *) M.pointer_coercion __self_0
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Selector",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Selector" |);
                            (* Unsize *) M.pointer_coercion __self_0
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "rotation"
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      let __self_2 := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_struct_field3_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Fixed" |);
                            M.read (| Value.String "query_index" |);
                            (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                            M.read (| Value.String "column_index" |);
                            (* Unsize *) M.pointer_coercion (M.read (| __self_1 |));
                            M.read (| Value.String "rotation" |);
                            (* Unsize *) M.pointer_coercion __self_2
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "rotation"
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      let __self_2 := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_struct_field3_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Advice" |);
                            M.read (| Value.String "query_index" |);
                            (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                            M.read (| Value.String "column_index" |);
                            (* Unsize *) M.pointer_coercion (M.read (| __self_1 |));
                            M.read (| Value.String "rotation" |);
                            (* Unsize *) M.pointer_coercion __self_2
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "rotation"
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      let __self_2 := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_struct_field3_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Instance" |);
                            M.read (| Value.String "query_index" |);
                            (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                            M.read (| Value.String "column_index" |);
                            (* Unsize *) M.pointer_coercion (M.read (| __self_1 |));
                            M.read (| Value.String "rotation" |);
                            (* Unsize *) M.pointer_coercion __self_2
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Negated",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Negated" |);
                            (* Unsize *) M.pointer_coercion __self_0
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          1
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field2_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Sum" |);
                            (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                            (* Unsize *) M.pointer_coercion __self_1
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          1
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field2_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Product" |);
                            (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                            (* Unsize *) M.pointer_coercion __self_1
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          1
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      let __self_1 := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field2_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Scaled" |);
                            (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                            (* Unsize *) M.pointer_coercion __self_1
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_halo2_proofs_plonk_circuit_Expression_F.
    
    Module Impl_halo2_proofs_plonk_circuit_Expression_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*
          pub fn is_constant(&self) -> Option<F> {
              match self {
                  Expression::Constant(c) => Some( *c),
                  _ => None,
              }
          }
      *)
      Definition is_constant (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Constant",
                          0
                        |) in
                      let c := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ M.read (| M.read (| c |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_constant :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "is_constant" (is_constant F).
      
      (*
          pub fn is_pure_fixed(&self) -> Option<usize> {
              match self {
                  Expression::Fixed {
                      column_index,
                      rotation,
                      ..
                  } => {
                      if rotation.0 == 0 {
                          Some( *column_index)
                      } else {
                          None
                      }
                  }
                  _ => None,
              }
          }
      *)
      Definition is_pure_fixed (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "column_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "rotation"
                        |) in
                      let column_index := M.alloc (| γ1_0 |) in
                      let rotation := M.alloc (| γ1_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (|
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.read (| rotation |),
                                          "halo2_proofs::poly::Rotation",
                                          0
                                        |)
                                      |))
                                      (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| M.read (| column_index |) |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_pure_fixed :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "is_pure_fixed" (is_pure_fixed F).
      
      (*
          pub fn is_pure_advice(&self) -> Option<usize> {
              match self {
                  Expression::Advice {
                      column_index,
                      rotation,
                      ..
                  } => {
                      if rotation.0 == 0 {
                          Some( *column_index)
                      } else {
                          None
                      }
                  }
                  _ => None,
              }
          }
      *)
      Definition is_pure_advice (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "column_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "rotation"
                        |) in
                      let column_index := M.alloc (| γ1_0 |) in
                      let rotation := M.alloc (| γ1_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (|
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.read (| rotation |),
                                          "halo2_proofs::poly::Rotation",
                                          0
                                        |)
                                      |))
                                      (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| M.read (| column_index |) |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_pure_advice :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "is_pure_advice" (is_pure_advice F).
      
      (*
          pub fn is_pure_instance(&self) -> Option<usize> {
              match self {
                  Expression::Instance {
                      column_index,
                      rotation,
                      ..
                  } => {
                      if rotation.0 == 0 {
                          Some( *column_index)
                      } else {
                          None
                      }
                  }
                  _ => None,
              }
          }
      *)
      Definition is_pure_instance (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "column_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "rotation"
                        |) in
                      let column_index := M.alloc (| γ1_0 |) in
                      let rotation := M.alloc (| γ1_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (|
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.read (| rotation |),
                                          "halo2_proofs::poly::Rotation",
                                          0
                                        |)
                                      |))
                                      (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| M.read (| column_index |) |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_pure_instance :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "is_pure_instance" (is_pure_instance F).
      
      (*
          pub fn evaluate<T>(
              &self,
              constant: &impl Fn(F) -> T,
              selector_column: &impl Fn(Selector) -> T,
              fixed_column: &impl Fn(usize, usize, Rotation) -> T,
              advice_column: &impl Fn(usize, usize, Rotation) -> T,
              instance_column: &impl Fn(usize, usize, Rotation) -> T,
              negated: &impl Fn(T) -> T,
              sum: &impl Fn(T, T) -> T,
              product: &impl Fn(&dyn Fn() -> T, &dyn Fn() -> T) -> T,
              scaled: &impl Fn(T, F) -> T,
          ) -> T {
              match self {
                  Expression::Constant(scalar) => constant( *scalar),
                  Expression::Selector(selector) => selector_column( *selector),
                  Expression::Fixed {
                      query_index,
                      column_index,
                      rotation,
                  } => fixed_column( *query_index, *column_index, *rotation),
                  Expression::Advice {
                      query_index,
                      column_index,
                      rotation,
                  } => advice_column( *query_index, *column_index, *rotation),
                  Expression::Instance {
                      query_index,
                      column_index,
                      rotation,
                  } => instance_column( *query_index, *column_index, *rotation),
                  Expression::Negated(a) => {
                      let a = a.evaluate(
                          constant,
                          selector_column,
                          fixed_column,
                          advice_column,
                          instance_column,
                          negated,
                          sum,
                          product,
                          scaled,
                      );
                      negated(a)
                  }
                  Expression::Sum(a, b) => {
                      let a = a.evaluate(
                          constant,
                          selector_column,
                          fixed_column,
                          advice_column,
                          instance_column,
                          negated,
                          sum,
                          product,
                          scaled,
                      );
                      let b = b.evaluate(
                          constant,
                          selector_column,
                          fixed_column,
                          advice_column,
                          instance_column,
                          negated,
                          sum,
                          product,
                          scaled,
                      );
                      sum(a, b)
                  }
                  Expression::Product(a, b) => {
                      let a = || {
                          a.evaluate(
                              constant,
                              selector_column,
                              fixed_column,
                              advice_column,
                              instance_column,
                              negated,
                              sum,
                              product,
                              scaled,
                          )
                      };
                      let b = || {
                          b.evaluate(
                              constant,
                              selector_column,
                              fixed_column,
                              advice_column,
                              instance_column,
                              negated,
                              sum,
                              product,
                              scaled,
                          )
                      };
                      product(&a, &b)
                  }
                  Expression::Scaled(a, f) => {
                      let a = a.evaluate(
                          constant,
                          selector_column,
                          fixed_column,
                          advice_column,
                          instance_column,
                          negated,
                          sum,
                          product,
                          scaled,
                      );
                      scaled(a, *f)
                  }
              }
          }
      *)
      Definition evaluate (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [
              T;
              impl_Fn_F__arrow_T;
              impl_Fn_Selector__arrow_T;
              impl_Fn_usize__usize__Rotation__arrow_T;
              impl_Fn_usize__usize__Rotation__arrow_T'1;
              impl_Fn_usize__usize__Rotation__arrow_T'2;
              impl_Fn_T__arrow_T;
              impl_Fn_T__T__arrow_T;
              impl_Fn__dyn_Fn___arrow_T___dyn_Fn___arrow_T__arrow_T;
              impl_Fn_T__F__arrow_T
            ],
            [
              self;
              constant;
              selector_column;
              fixed_column;
              advice_column;
              instance_column;
              negated;
              sum;
              product;
              scaled
            ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let constant := M.alloc (| constant |) in
            let selector_column := M.alloc (| selector_column |) in
            let fixed_column := M.alloc (| fixed_column |) in
            let advice_column := M.alloc (| advice_column |) in
            let instance_column := M.alloc (| instance_column |) in
            let negated := M.alloc (| negated |) in
            let sum := M.alloc (| sum |) in
            let product := M.alloc (| product |) in
            let scaled := M.alloc (| scaled |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Constant",
                          0
                        |) in
                      let scalar := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_F__arrow_T,
                            [ Ty.tuple [ F ] ],
                            "call",
                            []
                          |),
                          [ M.read (| constant |); Value.Tuple [ M.read (| M.read (| scalar |) |) ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Selector",
                          0
                        |) in
                      let selector := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_Selector__arrow_T,
                            [ Ty.tuple [ Ty.path "halo2_proofs::plonk::circuit::Selector" ] ],
                            "call",
                            []
                          |),
                          [
                            M.read (| selector_column |);
                            Value.Tuple [ M.read (| M.read (| selector |) |) ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "rotation"
                        |) in
                      let query_index := M.alloc (| γ1_0 |) in
                      let column_index := M.alloc (| γ1_1 |) in
                      let rotation := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_usize__usize__Rotation__arrow_T,
                            [
                              Ty.tuple
                                [
                                  Ty.path "usize";
                                  Ty.path "usize";
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ]
                            ],
                            "call",
                            []
                          |),
                          [
                            M.read (| fixed_column |);
                            Value.Tuple
                              [
                                M.read (| M.read (| query_index |) |);
                                M.read (| M.read (| column_index |) |);
                                M.read (| M.read (| rotation |) |)
                              ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "rotation"
                        |) in
                      let query_index := M.alloc (| γ1_0 |) in
                      let column_index := M.alloc (| γ1_1 |) in
                      let rotation := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_usize__usize__Rotation__arrow_T'1,
                            [
                              Ty.tuple
                                [
                                  Ty.path "usize";
                                  Ty.path "usize";
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ]
                            ],
                            "call",
                            []
                          |),
                          [
                            M.read (| advice_column |);
                            Value.Tuple
                              [
                                M.read (| M.read (| query_index |) |);
                                M.read (| M.read (| column_index |) |);
                                M.read (| M.read (| rotation |) |)
                              ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "rotation"
                        |) in
                      let query_index := M.alloc (| γ1_0 |) in
                      let column_index := M.alloc (| γ1_1 |) in
                      let rotation := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_usize__usize__Rotation__arrow_T'2,
                            [
                              Ty.tuple
                                [
                                  Ty.path "usize";
                                  Ty.path "usize";
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ]
                            ],
                            "call",
                            []
                          |),
                          [
                            M.read (| instance_column |);
                            Value.Tuple
                              [
                                M.read (| M.read (| query_index |) |);
                                M.read (| M.read (| column_index |) |);
                                M.read (| M.read (| rotation |) |)
                              ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Negated",
                          0
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let a :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "evaluate",
                              [
                                T;
                                impl_Fn_F__arrow_T;
                                impl_Fn_Selector__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                impl_Fn_T__arrow_T;
                                impl_Fn_T__T__arrow_T;
                                impl_Fn__dyn_Fn___arrow_T___dyn_Fn___arrow_T__arrow_T;
                                impl_Fn_T__F__arrow_T
                              ]
                            |),
                            [
                              M.read (| M.read (| a |) |);
                              M.read (| constant |);
                              M.read (| selector_column |);
                              M.read (| fixed_column |);
                              M.read (| advice_column |);
                              M.read (| instance_column |);
                              M.read (| negated |);
                              M.read (| sum |);
                              M.read (| product |);
                              M.read (| scaled |)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_T__arrow_T,
                            [ Ty.tuple [ T ] ],
                            "call",
                            []
                          |),
                          [ M.read (| negated |); Value.Tuple [ M.read (| a |) ] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let b := M.alloc (| γ1_1 |) in
                      let a :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "evaluate",
                              [
                                T;
                                impl_Fn_F__arrow_T;
                                impl_Fn_Selector__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                impl_Fn_T__arrow_T;
                                impl_Fn_T__T__arrow_T;
                                impl_Fn__dyn_Fn___arrow_T___dyn_Fn___arrow_T__arrow_T;
                                impl_Fn_T__F__arrow_T
                              ]
                            |),
                            [
                              M.read (| M.read (| a |) |);
                              M.read (| constant |);
                              M.read (| selector_column |);
                              M.read (| fixed_column |);
                              M.read (| advice_column |);
                              M.read (| instance_column |);
                              M.read (| negated |);
                              M.read (| sum |);
                              M.read (| product |);
                              M.read (| scaled |)
                            ]
                          |)
                        |) in
                      let b :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "evaluate",
                              [
                                T;
                                impl_Fn_F__arrow_T;
                                impl_Fn_Selector__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                impl_Fn_T__arrow_T;
                                impl_Fn_T__T__arrow_T;
                                impl_Fn__dyn_Fn___arrow_T___dyn_Fn___arrow_T__arrow_T;
                                impl_Fn_T__F__arrow_T
                              ]
                            |),
                            [
                              M.read (| M.read (| b |) |);
                              M.read (| constant |);
                              M.read (| selector_column |);
                              M.read (| fixed_column |);
                              M.read (| advice_column |);
                              M.read (| instance_column |);
                              M.read (| negated |);
                              M.read (| sum |);
                              M.read (| product |);
                              M.read (| scaled |)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_T__T__arrow_T,
                            [ Ty.tuple [ T; T ] ],
                            "call",
                            []
                          |),
                          [ M.read (| sum |); Value.Tuple [ M.read (| a |); M.read (| b |) ] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let b := M.alloc (| γ1_1 |) in
                      let a :=
                        M.alloc (|
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                                [ F ],
                                              "evaluate",
                                              [
                                                T;
                                                impl_Fn_F__arrow_T;
                                                impl_Fn_Selector__arrow_T;
                                                impl_Fn_usize__usize__Rotation__arrow_T;
                                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                                impl_Fn_T__arrow_T;
                                                impl_Fn_T__T__arrow_T;
                                                impl_Fn__dyn_Fn___arrow_T___dyn_Fn___arrow_T__arrow_T;
                                                impl_Fn_T__F__arrow_T
                                              ]
                                            |),
                                            [
                                              M.read (| M.read (| a |) |);
                                              M.read (| constant |);
                                              M.read (| selector_column |);
                                              M.read (| fixed_column |);
                                              M.read (| advice_column |);
                                              M.read (| instance_column |);
                                              M.read (| negated |);
                                              M.read (| sum |);
                                              M.read (| product |);
                                              M.read (| scaled |)
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        |) in
                      let b :=
                        M.alloc (|
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                                [ F ],
                                              "evaluate",
                                              [
                                                T;
                                                impl_Fn_F__arrow_T;
                                                impl_Fn_Selector__arrow_T;
                                                impl_Fn_usize__usize__Rotation__arrow_T;
                                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                                impl_Fn_T__arrow_T;
                                                impl_Fn_T__T__arrow_T;
                                                impl_Fn__dyn_Fn___arrow_T___dyn_Fn___arrow_T__arrow_T;
                                                impl_Fn_T__F__arrow_T
                                              ]
                                            |),
                                            [
                                              M.read (| M.read (| b |) |);
                                              M.read (| constant |);
                                              M.read (| selector_column |);
                                              M.read (| fixed_column |);
                                              M.read (| advice_column |);
                                              M.read (| instance_column |);
                                              M.read (| negated |);
                                              M.read (| sum |);
                                              M.read (| product |);
                                              M.read (| scaled |)
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn__dyn_Fn___arrow_T___dyn_Fn___arrow_T__arrow_T,
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ];
                                  Ty.apply
                                    (Ty.path "&")
                                    [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ]
                                ]
                            ],
                            "call",
                            []
                          |),
                          [
                            M.read (| product |);
                            Value.Tuple
                              [ (* Unsize *) M.pointer_coercion a; (* Unsize *) M.pointer_coercion b
                              ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let f := M.alloc (| γ1_1 |) in
                      let a :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "evaluate",
                              [
                                T;
                                impl_Fn_F__arrow_T;
                                impl_Fn_Selector__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                impl_Fn_T__arrow_T;
                                impl_Fn_T__T__arrow_T;
                                impl_Fn__dyn_Fn___arrow_T___dyn_Fn___arrow_T__arrow_T;
                                impl_Fn_T__F__arrow_T
                              ]
                            |),
                            [
                              M.read (| M.read (| a |) |);
                              M.read (| constant |);
                              M.read (| selector_column |);
                              M.read (| fixed_column |);
                              M.read (| advice_column |);
                              M.read (| instance_column |);
                              M.read (| negated |);
                              M.read (| sum |);
                              M.read (| product |);
                              M.read (| scaled |)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_T__F__arrow_T,
                            [ Ty.tuple [ T; F ] ],
                            "call",
                            []
                          |),
                          [
                            M.read (| scaled |);
                            Value.Tuple [ M.read (| a |); M.read (| M.read (| f |) |) ]
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_evaluate :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "evaluate" (evaluate F).
      
      (*
          pub fn evaluate_lazy<T: PartialEq>(
              &self,
              constant: &impl Fn(F) -> T,
              selector_column: &impl Fn(Selector) -> T,
              fixed_column: &impl Fn(usize, usize, Rotation) -> T,
              advice_column: &impl Fn(usize, usize, Rotation) -> T,
              instance_column: &impl Fn(usize, usize, Rotation) -> T,
              negated: &impl Fn(T) -> T,
              sum: &impl Fn(T, T) -> T,
              product: &impl Fn(T, T) -> T,
              scaled: &impl Fn(T, F) -> T,
              zero: &T,
          ) -> T {
              match self {
                  Expression::Constant(scalar) => constant( *scalar),
                  Expression::Selector(selector) => selector_column( *selector),
                  Expression::Fixed {
                      query_index,
                      column_index,
                      rotation,
                  } => fixed_column( *query_index, *column_index, *rotation),
                  Expression::Advice {
                      query_index,
                      column_index,
                      rotation,
                  } => advice_column( *query_index, *column_index, *rotation),
                  Expression::Instance {
                      query_index,
                      column_index,
                      rotation,
                  } => instance_column( *query_index, *column_index, *rotation),
                  Expression::Negated(a) => {
                      let a = a.evaluate_lazy(
                          constant,
                          selector_column,
                          fixed_column,
                          advice_column,
                          instance_column,
                          negated,
                          sum,
                          product,
                          scaled,
                          zero,
                      );
                      negated(a)
                  }
                  Expression::Sum(a, b) => {
                      let a = a.evaluate_lazy(
                          constant,
                          selector_column,
                          fixed_column,
                          advice_column,
                          instance_column,
                          negated,
                          sum,
                          product,
                          scaled,
                          zero,
                      );
                      let b = b.evaluate_lazy(
                          constant,
                          selector_column,
                          fixed_column,
                          advice_column,
                          instance_column,
                          negated,
                          sum,
                          product,
                          scaled,
                          zero,
                      );
                      sum(a, b)
                  }
                  Expression::Product(a, b) => {
                      let (a, b) = if a.complexity() <= b.complexity() {
                          (a, b)
                      } else {
                          (b, a)
                      };
                      let a = a.evaluate_lazy(
                          constant,
                          selector_column,
                          fixed_column,
                          advice_column,
                          instance_column,
                          negated,
                          sum,
                          product,
                          scaled,
                          zero,
                      );
      
                      if a == *zero {
                          a
                      } else {
                          let b = b.evaluate_lazy(
                              constant,
                              selector_column,
                              fixed_column,
                              advice_column,
                              instance_column,
                              negated,
                              sum,
                              product,
                              scaled,
                              zero,
                          );
                          product(a, b)
                      }
                  }
                  Expression::Scaled(a, f) => {
                      let a = a.evaluate_lazy(
                          constant,
                          selector_column,
                          fixed_column,
                          advice_column,
                          instance_column,
                          negated,
                          sum,
                          product,
                          scaled,
                          zero,
                      );
                      scaled(a, *f)
                  }
              }
          }
      *)
      Definition evaluate_lazy (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [
              T;
              impl_Fn_F__arrow_T;
              impl_Fn_Selector__arrow_T;
              impl_Fn_usize__usize__Rotation__arrow_T;
              impl_Fn_usize__usize__Rotation__arrow_T'1;
              impl_Fn_usize__usize__Rotation__arrow_T'2;
              impl_Fn_T__arrow_T;
              impl_Fn_T__T__arrow_T;
              impl_Fn_T__T__arrow_T'1;
              impl_Fn_T__F__arrow_T
            ],
            [
              self;
              constant;
              selector_column;
              fixed_column;
              advice_column;
              instance_column;
              negated;
              sum;
              product;
              scaled;
              zero
            ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let constant := M.alloc (| constant |) in
            let selector_column := M.alloc (| selector_column |) in
            let fixed_column := M.alloc (| fixed_column |) in
            let advice_column := M.alloc (| advice_column |) in
            let instance_column := M.alloc (| instance_column |) in
            let negated := M.alloc (| negated |) in
            let sum := M.alloc (| sum |) in
            let product := M.alloc (| product |) in
            let scaled := M.alloc (| scaled |) in
            let zero := M.alloc (| zero |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Constant",
                          0
                        |) in
                      let scalar := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_F__arrow_T,
                            [ Ty.tuple [ F ] ],
                            "call",
                            []
                          |),
                          [ M.read (| constant |); Value.Tuple [ M.read (| M.read (| scalar |) |) ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Selector",
                          0
                        |) in
                      let selector := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_Selector__arrow_T,
                            [ Ty.tuple [ Ty.path "halo2_proofs::plonk::circuit::Selector" ] ],
                            "call",
                            []
                          |),
                          [
                            M.read (| selector_column |);
                            Value.Tuple [ M.read (| M.read (| selector |) |) ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "rotation"
                        |) in
                      let query_index := M.alloc (| γ1_0 |) in
                      let column_index := M.alloc (| γ1_1 |) in
                      let rotation := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_usize__usize__Rotation__arrow_T,
                            [
                              Ty.tuple
                                [
                                  Ty.path "usize";
                                  Ty.path "usize";
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ]
                            ],
                            "call",
                            []
                          |),
                          [
                            M.read (| fixed_column |);
                            Value.Tuple
                              [
                                M.read (| M.read (| query_index |) |);
                                M.read (| M.read (| column_index |) |);
                                M.read (| M.read (| rotation |) |)
                              ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "rotation"
                        |) in
                      let query_index := M.alloc (| γ1_0 |) in
                      let column_index := M.alloc (| γ1_1 |) in
                      let rotation := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_usize__usize__Rotation__arrow_T'1,
                            [
                              Ty.tuple
                                [
                                  Ty.path "usize";
                                  Ty.path "usize";
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ]
                            ],
                            "call",
                            []
                          |),
                          [
                            M.read (| advice_column |);
                            Value.Tuple
                              [
                                M.read (| M.read (| query_index |) |);
                                M.read (| M.read (| column_index |) |);
                                M.read (| M.read (| rotation |) |)
                              ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "rotation"
                        |) in
                      let query_index := M.alloc (| γ1_0 |) in
                      let column_index := M.alloc (| γ1_1 |) in
                      let rotation := M.alloc (| γ1_2 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_usize__usize__Rotation__arrow_T'2,
                            [
                              Ty.tuple
                                [
                                  Ty.path "usize";
                                  Ty.path "usize";
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ]
                            ],
                            "call",
                            []
                          |),
                          [
                            M.read (| instance_column |);
                            Value.Tuple
                              [
                                M.read (| M.read (| query_index |) |);
                                M.read (| M.read (| column_index |) |);
                                M.read (| M.read (| rotation |) |)
                              ]
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Negated",
                          0
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let a :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "evaluate_lazy",
                              [
                                T;
                                impl_Fn_F__arrow_T;
                                impl_Fn_Selector__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                impl_Fn_T__arrow_T;
                                impl_Fn_T__T__arrow_T;
                                impl_Fn_T__T__arrow_T'1;
                                impl_Fn_T__F__arrow_T
                              ]
                            |),
                            [
                              M.read (| M.read (| a |) |);
                              M.read (| constant |);
                              M.read (| selector_column |);
                              M.read (| fixed_column |);
                              M.read (| advice_column |);
                              M.read (| instance_column |);
                              M.read (| negated |);
                              M.read (| sum |);
                              M.read (| product |);
                              M.read (| scaled |);
                              M.read (| zero |)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_T__arrow_T,
                            [ Ty.tuple [ T ] ],
                            "call",
                            []
                          |),
                          [ M.read (| negated |); Value.Tuple [ M.read (| a |) ] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let b := M.alloc (| γ1_1 |) in
                      let a :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "evaluate_lazy",
                              [
                                T;
                                impl_Fn_F__arrow_T;
                                impl_Fn_Selector__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                impl_Fn_T__arrow_T;
                                impl_Fn_T__T__arrow_T;
                                impl_Fn_T__T__arrow_T'1;
                                impl_Fn_T__F__arrow_T
                              ]
                            |),
                            [
                              M.read (| M.read (| a |) |);
                              M.read (| constant |);
                              M.read (| selector_column |);
                              M.read (| fixed_column |);
                              M.read (| advice_column |);
                              M.read (| instance_column |);
                              M.read (| negated |);
                              M.read (| sum |);
                              M.read (| product |);
                              M.read (| scaled |);
                              M.read (| zero |)
                            ]
                          |)
                        |) in
                      let b :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "evaluate_lazy",
                              [
                                T;
                                impl_Fn_F__arrow_T;
                                impl_Fn_Selector__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                impl_Fn_T__arrow_T;
                                impl_Fn_T__T__arrow_T;
                                impl_Fn_T__T__arrow_T'1;
                                impl_Fn_T__F__arrow_T
                              ]
                            |),
                            [
                              M.read (| M.read (| b |) |);
                              M.read (| constant |);
                              M.read (| selector_column |);
                              M.read (| fixed_column |);
                              M.read (| advice_column |);
                              M.read (| instance_column |);
                              M.read (| negated |);
                              M.read (| sum |);
                              M.read (| product |);
                              M.read (| scaled |);
                              M.read (| zero |)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_T__T__arrow_T,
                            [ Ty.tuple [ T; T ] ],
                            "call",
                            []
                          |),
                          [ M.read (| sum |); Value.Tuple [ M.read (| a |); M.read (| b |) ] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let b := M.alloc (| γ1_1 |) in
                      M.match_operator (|
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      BinOp.Pure.le
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ],
                                            "complexity",
                                            []
                                          |),
                                          [ M.read (| M.read (| a |) |) ]
                                        |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ],
                                            "complexity",
                                            []
                                          |),
                                          [ M.read (| M.read (| b |) |) ]
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (| Value.Tuple [ M.read (| a |); M.read (| b |) ] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (| Value.Tuple [ M.read (| b |); M.read (| a |) ] |)))
                          ]
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let a := M.copy (| γ0_0 |) in
                              let b := M.copy (| γ0_1 |) in
                              let a :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                        [ F ],
                                      "evaluate_lazy",
                                      [
                                        T;
                                        impl_Fn_F__arrow_T;
                                        impl_Fn_Selector__arrow_T;
                                        impl_Fn_usize__usize__Rotation__arrow_T;
                                        impl_Fn_usize__usize__Rotation__arrow_T'1;
                                        impl_Fn_usize__usize__Rotation__arrow_T'2;
                                        impl_Fn_T__arrow_T;
                                        impl_Fn_T__T__arrow_T;
                                        impl_Fn_T__T__arrow_T'1;
                                        impl_Fn_T__F__arrow_T
                                      ]
                                    |),
                                    [
                                      M.read (| M.read (| a |) |);
                                      M.read (| constant |);
                                      M.read (| selector_column |);
                                      M.read (| fixed_column |);
                                      M.read (| advice_column |);
                                      M.read (| instance_column |);
                                      M.read (| negated |);
                                      M.read (| sum |);
                                      M.read (| product |);
                                      M.read (| scaled |);
                                      M.read (| zero |)
                                    ]
                                  |)
                                |) in
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::cmp::PartialEq",
                                                T,
                                                [ T ],
                                                "eq",
                                                []
                                              |),
                                              [ a; M.read (| zero |) ]
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      a));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let b :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                                [ F ],
                                              "evaluate_lazy",
                                              [
                                                T;
                                                impl_Fn_F__arrow_T;
                                                impl_Fn_Selector__arrow_T;
                                                impl_Fn_usize__usize__Rotation__arrow_T;
                                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                                impl_Fn_T__arrow_T;
                                                impl_Fn_T__T__arrow_T;
                                                impl_Fn_T__T__arrow_T'1;
                                                impl_Fn_T__F__arrow_T
                                              ]
                                            |),
                                            [
                                              M.read (| M.read (| b |) |);
                                              M.read (| constant |);
                                              M.read (| selector_column |);
                                              M.read (| fixed_column |);
                                              M.read (| advice_column |);
                                              M.read (| instance_column |);
                                              M.read (| negated |);
                                              M.read (| sum |);
                                              M.read (| product |);
                                              M.read (| scaled |);
                                              M.read (| zero |)
                                            ]
                                          |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::function::Fn",
                                            impl_Fn_T__T__arrow_T'1,
                                            [ Ty.tuple [ T; T ] ],
                                            "call",
                                            []
                                          |),
                                          [
                                            M.read (| product |);
                                            Value.Tuple [ M.read (| a |); M.read (| b |) ]
                                          ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let f := M.alloc (| γ1_1 |) in
                      let a :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "evaluate_lazy",
                              [
                                T;
                                impl_Fn_F__arrow_T;
                                impl_Fn_Selector__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T;
                                impl_Fn_usize__usize__Rotation__arrow_T'1;
                                impl_Fn_usize__usize__Rotation__arrow_T'2;
                                impl_Fn_T__arrow_T;
                                impl_Fn_T__T__arrow_T;
                                impl_Fn_T__T__arrow_T'1;
                                impl_Fn_T__F__arrow_T
                              ]
                            |),
                            [
                              M.read (| M.read (| a |) |);
                              M.read (| constant |);
                              M.read (| selector_column |);
                              M.read (| fixed_column |);
                              M.read (| advice_column |);
                              M.read (| instance_column |);
                              M.read (| negated |);
                              M.read (| sum |);
                              M.read (| product |);
                              M.read (| scaled |);
                              M.read (| zero |)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            impl_Fn_T__F__arrow_T,
                            [ Ty.tuple [ T; F ] ],
                            "call",
                            []
                          |),
                          [
                            M.read (| scaled |);
                            Value.Tuple [ M.read (| a |); M.read (| M.read (| f |) |) ]
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_evaluate_lazy :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "evaluate_lazy" (evaluate_lazy F).
      
      (*
          pub fn identifier(&self) -> String {
              match self {
                  Expression::Constant(scalar) => format!("{:?}", scalar),
                  Expression::Selector(selector) => format!("selector[{}]", selector.0),
                  Expression::Fixed {
                      query_index: _,
                      column_index,
                      rotation,
                  } => format!("fixed[{}][{}]", column_index, rotation.0),
                  Expression::Advice {
                      query_index: _,
                      column_index,
                      rotation,
                  } => format!("advice[{}][{}]", column_index, rotation.0),
                  Expression::Instance {
                      query_index: _,
                      column_index,
                      rotation,
                  } => format!("instance[{}][{}]", column_index, rotation.0),
                  Expression::Negated(a) => {
                      format!("(-{})", a.identifier())
                  }
                  Expression::Sum(a, b) => {
                      format!("({}+{})", a.identifier(), b.identifier())
                  }
                  Expression::Product(a, b) => {
                      format!("({}*{})", a.identifier(), b.identifier())
                  }
                  Expression::Scaled(a, f) => {
                      format!("{}*{:?}", a.identifier(), f)
                  }
              }
          }
      *)
      Definition identifier (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Constant",
                          0
                        |) in
                      let scalar := M.alloc (| γ1_0 |) in
                      let res :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "alloc::fmt::format", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (| Value.Array [ M.read (| Value.String "" |) ] |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [ Ty.apply (Ty.path "&") [ F ] ]
                                            |),
                                            [ scalar ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Selector",
                          0
                        |) in
                      let selector := M.alloc (| γ1_0 |) in
                      let res :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "alloc::fmt::format", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "selector[" |);
                                          M.read (| Value.String "]" |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "usize" ]
                                            |),
                                            [
                                              M.SubPointer.get_struct_tuple_field (|
                                                M.read (| selector |),
                                                "halo2_proofs::plonk::circuit::Selector",
                                                0
                                              |)
                                            ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Fixed",
                          "rotation"
                        |) in
                      let column_index := M.alloc (| γ1_1 |) in
                      let rotation := M.alloc (| γ1_2 |) in
                      let res :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "alloc::fmt::format", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "fixed[" |);
                                          M.read (| Value.String "][" |);
                                          M.read (| Value.String "]" |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "usize" ] ]
                                            |),
                                            [ column_index ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "i32" ]
                                            |),
                                            [
                                              M.SubPointer.get_struct_tuple_field (|
                                                M.read (| rotation |),
                                                "halo2_proofs::poly::Rotation",
                                                0
                                              |)
                                            ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Advice",
                          "rotation"
                        |) in
                      let column_index := M.alloc (| γ1_1 |) in
                      let rotation := M.alloc (| γ1_2 |) in
                      let res :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "alloc::fmt::format", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "advice[" |);
                                          M.read (| Value.String "][" |);
                                          M.read (| Value.String "]" |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "usize" ] ]
                                            |),
                                            [ column_index ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "i32" ]
                                            |),
                                            [
                                              M.SubPointer.get_struct_tuple_field (|
                                                M.read (| rotation |),
                                                "halo2_proofs::poly::Rotation",
                                                0
                                              |)
                                            ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "query_index"
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "column_index"
                        |) in
                      let γ1_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Instance",
                          "rotation"
                        |) in
                      let column_index := M.alloc (| γ1_1 |) in
                      let rotation := M.alloc (| γ1_2 |) in
                      let res :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "alloc::fmt::format", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "instance[" |);
                                          M.read (| Value.String "][" |);
                                          M.read (| Value.String "]" |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "usize" ] ]
                                            |),
                                            [ column_index ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "i32" ]
                                            |),
                                            [
                                              M.SubPointer.get_struct_tuple_field (|
                                                M.read (| rotation |),
                                                "halo2_proofs::poly::Rotation",
                                                0
                                              |)
                                            ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Negated",
                          0
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let res :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "alloc::fmt::format", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "(-" |);
                                          M.read (| Value.String ")" |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "alloc::string::String" ]
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Expression")
                                                      [ F ],
                                                    "identifier",
                                                    []
                                                  |),
                                                  [ M.read (| M.read (| a |) |) ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let b := M.alloc (| γ1_1 |) in
                      let res :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "alloc::fmt::format", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "(" |);
                                          M.read (| Value.String "+" |);
                                          M.read (| Value.String ")" |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "alloc::string::String" ]
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Expression")
                                                      [ F ],
                                                    "identifier",
                                                    []
                                                  |),
                                                  [ M.read (| M.read (| a |) |) ]
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "alloc::string::String" ]
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Expression")
                                                      [ F ],
                                                    "identifier",
                                                    []
                                                  |),
                                                  [ M.read (| M.read (| b |) |) ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let b := M.alloc (| γ1_1 |) in
                      let res :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "alloc::fmt::format", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "(" |);
                                          M.read (| Value.String "*" |);
                                          M.read (| Value.String ")" |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "alloc::string::String" ]
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Expression")
                                                      [ F ],
                                                    "identifier",
                                                    []
                                                  |),
                                                  [ M.read (| M.read (| a |) |) ]
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "alloc::string::String" ]
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Expression")
                                                      [ F ],
                                                    "identifier",
                                                    []
                                                  |),
                                                  [ M.read (| M.read (| b |) |) ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let f := M.alloc (| γ1_1 |) in
                      let res :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "alloc::fmt::format", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "" |);
                                          M.read (| Value.String "*" |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "alloc::string::String" ]
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Expression")
                                                      [ F ],
                                                    "identifier",
                                                    []
                                                  |),
                                                  [ M.read (| M.read (| a |) |) ]
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [ Ty.apply (Ty.path "&") [ F ] ]
                                            |),
                                            [ f ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_identifier :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "identifier" (identifier F).
      
      (*
          pub fn degree(&self) -> usize {
              match self {
                  Expression::Constant(_) => 0,
                  Expression::Selector(_) => 1,
                  Expression::Fixed { .. } => 1,
                  Expression::Advice { .. } => 1,
                  Expression::Instance { .. } => 1,
                  Expression::Negated(poly) => poly.degree(),
                  Expression::Sum(a, b) => max(a.degree(), b.degree()),
                  Expression::Product(a, b) => a.degree() + b.degree(),
                  Expression::Scaled(poly, _) => poly.degree(),
              }
          }
      *)
      Definition degree (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Constant",
                          0
                        |) in
                      M.alloc (| Value.Integer 0 |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Selector",
                          0
                        |) in
                      M.alloc (| Value.Integer 1 |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (| Value.Integer 1 |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (| Value.Integer 1 |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (| Value.Integer 1 |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Negated",
                          0
                        |) in
                      let poly := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                            "degree",
                            []
                          |),
                          [ M.read (| M.read (| poly |) |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let b := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                                "degree",
                                []
                              |),
                              [ M.read (| M.read (| a |) |) ]
                            |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                                "degree",
                                []
                              |),
                              [ M.read (| M.read (| b |) |) ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let b := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        BinOp.Panic.add (|
                          Integer.Usize,
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "degree",
                              []
                            |),
                            [ M.read (| M.read (| a |) |) ]
                          |),
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "degree",
                              []
                            |),
                            [ M.read (| M.read (| b |) |) ]
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          1
                        |) in
                      let poly := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                            "degree",
                            []
                          |),
                          [ M.read (| M.read (| poly |) |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_degree :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "degree" (degree F).
      
      (*
          pub fn complexity(&self) -> usize {
              match self {
                  Expression::Constant(_) => 0,
                  Expression::Selector(_) => 1,
                  Expression::Fixed { .. } => 1,
                  Expression::Advice { .. } => 1,
                  Expression::Instance { .. } => 1,
                  Expression::Negated(poly) => poly.complexity() + 5,
                  Expression::Sum(a, b) => a.complexity() + b.complexity() + 15,
                  Expression::Product(a, b) => a.complexity() + b.complexity() + 30,
                  Expression::Scaled(poly, _) => poly.complexity() + 30,
              }
          }
      *)
      Definition complexity (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Constant",
                          0
                        |) in
                      M.alloc (| Value.Integer 0 |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Selector",
                          0
                        |) in
                      M.alloc (| Value.Integer 1 |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (| Value.Integer 1 |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (| Value.Integer 1 |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (| Value.Integer 1 |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Negated",
                          0
                        |) in
                      let poly := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        BinOp.Panic.add (|
                          Integer.Usize,
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "complexity",
                              []
                            |),
                            [ M.read (| M.read (| poly |) |) ]
                          |),
                          Value.Integer 5
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Sum",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let b := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        BinOp.Panic.add (|
                          Integer.Usize,
                          BinOp.Panic.add (|
                            Integer.Usize,
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                                "complexity",
                                []
                              |),
                              [ M.read (| M.read (| a |) |) ]
                            |),
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                                "complexity",
                                []
                              |),
                              [ M.read (| M.read (| b |) |) ]
                            |)
                          |),
                          Value.Integer 15
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Product",
                          1
                        |) in
                      let a := M.alloc (| γ1_0 |) in
                      let b := M.alloc (| γ1_1 |) in
                      M.alloc (|
                        BinOp.Panic.add (|
                          Integer.Usize,
                          BinOp.Panic.add (|
                            Integer.Usize,
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                                "complexity",
                                []
                              |),
                              [ M.read (| M.read (| a |) |) ]
                            |),
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                                "complexity",
                                []
                              |),
                              [ M.read (| M.read (| b |) |) ]
                            |)
                          |),
                          Value.Integer 30
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          0
                        |) in
                      let γ1_1 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::circuit::Expression::Scaled",
                          1
                        |) in
                      let poly := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        BinOp.Panic.add (|
                          Integer.Usize,
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                              "complexity",
                              []
                            |),
                            [ M.read (| M.read (| poly |) |) ]
                          |),
                          Value.Integer 30
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_complexity :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "complexity" (complexity F).
      
      (*
          pub fn square(self) -> Self {
              self.clone() * self
          }
      *)
      Definition square (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::arith::Mul",
                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ] ],
                "mul",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                    [],
                    "clone",
                    []
                  |),
                  [ self ]
                |);
                M.read (| self |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_square :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "square" (square F).
      
      (*
          fn contains_simple_selector(&self) -> bool {
              self.evaluate(
                  &|_| false,
                  &|selector| selector.is_simple(),
                  &|_, _, _| false,
                  &|_, _, _| false,
                  &|_, _, _| false,
                  &|a| a,
                  &|a, b| a || b,
                  &|a, b| a() || b(),
                  &|a, _| a,
              )
          }
      *)
      Definition contains_simple_selector (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                "evaluate",
                [
                  Ty.path "bool";
                  Ty.function [ Ty.tuple [ F ] ] (Ty.path "bool");
                  Ty.function
                    [ Ty.tuple [ Ty.path "halo2_proofs::plonk::circuit::Selector" ] ]
                    (Ty.path "bool");
                  Ty.function
                    [
                      Ty.tuple
                        [ Ty.path "usize"; Ty.path "usize"; Ty.path "halo2_proofs::poly::Rotation" ]
                    ]
                    (Ty.path "bool");
                  Ty.function
                    [
                      Ty.tuple
                        [ Ty.path "usize"; Ty.path "usize"; Ty.path "halo2_proofs::poly::Rotation" ]
                    ]
                    (Ty.path "bool");
                  Ty.function
                    [
                      Ty.tuple
                        [ Ty.path "usize"; Ty.path "usize"; Ty.path "halo2_proofs::poly::Rotation" ]
                    ]
                    (Ty.path "bool");
                  Ty.function [ Ty.tuple [ Ty.path "bool" ] ] (Ty.path "bool");
                  Ty.function [ Ty.tuple [ Ty.path "bool"; Ty.path "bool" ] ] (Ty.path "bool");
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ];
                          Ty.apply
                            (Ty.path "&")
                            [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ]
                        ]
                    ]
                    (Ty.path "bool");
                  Ty.function [ Ty.tuple [ Ty.path "bool"; F ] ] (Ty.path "bool")
                ]
              |),
              [
                M.read (| self |);
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [ fun γ => ltac:(M.monadic (Value.Bool false)) ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |);
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let selector := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "halo2_proofs::plonk::circuit::Selector",
                                      "is_simple",
                                      []
                                    |),
                                    [ selector ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |);
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1; α2 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            M.alloc (| α2 |),
                                            [ fun γ => ltac:(M.monadic (Value.Bool false)) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |);
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1; α2 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            M.alloc (| α2 |),
                                            [ fun γ => ltac:(M.monadic (Value.Bool false)) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |);
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1; α2 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            M.alloc (| α2 |),
                                            [ fun γ => ltac:(M.monadic (Value.Bool false)) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |);
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.read (| a |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |);
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          LogicalOp.or (|
                                            M.read (| a |),
                                            ltac:(M.monadic (M.read (| b |)))
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |);
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          LogicalOp.or (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::function::Fn",
                                                Ty.dyn [ ("core::ops::function::Fn::Trait", []) ],
                                                [ Ty.tuple [] ],
                                                "call",
                                                []
                                              |),
                                              [ M.read (| a |); Value.Tuple [] ]
                                            |),
                                            ltac:(M.monadic
                                              (M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::Fn",
                                                  Ty.dyn [ ("core::ops::function::Fn::Trait", []) ],
                                                  [ Ty.tuple [] ],
                                                  "call",
                                                  []
                                                |),
                                                [ M.read (| b |); Value.Tuple [] ]
                                              |)))
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |);
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [ fun γ => ltac:(M.monadic (M.read (| a |))) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_contains_simple_selector :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "contains_simple_selector" (contains_simple_selector F).
      
      (*
          fn extract_simple_selector(&self) -> Option<Selector> {
              let op = |a, b| match (a, b) {
                  (Some(a), None) | (None, Some(a)) => Some(a),
                  (Some(_), Some(_)) => panic!("two simple selectors cannot be in the same expression"),
                  _ => None,
              };
      
              self.evaluate(
                  &|_| None,
                  &|selector| {
                      if selector.is_simple() {
                          Some(selector)
                      } else {
                          None
                      }
                  },
                  &|_, _, _| None,
                  &|_, _, _| None,
                  &|_, _, _| None,
                  &|a| a,
                  &op,
                  &|a, b| match (a(), b()) {
                      (Some(a), None) | (None, Some(a)) => Some(a),
                      (Some(_), Some(_)) => {
                          panic!("two simple selectors cannot be in the same expression")
                      }
                      _ => None,
                  },
                  &|a, _| a,
              )
          }
      *)
      Definition extract_simple_selector (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let op :=
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.read (|
                                            M.match_operator (|
                                              M.alloc (|
                                                Value.Tuple [ M.read (| a |); M.read (| b |) ]
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.find_or_pattern (|
                                                      γ,
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_tuple_field (|
                                                                γ,
                                                                0
                                                              |) in
                                                            let γ0_1 :=
                                                              M.SubPointer.get_tuple_field (|
                                                                γ,
                                                                1
                                                              |) in
                                                            let γ1_0 :=
                                                              M.SubPointer.get_struct_tuple_field (|
                                                                γ0_0,
                                                                "core::option::Option::Some",
                                                                0
                                                              |) in
                                                            let a := M.copy (| γ1_0 |) in
                                                            Value.Tuple [ a ]));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_tuple_field (|
                                                                γ,
                                                                0
                                                              |) in
                                                            let γ0_1 :=
                                                              M.SubPointer.get_tuple_field (|
                                                                γ,
                                                                1
                                                              |) in
                                                            let γ1_0 :=
                                                              M.SubPointer.get_struct_tuple_field (|
                                                                γ0_1,
                                                                "core::option::Option::Some",
                                                                0
                                                              |) in
                                                            let a := M.copy (| γ1_0 |) in
                                                            Value.Tuple [ a ]))
                                                      ],
                                                      M.closure
                                                        (fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [ a ] =>
                                                              M.alloc (|
                                                                Value.StructTuple
                                                                  "core::option::Option::Some"
                                                                  [ M.read (| a |) ]
                                                              |)
                                                            | _ => M.impossible (||)
                                                            end))
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let γ1_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ0_0,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let γ1_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ0_1,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.call_closure (|
                                                          M.get_function (|
                                                            "std::panicking::begin_panic",
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [ Ty.path "str" ]
                                                            ]
                                                          |),
                                                          [
                                                            M.read (|
                                                              Value.String
                                                                "two simple selectors cannot be in the same expression"
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.alloc (|
                                                      Value.StructTuple
                                                        "core::option::Option::None"
                                                        []
                                                    |)))
                                              ]
                                            |)
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                    "evaluate",
                    [
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [ Ty.path "halo2_proofs::plonk::circuit::Selector" ];
                      Ty.function
                        [ Ty.tuple [ F ] ]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.path "halo2_proofs::plonk::circuit::Selector" ]);
                      Ty.function
                        [ Ty.tuple [ Ty.path "halo2_proofs::plonk::circuit::Selector" ] ]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.path "halo2_proofs::plonk::circuit::Selector" ]);
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.path "usize";
                              Ty.path "usize";
                              Ty.path "halo2_proofs::poly::Rotation"
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.path "halo2_proofs::plonk::circuit::Selector" ]);
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.path "usize";
                              Ty.path "usize";
                              Ty.path "halo2_proofs::poly::Rotation"
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.path "halo2_proofs::plonk::circuit::Selector" ]);
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.path "usize";
                              Ty.path "usize";
                              Ty.path "halo2_proofs::poly::Rotation"
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.path "halo2_proofs::plonk::circuit::Selector" ]);
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                [ Ty.path "halo2_proofs::plonk::circuit::Selector" ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.path "halo2_proofs::plonk::circuit::Selector" ]);
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                [ Ty.path "halo2_proofs::plonk::circuit::Selector" ];
                              Ty.apply
                                (Ty.path "core::option::Option")
                                [ Ty.path "halo2_proofs::plonk::circuit::Selector" ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.path "halo2_proofs::plonk::circuit::Selector" ]);
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "&")
                                [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ];
                              Ty.apply
                                (Ty.path "&")
                                [ Ty.dyn [ ("core::ops::function::Fn::Trait", []) ] ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.path "halo2_proofs::plonk::circuit::Selector" ]);
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                [ Ty.path "halo2_proofs::plonk::circuit::Selector" ];
                              F
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.path "halo2_proofs::plonk::circuit::Selector" ])
                    ]
                  |),
                  [
                    M.read (| self |);
                    M.alloc (|
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple "core::option::Option::None" []))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |);
                    M.alloc (|
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let selector := M.copy (| γ |) in
                                      M.read (|
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path
                                                            "halo2_proofs::plonk::circuit::Selector",
                                                          "is_simple",
                                                          []
                                                        |),
                                                        [ selector ]
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::option::Option::Some"
                                                    [ M.read (| selector |) ]
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.alloc (|
                                                  Value.StructTuple "core::option::Option::None" []
                                                |)))
                                          ]
                                        |)
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |);
                    M.alloc (|
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0; α1; α2 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        M.alloc (| α1 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                M.alloc (| α2 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (Value.StructTuple
                                                        "core::option::Option::None"
                                                        []))
                                                ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |);
                    M.alloc (|
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0; α1; α2 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        M.alloc (| α1 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                M.alloc (| α2 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (Value.StructTuple
                                                        "core::option::Option::None"
                                                        []))
                                                ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |);
                    M.alloc (|
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0; α1; α2 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        M.alloc (| α1 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                M.alloc (| α2 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (Value.StructTuple
                                                        "core::option::Option::None"
                                                        []))
                                                ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |);
                    M.alloc (|
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let a := M.copy (| γ |) in
                                      M.read (| a |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |);
                    op;
                    M.alloc (|
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0; α1 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let a := M.copy (| γ |) in
                                      M.match_operator (|
                                        M.alloc (| α1 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let b := M.copy (| γ |) in
                                              M.read (|
                                                M.match_operator (|
                                                  M.alloc (|
                                                    Value.Tuple
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::function::Fn",
                                                            Ty.dyn
                                                              [
                                                                ("core::ops::function::Fn::Trait",
                                                                  [])
                                                              ],
                                                            [ Ty.tuple [] ],
                                                            "call",
                                                            []
                                                          |),
                                                          [ M.read (| a |); Value.Tuple [] ]
                                                        |);
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::function::Fn",
                                                            Ty.dyn
                                                              [
                                                                ("core::ops::function::Fn::Trait",
                                                                  [])
                                                              ],
                                                            [ Ty.tuple [] ],
                                                            "call",
                                                            []
                                                          |),
                                                          [ M.read (| b |); Value.Tuple [] ]
                                                        |)
                                                      ]
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.find_or_pattern (|
                                                          γ,
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ,
                                                                    0
                                                                  |) in
                                                                let γ0_1 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ,
                                                                    1
                                                                  |) in
                                                                let γ1_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ0_0,
                                                                    "core::option::Option::Some",
                                                                    0
                                                                  |) in
                                                                let a := M.copy (| γ1_0 |) in
                                                                Value.Tuple [ a ]));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ,
                                                                    0
                                                                  |) in
                                                                let γ0_1 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ,
                                                                    1
                                                                  |) in
                                                                let γ1_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ0_1,
                                                                    "core::option::Option::Some",
                                                                    0
                                                                  |) in
                                                                let a := M.copy (| γ1_0 |) in
                                                                Value.Tuple [ a ]))
                                                          ],
                                                          M.closure
                                                            (fun γ =>
                                                              ltac:(M.monadic
                                                                match γ with
                                                                | [ a ] =>
                                                                  M.alloc (|
                                                                    Value.StructTuple
                                                                      "core::option::Option::Some"
                                                                      [ M.read (| a |) ]
                                                                  |)
                                                                | _ => M.impossible (||)
                                                                end))
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                        let γ0_1 :=
                                                          M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                        let γ1_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ0_0,
                                                            "core::option::Option::Some",
                                                            0
                                                          |) in
                                                        let γ1_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ0_1,
                                                            "core::option::Option::Some",
                                                            0
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.call_closure (|
                                                              M.get_function (|
                                                                "std::panicking::begin_panic",
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [ Ty.path "str" ]
                                                                ]
                                                              |),
                                                              [
                                                                M.read (|
                                                                  Value.String
                                                                    "two simple selectors cannot be in the same expression"
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (|
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                        |)))
                                                  ]
                                                |)
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |);
                    M.alloc (|
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0; α1 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let a := M.copy (| γ |) in
                                      M.match_operator (|
                                        M.alloc (| α1 |),
                                        [ fun γ => ltac:(M.monadic (M.read (| a |))) ]
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_extract_simple_selector :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "extract_simple_selector" (extract_simple_selector F).
    End Impl_halo2_proofs_plonk_circuit_Expression_F.
    
    Module Impl_core_ops_arith_Neg_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Expression_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*     type Output = Expression<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*
          fn neg(self) -> Self::Output {
              Expression::Negated(Box::new(self))
          }
      *)
      Definition neg (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "halo2_proofs::plonk::circuit::Expression::Negated"
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [
                        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("neg", InstanceField.Method (neg F)) ].
    End Impl_core_ops_arith_Neg_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Expression_F.
    
    Module Impl_core_ops_arith_Add_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Expression_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*     type Output = Expression<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*
          fn add(self, rhs: Expression<F>) -> Expression<F> {
              if self.contains_simple_selector() || rhs.contains_simple_selector() {
                  panic!("attempted to use a simple selector in an addition");
              }
              if Some(F::zero()) == self.is_constant() {
                  return rhs;
              }
              if Some(F::zero()) == rhs.is_constant() {
                  return self;
              }
              if let Some(l) = rhs.is_constant() {
                  if let Some(r) = self.is_constant() {
                      return Expression::Constant(l + r);
                  }
              }
              Expression::Sum(Box::new(self), Box::new(rhs))
          }
      *)
      Definition add (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                          [ F ],
                                        "contains_simple_selector",
                                        []
                                      |),
                                      [ self ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                            [ F ],
                                          "contains_simple_selector",
                                          []
                                        |),
                                        [ rhs ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (|
                                    "std::panicking::begin_panic",
                                    [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                  |),
                                  [
                                    M.read (|
                                      Value.String
                                        "attempted to use a simple selector in an addition"
                                    |)
                                  ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "core::option::Option") [ F ],
                                      [ Ty.apply (Ty.path "core::option::Option") [ F ] ],
                                      "eq",
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "ff::Field",
                                                F,
                                                [],
                                                "zero",
                                                []
                                              |),
                                              []
                                            |)
                                          ]
                                      |);
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ],
                                            "is_constant",
                                            []
                                          |),
                                          [ self ]
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| rhs |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "core::option::Option") [ F ],
                                      [ Ty.apply (Ty.path "core::option::Option") [ F ] ],
                                      "eq",
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "ff::Field",
                                                F,
                                                [],
                                                "zero",
                                                []
                                              |),
                                              []
                                            |)
                                          ]
                                      |);
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ],
                                            "is_constant",
                                            []
                                          |),
                                          [ rhs ]
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ],
                                    "is_constant",
                                    []
                                  |),
                                  [ rhs ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let l := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ],
                                            "is_constant",
                                            []
                                          |),
                                          [ self ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let r := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            Value.StructTuple
                                              "halo2_proofs::plonk::circuit::Expression::Constant"
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Add",
                                                    F,
                                                    [ F ],
                                                    "add",
                                                    []
                                                  |),
                                                  [ M.read (| l |); M.read (| r |) ]
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "halo2_proofs::plonk::circuit::Expression::Sum"
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            []
                          |),
                          [ M.read (| rhs |) ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("add", InstanceField.Method (add F)) ].
    End Impl_core_ops_arith_Add_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Expression_F.
    
    Module Impl_core_ops_arith_Sub_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Expression_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*     type Output = Expression<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*
          fn sub(self, rhs: Expression<F>) -> Expression<F> {
              if self.contains_simple_selector() || rhs.contains_simple_selector() {
                  panic!("attempted to use a simple selector in a subtraction");
              }
              Expression::Sum(Box::new(self), Box::new(-rhs))
          }
      *)
      Definition sub (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.or (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ],
                                    "contains_simple_selector",
                                    []
                                  |),
                                  [ self ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                        [ F ],
                                      "contains_simple_selector",
                                      []
                                    |),
                                    [ rhs ]
                                  |)))
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (|
                                "std::panicking::begin_panic",
                                [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                              |),
                              [
                                M.read (|
                                  Value.String "attempted to use a simple selector in a subtraction"
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                Value.StructTuple
                  "halo2_proofs::plonk::circuit::Expression::Sum"
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "new",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "new",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::arith::Neg",
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ],
                            [],
                            "neg",
                            []
                          |),
                          [ M.read (| rhs |) ]
                        |)
                      ]
                    |)
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("sub", InstanceField.Method (sub F)) ].
    End Impl_core_ops_arith_Sub_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Expression_F.
    
    Module Impl_core_ops_arith_Mul_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Expression_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*     type Output = Expression<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*
          fn mul(self, rhs: Expression<F>) -> Expression<F> {
              if self.contains_simple_selector() && rhs.contains_simple_selector() {
                  panic!("attempted to multiply two expressions containing simple selectors");
              }
              if Some(F::one()) == self.is_constant() {
                  return rhs;
              }
              if Some(F::one()) == rhs.is_constant() {
                  return self;
              }
              if let Some(l) = rhs.is_constant() {
                  if let Some(r) = self.is_constant() {
                      return Expression::Constant(l * r);
                  }
              }
              Expression::Product(Box::new(self), Box::new(rhs))
          }
      *)
      Definition mul (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                          [ F ],
                                        "contains_simple_selector",
                                        []
                                      |),
                                      [ self ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                            [ F ],
                                          "contains_simple_selector",
                                          []
                                        |),
                                        [ rhs ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (|
                                    "std::panicking::begin_panic",
                                    [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                  |),
                                  [
                                    M.read (|
                                      Value.String
                                        "attempted to multiply two expressions containing simple selectors"
                                    |)
                                  ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "core::option::Option") [ F ],
                                      [ Ty.apply (Ty.path "core::option::Option") [ F ] ],
                                      "eq",
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "ff::Field",
                                                F,
                                                [],
                                                "one",
                                                []
                                              |),
                                              []
                                            |)
                                          ]
                                      |);
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ],
                                            "is_constant",
                                            []
                                          |),
                                          [ self ]
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| rhs |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "core::option::Option") [ F ],
                                      [ Ty.apply (Ty.path "core::option::Option") [ F ] ],
                                      "eq",
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "ff::Field",
                                                F,
                                                [],
                                                "one",
                                                []
                                              |),
                                              []
                                            |)
                                          ]
                                      |);
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ],
                                            "is_constant",
                                            []
                                          |),
                                          [ rhs ]
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ],
                                    "is_constant",
                                    []
                                  |),
                                  [ rhs ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let l := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ],
                                            "is_constant",
                                            []
                                          |),
                                          [ self ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let r := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            Value.StructTuple
                                              "halo2_proofs::plonk::circuit::Expression::Constant"
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Mul",
                                                    F,
                                                    [ F ],
                                                    "mul",
                                                    []
                                                  |),
                                                  [ M.read (| l |); M.read (| r |) ]
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "halo2_proofs::plonk::circuit::Expression::Product"
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            []
                          |),
                          [ M.read (| self |) ]
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            []
                          |),
                          [ M.read (| rhs |) ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("mul", InstanceField.Method (mul F)) ].
    End Impl_core_ops_arith_Mul_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Expression_F.
    
    Module Impl_core_ops_arith_Mul_where_ff_Field_F_F_for_halo2_proofs_plonk_circuit_Expression_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*     type Output = Expression<F>; *)
      Definition _Output (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ].
      
      (*
          fn mul(self, rhs: F) -> Expression<F> {
              Expression::Scaled(Box::new(self), rhs)
          }
      *)
      Definition mul (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "halo2_proofs::plonk::circuit::Expression::Scaled"
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [
                        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.read (| rhs |)
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (Self F)
          (* Trait polymorphic types *) [ (* Rhs *) F ]
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("mul", InstanceField.Method (mul F)) ].
    End Impl_core_ops_arith_Mul_where_ff_Field_F_F_for_halo2_proofs_plonk_circuit_Expression_F.
    
    (* StructTuple
      {
        name := "PointIndex";
        ty_params := [];
        fields := [ Ty.path "usize" ];
      } *)
    
    Module Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_PointIndex.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::PointIndex".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_halo2_proofs_plonk_circuit_PointIndex.
    
    Module Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_PointIndex.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::PointIndex".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_PointIndex.
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_PointIndex.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::PointIndex".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_tuple_field1_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "PointIndex" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::PointIndex",
                      0
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_PointIndex.
    
    (* StructRecord
      {
        name := "VirtualCell";
        ty_params := [];
        fields :=
          [
            ("column",
              Ty.apply
                (Ty.path "halo2_proofs::plonk::circuit::Column")
                [ Ty.path "halo2_proofs::plonk::circuit::Any" ]);
            ("rotation", Ty.path "halo2_proofs::poly::Rotation")
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_VirtualCell.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::VirtualCell".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::VirtualCell"
              [
                ("column",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::VirtualCell",
                        "column"
                      |)
                    ]
                  |));
                ("rotation",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "halo2_proofs::poly::Rotation",
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::VirtualCell",
                        "rotation"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_halo2_proofs_plonk_circuit_VirtualCell.
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_VirtualCell.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::circuit::VirtualCell".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "VirtualCell" |);
                M.read (| Value.String "column" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::VirtualCell",
                    "column"
                  |));
                M.read (| Value.String "rotation" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::VirtualCell",
                      "rotation"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_plonk_circuit_VirtualCell.
    
    Module Impl_core_convert_From_where_core_convert_Into_Col_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any_Tuple_Col_halo2_proofs_poly_Rotation__for_halo2_proofs_plonk_circuit_VirtualCell.
      Definition Self (Col : Ty.t) : Ty.t := Ty.path "halo2_proofs::plonk::circuit::VirtualCell".
      
      (*
          fn from((column, rotation): (Col, Rotation)) -> Self {
              VirtualCell {
                  column: column.into(),
                  rotation,
              }
          }
      *)
      Definition from (Col : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self Col in
        match τ, α with
        | [], [ β0 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let column := M.copy (| γ0_0 |) in
                    let rotation := M.copy (| γ0_1 |) in
                    Value.StructRecord
                      "halo2_proofs::plonk::circuit::VirtualCell"
                      [
                        ("column",
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::convert::Into",
                              Col,
                              [
                                Ty.apply
                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                  [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                              ],
                              "into",
                              []
                            |),
                            [ M.read (| column |) ]
                          |));
                        ("rotation", M.read (| rotation |))
                      ]))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (Col : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self Col)
          (* Trait polymorphic types *)
          [ (* T *) Ty.tuple [ Col; Ty.path "halo2_proofs::poly::Rotation" ] ]
          (* Instance *) [ ("from", InstanceField.Method (from Col)) ].
    End Impl_core_convert_From_where_core_convert_Into_Col_halo2_proofs_plonk_circuit_Column_halo2_proofs_plonk_circuit_Any_Tuple_Col_halo2_proofs_poly_Rotation__for_halo2_proofs_plonk_circuit_VirtualCell.
    
    (* StructRecord
      {
        name := "Constraint";
        ty_params := [ "F" ];
        fields :=
          [
            ("name", Ty.apply (Ty.path "&") [ Ty.path "str" ]);
            ("poly", Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Constraint_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Constraint") [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Constraint" |);
                M.read (| Value.String "name" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::Constraint",
                    "name"
                  |));
                M.read (| Value.String "poly" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::Constraint",
                      "poly"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Constraint_F.
    
    Module Impl_core_convert_From_where_ff_Field_F_halo2_proofs_plonk_circuit_Expression_F_for_halo2_proofs_plonk_circuit_Constraint_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Constraint") [ F ].
      
      (*
          fn from(poly: Expression<F>) -> Self {
              Constraint { name: "", poly }
          }
      *)
      Definition from (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ poly ] =>
          ltac:(M.monadic
            (let poly := M.alloc (| poly |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::Constraint"
              [ ("name", M.read (| Value.String "" |)); ("poly", M.read (| poly |)) ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self F)
          (* Trait polymorphic types *)
          [ (* T *) Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ] ]
          (* Instance *) [ ("from", InstanceField.Method (from F)) ].
    End Impl_core_convert_From_where_ff_Field_F_halo2_proofs_plonk_circuit_Expression_F_for_halo2_proofs_plonk_circuit_Constraint_F.
    
    Module Impl_core_convert_From_where_ff_Field_F_Tuple_ref__str_halo2_proofs_plonk_circuit_Expression_F__for_halo2_proofs_plonk_circuit_Constraint_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Constraint") [ F ].
      
      (*
          fn from((name, poly): (&'static str, Expression<F>)) -> Self {
              Constraint { name, poly }
          }
      *)
      Definition from (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ β0 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let name := M.copy (| γ0_0 |) in
                    let poly := M.copy (| γ0_1 |) in
                    Value.StructRecord
                      "halo2_proofs::plonk::circuit::Constraint"
                      [ ("name", M.read (| name |)); ("poly", M.read (| poly |)) ]))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self F)
          (* Trait polymorphic types *)
          [
            (* T *)
            Ty.tuple
              [
                Ty.apply (Ty.path "&") [ Ty.path "str" ];
                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ]
              ]
          ]
          (* Instance *) [ ("from", InstanceField.Method (from F)) ].
    End Impl_core_convert_From_where_ff_Field_F_Tuple_ref__str_halo2_proofs_plonk_circuit_Expression_F__for_halo2_proofs_plonk_circuit_Constraint_F.
    
    Module Impl_core_convert_From_where_ff_Field_F_halo2_proofs_plonk_circuit_Expression_F_for_alloc_vec_Vec_halo2_proofs_plonk_circuit_Constraint_F_alloc_alloc_Global.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::vec::Vec")
          [
            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Constraint") [ F ];
            Ty.path "alloc::alloc::Global"
          ].
      
      (*
          fn from(poly: Expression<F>) -> Self {
              vec![Constraint { name: "", poly }]
          }
      *)
      Definition from (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ poly ] =>
          ltac:(M.monadic
            (let poly := M.alloc (| poly |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "slice")
                  [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Constraint") [ F ] ],
                "into_vec",
                [ Ty.path "alloc::alloc::Global" ]
              |),
              [
                (* Unsize *)
                M.pointer_coercion
                  (M.read (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Constraint") [ F ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "new",
                        []
                      |),
                      [
                        M.alloc (|
                          Value.Array
                            [
                              Value.StructRecord
                                "halo2_proofs::plonk::circuit::Constraint"
                                [
                                  ("name", M.read (| Value.String "" |));
                                  ("poly", M.read (| poly |))
                                ]
                            ]
                        |)
                      ]
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self F)
          (* Trait polymorphic types *)
          [ (* T *) Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ] ]
          (* Instance *) [ ("from", InstanceField.Method (from F)) ].
    End Impl_core_convert_From_where_ff_Field_F_halo2_proofs_plonk_circuit_Expression_F_for_alloc_vec_Vec_halo2_proofs_plonk_circuit_Constraint_F_alloc_alloc_Global.
    
    (* StructRecord
      {
        name := "Gate";
        ty_params := [ "F" ];
        fields :=
          [
            ("name", Ty.apply (Ty.path "&") [ Ty.path "str" ]);
            ("constraint_names",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.apply (Ty.path "&") [ Ty.path "str" ]; Ty.path "alloc::alloc::Global" ]);
            ("polys",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("queried_selectors",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "halo2_proofs::plonk::circuit::Selector"; Ty.path "alloc::alloc::Global"
                ]);
            ("queried_cells",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.path "halo2_proofs::plonk::circuit::VirtualCell";
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Gate_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ].
      
      (* Clone *)
      Definition clone (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::Gate"
              [
                ("name",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "&") [ Ty.path "str" ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::Gate",
                        "name"
                      |)
                    ]
                  |));
                ("constraint_names",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.apply (Ty.path "&") [ Ty.path "str" ]; Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::Gate",
                        "constraint_names"
                      |)
                    ]
                  |));
                ("polys",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::Gate",
                        "polys"
                      |)
                    ]
                  |));
                ("queried_selectors",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "halo2_proofs::plonk::circuit::Selector";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::Gate",
                        "queried_selectors"
                      |)
                    ]
                  |));
                ("queried_cells",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "halo2_proofs::plonk::circuit::VirtualCell";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::Gate",
                        "queried_cells"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Gate_F.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Gate_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field5_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Gate" |);
                M.read (| Value.String "name" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::Gate",
                    "name"
                  |));
                M.read (| Value.String "constraint_names" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::Gate",
                    "constraint_names"
                  |));
                M.read (| Value.String "polys" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::Gate",
                    "polys"
                  |));
                M.read (| Value.String "queried_selectors" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::Gate",
                    "queried_selectors"
                  |));
                M.read (| Value.String "queried_cells" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::Gate",
                      "queried_cells"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_Gate_F.
    
    Module Impl_halo2_proofs_plonk_circuit_Gate_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ].
      
      (*
          pub(crate) fn new_with_polys_and_queries(
              polys: Vec<Expression<F>>,
              queried_cells: Vec<VirtualCell>,
          ) -> Self {
              Gate {
                  name: "",
                  constraint_names: vec![],
                  polys,
                  queried_cells,
                  queried_selectors: vec![],
              }
          }
      *)
      Definition new_with_polys_and_queries (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ polys; queried_cells ] =>
          ltac:(M.monadic
            (let polys := M.alloc (| polys |) in
            let queried_cells := M.alloc (| queried_cells |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::Gate"
              [
                ("name", M.read (| Value.String "" |));
                ("constraint_names",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.apply (Ty.path "&") [ Ty.path "str" ]; Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("polys", M.read (| polys |));
                ("queried_cells", M.read (| queried_cells |));
                ("queried_selectors",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "halo2_proofs::plonk::circuit::Selector";
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_with_polys_and_queries :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "new_with_polys_and_queries" (new_with_polys_and_queries F).
      
      (*
          pub(crate) fn name(&self) -> &'static str {
              self.name
          }
      *)
      Definition name (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::plonk::circuit::Gate",
                "name"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_name :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "name" (name F).
      
      (*
          pub(crate) fn constraint_name(&self, constraint_index: usize) -> &'static str {
              self.constraint_names[constraint_index]
          }
      *)
      Definition constraint_name (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; constraint_index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let constraint_index := M.alloc (| constraint_index |) in
            M.read (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::index::Index",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.apply (Ty.path "&") [ Ty.path "str" ]; Ty.path "alloc::alloc::Global" ],
                  [ Ty.path "usize" ],
                  "index",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::Gate",
                    "constraint_names"
                  |);
                  M.read (| constraint_index |)
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_constraint_name :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "constraint_name" (constraint_name F).
      
      (*
          pub(crate) fn polynomials(&self) -> &[Expression<F>] {
              &self.polys
          }
      *)
      Definition polynomials (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::deref::Deref",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                    Ty.path "alloc::alloc::Global"
                  ],
                [],
                "deref",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::plonk::circuit::Gate",
                  "polys"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_polynomials :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "polynomials" (polynomials F).
      
      (*
          pub(crate) fn queried_selectors(&self) -> &[Selector] {
              &self.queried_selectors
          }
      *)
      Definition queried_selectors (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::deref::Deref",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "halo2_proofs::plonk::circuit::Selector"; Ty.path "alloc::alloc::Global"
                  ],
                [],
                "deref",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::plonk::circuit::Gate",
                  "queried_selectors"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_queried_selectors :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "queried_selectors" (queried_selectors F).
      
      (*
          pub(crate) fn queried_cells(&self) -> &[VirtualCell] {
              &self.queried_cells
          }
      *)
      Definition queried_cells (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::deref::Deref",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.path "halo2_proofs::plonk::circuit::VirtualCell";
                    Ty.path "alloc::alloc::Global"
                  ],
                [],
                "deref",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::plonk::circuit::Gate",
                  "queried_cells"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_queried_cells :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "queried_cells" (queried_cells F).
    End Impl_halo2_proofs_plonk_circuit_Gate_F.
    
    (* StructRecord
      {
        name := "ConstraintSystem";
        ty_params := [ "F" ];
        fields :=
          [
            ("num_fixed_columns", Ty.path "usize");
            ("num_advice_columns", Ty.path "usize");
            ("num_instance_columns", Ty.path "usize");
            ("num_selectors", Ty.path "usize");
            ("selector_map",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                    [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("gates",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("advice_queries",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                      Ty.path "halo2_proofs::poly::Rotation"
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("named_advices",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.tuple [ Ty.path "alloc::string::String"; Ty.path "u32" ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("num_advice_queries",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]);
            ("instance_queries",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                      Ty.path "halo2_proofs::poly::Rotation"
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("fixed_queries",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                      Ty.path "halo2_proofs::poly::Rotation"
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("permutation", Ty.path "halo2_proofs::plonk::permutation::Argument");
            ("lookups",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("constants",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                    [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("minimum_degree", Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_ConstraintSystem_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let names :=
                M.alloc (|
                  M.alloc (|
                    Value.Array
                      [
                        M.read (| Value.String "num_fixed_columns" |);
                        M.read (| Value.String "num_advice_columns" |);
                        M.read (| Value.String "num_instance_columns" |);
                        M.read (| Value.String "num_selectors" |);
                        M.read (| Value.String "selector_map" |);
                        M.read (| Value.String "gates" |);
                        M.read (| Value.String "advice_queries" |);
                        M.read (| Value.String "named_advices" |);
                        M.read (| Value.String "num_advice_queries" |);
                        M.read (| Value.String "instance_queries" |);
                        M.read (| Value.String "fixed_queries" |);
                        M.read (| Value.String "permutation" |);
                        M.read (| Value.String "lookups" |);
                        M.read (| Value.String "constants" |);
                        M.read (| Value.String "minimum_degree" |)
                      ]
                  |)
                |) in
              let values :=
                M.alloc (|
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "num_fixed_columns"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "num_advice_columns"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "num_instance_columns"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "num_selectors"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "selector_map"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "gates"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "advice_queries"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "named_advices"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "num_advice_queries"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "instance_queries"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "fixed_queries"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "permutation"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "lookups"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                              "constants"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.alloc (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::circuit::ConstraintSystem",
                                "minimum_degree"
                              |)
                            |))
                        ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "debug_struct_fields_finish",
                    []
                  |),
                  [
                    M.read (| f |);
                    M.read (| Value.String "ConstraintSystem" |);
                    (* Unsize *) M.pointer_coercion (M.read (| names |));
                    M.read (| values |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_ConstraintSystem_F.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_ConstraintSystem_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ].
      
      (* Clone *)
      Definition clone (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::ConstraintSystem"
              [
                ("num_fixed_columns",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Ty.path "usize", [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "num_fixed_columns"
                      |)
                    ]
                  |));
                ("num_advice_columns",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Ty.path "usize", [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "num_advice_columns"
                      |)
                    ]
                  |));
                ("num_instance_columns",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Ty.path "usize", [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "num_instance_columns"
                      |)
                    ]
                  |));
                ("num_selectors",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Ty.path "usize", [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "num_selectors"
                      |)
                    ]
                  |));
                ("selector_map",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "selector_map"
                      |)
                    ]
                  |));
                ("gates",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "gates"
                      |)
                    ]
                  |));
                ("advice_queries",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                              Ty.path "halo2_proofs::poly::Rotation"
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "advice_queries"
                      |)
                    ]
                  |));
                ("named_advices",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.tuple [ Ty.path "alloc::string::String"; Ty.path "u32" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "named_advices"
                      |)
                    ]
                  |));
                ("num_advice_queries",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "num_advice_queries"
                      |)
                    ]
                  |));
                ("instance_queries",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                              Ty.path "halo2_proofs::poly::Rotation"
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "instance_queries"
                      |)
                    ]
                  |));
                ("fixed_queries",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                              Ty.path "halo2_proofs::poly::Rotation"
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "fixed_queries"
                      |)
                    ]
                  |));
                ("permutation",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "halo2_proofs::plonk::permutation::Argument",
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "permutation"
                      |)
                    ]
                  |));
                ("lookups",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "lookups"
                      |)
                    ]
                  |));
                ("constants",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "constants"
                      |)
                    ]
                  |));
                ("minimum_degree",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "minimum_degree"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_ConstraintSystem_F.
    
    (* StructRecord
      {
        name := "PinnedConstraintSystem";
        ty_params := [ "F" ];
        fields :=
          [
            ("num_fixed_columns", Ty.apply (Ty.path "&") [ Ty.path "usize" ]);
            ("num_advice_columns", Ty.apply (Ty.path "&") [ Ty.path "usize" ]);
            ("num_instance_columns", Ty.apply (Ty.path "&") [ Ty.path "usize" ]);
            ("num_selectors", Ty.apply (Ty.path "&") [ Ty.path "usize" ]);
            ("selector_map",
              Ty.apply
                (Ty.path "&")
                [
                  Ty.apply
                    (Ty.path "slice")
                    [
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                    ]
                ]);
            ("gates", Ty.apply (Ty.path "halo2_proofs::plonk::circuit::PinnedGates") [ F ]);
            ("advice_queries",
              Ty.apply
                (Ty.path "&")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                          Ty.path "halo2_proofs::poly::Rotation"
                        ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ]);
            ("instance_queries",
              Ty.apply
                (Ty.path "&")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                          Ty.path "halo2_proofs::poly::Rotation"
                        ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ]);
            ("fixed_queries",
              Ty.apply
                (Ty.path "&")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                          Ty.path "halo2_proofs::poly::Rotation"
                        ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ]);
            ("permutation",
              Ty.apply (Ty.path "&") [ Ty.path "halo2_proofs::plonk::permutation::Argument" ]);
            ("lookups", Ty.apply (Ty.path "halo2_proofs::plonk::circuit::PinnedLookups") [ F ]);
            ("constants",
              Ty.apply
                (Ty.path "&")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ]);
            ("minimum_degree",
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_PinnedConstraintSystem_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::PinnedConstraintSystem") [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let names :=
                M.alloc (|
                  M.alloc (|
                    Value.Array
                      [
                        M.read (| Value.String "num_fixed_columns" |);
                        M.read (| Value.String "num_advice_columns" |);
                        M.read (| Value.String "num_instance_columns" |);
                        M.read (| Value.String "num_selectors" |);
                        M.read (| Value.String "selector_map" |);
                        M.read (| Value.String "gates" |);
                        M.read (| Value.String "advice_queries" |);
                        M.read (| Value.String "instance_queries" |);
                        M.read (| Value.String "fixed_queries" |);
                        M.read (| Value.String "permutation" |);
                        M.read (| Value.String "lookups" |);
                        M.read (| Value.String "constants" |);
                        M.read (| Value.String "minimum_degree" |)
                      ]
                  |)
                |) in
              let values :=
                M.alloc (|
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "num_fixed_columns"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "num_advice_columns"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "num_instance_columns"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "num_selectors"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "selector_map"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "gates"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "advice_queries"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "instance_queries"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "fixed_queries"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "permutation"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "lookups"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                              "constants"
                            |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.alloc (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::circuit::PinnedConstraintSystem",
                                "minimum_degree"
                              |)
                            |))
                        ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "debug_struct_fields_finish",
                    []
                  |),
                  [
                    M.read (| f |);
                    M.read (| Value.String "PinnedConstraintSystem" |);
                    (* Unsize *) M.pointer_coercion (M.read (| names |));
                    M.read (| values |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_PinnedConstraintSystem_F.
    
    (* StructTuple
      {
        name := "PinnedLookups";
        ty_params := [ "F" ];
        fields :=
          [
            Ty.apply
              (Ty.path "&")
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ]
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_ff_Field_F_for_halo2_proofs_plonk_circuit_PinnedLookups_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::PinnedLookups") [ F ].
      
      (*
          fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
              f.debug_list()
                  .entries(self.0.iter().enumerate().map(|(i, arg)| {
                      (
                          format!("lookup{}", i),
                          &arg.input_expressions,
                          &arg.table_expressions,
                      )
                  }))
                  .finish()
          }
      *)
      Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugList",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugList",
                    "entries",
                    [
                      Ty.tuple
                        [
                          Ty.path "alloc::string::String";
                          Ty.apply
                            (Ty.path "&")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ];
                          Ty.apply
                            (Ty.path "&")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                        ];
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                            [
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                [ Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ] ]
                            ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "usize";
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                            [ F ]
                                        ]
                                    ]
                                ]
                            ]
                            (Ty.tuple
                              [
                                Ty.path "alloc::string::String";
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                          [ F ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ];
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                          [ F ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ]
                              ])
                        ]
                    ]
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_list",
                          []
                        |),
                        [ M.read (| f |) ]
                      |)
                    |);
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                          [
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [ Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ] ]
                          ],
                        [],
                        "map",
                        [
                          Ty.tuple
                            [
                              Ty.path "alloc::string::String";
                              Ty.apply
                                (Ty.path "&")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                        [ F ];
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ];
                              Ty.apply
                                (Ty.path "&")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                        [ F ];
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ]
                            ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "usize";
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                            [ F ]
                                        ]
                                    ]
                                ]
                            ]
                            (Ty.tuple
                              [
                                Ty.path "alloc::string::String";
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                          [ F ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ];
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                          [ F ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ]
                              ])
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [ Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ] ],
                            [],
                            "enumerate",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ]
                                  ],
                                "iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                          [ F ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_tuple_field (|
                                        M.read (| self |),
                                        "halo2_proofs::plonk::circuit::PinnedLookups",
                                        0
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let i := M.copy (| γ0_0 |) in
                                        let arg := M.copy (| γ0_1 |) in
                                        Value.Tuple
                                          [
                                            M.read (|
                                              let res :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_function (| "alloc::fmt::format", [] |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::Arguments",
                                                          "new_v1",
                                                          []
                                                        |),
                                                        [
                                                          (* Unsize *)
                                                          M.pointer_coercion
                                                            (M.alloc (|
                                                              Value.Array
                                                                [ M.read (| Value.String "lookup" |)
                                                                ]
                                                            |));
                                                          (* Unsize *)
                                                          M.pointer_coercion
                                                            (M.alloc (|
                                                              Value.Array
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "core::fmt::rt::Argument",
                                                                      "new_display",
                                                                      [ Ty.path "usize" ]
                                                                    |),
                                                                    [ i ]
                                                                  |)
                                                                ]
                                                            |))
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              res
                                            |);
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| arg |),
                                              "halo2_proofs::plonk::lookup::Argument",
                                              "input_expressions"
                                            |);
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| arg |),
                                              "halo2_proofs::plonk::lookup::Argument",
                                              "table_expressions"
                                            |)
                                          ]))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_ff_Field_F_for_halo2_proofs_plonk_circuit_PinnedLookups_F.
    
    (* StructTuple
      {
        name := "PinnedGates";
        ty_params := [ "F" ];
        fields :=
          [
            Ty.apply
              (Ty.path "&")
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ]
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_ff_Field_F_for_halo2_proofs_plonk_circuit_PinnedGates_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::PinnedGates") [ F ].
      
      (*
          fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
              f.debug_list()
                  .entries(self.0.iter().flat_map(|gate| gate.polynomials().iter()))
                  .finish()
          }
      *)
      Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugList",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugList",
                    "entries",
                    [
                      Ty.apply
                        (Ty.path "&")
                        [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ] ];
                      Ty.apply
                        (Ty.path "core::iter::adapters::flatten::FlatMap")
                        [
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ] ];
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ] ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ]
                                    ]
                                ]
                            ]
                            (Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ]
                              ])
                        ]
                    ]
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_list",
                          []
                        |),
                        [ M.read (| f |) ]
                      |)
                    |);
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ] ],
                        [],
                        "flat_map",
                        [
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ] ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ]
                                    ]
                                ]
                            ]
                            (Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ]
                              ])
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ] ],
                            "iter",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "deref",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.read (| self |),
                                    "halo2_proofs::plonk::circuit::PinnedGates",
                                    0
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let gate := M.copy (| γ |) in
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "slice")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::circuit::Expression")
                                                  [ F ]
                                              ],
                                            "iter",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                                  [ F ],
                                                "polynomials",
                                                []
                                              |),
                                              [ M.read (| gate |) ]
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_ff_Field_F_for_halo2_proofs_plonk_circuit_PinnedGates_F.
    
    Module Impl_core_default_Default_where_ff_Field_F_for_halo2_proofs_plonk_circuit_ConstraintSystem_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ].
      
      (*
          fn default() -> ConstraintSystem<F> {
              ConstraintSystem {
                  num_fixed_columns: 0,
                  num_advice_columns: 0,
                  num_instance_columns: 0,
                  num_selectors: 0,
                  selector_map: vec![],
                  gates: vec![],
                  fixed_queries: Vec::new(),
                  advice_queries: Vec::new(),
                  named_advices: Vec::new(),
                  num_advice_queries: Vec::new(),
                  instance_queries: Vec::new(),
                  permutation: permutation::Argument::new(),
                  lookups: Vec::new(),
                  constants: vec![],
                  minimum_degree: None,
              }
          }
      *)
      Definition default (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "halo2_proofs::plonk::circuit::ConstraintSystem"
              [
                ("num_fixed_columns", Value.Integer 0);
                ("num_advice_columns", Value.Integer 0);
                ("num_instance_columns", Value.Integer 0);
                ("num_selectors", Value.Integer 0);
                ("selector_map",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("gates",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("fixed_queries",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                              Ty.path "halo2_proofs::poly::Rotation"
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("advice_queries",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                              Ty.path "halo2_proofs::poly::Rotation"
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("named_advices",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.tuple [ Ty.path "alloc::string::String"; Ty.path "u32" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("num_advice_queries",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("instance_queries",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                              Ty.path "halo2_proofs::poly::Rotation"
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("permutation",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "halo2_proofs::plonk::permutation::Argument",
                      "new",
                      []
                    |),
                    []
                  |));
                ("lookups",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("constants",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("minimum_degree", Value.StructTuple "core::option::Option::None" [])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method (default F)) ].
    End Impl_core_default_Default_where_ff_Field_F_for_halo2_proofs_plonk_circuit_ConstraintSystem_F.
    
    Module Impl_halo2_proofs_plonk_circuit_ConstraintSystem_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ].
      
      (*
          pub fn pinned(&self) -> PinnedConstraintSystem<'_, F> {
              PinnedConstraintSystem {
                  num_fixed_columns: &self.num_fixed_columns,
                  num_advice_columns: &self.num_advice_columns,
                  num_instance_columns: &self.num_instance_columns,
                  num_selectors: &self.num_selectors,
                  selector_map: &self.selector_map,
                  gates: PinnedGates(&self.gates),
                  fixed_queries: &self.fixed_queries,
                  advice_queries: &self.advice_queries,
                  instance_queries: &self.instance_queries,
                  permutation: &self.permutation,
                  lookups: PinnedLookups(&self.lookups),
                  constants: &self.constants,
                  minimum_degree: &self.minimum_degree,
              }
          }
      *)
      Definition pinned (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::PinnedConstraintSystem"
              [
                ("num_fixed_columns",
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_fixed_columns"
                  |));
                ("num_advice_columns",
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_advice_columns"
                  |));
                ("num_instance_columns",
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_instance_columns"
                  |));
                ("num_selectors",
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_selectors"
                  |));
                ("selector_map",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "deref",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "selector_map"
                      |)
                    ]
                  |));
                ("gates",
                  Value.StructTuple
                    "halo2_proofs::plonk::circuit::PinnedGates"
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "gates"
                      |)
                    ]);
                ("fixed_queries",
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "fixed_queries"
                  |));
                ("advice_queries",
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "advice_queries"
                  |));
                ("instance_queries",
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "instance_queries"
                  |));
                ("permutation",
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "permutation"
                  |));
                ("lookups",
                  Value.StructTuple
                    "halo2_proofs::plonk::circuit::PinnedLookups"
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "lookups"
                      |)
                    ]);
                ("constants",
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "constants"
                  |));
                ("minimum_degree",
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "minimum_degree"
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pinned :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "pinned" (pinned F).
      
      (*
          pub fn enable_constant(&mut self, column: Column<Fixed>) {
              if !self.constants.contains(&column) {
                  self.constants.push(column);
                  self.enable_equality(column);
              }
          }
      *)
      Definition enable_constant (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                                    ],
                                  "contains",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                                        "constants"
                                      |)
                                    ]
                                  |);
                                  column
                                ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "push",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::circuit::ConstraintSystem",
                                "constants"
                              |);
                              M.read (| column |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                                [ F ],
                              "enable_equality",
                              [
                                Ty.apply
                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                  [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                              ]
                            |),
                            [ M.read (| self |); M.read (| column |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_enable_constant :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "enable_constant" (enable_constant F).
      
      (*
          pub fn enable_equality<C: Into<Column<Any>>>(&mut self, column: C) {
              let column = column.into();
              self.query_any_index(column, Rotation::cur());
              self.permutation.add_column(column);
          }
      *)
      Definition enable_equality (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [ C ], [ self; column ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            M.read (|
              let column :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::Into",
                      C,
                      [
                        Ty.apply
                          (Ty.path "halo2_proofs::plonk::circuit::Column")
                          [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                      ],
                      "into",
                      []
                    |),
                    [ M.read (| column |) ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ],
                      "query_any_index",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (| column |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "halo2_proofs::poly::Rotation",
                          "cur",
                          []
                        |),
                        []
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "halo2_proofs::plonk::permutation::Argument",
                      "add_column",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "permutation"
                      |);
                      M.read (| column |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_enable_equality :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "enable_equality" (enable_equality F).
      
      (*
          pub fn lookup(
              &mut self,
              name: &'static str,
              table_map: impl FnOnce(&mut VirtualCells<'_, F>) -> Vec<(Expression<F>, TableColumn)>,
          ) -> usize {
              let mut cells = VirtualCells::new(self);
              let table_map = table_map(&mut cells)
                  .into_iter()
                  .map(|(input, table)| {
                      if input.contains_simple_selector() {
                          panic!("expression containing simple selector supplied to lookup argument");
                      }
      
                      let table = cells.query_fixed(table.inner(), Rotation::cur());
      
                      (input, table)
                  })
                  .collect();
      
              let index = self.lookups.len();
      
              self.lookups.push(lookup::Argument::new(name, table_map));
      
              index
          }
      *)
      Definition lookup (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [ impl_FnOnce__mut_VirtualCells_'___F___arrow_Vec__Expression_F___TableColumn__ ],
            [ self; name; table_map ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let name := M.alloc (| name |) in
            let table_map := M.alloc (| table_map |) in
            M.read (|
              let cells :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                      "new",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let table_map :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::into_iter::IntoIter")
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ];
                                  Ty.path "halo2_proofs::plonk::circuit::TableColumn"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                        [ F ];
                                      Ty.path "halo2_proofs::plonk::circuit::TableColumn"
                                    ]
                                ]
                            ]
                            (Ty.tuple
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ]
                              ])
                        ],
                      [],
                      "collect",
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "alloc::vec::into_iter::IntoIter")
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ];
                                  Ty.path "halo2_proofs::plonk::circuit::TableColumn"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "map",
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ]
                              ];
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                          [ F ];
                                        Ty.path "halo2_proofs::plonk::circuit::TableColumn"
                                      ]
                                  ]
                              ]
                              (Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ];
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ]
                                ])
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                        [ F ];
                                      Ty.path "halo2_proofs::plonk::circuit::TableColumn"
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "into_iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::function::FnOnce",
                                  impl_FnOnce__mut_VirtualCells_'___F___arrow_Vec__Expression_F___TableColumn__,
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::VirtualCells")
                                              [ F ]
                                          ]
                                      ]
                                  ],
                                  "call_once",
                                  []
                                |),
                                [ M.read (| table_map |); Value.Tuple [ cells ] ]
                              |)
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                          let input := M.copy (| γ0_0 |) in
                                          let table := M.copy (| γ0_1 |) in
                                          M.read (|
                                            let _ :=
                                              M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Expression")
                                                                  [ F ],
                                                                "contains_simple_selector",
                                                                []
                                                              |),
                                                              [ input ]
                                                            |)
                                                          |)) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.call_closure (|
                                                            M.get_function (|
                                                              "std::panicking::begin_panic",
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [ Ty.path "str" ]
                                                              ]
                                                            |),
                                                            [
                                                              M.read (|
                                                                Value.String
                                                                  "expression containing simple selector supplied to lookup argument"
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |) in
                                            let table :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::VirtualCells")
                                                      [ F ],
                                                    "query_fixed",
                                                    []
                                                  |),
                                                  [
                                                    cells;
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path
                                                          "halo2_proofs::plonk::circuit::TableColumn",
                                                        "inner",
                                                        []
                                                      |),
                                                      [ table ]
                                                    |);
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "halo2_proofs::poly::Rotation",
                                                        "cur",
                                                        []
                                                      |),
                                                      []
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            M.alloc (|
                                              Value.Tuple [ M.read (| input |); M.read (| table |) ]
                                            |)
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    ]
                  |)
                |) in
              let index :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "len",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "lookups"
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "lookups"
                      |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ],
                          "new",
                          []
                        |),
                        [ M.read (| name |); M.read (| table_map |) ]
                      |)
                    ]
                  |)
                |) in
              index
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_lookup :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "lookup" (lookup F).
      
      (*
          pub fn lookup_any(
              &mut self,
              name: &'static str,
              table_map: impl FnOnce(&mut VirtualCells<'_, F>) -> Vec<(Expression<F>, Expression<F>)>,
          ) -> usize {
              let mut cells = VirtualCells::new(self);
              let table_map = table_map(&mut cells);
      
              let index = self.lookups.len();
      
              self.lookups.push(lookup::Argument::new(name, table_map));
      
              index
          }
      *)
      Definition lookup_any (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [ impl_FnOnce__mut_VirtualCells_'___F___arrow_Vec__Expression_F___Expression_F___ ],
            [ self; name; table_map ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let name := M.alloc (| name |) in
            let table_map := M.alloc (| table_map |) in
            M.read (|
              let cells :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                      "new",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let table_map :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::function::FnOnce",
                      impl_FnOnce__mut_VirtualCells_'___F___arrow_Vec__Expression_F___Expression_F___,
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              [
                                Ty.apply
                                  (Ty.path "halo2_proofs::plonk::circuit::VirtualCells")
                                  [ F ]
                              ]
                          ]
                      ],
                      "call_once",
                      []
                    |),
                    [ M.read (| table_map |); Value.Tuple [ cells ] ]
                  |)
                |) in
              let index :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "len",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "lookups"
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "lookups"
                      |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ],
                          "new",
                          []
                        |),
                        [ M.read (| name |); M.read (| table_map |) ]
                      |)
                    ]
                  |)
                |) in
              index
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_lookup_any :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "lookup_any" (lookup_any F).
      
      (*
          fn query_fixed_index(&mut self, column: Column<Fixed>, at: Rotation) -> usize {
              // Return existing query, if it exists
              for (index, fixed_query) in self.fixed_queries.iter().enumerate() {
                  if fixed_query == &(column, at) {
                      return index;
                  }
              }
      
              // Make a new query
              let index = self.fixed_queries.len();
              self.fixed_queries.push((column, at));
      
              index
          }
      *)
      Definition query_fixed_index (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.use
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                          Ty.path "halo2_proofs::poly::Rotation"
                                        ]
                                    ]
                                ],
                              [],
                              "into_iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                          Ty.path "halo2_proofs::poly::Rotation"
                                        ]
                                    ],
                                  [],
                                  "enumerate",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                              Ty.path "halo2_proofs::poly::Rotation"
                                            ]
                                        ],
                                      "iter",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                    [ Ty.path "halo2_proofs::plonk::circuit::Fixed"
                                                    ];
                                                  Ty.path "halo2_proofs::poly::Rotation"
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                                            "fixed_queries"
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                ltac:(M.monadic
                                  (let _ :=
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Column")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                          ];
                                                        Ty.path "halo2_proofs::poly::Rotation"
                                                      ]
                                                  ]
                                              ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                            let index := M.copy (| γ1_0 |) in
                                            let fixed_query := M.copy (| γ1_1 |) in
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::cmp::PartialEq",
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Fixed"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation"
                                                                    ]
                                                                ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                                          ];
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ]
                                                              ],
                                                              "eq",
                                                              []
                                                            |),
                                                            [
                                                              fixed_query;
                                                              M.alloc (|
                                                                M.alloc (|
                                                                  Value.Tuple
                                                                    [
                                                                      M.read (| column |);
                                                                      M.read (| at_ |)
                                                                    ]
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          M.return_ (| M.read (| index |) |)
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |)) in
                  let index :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "fixed_queries"
                          |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "push",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "fixed_queries"
                          |);
                          Value.Tuple [ M.read (| column |); M.read (| at_ |) ]
                        ]
                      |)
                    |) in
                  index
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_query_fixed_index :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "query_fixed_index" (query_fixed_index F).
      
      (*
          pub(crate) fn query_advice_index(&mut self, column: Column<Advice>, at: Rotation) -> usize {
              // Return existing query, if it exists
              for (index, advice_query) in self.advice_queries.iter().enumerate() {
                  if advice_query == &(column, at) {
                      return index;
                  }
              }
      
              // Make a new query
              let index = self.advice_queries.len();
              self.advice_queries.push((column, at));
              self.num_advice_queries[column.index] += 1;
      
              index
          }
      *)
      Definition query_advice_index (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.use
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                          Ty.path "halo2_proofs::poly::Rotation"
                                        ]
                                    ]
                                ],
                              [],
                              "into_iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                          Ty.path "halo2_proofs::poly::Rotation"
                                        ]
                                    ],
                                  [],
                                  "enumerate",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                              Ty.path "halo2_proofs::poly::Rotation"
                                            ]
                                        ],
                                      "iter",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                    [ Ty.path "halo2_proofs::plonk::circuit::Advice"
                                                    ];
                                                  Ty.path "halo2_proofs::poly::Rotation"
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                                            "advice_queries"
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                ltac:(M.monadic
                                  (let _ :=
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Column")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::plonk::circuit::Advice"
                                                          ];
                                                        Ty.path "halo2_proofs::poly::Rotation"
                                                      ]
                                                  ]
                                              ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                            let index := M.copy (| γ1_0 |) in
                                            let advice_query := M.copy (| γ1_1 |) in
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::cmp::PartialEq",
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Advice"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation"
                                                                    ]
                                                                ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Advice"
                                                                          ];
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ]
                                                              ],
                                                              "eq",
                                                              []
                                                            |),
                                                            [
                                                              advice_query;
                                                              M.alloc (|
                                                                M.alloc (|
                                                                  Value.Tuple
                                                                    [
                                                                      M.read (| column |);
                                                                      M.read (| at_ |)
                                                                    ]
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          M.return_ (| M.read (| index |) |)
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |)) in
                  let index :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "advice_queries"
                          |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "push",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "advice_queries"
                          |);
                          Value.Tuple [ M.read (| column |); M.read (| at_ |) ]
                        ]
                      |)
                    |) in
                  let _ :=
                    let β :=
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::index::IndexMut",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                          [ Ty.path "usize" ],
                          "index_mut",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "num_advice_queries"
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              column,
                              "halo2_proofs::plonk::circuit::Column",
                              "index"
                            |)
                          |)
                        ]
                      |) in
                    M.write (|
                      β,
                      BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                    |) in
                  index
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_query_advice_index :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "query_advice_index" (query_advice_index F).
      
      (*
          fn query_instance_index(&mut self, column: Column<Instance>, at: Rotation) -> usize {
              // Return existing query, if it exists
              for (index, instance_query) in self.instance_queries.iter().enumerate() {
                  if instance_query == &(column, at) {
                      return index;
                  }
              }
      
              // Make a new query
              let index = self.instance_queries.len();
              self.instance_queries.push((column, at));
      
              index
          }
      *)
      Definition query_instance_index (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.use
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                                          Ty.path "halo2_proofs::poly::Rotation"
                                        ]
                                    ]
                                ],
                              [],
                              "into_iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                                          Ty.path "halo2_proofs::poly::Rotation"
                                        ]
                                    ],
                                  [],
                                  "enumerate",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                [ Ty.path "halo2_proofs::plonk::circuit::Instance"
                                                ];
                                              Ty.path "halo2_proofs::poly::Rotation"
                                            ]
                                        ],
                                      "iter",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                    [
                                                      Ty.path
                                                        "halo2_proofs::plonk::circuit::Instance"
                                                    ];
                                                  Ty.path "halo2_proofs::poly::Rotation"
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                                            "instance_queries"
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                ltac:(M.monadic
                                  (let _ :=
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Column")
                                                          [
                                                            Ty.path
                                                              "halo2_proofs::plonk::circuit::Instance"
                                                          ];
                                                        Ty.path "halo2_proofs::poly::Rotation"
                                                      ]
                                                  ]
                                              ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                            let index := M.copy (| γ1_0 |) in
                                            let instance_query := M.copy (| γ1_1 |) in
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::cmp::PartialEq",
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Column")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::plonk::circuit::Instance"
                                                                        ];
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation"
                                                                    ]
                                                                ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Instance"
                                                                          ];
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ]
                                                              ],
                                                              "eq",
                                                              []
                                                            |),
                                                            [
                                                              instance_query;
                                                              M.alloc (|
                                                                M.alloc (|
                                                                  Value.Tuple
                                                                    [
                                                                      M.read (| column |);
                                                                      M.read (| at_ |)
                                                                    ]
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          M.return_ (| M.read (| index |) |)
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |)) in
                  let index :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "instance_queries"
                          |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                                  Ty.path "halo2_proofs::poly::Rotation"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "push",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "instance_queries"
                          |);
                          Value.Tuple [ M.read (| column |); M.read (| at_ |) ]
                        ]
                      |)
                    |) in
                  index
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_query_instance_index :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "query_instance_index" (query_instance_index F).
      
      (*
          fn query_any_index(&mut self, column: Column<Any>, at: Rotation) -> usize {
              match column.column_type() {
                  Any::Advice => self.query_advice_index(Column::<Advice>::try_from(column).unwrap(), at),
                  Any::Fixed => self.query_fixed_index(Column::<Fixed>::try_from(column).unwrap(), at),
                  Any::Instance => {
                      self.query_instance_index(Column::<Instance>::try_from(column).unwrap(), at)
                  }
              }
          }
      *)
      Definition query_any_index (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                      "column_type",
                      []
                    |),
                    [ column ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                              [ F ],
                            "query_advice_index",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                    Ty.apply (Ty.path "&") [ Ty.path "str" ]
                                  ],
                                "unwrap",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Advice" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "try_from",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |)
                              ]
                            |);
                            M.read (| at_ |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                              [ F ],
                            "query_fixed_index",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                    Ty.apply (Ty.path "&") [ Ty.path "str" ]
                                  ],
                                "unwrap",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "try_from",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |)
                              ]
                            |);
                            M.read (| at_ |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                              [ F ],
                            "query_instance_index",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                                    Ty.apply (Ty.path "&") [ Ty.path "str" ]
                                  ],
                                "unwrap",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Instance" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "try_from",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |)
                              ]
                            |);
                            M.read (| at_ |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_query_any_index :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "query_any_index" (query_any_index F).
      
      (*
          pub(crate) fn get_advice_query_index(&self, column: Column<Advice>, at: Rotation) -> usize {
              for (index, advice_query) in self.advice_queries.iter().enumerate() {
                  if advice_query == &(column, at) {
                      return index;
                  }
              }
      
              panic!("get_advice_query_index called for non-existent query");
          }
      *)
      Definition get_advice_query_index (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.never_to_any (|
                  M.read (|
                    let _ :=
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Column")
                                              [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                            Ty.path "halo2_proofs::poly::Rotation"
                                          ]
                                      ]
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Column")
                                              [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                            Ty.path "halo2_proofs::poly::Rotation"
                                          ]
                                      ],
                                    [],
                                    "enumerate",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                  [ Ty.path "halo2_proofs::plonk::circuit::Advice"
                                                  ];
                                                Ty.path "halo2_proofs::poly::Rotation"
                                              ]
                                          ],
                                        "iter",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [
                                                        Ty.path
                                                          "halo2_proofs::plonk::circuit::Advice"
                                                      ];
                                                    Ty.path "halo2_proofs::poly::Rotation"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "deref",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                                              "advice_queries"
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path
                                                  "core::iter::adapters::enumerate::Enumerate")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Advice"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ]
                                                ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                              let index := M.copy (| γ1_0 |) in
                                              let advice_query := M.copy (| γ1_1 |) in
                                              M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::cmp::PartialEq",
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Advice"
                                                                          ];
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ],
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::plonk::circuit::Column")
                                                                            [
                                                                              Ty.path
                                                                                "halo2_proofs::plonk::circuit::Advice"
                                                                            ];
                                                                          Ty.path
                                                                            "halo2_proofs::poly::Rotation"
                                                                        ]
                                                                    ]
                                                                ],
                                                                "eq",
                                                                []
                                                              |),
                                                              [
                                                                advice_query;
                                                                M.alloc (|
                                                                  M.alloc (|
                                                                    Value.Tuple
                                                                      [
                                                                        M.read (| column |);
                                                                        M.read (| at_ |)
                                                                      ]
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (| M.read (| index |) |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "std::panicking::begin_panic",
                          [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                        |),
                        [
                          M.read (|
                            Value.String "get_advice_query_index called for non-existent query"
                          |)
                        ]
                      |)
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_advice_query_index :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "get_advice_query_index" (get_advice_query_index F).
      
      (*
          pub(crate) fn get_fixed_query_index(&self, column: Column<Fixed>, at: Rotation) -> usize {
              for (index, fixed_query) in self.fixed_queries.iter().enumerate() {
                  if fixed_query == &(column, at) {
                      return index;
                  }
              }
      
              panic!("get_fixed_query_index called for non-existent query");
          }
      *)
      Definition get_fixed_query_index (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.never_to_any (|
                  M.read (|
                    let _ :=
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Column")
                                              [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                            Ty.path "halo2_proofs::poly::Rotation"
                                          ]
                                      ]
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Column")
                                              [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                            Ty.path "halo2_proofs::poly::Rotation"
                                          ]
                                      ],
                                    [],
                                    "enumerate",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                  [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                                Ty.path "halo2_proofs::poly::Rotation"
                                              ]
                                          ],
                                        "iter",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [
                                                        Ty.path
                                                          "halo2_proofs::plonk::circuit::Fixed"
                                                      ];
                                                    Ty.path "halo2_proofs::poly::Rotation"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "deref",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                                              "fixed_queries"
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path
                                                  "core::iter::adapters::enumerate::Enumerate")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Fixed"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ]
                                                ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                              let index := M.copy (| γ1_0 |) in
                                              let fixed_query := M.copy (| γ1_1 |) in
                                              M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::cmp::PartialEq",
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Fixed"
                                                                          ];
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ],
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::plonk::circuit::Column")
                                                                            [
                                                                              Ty.path
                                                                                "halo2_proofs::plonk::circuit::Fixed"
                                                                            ];
                                                                          Ty.path
                                                                            "halo2_proofs::poly::Rotation"
                                                                        ]
                                                                    ]
                                                                ],
                                                                "eq",
                                                                []
                                                              |),
                                                              [
                                                                fixed_query;
                                                                M.alloc (|
                                                                  M.alloc (|
                                                                    Value.Tuple
                                                                      [
                                                                        M.read (| column |);
                                                                        M.read (| at_ |)
                                                                      ]
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (| M.read (| index |) |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "std::panicking::begin_panic",
                          [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                        |),
                        [
                          M.read (|
                            Value.String "get_fixed_query_index called for non-existent query"
                          |)
                        ]
                      |)
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_fixed_query_index :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "get_fixed_query_index" (get_fixed_query_index F).
      
      (*
          pub(crate) fn get_instance_query_index(&self, column: Column<Instance>, at: Rotation) -> usize {
              for (index, instance_query) in self.instance_queries.iter().enumerate() {
                  if instance_query == &(column, at) {
                      return index;
                  }
              }
      
              panic!("get_instance_query_index called for non-existent query");
          }
      *)
      Definition get_instance_query_index (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.never_to_any (|
                  M.read (|
                    let _ :=
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Column")
                                              [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                                            Ty.path "halo2_proofs::poly::Rotation"
                                          ]
                                      ]
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Column")
                                              [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                                            Ty.path "halo2_proofs::poly::Rotation"
                                          ]
                                      ],
                                    [],
                                    "enumerate",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                  [ Ty.path "halo2_proofs::plonk::circuit::Instance"
                                                  ];
                                                Ty.path "halo2_proofs::poly::Rotation"
                                              ]
                                          ],
                                        "iter",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [
                                                        Ty.path
                                                          "halo2_proofs::plonk::circuit::Instance"
                                                      ];
                                                    Ty.path "halo2_proofs::poly::Rotation"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "deref",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "halo2_proofs::plonk::circuit::ConstraintSystem",
                                              "instance_queries"
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path
                                                  "core::iter::adapters::enumerate::Enumerate")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Instance"
                                                            ];
                                                          Ty.path "halo2_proofs::poly::Rotation"
                                                        ]
                                                    ]
                                                ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                              let index := M.copy (| γ1_0 |) in
                                              let instance_query := M.copy (| γ1_1 |) in
                                              M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::cmp::PartialEq",
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Column")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::plonk::circuit::Instance"
                                                                          ];
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ],
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::plonk::circuit::Column")
                                                                            [
                                                                              Ty.path
                                                                                "halo2_proofs::plonk::circuit::Instance"
                                                                            ];
                                                                          Ty.path
                                                                            "halo2_proofs::poly::Rotation"
                                                                        ]
                                                                    ]
                                                                ],
                                                                "eq",
                                                                []
                                                              |),
                                                              [
                                                                instance_query;
                                                                M.alloc (|
                                                                  M.alloc (|
                                                                    Value.Tuple
                                                                      [
                                                                        M.read (| column |);
                                                                        M.read (| at_ |)
                                                                      ]
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (| M.read (| index |) |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "std::panicking::begin_panic",
                          [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                        |),
                        [
                          M.read (|
                            Value.String "get_instance_query_index called for non-existent query"
                          |)
                        ]
                      |)
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_instance_query_index :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "get_instance_query_index" (get_instance_query_index F).
      
      (*
          pub fn get_any_query_index(&self, column: Column<Any>, at: Rotation) -> usize {
              match column.column_type() {
                  Any::Advice => {
                      self.get_advice_query_index(Column::<Advice>::try_from(column).unwrap(), at)
                  }
                  Any::Fixed => {
                      self.get_fixed_query_index(Column::<Fixed>::try_from(column).unwrap(), at)
                  }
                  Any::Instance => {
                      self.get_instance_query_index(Column::<Instance>::try_from(column).unwrap(), at)
                  }
              }
          }
      *)
      Definition get_any_query_index (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                      "column_type",
                      []
                    |),
                    [ column ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                              [ F ],
                            "get_advice_query_index",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                    Ty.apply (Ty.path "&") [ Ty.path "str" ]
                                  ],
                                "unwrap",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Advice" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "try_from",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |)
                              ]
                            |);
                            M.read (| at_ |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                              [ F ],
                            "get_fixed_query_index",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                    Ty.apply (Ty.path "&") [ Ty.path "str" ]
                                  ],
                                "unwrap",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "try_from",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |)
                              ]
                            |);
                            M.read (| at_ |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                              [ F ],
                            "get_instance_query_index",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                                    Ty.apply (Ty.path "&") [ Ty.path "str" ]
                                  ],
                                "unwrap",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Instance" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "try_from",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |)
                              ]
                            |);
                            M.read (| at_ |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_any_query_index :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "get_any_query_index" (get_any_query_index F).
      
      (*
          pub fn set_minimum_degree(&mut self, degree: usize) {
              self.minimum_degree = Some(degree);
          }
      *)
      Definition set_minimum_degree (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; degree ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let degree := M.alloc (| degree |) in
            M.read (|
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "minimum_degree"
                  |),
                  Value.StructTuple "core::option::Option::Some" [ M.read (| degree |) ]
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_set_minimum_degree :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "set_minimum_degree" (set_minimum_degree F).
      
      (*
          pub fn create_gate<C: Into<Constraint<F>>, Iter: IntoIterator<Item = C>>(
              &mut self,
              name: &'static str,
              constraints: impl FnOnce(&mut VirtualCells<'_, F>) -> Iter,
          ) {
              let mut cells = VirtualCells::new(self);
              let constraints = constraints(&mut cells);
              let queried_selectors = cells.queried_selectors;
              let queried_cells = cells.queried_cells;
      
              let (constraint_names, polys): (_, Vec<_>) = constraints
                  .into_iter()
                  .map(|c| c.into())
                  .map(|c| (c.name, c.poly))
                  .unzip();
      
              assert!(
                  !polys.is_empty(),
                  "Gates must contain at least one constraint."
              );
      
              self.gates.push(Gate {
                  name,
                  constraint_names,
                  polys,
                  queried_selectors,
                  queried_cells,
              });
          }
      *)
      Definition create_gate (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [ C; Iter; impl_FnOnce__mut_VirtualCells_'___F___arrow_Iter ],
            [ self; name; constraints ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let name := M.alloc (| name |) in
            let constraints := M.alloc (| constraints |) in
            M.read (|
              let cells :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                      "new",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let constraints :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::function::FnOnce",
                      impl_FnOnce__mut_VirtualCells_'___F___arrow_Iter,
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              [
                                Ty.apply
                                  (Ty.path "halo2_proofs::plonk::circuit::VirtualCells")
                                  [ F ]
                              ]
                          ]
                      ],
                      "call_once",
                      []
                    |),
                    [ M.read (| constraints |); Value.Tuple [ cells ] ]
                  |)
                |) in
              let queried_selectors :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    cells,
                    "halo2_proofs::plonk::circuit::VirtualCells",
                    "queried_selectors"
                  |)
                |) in
              let queried_cells :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    cells,
                    "halo2_proofs::plonk::circuit::VirtualCells",
                    "queried_cells"
                  |)
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            [
                              Ty.associated;
                              Ty.function
                                [ Ty.tuple [ C ] ]
                                (Ty.apply
                                  (Ty.path "halo2_proofs::plonk::circuit::Constraint")
                                  [ F ])
                            ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Constraint")
                                    [ F ]
                                ]
                            ]
                            (Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [ Ty.path "str" ];
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ]
                              ])
                        ],
                      [],
                      "unzip",
                      [
                        Ty.apply (Ty.path "&") [ Ty.path "str" ];
                        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [ Ty.apply (Ty.path "&") [ Ty.path "str" ]; Ty.path "alloc::alloc::Global"
                          ];
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            [
                              Ty.associated;
                              Ty.function
                                [ Ty.tuple [ C ] ]
                                (Ty.apply
                                  (Ty.path "halo2_proofs::plonk::circuit::Constraint")
                                  [ F ])
                            ],
                          [],
                          "map",
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [ Ty.path "str" ];
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ]
                              ];
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Constraint")
                                      [ F ]
                                  ]
                              ]
                              (Ty.tuple
                                [
                                  Ty.apply (Ty.path "&") [ Ty.path "str" ];
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ]
                                ])
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.associated,
                              [],
                              "map",
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Constraint") [ F ];
                                Ty.function
                                  [ Ty.tuple [ C ] ]
                                  (Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Constraint")
                                    [ F ])
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Iter,
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [ M.read (| constraints |) ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let c := M.copy (| γ |) in
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::convert::Into",
                                                  C,
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Constraint")
                                                      [ F ]
                                                  ],
                                                  "into",
                                                  []
                                                |),
                                                [ M.read (| c |) ]
                                              |)))
                                        ]
                                      |)
                                    | _ => M.impossible (||)
                                    end))
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let c := M.copy (| γ |) in
                                          Value.Tuple
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  c,
                                                  "halo2_proofs::plonk::circuit::Constraint",
                                                  "name"
                                                |)
                                              |);
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  c,
                                                  "halo2_proofs::plonk::circuit::Constraint",
                                                  "poly"
                                                |)
                                              |)
                                            ]))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let constraint_names := M.copy (| γ0_0 |) in
                      let polys := M.copy (| γ0_1 |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (UnOp.Pure.not
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::plonk::circuit::Expression")
                                                    [ F ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "is_empty",
                                              []
                                            |),
                                            [ polys ]
                                          |)))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "std::panicking::begin_panic",
                                        [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                      |),
                                      [
                                        M.read (|
                                          Value.String "Gates must contain at least one constraint."
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "push",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::circuit::ConstraintSystem",
                                "gates"
                              |);
                              Value.StructRecord
                                "halo2_proofs::plonk::circuit::Gate"
                                [
                                  ("name", M.read (| name |));
                                  ("constraint_names", M.read (| constraint_names |));
                                  ("polys", M.read (| polys |));
                                  ("queried_selectors", M.read (| queried_selectors |));
                                  ("queried_cells", M.read (| queried_cells |))
                                ]
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_create_gate :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "create_gate" (create_gate F).
      
      (*
          pub(crate) fn compress_selectors(mut self, selectors: Vec<Vec<bool>>) -> (Self, Vec<Vec<F>>) {
              // The number of provided selector assignments must be the number we
              // counted for this constraint system.
              assert_eq!(selectors.len(), self.num_selectors);
      
              // Compute the maximal degree of every selector. We only consider the
              // expressions in gates, as lookup arguments cannot support simple
              // selectors. Selectors that are complex or do not appear in any gates
              // will have degree zero.
              let mut degrees = vec![0; selectors.len()];
              for expr in self.gates.iter().flat_map(|gate| gate.polys.iter()) {
                  if let Some(selector) = expr.extract_simple_selector() {
                      degrees[selector.0] = max(degrees[selector.0], expr.degree());
                  }
              }
      
              // We will not increase the degree of the constraint system, so we limit
              // ourselves to the largest existing degree constraint.
              let max_degree = self.degree();
      
              let mut new_columns = vec![];
              let (polys, selector_assignment) = compress_selectors::process(
                  selectors
                      .into_iter()
                      .zip(degrees.into_iter())
                      .enumerate()
                      .map(
                          |(i, (activations, max_degree))| compress_selectors::SelectorDescription {
                              selector: i,
                              activations,
                              max_degree,
                          },
                      )
                      .collect(),
                  max_degree,
                  || {
                      let column = self.fixed_column();
                      new_columns.push(column);
                      Expression::Fixed {
                          query_index: self.query_fixed_index(column, Rotation::cur()),
                          column_index: column.index,
                          rotation: Rotation::cur(),
                      }
                  },
              );
      
              let mut selector_map = vec![None; selector_assignment.len()];
              let mut selector_replacements = vec![None; selector_assignment.len()];
              for assignment in selector_assignment {
                  selector_replacements[assignment.selector] = Some(assignment.expression);
                  selector_map[assignment.selector] = Some(new_columns[assignment.combination_index]);
              }
      
              self.selector_map = selector_map
                  .into_iter()
                  .map(|a| a.unwrap())
                  .collect::<Vec<_>>();
              let selector_replacements = selector_replacements
                  .into_iter()
                  .map(|a| a.unwrap())
                  .collect::<Vec<_>>();
      
              fn replace_selectors<F: Field>(
                  expr: &mut Expression<F>,
                  selector_replacements: &[Expression<F>],
                  must_be_nonsimple: bool,
              ) {
                  *expr = expr.evaluate(
                      &|constant| Expression::Constant(constant),
                      &|selector| {
                          if must_be_nonsimple {
                              // Simple selectors are prohibited from appearing in
                              // expressions in the lookup argument by
                              // `ConstraintSystem`.
                              assert!(!selector.is_simple());
                          }
      
                          selector_replacements[selector.0].clone()
                      },
                      &|query_index, column_index, rotation| Expression::Fixed {
                          query_index,
                          column_index,
                          rotation,
                      },
                      &|query_index, column_index, rotation| Expression::Advice {
                          query_index,
                          column_index,
                          rotation,
                      },
                      &|query_index, column_index, rotation| Expression::Instance {
                          query_index,
                          column_index,
                          rotation,
                      },
                      &|a| -a,
                      &|a, b| a + b,
                      &|a, b| a() * b(),
                      &|a, f| a * f,
                  );
              }
      
              // Substitute selectors for the real fixed columns in all gates
              for expr in self.gates.iter_mut().flat_map(|gate| gate.polys.iter_mut()) {
                  replace_selectors(expr, &selector_replacements, false);
              }
      
              // Substitute non-simple selectors for the real fixed columns in all
              // lookup expressions
              for expr in self.lookups.iter_mut().flat_map(|lookup| {
                  lookup
                      .input_expressions
                      .iter_mut()
                      .chain(lookup.table_expressions.iter_mut())
              }) {
                  replace_selectors(expr, &selector_replacements, true);
              }
      
              (self, polys)
          }
      *)
      Definition compress_selectors (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; selectors ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let selectors := M.alloc (| selectors |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    Value.Tuple
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "len",
                              []
                            |),
                            [ selectors ]
                          |)
                        |);
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "halo2_proofs::plonk::circuit::ConstraintSystem",
                          "num_selectors"
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (BinOp.Pure.eq
                                          (M.read (| M.read (| left_val |) |))
                                          (M.read (| M.read (| right_val |) |)))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let kind :=
                                        M.alloc (|
                                          Value.StructTuple "core::panicking::AssertKind::Eq" []
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.read (| left_val |);
                                            M.read (| right_val |);
                                            Value.StructTuple "core::option::Option::None" []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |) in
              let degrees :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "alloc::vec::from_elem", [ Ty.path "usize" ] |),
                    [
                      Value.Integer 0;
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          []
                        |),
                        [ selectors ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.use
                  (M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::flatten::FlatMap")
                            [
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ] ];
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ]
                                ];
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                            [ F ]
                                        ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ]
                                  ])
                            ],
                          [],
                          "into_iter",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ] ],
                              [],
                              "flat_map",
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ]
                                  ];
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                              [ F ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                        [ F ]
                                    ])
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ]
                                    ],
                                  "iter",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                            [ F ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                                        "gates"
                                      |)
                                    ]
                                  |)
                                ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let gate := M.copy (| γ |) in
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "slice")
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::circuit::Expression")
                                                        [ F ]
                                                    ],
                                                  "iter",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Expression")
                                                            [ F ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      [],
                                                      "deref",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| gate |),
                                                        "halo2_proofs::plonk::circuit::Gate",
                                                        "polys"
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)))
                                        ]
                                      |)
                                    | _ => M.impossible (||)
                                    end))
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            ltac:(M.monadic
                              (let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::flatten::FlatMap")
                                          [
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Iter")
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                                  [ F ]
                                              ];
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Iter")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::circuit::Expression")
                                                  [ F ]
                                              ];
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Gate")
                                                          [ F ]
                                                      ]
                                                  ]
                                              ]
                                              (Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::plonk::circuit::Expression")
                                                    [ F ]
                                                ])
                                          ],
                                        [],
                                        "next",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let expr := M.copy (| γ0_0 |) in
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Expression")
                                                          [ F ],
                                                        "extract_simple_selector",
                                                        []
                                                      |),
                                                      [ M.read (| expr |) ]
                                                    |)
                                                  |) in
                                                let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let selector := M.copy (| γ0_0 |) in
                                                let _ :=
                                                  M.write (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::index::IndexMut",
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          [
                                                            Ty.path "usize";
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        [ Ty.path "usize" ],
                                                        "index_mut",
                                                        []
                                                      |),
                                                      [
                                                        degrees;
                                                        M.read (|
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            selector,
                                                            "halo2_proofs::plonk::circuit::Selector",
                                                            0
                                                          |)
                                                        |)
                                                      ]
                                                    |),
                                                    M.call_closure (|
                                                      M.get_function (|
                                                        "core::cmp::max",
                                                        [ Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.read (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::index::Index",
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                [
                                                                  Ty.path "usize";
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              [ Ty.path "usize" ],
                                                              "index",
                                                              []
                                                            |),
                                                            [
                                                              degrees;
                                                              M.read (|
                                                                M.SubPointer.get_struct_tuple_field (|
                                                                  selector,
                                                                  "halo2_proofs::plonk::circuit::Selector",
                                                                  0
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |);
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Expression")
                                                              [ F ],
                                                            "degree",
                                                            []
                                                          |),
                                                          [ M.read (| expr |) ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |)) in
              let max_degree :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ],
                      "degree",
                      []
                    |),
                    [ self ]
                  |)
                |) in
              let new_columns :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |)
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "halo2_proofs::plonk::circuit::compress_selectors::process",
                      [
                        F;
                        Ty.function
                          [ Ty.tuple [] ]
                          (Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ])
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                          Ty.path "alloc::alloc::Global"
                                        ];
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                                    ]
                                ];
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.tuple
                                        [
                                          Ty.path "usize";
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                              Ty.path "usize"
                                            ]
                                        ]
                                    ]
                                ]
                                (Ty.path
                                  "halo2_proofs::plonk::circuit::compress_selectors::SelectorDescription")
                            ],
                          [],
                          "collect",
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.path
                                  "halo2_proofs::plonk::circuit::compress_selectors::SelectorDescription";
                                Ty.path "alloc::alloc::Global"
                              ]
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                          Ty.path "alloc::alloc::Global"
                                        ];
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                                    ]
                                ],
                              [],
                              "map",
                              [
                                Ty.path
                                  "halo2_proofs::plonk::circuit::compress_selectors::SelectorDescription";
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "usize";
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [ Ty.path "bool"; Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "usize"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.path
                                    "halo2_proofs::plonk::circuit::compress_selectors::SelectorDescription")
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                          Ty.path "alloc::alloc::Global"
                                        ];
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                                    ],
                                  [],
                                  "enumerate",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "zip",
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::collect::IntoIterator",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "into_iter",
                                          []
                                        |),
                                        [ M.read (| selectors |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::collect::IntoIterator",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                                          [],
                                          "into_iter",
                                          []
                                        |),
                                        [ M.read (| degrees |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_tuple_field (| γ, 0 |) in
                                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                              let i := M.copy (| γ0_0 |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_1, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_1, 1 |) in
                                              let activations := M.copy (| γ1_0 |) in
                                              let max_degree := M.copy (| γ1_1 |) in
                                              Value.StructRecord
                                                "halo2_proofs::plonk::circuit::compress_selectors::SelectorDescription"
                                                [
                                                  ("selector", M.read (| i |));
                                                  ("activations", M.read (| activations |));
                                                  ("max_degree", M.read (| max_degree |))
                                                ]))
                                        ]
                                      |)
                                    | _ => M.impossible (||)
                                    end))
                            ]
                          |)
                        ]
                      |);
                      M.read (| max_degree |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.read (|
                                        let column :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::circuit::ConstraintSystem")
                                                  [ F ],
                                                "fixed_column",
                                                []
                                              |),
                                              [ self ]
                                            |)
                                          |) in
                                        let _ :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [
                                                        Ty.path
                                                          "halo2_proofs::plonk::circuit::Fixed"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                "push",
                                                []
                                              |),
                                              [ new_columns; M.read (| column |) ]
                                            |)
                                          |) in
                                        M.alloc (|
                                          Value.StructRecord
                                            "halo2_proofs::plonk::circuit::Expression::Fixed"
                                            [
                                              ("query_index",
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::ConstraintSystem")
                                                      [ F ],
                                                    "query_fixed_index",
                                                    []
                                                  |),
                                                  [
                                                    self;
                                                    M.read (| column |);
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "halo2_proofs::poly::Rotation",
                                                        "cur",
                                                        []
                                                      |),
                                                      []
                                                    |)
                                                  ]
                                                |));
                                              ("column_index",
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    column,
                                                    "halo2_proofs::plonk::circuit::Column",
                                                    "index"
                                                  |)
                                                |));
                                              ("rotation",
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "halo2_proofs::poly::Rotation",
                                                    "cur",
                                                    []
                                                  |),
                                                  []
                                                |))
                                            ]
                                        |)
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let polys := M.copy (| γ0_0 |) in
                      let selector_assignment := M.copy (| γ0_1 |) in
                      let selector_map :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "alloc::vec::from_elem",
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                                  ]
                              ]
                            |),
                            [
                              Value.StructTuple "core::option::Option::None" [];
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "halo2_proofs::plonk::circuit::compress_selectors::SelectorAssignment")
                                        [ F ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "len",
                                  []
                                |),
                                [ selector_assignment ]
                              |)
                            ]
                          |)
                        |) in
                      let selector_replacements :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "alloc::vec::from_elem",
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ]
                                  ]
                              ]
                            |),
                            [
                              Value.StructTuple "core::option::Option::None" [];
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "halo2_proofs::plonk::circuit::compress_selectors::SelectorAssignment")
                                        [ F ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "len",
                                  []
                                |),
                                [ selector_assignment ]
                              |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.use
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "halo2_proofs::plonk::circuit::compress_selectors::SelectorAssignment")
                                        [ F ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [ M.read (| selector_assignment |) ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "alloc::vec::into_iter::IntoIter")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::compress_selectors::SelectorAssignment")
                                                      [ F ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                [],
                                                "next",
                                                []
                                              |),
                                              [ iter ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let assignment := M.copy (| γ0_0 |) in
                                                let _ :=
                                                  M.write (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::index::IndexMut",
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Expression")
                                                                  [ F ]
                                                              ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        [ Ty.path "usize" ],
                                                        "index_mut",
                                                        []
                                                      |),
                                                      [
                                                        selector_replacements;
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            assignment,
                                                            "halo2_proofs::plonk::circuit::compress_selectors::SelectorAssignment",
                                                            "selector"
                                                          |)
                                                        |)
                                                      ]
                                                    |),
                                                    Value.StructTuple
                                                      "core::option::Option::Some"
                                                      [
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            assignment,
                                                            "halo2_proofs::plonk::circuit::compress_selectors::SelectorAssignment",
                                                            "expression"
                                                          |)
                                                        |)
                                                      ]
                                                  |) in
                                                let _ :=
                                                  M.write (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::index::IndexMut",
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Column")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::circuit::Fixed"
                                                                  ]
                                                              ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        [ Ty.path "usize" ],
                                                        "index_mut",
                                                        []
                                                      |),
                                                      [
                                                        selector_map;
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            assignment,
                                                            "halo2_proofs::plonk::circuit::compress_selectors::SelectorAssignment",
                                                            "selector"
                                                          |)
                                                        |)
                                                      ]
                                                    |),
                                                    Value.StructTuple
                                                      "core::option::Option::Some"
                                                      [
                                                        M.read (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::index::Index",
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Column")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::circuit::Fixed"
                                                                    ];
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              [ Ty.path "usize" ],
                                                              "index",
                                                              []
                                                            |),
                                                            [
                                                              new_columns;
                                                              M.read (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  assignment,
                                                                  "halo2_proofs::plonk::circuit::compress_selectors::SelectorAssignment",
                                                                  "combination_index"
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      ]
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |)) in
                      let _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "selector_map"
                          |),
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    [
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ])
                                ],
                              [],
                              "collect",
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    [
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "map",
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                  [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                                              ]
                                          ]
                                      ]
                                      (Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ])
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::collect::IntoIterator",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ]
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "into_iter",
                                      []
                                    |),
                                    [ M.read (| selector_map |) ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let a := M.copy (| γ |) in
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Column")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::plonk::circuit::Fixed"
                                                            ]
                                                        ],
                                                      "unwrap",
                                                      []
                                                    |),
                                                    [ M.read (| a |) ]
                                                  |)))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let selector_replacements :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    [
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                            [ F ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ])
                                ],
                              [],
                              "collect",
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    [
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                            [ F ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "map",
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                      [ F ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::circuit::Expression")
                                                  [ F ]
                                              ]
                                          ]
                                      ]
                                      (Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                        [ F ])
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::collect::IntoIterator",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                                [ F ]
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "into_iter",
                                      []
                                    |),
                                    [ M.read (| selector_replacements |) ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let a := M.copy (| γ |) in
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Expression")
                                                            [ F ]
                                                        ],
                                                      "unwrap",
                                                      []
                                                    |),
                                                    [ M.read (| a |) ]
                                                  |)))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.use
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::flatten::FlatMap")
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                            [ F ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                            [ F ]
                                        ];
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&mut")
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                                    [ F ]
                                                ]
                                            ]
                                        ]
                                        (Ty.apply
                                          (Ty.path "core::slice::iter::IterMut")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ]
                                          ])
                                    ],
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                            [ F ]
                                        ],
                                      [],
                                      "flat_map",
                                      [
                                        Ty.apply
                                          (Ty.path "core::slice::iter::IterMut")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ]
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                                      [ F ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.apply
                                            (Ty.path "core::slice::iter::IterMut")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                                [ F ]
                                            ])
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "slice")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                                [ F ]
                                            ],
                                          "iter_mut",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::deref::DerefMut",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                                    [ F ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              "deref_mut",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                self,
                                                "halo2_proofs::plonk::circuit::ConstraintSystem",
                                                "gates"
                                              |)
                                            ]
                                          |)
                                        ]
                                      |);
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let gate := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "slice")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Expression")
                                                                [ F ]
                                                            ],
                                                          "iter_mut",
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::deref::DerefMut",
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Expression")
                                                                    [ F ];
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              [],
                                                              "deref_mut",
                                                              []
                                                            |),
                                                            [
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.read (| gate |),
                                                                "halo2_proofs::plonk::circuit::Gate",
                                                                "polys"
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)))
                                                ]
                                              |)
                                            | _ => M.impossible (||)
                                            end))
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::flatten::FlatMap")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::IterMut")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Gate")
                                                          [ F ]
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::IterMut")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::circuit::Expression")
                                                          [ F ]
                                                      ];
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&mut")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Gate")
                                                                  [ F ]
                                                              ]
                                                          ]
                                                      ]
                                                      (Ty.apply
                                                        (Ty.path "core::slice::iter::IterMut")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Expression")
                                                            [ F ]
                                                        ])
                                                  ],
                                                [],
                                                "next",
                                                []
                                              |),
                                              [ iter ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let expr := M.copy (| γ0_0 |) in
                                                let _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Self,
                                                        "replace_selectors.compress_selectors",
                                                        []
                                                      |),
                                                      [
                                                        M.read (| expr |);
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Expression")
                                                                  [ F ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ selector_replacements ]
                                                        |);
                                                        Value.Bool false
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |)) in
                      let _ :=
                        M.use
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::flatten::FlatMap")
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                            [ F ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::chain::Chain")
                                        [
                                          Ty.apply
                                            (Ty.path "core::slice::iter::IterMut")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                                [ F ]
                                            ];
                                          Ty.apply
                                            (Ty.path "core::slice::iter::IterMut")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                                [ F ]
                                            ]
                                        ];
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&mut")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::plonk::lookup::Argument")
                                                    [ F ]
                                                ]
                                            ]
                                        ]
                                        (Ty.apply
                                          (Ty.path "core::iter::adapters::chain::Chain")
                                          [
                                            Ty.apply
                                              (Ty.path "core::slice::iter::IterMut")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::circuit::Expression")
                                                  [ F ]
                                              ];
                                            Ty.apply
                                              (Ty.path "core::slice::iter::IterMut")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::circuit::Expression")
                                                  [ F ]
                                              ]
                                          ])
                                    ],
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                            [ F ]
                                        ],
                                      [],
                                      "flat_map",
                                      [
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::chain::Chain")
                                          [
                                            Ty.apply
                                              (Ty.path "core::slice::iter::IterMut")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::circuit::Expression")
                                                  [ F ]
                                              ];
                                            Ty.apply
                                              (Ty.path "core::slice::iter::IterMut")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::circuit::Expression")
                                                  [ F ]
                                              ]
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::lookup::Argument")
                                                      [ F ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.apply
                                            (Ty.path "core::iter::adapters::chain::Chain")
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::IterMut")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::plonk::circuit::Expression")
                                                    [ F ]
                                                ];
                                              Ty.apply
                                                (Ty.path "core::slice::iter::IterMut")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::plonk::circuit::Expression")
                                                    [ F ]
                                                ]
                                            ])
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "slice")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                                [ F ]
                                            ],
                                          "iter_mut",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::deref::DerefMut",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::plonk::lookup::Argument")
                                                    [ F ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              "deref_mut",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                self,
                                                "halo2_proofs::plonk::circuit::ConstraintSystem",
                                                "lookups"
                                              |)
                                            ]
                                          |)
                                        ]
                                      |);
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let lookup := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::iter::traits::iterator::Iterator",
                                                          Ty.apply
                                                            (Ty.path "core::slice::iter::IterMut")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Expression")
                                                                [ F ]
                                                            ],
                                                          [],
                                                          "chain",
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::IterMut")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Expression")
                                                                  [ F ]
                                                              ]
                                                          ]
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Expression")
                                                                    [ F ]
                                                                ],
                                                              "iter_mut",
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::deref::DerefMut",
                                                                  Ty.apply
                                                                    (Ty.path "alloc::vec::Vec")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Expression")
                                                                        [ F ];
                                                                      Ty.path "alloc::alloc::Global"
                                                                    ],
                                                                  [],
                                                                  "deref_mut",
                                                                  []
                                                                |),
                                                                [
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.read (| lookup |),
                                                                    "halo2_proofs::plonk::lookup::Argument",
                                                                    "input_expressions"
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::circuit::Expression")
                                                                    [ F ]
                                                                ],
                                                              "iter_mut",
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::deref::DerefMut",
                                                                  Ty.apply
                                                                    (Ty.path "alloc::vec::Vec")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Expression")
                                                                        [ F ];
                                                                      Ty.path "alloc::alloc::Global"
                                                                    ],
                                                                  [],
                                                                  "deref_mut",
                                                                  []
                                                                |),
                                                                [
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.read (| lookup |),
                                                                    "halo2_proofs::plonk::lookup::Argument",
                                                                    "table_expressions"
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)))
                                                ]
                                              |)
                                            | _ => M.impossible (||)
                                            end))
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::flatten::FlatMap")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::IterMut")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::plonk::lookup::Argument")
                                                          [ F ]
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::chain::Chain")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::IterMut")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Expression")
                                                              [ F ]
                                                          ];
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::IterMut")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::circuit::Expression")
                                                              [ F ]
                                                          ]
                                                      ];
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&mut")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::lookup::Argument")
                                                                  [ F ]
                                                              ]
                                                          ]
                                                      ]
                                                      (Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::chain::Chain")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::slice::iter::IterMut")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Expression")
                                                                [ F ]
                                                            ];
                                                          Ty.apply
                                                            (Ty.path "core::slice::iter::IterMut")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Expression")
                                                                [ F ]
                                                            ]
                                                        ])
                                                  ],
                                                [],
                                                "next",
                                                []
                                              |),
                                              [ iter ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let expr := M.copy (| γ0_0 |) in
                                                let _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Self,
                                                        "replace_selectors.compress_selectors",
                                                        []
                                                      |),
                                                      [
                                                        M.read (| expr |);
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::circuit::Expression")
                                                                  [ F ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ selector_replacements ]
                                                        |);
                                                        Value.Bool true
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |)) in
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| polys |) ] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_compress_selectors :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "compress_selectors" (compress_selectors F).
      
      (*
          pub fn selector(&mut self) -> Selector {
              let index = self.num_selectors;
              self.num_selectors += 1;
              Selector(index, true)
          }
      *)
      Definition selector (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let index :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_selectors"
                  |)
                |) in
              let _ :=
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_selectors"
                  |) in
                M.write (|
                  β,
                  BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                |) in
              M.alloc (|
                Value.StructTuple
                  "halo2_proofs::plonk::circuit::Selector"
                  [ M.read (| index |); Value.Bool true ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_selector :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "selector" (selector F).
      
      (*
          pub fn complex_selector(&mut self) -> Selector {
              let index = self.num_selectors;
              self.num_selectors += 1;
              Selector(index, false)
          }
      *)
      Definition complex_selector (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let index :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_selectors"
                  |)
                |) in
              let _ :=
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_selectors"
                  |) in
                M.write (|
                  β,
                  BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                |) in
              M.alloc (|
                Value.StructTuple
                  "halo2_proofs::plonk::circuit::Selector"
                  [ M.read (| index |); Value.Bool false ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_complex_selector :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "complex_selector" (complex_selector F).
      
      (*
          pub fn lookup_table_column(&mut self) -> TableColumn {
              TableColumn {
                  inner: self.fixed_column(),
              }
          }
      *)
      Definition lookup_table_column (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::TableColumn"
              [
                ("inner",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ],
                      "fixed_column",
                      []
                    |),
                    [ M.read (| self |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_lookup_table_column :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "lookup_table_column" (lookup_table_column F).
      
      (*
          pub fn fixed_column(&mut self) -> Column<Fixed> {
              let tmp = Column {
                  index: self.num_fixed_columns,
                  column_type: Fixed,
              };
              self.num_fixed_columns += 1;
              tmp
          }
      *)
      Definition fixed_column (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let tmp :=
                M.alloc (|
                  Value.StructRecord
                    "halo2_proofs::plonk::circuit::Column"
                    [
                      ("index",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "num_fixed_columns"
                          |)
                        |));
                      ("column_type", Value.StructTuple "halo2_proofs::plonk::circuit::Fixed" [])
                    ]
                |) in
              let _ :=
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_fixed_columns"
                  |) in
                M.write (|
                  β,
                  BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                |) in
              tmp
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fixed_column :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "fixed_column" (fixed_column F).
      
      (*
          pub fn advice_column(&mut self) -> Column<Advice> {
              let tmp = Column {
                  index: self.num_advice_columns,
                  column_type: Advice,
              };
              self.num_advice_columns += 1;
              self.num_advice_queries.push(0);
              tmp
          }
      *)
      Definition advice_column (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let tmp :=
                M.alloc (|
                  Value.StructRecord
                    "halo2_proofs::plonk::circuit::Column"
                    [
                      ("index",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "num_advice_columns"
                          |)
                        |));
                      ("column_type", Value.StructTuple "halo2_proofs::plonk::circuit::Advice" [])
                    ]
                |) in
              let _ :=
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_advice_columns"
                  |) in
                M.write (|
                  β,
                  BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      "push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "num_advice_queries"
                      |);
                      Value.Integer 0
                    ]
                  |)
                |) in
              tmp
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_advice_column :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "advice_column" (advice_column F).
      
      (*
          pub fn named_advice_column(&mut self, name: String) -> Column<Advice> {
              let res = Column {
                  index: self.num_advice_columns,
                  column_type: Advice,
              };
              self.named_advices
                  .push((name, self.num_advice_columns as u32));
              self.num_advice_columns += 1;
              self.num_advice_queries.push(0);
              res
          }
      *)
      Definition named_advice_column (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; name ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let name := M.alloc (| name |) in
            M.read (|
              let res :=
                M.alloc (|
                  Value.StructRecord
                    "halo2_proofs::plonk::circuit::Column"
                    [
                      ("index",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "num_advice_columns"
                          |)
                        |));
                      ("column_type", Value.StructTuple "halo2_proofs::plonk::circuit::Advice" [])
                    ]
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.tuple [ Ty.path "alloc::string::String"; Ty.path "u32" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "named_advices"
                      |);
                      Value.Tuple
                        [
                          M.read (| name |);
                          M.rust_cast
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::circuit::ConstraintSystem",
                                "num_advice_columns"
                              |)
                            |))
                        ]
                    ]
                  |)
                |) in
              let _ :=
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_advice_columns"
                  |) in
                M.write (|
                  β,
                  BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      "push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "num_advice_queries"
                      |);
                      Value.Integer 0
                    ]
                  |)
                |) in
              res
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_named_advice_column :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "named_advice_column" (named_advice_column F).
      
      (*
          pub fn instance_column(&mut self) -> Column<Instance> {
              let tmp = Column {
                  index: self.num_instance_columns,
                  column_type: Instance,
              };
              self.num_instance_columns += 1;
              tmp
          }
      *)
      Definition instance_column (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let tmp :=
                M.alloc (|
                  Value.StructRecord
                    "halo2_proofs::plonk::circuit::Column"
                    [
                      ("index",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "num_instance_columns"
                          |)
                        |));
                      ("column_type", Value.StructTuple "halo2_proofs::plonk::circuit::Instance" [])
                    ]
                |) in
              let _ :=
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                    "num_instance_columns"
                  |) in
                M.write (|
                  β,
                  BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                |) in
              tmp
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_instance_column :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "instance_column" (instance_column F).
      
      (*
          pub fn degree(&self) -> usize {
              // The permutation argument will serve alongside the gates, so must be
              // accounted for.
              let mut degree = self.permutation.required_degree();
      
              // The lookup argument also serves alongside the gates and must be accounted
              // for.
              degree = std::cmp::max(
                  degree,
                  self.lookups
                      .iter()
                      .map(|l| l.required_degree())
                      .max()
                      .unwrap_or(1),
              );
      
              // Account for each gate to ensure our quotient polynomial is the
              // correct degree and that our extended domain is the right size.
              degree = std::cmp::max(
                  degree,
                  self.gates
                      .iter()
                      .flat_map(|gate| gate.polynomials().iter().map(|poly| poly.degree()))
                      .max()
                      .unwrap_or(0),
              );
      
              std::cmp::max(degree, self.minimum_degree.unwrap_or(1))
          }
      *)
      Definition degree (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let degree :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "halo2_proofs::plonk::permutation::Argument",
                      "required_degree",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::ConstraintSystem",
                        "permutation"
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.write (|
                  degree,
                  M.call_closure (|
                    M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                    [
                      M.read (| degree |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                          "unwrap_or",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                        [ F ]
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    (Ty.path "usize")
                                ],
                              [],
                              "max",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                        [ F ]
                                    ],
                                  [],
                                  "map",
                                  [
                                    Ty.path "usize";
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                                  [ F ]
                                              ]
                                          ]
                                      ]
                                      (Ty.path "usize")
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                            [ F ]
                                        ],
                                      "iter",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::lookup::Argument")
                                                [ F ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                                            "lookups"
                                          |)
                                        ]
                                      |)
                                    ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let l := M.copy (| γ |) in
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::lookup::Argument")
                                                        [ F ],
                                                      "required_degree",
                                                      []
                                                    |),
                                                    [ M.read (| l |) ]
                                                  |)))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |)
                            ]
                          |);
                          Value.Integer 1
                        ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.write (|
                  degree,
                  M.call_closure (|
                    M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                    [
                      M.read (| degree |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                          "unwrap_or",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::flatten::FlatMap")
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ]
                                    ];
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                            [ F ]
                                        ];
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::plonk::circuit::Expression")
                                                    [ F ]
                                                ]
                                            ]
                                        ]
                                        (Ty.path "usize")
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      [
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ]
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Expression")
                                                      [ F ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.path "usize")
                                      ])
                                ],
                              [],
                              "max",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Gate") [ F ]
                                    ],
                                  [],
                                  "flat_map",
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      [
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ]
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Expression")
                                                      [ F ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.path "usize")
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                                  [ F ]
                                              ]
                                          ]
                                      ]
                                      (Ty.apply
                                        (Ty.path "core::iter::adapters::map::Map")
                                        [
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                                [ F ]
                                            ];
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::circuit::Expression")
                                                        [ F ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "usize")
                                        ])
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                            [ F ]
                                        ],
                                      "iter",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::plonk::circuit::Gate")
                                                [ F ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                                            "gates"
                                          |)
                                        ]
                                      |)
                                    ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let gate := M.copy (| γ |) in
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::circuit::Expression")
                                                            [ F ]
                                                        ],
                                                      [],
                                                      "map",
                                                      [
                                                        Ty.path "usize";
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Expression")
                                                                      [ F ]
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.path "usize")
                                                      ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "slice")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Expression")
                                                                [ F ]
                                                            ],
                                                          "iter",
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::plonk::circuit::Gate")
                                                                [ F ],
                                                              "polynomials",
                                                              []
                                                            |),
                                                            [ M.read (| gate |) ]
                                                          |)
                                                        ]
                                                      |);
                                                      M.closure
                                                        (fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [ α0 ] =>
                                                              M.match_operator (|
                                                                M.alloc (| α0 |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let poly := M.copy (| γ |) in
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::plonk::circuit::Expression")
                                                                            [ F ],
                                                                          "degree",
                                                                          []
                                                                        |),
                                                                        [ M.read (| poly |) ]
                                                                      |)))
                                                                ]
                                                              |)
                                                            | _ => M.impossible (||)
                                                            end))
                                                    ]
                                                  |)))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |)
                            ]
                          |);
                          Value.Integer 0
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                  [
                    M.read (| degree |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                        "unwrap_or",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::circuit::ConstraintSystem",
                            "minimum_degree"
                          |)
                        |);
                        Value.Integer 1
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_degree :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "degree" (degree F).
      
      (*
          pub fn blinding_factors(&self) -> usize {
              // All of the prover's advice columns are evaluated at no more than
              let factors = *self.num_advice_queries.iter().max().unwrap_or(&1);
              // distinct points during gate checks.
      
              // - The permutation argument witness polynomials are evaluated at most 3 times.
              // - Each lookup argument has independent witness polynomials, and they are
              //   evaluated at most 2 times.
              let factors = std::cmp::max(3, factors);
      
              // Each polynomial is evaluated at most an additional time during
              // multiopen (at x_3 to produce q_evals):
              let factors = factors + 1;
      
              // h(x) is derived by the other evaluations so it does not reveal
              // anything; in fact it does not even appear in the proof.
      
              // h(x_3) is also not revealed; the verifier only learns a single
              // evaluation of a polynomial in x_1 which has h(x_3) and another random
              // polynomial evaluated at x_3 as coefficients -- this random polynomial
              // is "random_poly" in the vanishing argument.
      
              // Add an additional blinding factor as a slight defense against
              // off-by-one errors.
              factors + 1
          }
      *)
      Definition blinding_factors (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let factors :=
                M.copy (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [ Ty.apply (Ty.path "&") [ Ty.path "usize" ] ],
                      "unwrap_or",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.path "usize" ],
                          [],
                          "max",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ Ty.path "usize" ],
                              "iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::plonk::circuit::ConstraintSystem",
                                    "num_advice_queries"
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |);
                      M.alloc (| Value.Integer 1 |)
                    ]
                  |)
                |) in
              let factors :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                    [ Value.Integer 3; M.read (| factors |) ]
                  |)
                |) in
              let factors :=
                M.alloc (|
                  BinOp.Panic.add (| Integer.Usize, M.read (| factors |), Value.Integer 1 |)
                |) in
              M.alloc (|
                BinOp.Panic.add (| Integer.Usize, M.read (| factors |), Value.Integer 1 |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_blinding_factors :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "blinding_factors" (blinding_factors F).
      
      (*
          pub fn minimum_rows(&self) -> usize {
              self.blinding_factors() // m blinding factors
                  + 1 // for l_{-(m + 1)} (l_last)
                  + 1 // for l_0 (just for extra breathing room for the permutation
                      // argument, to essentially force a separation in the
                      // permutation polynomial between the roles of l_last, l_0
                      // and the interstitial values.)
                  + 1 // for at least one row
          }
      *)
      Definition minimum_rows (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Panic.add (|
              Integer.Usize,
              BinOp.Panic.add (|
                Integer.Usize,
                BinOp.Panic.add (|
                  Integer.Usize,
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ],
                      "blinding_factors",
                      []
                    |),
                    [ M.read (| self |) ]
                  |),
                  Value.Integer 1
                |),
                Value.Integer 1
              |),
              Value.Integer 1
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_minimum_rows :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "minimum_rows" (minimum_rows F).
    End Impl_halo2_proofs_plonk_circuit_ConstraintSystem_F.
    
    (* StructRecord
      {
        name := "VirtualCells";
        ty_params := [ "F" ];
        fields :=
          [
            ("meta",
              Ty.apply
                (Ty.path "&mut")
                [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ] ]);
            ("queried_selectors",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "halo2_proofs::plonk::circuit::Selector"; Ty.path "alloc::alloc::Global"
                ]);
            ("queried_cells",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.path "halo2_proofs::plonk::circuit::VirtualCell";
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_VirtualCells_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "VirtualCells" |);
                M.read (| Value.String "meta" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::VirtualCells",
                    "meta"
                  |));
                M.read (| Value.String "queried_selectors" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::circuit::VirtualCells",
                    "queried_selectors"
                  |));
                M.read (| Value.String "queried_cells" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::circuit::VirtualCells",
                      "queried_cells"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_circuit_VirtualCells_F.
    
    Module Impl_halo2_proofs_plonk_circuit_VirtualCells_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ].
      
      (*
          fn new(meta: &'a mut ConstraintSystem<F>) -> Self {
              VirtualCells {
                  meta,
                  queried_selectors: vec![],
                  queried_cells: vec![],
              }
          }
      *)
      Definition new (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ meta ] =>
          ltac:(M.monadic
            (let meta := M.alloc (| meta |) in
            Value.StructRecord
              "halo2_proofs::plonk::circuit::VirtualCells"
              [
                ("meta", M.read (| meta |));
                ("queried_selectors",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "halo2_proofs::plonk::circuit::Selector";
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |));
                ("queried_cells",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "halo2_proofs::plonk::circuit::VirtualCell";
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "new" (new F).
      
      (*
          pub fn query_selector(&mut self, selector: Selector) -> Expression<F> {
              self.queried_selectors.push(selector);
              Expression::Selector(selector)
          }
      *)
      Definition query_selector (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; selector ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let selector := M.alloc (| selector |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "halo2_proofs::plonk::circuit::Selector";
                          Ty.path "alloc::alloc::Global"
                        ],
                      "push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::VirtualCells",
                        "queried_selectors"
                      |);
                      M.read (| selector |)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructTuple
                  "halo2_proofs::plonk::circuit::Expression::Selector"
                  [ M.read (| selector |) ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_query_selector :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "query_selector" (query_selector F).
      
      (*
          pub fn query_fixed(&mut self, column: Column<Fixed>, at: Rotation) -> Expression<F> {
              self.queried_cells.push((column, at).into());
              Expression::Fixed {
                  query_index: self.meta.query_fixed_index(column, at),
                  column_index: column.index,
                  rotation: at,
              }
          }
      *)
      Definition query_fixed (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "halo2_proofs::plonk::circuit::VirtualCell";
                          Ty.path "alloc::alloc::Global"
                        ],
                      "push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::VirtualCells",
                        "queried_cells"
                      |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                              Ty.path "halo2_proofs::poly::Rotation"
                            ],
                          [ Ty.path "halo2_proofs::plonk::circuit::VirtualCell" ],
                          "into",
                          []
                        |),
                        [ Value.Tuple [ M.read (| column |); M.read (| at_ |) ] ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "halo2_proofs::plonk::circuit::Expression::Fixed"
                  [
                    ("query_index",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ],
                          "query_fixed_index",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::VirtualCells",
                              "meta"
                            |)
                          |);
                          M.read (| column |);
                          M.read (| at_ |)
                        ]
                      |));
                    ("column_index",
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          column,
                          "halo2_proofs::plonk::circuit::Column",
                          "index"
                        |)
                      |));
                    ("rotation", M.read (| at_ |))
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_query_fixed :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "query_fixed" (query_fixed F).
      
      (*
          pub fn query_advice(&mut self, column: Column<Advice>, at: Rotation) -> Expression<F> {
              self.queried_cells.push((column, at).into());
              Expression::Advice {
                  query_index: self.meta.query_advice_index(column, at),
                  column_index: column.index,
                  rotation: at,
              }
          }
      *)
      Definition query_advice (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "halo2_proofs::plonk::circuit::VirtualCell";
                          Ty.path "alloc::alloc::Global"
                        ],
                      "push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::VirtualCells",
                        "queried_cells"
                      |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                              Ty.path "halo2_proofs::poly::Rotation"
                            ],
                          [ Ty.path "halo2_proofs::plonk::circuit::VirtualCell" ],
                          "into",
                          []
                        |),
                        [ Value.Tuple [ M.read (| column |); M.read (| at_ |) ] ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "halo2_proofs::plonk::circuit::Expression::Advice"
                  [
                    ("query_index",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ],
                          "query_advice_index",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::VirtualCells",
                              "meta"
                            |)
                          |);
                          M.read (| column |);
                          M.read (| at_ |)
                        ]
                      |));
                    ("column_index",
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          column,
                          "halo2_proofs::plonk::circuit::Column",
                          "index"
                        |)
                      |));
                    ("rotation", M.read (| at_ |))
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_query_advice :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "query_advice" (query_advice F).
      
      (*
          pub fn query_instance(&mut self, column: Column<Instance>, at: Rotation) -> Expression<F> {
              self.queried_cells.push((column, at).into());
              Expression::Instance {
                  query_index: self.meta.query_instance_index(column, at),
                  column_index: column.index,
                  rotation: at,
              }
          }
      *)
      Definition query_instance (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "halo2_proofs::plonk::circuit::VirtualCell";
                          Ty.path "alloc::alloc::Global"
                        ],
                      "push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::circuit::VirtualCells",
                        "queried_cells"
                      |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::plonk::circuit::Column")
                                [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                              Ty.path "halo2_proofs::poly::Rotation"
                            ],
                          [ Ty.path "halo2_proofs::plonk::circuit::VirtualCell" ],
                          "into",
                          []
                        |),
                        [ Value.Tuple [ M.read (| column |); M.read (| at_ |) ] ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "halo2_proofs::plonk::circuit::Expression::Instance"
                  [
                    ("query_index",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem") [ F ],
                          "query_instance_index",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::circuit::VirtualCells",
                              "meta"
                            |)
                          |);
                          M.read (| column |);
                          M.read (| at_ |)
                        ]
                      |));
                    ("column_index",
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          column,
                          "halo2_proofs::plonk::circuit::Column",
                          "index"
                        |)
                      |));
                    ("rotation", M.read (| at_ |))
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_query_instance :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "query_instance" (query_instance F).
      
      (*
          pub fn query_any<C: Into<Column<Any>>>(&mut self, column: C, at: Rotation) -> Expression<F> {
              let column = column.into();
              match column.column_type() {
                  Any::Advice => self.query_advice(Column::<Advice>::try_from(column).unwrap(), at),
                  Any::Fixed => self.query_fixed(Column::<Fixed>::try_from(column).unwrap(), at),
                  Any::Instance => self.query_instance(Column::<Instance>::try_from(column).unwrap(), at),
              }
          }
      *)
      Definition query_any (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [ C ], [ self; column; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            let at_ := M.alloc (| at_ |) in
            M.read (|
              let column :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::Into",
                      C,
                      [
                        Ty.apply
                          (Ty.path "halo2_proofs::plonk::circuit::Column")
                          [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                      ],
                      "into",
                      []
                    |),
                    [ M.read (| column |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ],
                      "column_type",
                      []
                    |),
                    [ column ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                            "query_advice",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Advice" ];
                                    Ty.apply (Ty.path "&") [ Ty.path "str" ]
                                  ],
                                "unwrap",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Advice" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "try_from",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |)
                              ]
                            |);
                            M.read (| at_ |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                            "query_fixed",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ];
                                    Ty.apply (Ty.path "&") [ Ty.path "str" ]
                                  ],
                                "unwrap",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Fixed" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "try_from",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |)
                              ]
                            |);
                            M.read (| at_ |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                            "query_instance",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Instance" ];
                                    Ty.apply (Ty.path "&") [ Ty.path "str" ]
                                  ],
                                "unwrap",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                                      [ Ty.path "halo2_proofs::plonk::circuit::Instance" ],
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                    "try_from",
                                    []
                                  |),
                                  [ M.read (| column |) ]
                                |)
                              ]
                            |);
                            M.read (| at_ |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_query_any :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "query_any" (query_any F).
    End Impl_halo2_proofs_plonk_circuit_VirtualCells_F.
  End circuit.
End plonk.
