(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module plonk.
  Module error.
    (*
    Enum Error
    {
      ty_params := [];
      variants :=
        [
          {
            name := "Synthesis";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "InvalidInstances";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "ConstraintSystemFailure";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "BoundsFailure";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Opening";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Transcript";
            item := StructTuple [ Ty.path "std::io::error::Error" ];
            discriminant := None;
          };
          {
            name := "NotEnoughRowsAvailable";
            item := StructRecord [ ("current_k", Ty.path "u32") ];
            discriminant := None;
          };
          {
            name := "InstanceTooLarge";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "NotEnoughColumnsForConstants";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "ColumnNotInPermutation";
            item :=
              StructTuple
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                ];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_plonk_error_Error.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::error::Error".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "Synthesis" |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "InvalidInstances" |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "ConstraintSystemFailure" |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "BoundsFailure" |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "Opening" |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::error::Error::Transcript",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Transcript" |);
                            (* Unsize *) M.pointer_coercion __self_0
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::error::Error::NotEnoughRowsAvailable",
                          "current_k"
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_struct_field1_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "NotEnoughRowsAvailable" |);
                            M.read (| Value.String "current_k" |);
                            (* Unsize *) M.pointer_coercion __self_0
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "InstanceTooLarge" |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "NotEnoughColumnsForConstants" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::error::Error::ColumnNotInPermutation",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "ColumnNotInPermutation" |);
                            (* Unsize *) M.pointer_coercion __self_0
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_plonk_error_Error.
    
    Module Impl_core_convert_From_std_io_error_Error_for_halo2_proofs_plonk_error_Error.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::error::Error".
      
      (*
          fn from(error: io::Error) -> Self {
              // The only place we can get io::Error from is the transcript.
              Error::Transcript(error)
          }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ error ] =>
          ltac:(M.monadic
            (let error := M.alloc (| error |) in
            Value.StructTuple
              "halo2_proofs::plonk::error::Error::Transcript"
              [ M.read (| error |) ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "std::io::error::Error" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_std_io_error_Error_for_halo2_proofs_plonk_error_Error.
    
    Module Impl_halo2_proofs_plonk_error_Error.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::error::Error".
      
      (*
          pub(crate) fn not_enough_rows_available(current_k: u32) -> Self {
              Error::NotEnoughRowsAvailable { current_k }
          }
      *)
      Definition not_enough_rows_available (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ current_k ] =>
          ltac:(M.monadic
            (let current_k := M.alloc (| current_k |) in
            Value.StructRecord
              "halo2_proofs::plonk::error::Error::NotEnoughRowsAvailable"
              [ ("current_k", M.read (| current_k |)) ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_not_enough_rows_available :
        M.IsAssociatedFunction Self "not_enough_rows_available" not_enough_rows_available.
    End Impl_halo2_proofs_plonk_error_Error.
    
    Module Impl_core_fmt_Display_for_halo2_proofs_plonk_error_Error.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::error::Error".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              match self {
                  Error::Synthesis => write!(f, "General synthesis error"),
                  Error::InvalidInstances => write!(f, "Provided instances do not match the circuit"),
                  Error::ConstraintSystemFailure => write!(f, "The constraint system is not satisfied"),
                  Error::BoundsFailure => write!(f, "An out-of-bounds index was passed to the backend"),
                  Error::Opening => write!(f, "Multi-opening proof was invalid"),
                  Error::Transcript(e) => write!(f, "Transcript error: {}", e),
                  Error::NotEnoughRowsAvailable { current_k } => write!(
                      f,
                      "k = {} is too small for the given circuit. Try using a larger value of k",
                      current_k,
                  ),
                  Error::InstanceTooLarge => write!(f, "Instance vectors are larger than the circuit"),
                  Error::NotEnoughColumnsForConstants => {
                      write!(
                          f,
                          "Too few fixed columns are enabled for global constants usage"
                      )
                  }
                  Error::ColumnNotInPermutation(column) => write!(
                      f,
                      "Column {:?} must be included in the permutation. Help: try applying `meta.enable_equalty` on the column",
                      column
                  ),
              }
          }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [ M.read (| Value.String "General synthesis error" |) ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String "Provided instances do not match the circuit"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String "The constraint system is not satisfied"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "An out-of-bounds index was passed to the backend"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [ M.read (| Value.String "Multi-opening proof was invalid" |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::error::Error::Transcript",
                          0
                        |) in
                      let e := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_v1",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array [ M.read (| Value.String "Transcript error: " |) ]
                                  |));
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                [ Ty.path "std::io::error::Error" ]
                                            ]
                                          |),
                                          [ e ]
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "halo2_proofs::plonk::error::Error::NotEnoughRowsAvailable",
                          "current_k"
                        |) in
                      let current_k := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_v1",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (| Value.String "k = " |);
                                        M.read (|
                                          Value.String
                                            " is too small for the given circuit. Try using a larger value of k"
                                        |)
                                      ]
                                  |));
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [ Ty.apply (Ty.path "&") [ Ty.path "u32" ] ]
                                          |),
                                          [ current_k ]
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "Instance vectors are larger than the circuit"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "Too few fixed columns are enabled for global constants usage"
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::error::Error::ColumnNotInPermutation",
                          0
                        |) in
                      let column := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_v1",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (| Value.String "Column " |);
                                        M.read (|
                                          Value.String
                                            " must be included in the permutation. Help: try applying `meta.enable_equalty` on the column"
                                        |)
                                      ]
                                  |));
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_debug",
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                                ]
                                            ]
                                          |),
                                          [ column ]
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_halo2_proofs_plonk_error_Error.
    
    Module Impl_core_error_Error_for_halo2_proofs_plonk_error_Error.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::error::Error".
      
      (*
          fn source(&self) -> Option<&(dyn error::Error + 'static)> {
              match self {
                  Error::Transcript(e) => Some(e),
                  _ => None,
              }
          }
      *)
      Definition source (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::plonk::error::Error::Transcript",
                          0
                        |) in
                      let e := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ (* Unsize *) M.pointer_coercion (M.read (| e |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::error::Error"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("source", InstanceField.Method source) ].
    End Impl_core_error_Error_for_halo2_proofs_plonk_error_Error.
  End error.
End plonk.
