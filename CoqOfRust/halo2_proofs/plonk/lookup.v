(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module plonk.
  Module lookup.
    (* StructRecord
      {
        name := "Argument";
        ty_params := [ "F" ];
        fields :=
          [
            ("name", Ty.apply (Ty.path "&") [ Ty.path "str" ]);
            ("input_expressions",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("table_expressions",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_plonk_lookup_Argument_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ].
      
      (* Clone *)
      Definition clone (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::plonk::lookup::Argument"
              [
                ("name",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "&") [ Ty.path "str" ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::lookup::Argument",
                        "name"
                      |)
                    ]
                  |));
                ("input_expressions",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::lookup::Argument",
                        "input_expressions"
                      |)
                    ]
                  |));
                ("table_expressions",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::lookup::Argument",
                        "table_expressions"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_where_ff_Field_F_for_halo2_proofs_plonk_lookup_Argument_F.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_lookup_Argument_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Argument" |);
                M.read (| Value.String "name" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::lookup::Argument",
                    "name"
                  |));
                M.read (| Value.String "input_expressions" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::lookup::Argument",
                    "input_expressions"
                  |));
                M.read (| Value.String "table_expressions" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::lookup::Argument",
                      "table_expressions"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_ff_Field_F_for_halo2_proofs_plonk_lookup_Argument_F.
    
    Module Impl_halo2_proofs_plonk_lookup_Argument_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ].
      
      (*
          pub fn new(name: &'static str, table_map: Vec<(Expression<F>, Expression<F>)>) -> Self {
              let (input_expressions, table_expressions) = table_map.into_iter().unzip();
              Argument {
                  name,
                  input_expressions,
                  table_expressions,
              }
          }
      *)
      Definition new (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ name; table_map ] =>
          ltac:(M.monadic
            (let name := M.alloc (| name |) in
            let table_map := M.alloc (| table_map |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [
                          Ty.tuple
                            [
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                              Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "unzip",
                      [
                        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                        Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ];
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "into_iter",
                          []
                        |),
                        [ M.read (| table_map |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let input_expressions := M.copy (| γ0_0 |) in
                      let table_expressions := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.StructRecord
                          "halo2_proofs::plonk::lookup::Argument"
                          [
                            ("name", M.read (| name |));
                            ("input_expressions", M.read (| input_expressions |));
                            ("table_expressions", M.read (| table_expressions |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "new" (new F).
      
      (*
          pub(crate) fn required_degree(&self) -> usize {
              assert_eq!(self.input_expressions.len(), self.table_expressions.len());
      
              // The first value in the permutation poly should be one.
              // degree 2:
              // l_0(X) * (1 - z(X)) = 0
              //
              // The "last" value in the permutation poly should be a boolean, for
              // completeness and soundness.
              // degree 3:
              // l_last(X) * (z(X)^2 - z(X)) = 0
              //
              // Enable the permutation argument for only the rows involved.
              // degree (2 + input_degree + table_degree) or 4, whichever is larger:
              // (1 - (l_last(X) + l_blind(X))) * (
              //   z(\omega X) (a'(X) + \beta) (s'(X) + \gamma)
              //   - z(X) (\theta^{m-1} a_0(X) + ... + a_{m-1}(X) + \beta) (\theta^{m-1} s_0(X) + ... + s_{m-1}(X) + \gamma)
              // ) = 0
              //
              // The first two values of a' and s' should be the same.
              // degree 2:
              // l_0(X) * (a'(X) - s'(X)) = 0
              //
              // Either the two values are the same, or the previous
              // value of a' is the same as the current value.
              // degree 3:
              // (1 - (l_last(X) + l_blind(X))) * (a′(X) − s′(X))⋅(a′(X) − a′(\omega^{-1} X)) = 0
              let mut input_degree = 1;
              for expr in self.input_expressions.iter() {
                  input_degree = std::cmp::max(input_degree, expr.degree());
              }
              let mut table_degree = 1;
              for expr in self.table_expressions.iter() {
                  table_degree = std::cmp::max(table_degree, expr.degree());
              }
      
              // In practice because input_degree and table_degree are initialized to
              // one, the latter half of this max() invocation is at least 4 always,
              // rendering this call pointless except to be explicit in case we change
              // the initialization of input_degree/table_degree in the future.
              std::cmp::max(
                  // (1 - (l_last + l_blind)) z(\omega X) (a'(X) + \beta) (s'(X) + \gamma)
                  4,
                  // (1 - (l_last + l_blind)) z(X) (\theta^{m-1} a_0(X) + ... + a_{m-1}(X) + \beta) (\theta^{m-1} s_0(X) + ... + s_{m-1}(X) + \gamma)
                  2 + input_degree + table_degree,
              )
          }
      *)
      Definition required_degree (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    Value.Tuple
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "len",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::lookup::Argument",
                                "input_expressions"
                              |)
                            ]
                          |)
                        |);
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "len",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::lookup::Argument",
                                "table_expressions"
                              |)
                            ]
                          |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (BinOp.Pure.eq
                                          (M.read (| M.read (| left_val |) |))
                                          (M.read (| M.read (| right_val |) |)))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let kind :=
                                        M.alloc (|
                                          Value.StructTuple "core::panicking::AssertKind::Eq" []
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.read (| left_val |);
                                            M.read (| right_val |);
                                            Value.StructTuple "core::option::Option::None" []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |) in
              let input_degree := M.alloc (| Value.Integer 1 |) in
              let _ :=
                M.use
                  (M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ] ],
                          [],
                          "into_iter",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ]
                                ],
                              "iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                        [ F ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::plonk::lookup::Argument",
                                    "input_expressions"
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            ltac:(M.monadic
                              (let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ]
                                          ],
                                        [],
                                        "next",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let expr := M.copy (| γ0_0 |) in
                                        let _ :=
                                          M.write (|
                                            input_degree,
                                            M.call_closure (|
                                              M.get_function (|
                                                "core::cmp::max",
                                                [ Ty.path "usize" ]
                                              |),
                                              [
                                                M.read (| input_degree |);
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Expression")
                                                      [ F ],
                                                    "degree",
                                                    []
                                                  |),
                                                  [ M.read (| expr |) ]
                                                |)
                                              ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |)) in
              let table_degree := M.alloc (| Value.Integer 1 |) in
              let _ :=
                M.use
                  (M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ] ],
                          [],
                          "into_iter",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                    [ F ]
                                ],
                              "iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                        [ F ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::plonk::lookup::Argument",
                                    "table_expressions"
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            ltac:(M.monadic
                              (let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ]
                                          ],
                                        [],
                                        "next",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let expr := M.copy (| γ0_0 |) in
                                        let _ :=
                                          M.write (|
                                            table_degree,
                                            M.call_closure (|
                                              M.get_function (|
                                                "core::cmp::max",
                                                [ Ty.path "usize" ]
                                              |),
                                              [
                                                M.read (| table_degree |);
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Expression")
                                                      [ F ],
                                                    "degree",
                                                    []
                                                  |),
                                                  [ M.read (| expr |) ]
                                                |)
                                              ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |)) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                  [
                    Value.Integer 4;
                    BinOp.Panic.add (|
                      Integer.Usize,
                      BinOp.Panic.add (|
                        Integer.Usize,
                        Value.Integer 2,
                        M.read (| input_degree |)
                      |),
                      M.read (| table_degree |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_required_degree :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "required_degree" (required_degree F).
    End Impl_halo2_proofs_plonk_lookup_Argument_F.
  End lookup.
End plonk.
