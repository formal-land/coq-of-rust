(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module plonk.
  Module lookup.
    Module prover.
      (* StructRecord
        {
          name := "Permuted";
          ty_params := [ "C" ];
          fields :=
            [
              ("compressed_input_expression",
                Ty.apply
                  (Ty.path "halo2_proofs::poly::Polynomial")
                  [ Ty.associated; Ty.path "halo2_proofs::poly::LagrangeCoeff" ]);
              ("permuted_input_expression",
                Ty.apply
                  (Ty.path "halo2_proofs::poly::Polynomial")
                  [ Ty.associated; Ty.path "halo2_proofs::poly::LagrangeCoeff" ]);
              ("compressed_table_expression",
                Ty.apply
                  (Ty.path "halo2_proofs::poly::Polynomial")
                  [ Ty.associated; Ty.path "halo2_proofs::poly::LagrangeCoeff" ]);
              ("permuted_table_expression",
                Ty.apply
                  (Ty.path "halo2_proofs::poly::Polynomial")
                  [ Ty.associated; Ty.path "halo2_proofs::poly::LagrangeCoeff" ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_plonk_lookup_prover_Permuted_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::prover::Permuted") [ C ].
        
        (* Debug *)
        Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field4_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "Permuted" |);
                  M.read (| Value.String "compressed_input_expression" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::lookup::prover::Permuted",
                      "compressed_input_expression"
                    |));
                  M.read (| Value.String "permuted_input_expression" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::lookup::prover::Permuted",
                      "permuted_input_expression"
                    |));
                  M.read (| Value.String "compressed_table_expression" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::lookup::prover::Permuted",
                      "compressed_table_expression"
                    |));
                  M.read (| Value.String "permuted_table_expression" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::lookup::prover::Permuted",
                        "permuted_table_expression"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (C : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self C)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_plonk_lookup_prover_Permuted_C.
      
      (* StructRecord
        {
          name := "Committed";
          ty_params := [ "C" ];
          fields :=
            [
              ("permuted_input_poly",
                Ty.apply
                  (Ty.path "halo2_proofs::poly::Polynomial")
                  [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]);
              ("permuted_table_poly",
                Ty.apply
                  (Ty.path "halo2_proofs::poly::Polynomial")
                  [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]);
              ("product_poly",
                Ty.apply
                  (Ty.path "halo2_proofs::poly::Polynomial")
                  [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_plonk_lookup_prover_Committed_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::prover::Committed") [ C ].
        
        (* Debug *)
        Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field3_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "Committed" |);
                  M.read (| Value.String "permuted_input_poly" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::lookup::prover::Committed",
                      "permuted_input_poly"
                    |));
                  M.read (| Value.String "permuted_table_poly" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::lookup::prover::Committed",
                      "permuted_table_poly"
                    |));
                  M.read (| Value.String "product_poly" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::lookup::prover::Committed",
                        "product_poly"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (C : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self C)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_plonk_lookup_prover_Committed_C.
      
      (* StructRecord
        {
          name := "Evaluated";
          ty_params := [ "C" ];
          fields :=
            [
              ("constructed",
                Ty.apply (Ty.path "halo2_proofs::plonk::lookup::prover::Committed") [ C ])
            ];
        } *)
      
      Module Impl_halo2_proofs_plonk_lookup_Argument_F.
        Definition Self (F : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ].
        
        (*
            pub(in crate::plonk) fn commit_permuted<'a, C, R: RngCore>(
                &self,
                pk: &ProvingKey<C>,
                params: &Params<C>,
                domain: &EvaluationDomain<C::Scalar>,
                theta: ChallengeTheta<C>,
                advice_values: &'a [Polynomial<C::Scalar, LagrangeCoeff>],
                fixed_values: &'a [Polynomial<C::Scalar, LagrangeCoeff>],
                instance_values: &'a [Polynomial<C::Scalar, LagrangeCoeff>],
                mut rng: R,
            ) -> Result<(Permuted<C>, [C; 2]), Error>
            where
                C: CurveAffine<ScalarExt = F>,
                C::Curve: Mul<F, Output = C::Curve> + MulAssign<F>,
            {
                // Closure to get values of expressions and compress them
                let compress_expressions = |expressions: &[Expression<C::Scalar>]| {
                    pk.vk.domain.lagrange_from_vec(evaluate_with_theta(
                        expressions,
                        params.n as usize,
                        1,
                        fixed_values,
                        advice_values,
                        instance_values,
                        *theta,
                    ))
                };
        
                // Closure to construct commitment to vector of values
                let commit_values = |values: &Polynomial<C::Scalar, LagrangeCoeff>, max_bits: usize| {
                    params
                        .commit_lagrange_with_bound(values, max_bits)
                        .to_affine()
                };
        
                // Get values of input expressions involved in the lookup and compress them
                let compressed_input_expression = compress_expressions(&self.input_expressions);
        
                // Get values of table expressions involved in the lookup and compress them
                let compressed_table_expression = compress_expressions(&self.table_expressions);
        
                // Permute compressed (InputExpression, TableExpression) pair
                let (
                    permuted_input_expression,
                    permuted_table_expression,
                    permuted_input_expression_max_bits,
                    permuted_table_expression_max_bits,
                ) = permute_expression_pair::<C, _>(
                    pk,
                    params,
                    domain,
                    &mut rng,
                    &compressed_input_expression,
                    &compressed_table_expression,
                )?;
        
                // Commit to permuted input expression
                let permuted_input_commitment = commit_values(
                    &permuted_input_expression,
                    permuted_input_expression_max_bits,
                );
        
                // Commit to permuted table expression
                let permuted_table_commitment = commit_values(
                    &permuted_table_expression,
                    permuted_table_expression_max_bits,
                );
        
                Ok((
                    Permuted {
                        compressed_input_expression,
                        permuted_input_expression,
                        compressed_table_expression,
                        permuted_table_expression,
                    },
                    [permuted_input_commitment, permuted_table_commitment],
                ))
            }
        *)
        Definition commit_permuted (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match τ, α with
          | [ C; R ],
              [ self; pk; params; domain; theta; advice_values; fixed_values; instance_values; rng
              ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let pk := M.alloc (| pk |) in
              let params := M.alloc (| params |) in
              let domain := M.alloc (| domain |) in
              let theta := M.alloc (| theta |) in
              let advice_values := M.alloc (| advice_values |) in
              let fixed_values := M.alloc (| fixed_values |) in
              let instance_values := M.alloc (| instance_values |) in
              let rng := M.alloc (| rng |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let compress_expressions :=
                      M.alloc (|
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let expressions := M.copy (| γ |) in
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "halo2_proofs::poly::domain::EvaluationDomain")
                                              [ F ],
                                            "lagrange_from_vec",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| pk |),
                                                "halo2_proofs::plonk::ProvingKey",
                                                "vk"
                                              |),
                                              "halo2_proofs::plonk::VerifyingKey",
                                              "domain"
                                            |);
                                            M.call_closure (|
                                              M.get_function (|
                                                "halo2_proofs::plonk::evaluation::evaluate_with_theta",
                                                [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ]
                                              |),
                                              [
                                                M.read (| expressions |);
                                                M.rust_cast
                                                  (M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| params |),
                                                      "halo2_proofs::poly::commitment::Params",
                                                      "n"
                                                    |)
                                                  |));
                                                Value.Integer 1;
                                                M.read (| fixed_values |);
                                                M.read (| advice_values |);
                                                M.read (| instance_values |);
                                                M.read (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::transcript::ChallengeScalar")
                                                        [ C; Ty.path "halo2_proofs::plonk::Theta" ],
                                                      [],
                                                      "deref",
                                                      []
                                                    |),
                                                    [ theta ]
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      |) in
                    let commit_values :=
                      M.alloc (|
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0; α1 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let values := M.copy (| γ |) in
                                        M.match_operator (|
                                          M.alloc (| α1 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let max_bits := M.copy (| γ |) in
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "group::Curve",
                                                    Ty.associated,
                                                    [],
                                                    "to_affine",
                                                    []
                                                  |),
                                                  [
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::poly::commitment::Params")
                                                            [ C ],
                                                          "commit_lagrange_with_bound",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| params |);
                                                          M.read (| values |);
                                                          M.read (| max_bits |)
                                                        ]
                                                      |)
                                                    |)
                                                  ]
                                                |)))
                                          ]
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      |) in
                    let compressed_input_expression :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ]
                                          ]
                                      ]
                                  ]
                              ]
                              (Ty.apply
                                (Ty.path "halo2_proofs::poly::Polynomial")
                                [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ]),
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                            [ F ]
                                        ]
                                    ]
                                ]
                            ],
                            "call",
                            []
                          |),
                          [
                            compress_expressions;
                            Value.Tuple
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                          [ F ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::plonk::lookup::Argument",
                                      "input_expressions"
                                    |)
                                  ]
                                |)
                              ]
                          ]
                        |)
                      |) in
                    let compressed_table_expression :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::function::Fn",
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                              [ F ]
                                          ]
                                      ]
                                  ]
                              ]
                              (Ty.apply
                                (Ty.path "halo2_proofs::poly::Polynomial")
                                [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ]),
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                            [ F ]
                                        ]
                                    ]
                                ]
                            ],
                            "call",
                            []
                          |),
                          [
                            compress_expressions;
                            Value.Tuple
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::circuit::Expression")
                                          [ F ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::plonk::lookup::Argument",
                                      "table_expressions"
                                    |)
                                  ]
                                |)
                              ]
                          ]
                        |)
                      |) in
                    M.match_operator (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::poly::Polynomial")
                                        [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ];
                                      Ty.apply
                                        (Ty.path "halo2_proofs::poly::Polynomial")
                                        [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ];
                                      Ty.path "usize";
                                      Ty.path "usize"
                                    ];
                                  Ty.path "halo2_proofs::plonk::error::Error"
                                ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_function (|
                                  "halo2_proofs::plonk::lookup::prover::permute_expression_pair",
                                  [ C; Ty.apply (Ty.path "&mut") [ R ] ]
                                |),
                                [
                                  M.read (| pk |);
                                  M.read (| params |);
                                  M.read (| domain |);
                                  rng;
                                  compressed_input_expression;
                                  compressed_table_expression
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::plonk::lookup::prover::Permuted")
                                                    [ C ];
                                                  Ty.apply (Ty.path "array") [ C ]
                                                ];
                                              Ty.path "halo2_proofs::plonk::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                            let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                            let permuted_input_expression := M.copy (| γ0_0 |) in
                            let permuted_table_expression := M.copy (| γ0_1 |) in
                            let permuted_input_expression_max_bits := M.copy (| γ0_2 |) in
                            let permuted_table_expression_max_bits := M.copy (| γ0_3 |) in
                            let permuted_input_commitment :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::function::Fn",
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::poly::Polynomial")
                                                  [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ]
                                              ];
                                            Ty.path "usize"
                                          ]
                                      ]
                                      C,
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::poly::Polynomial")
                                                [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ]
                                            ];
                                          Ty.path "usize"
                                        ]
                                    ],
                                    "call",
                                    []
                                  |),
                                  [
                                    commit_values;
                                    Value.Tuple
                                      [
                                        permuted_input_expression;
                                        M.read (| permuted_input_expression_max_bits |)
                                      ]
                                  ]
                                |)
                              |) in
                            let permuted_table_commitment :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::function::Fn",
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::poly::Polynomial")
                                                  [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ]
                                              ];
                                            Ty.path "usize"
                                          ]
                                      ]
                                      C,
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::poly::Polynomial")
                                                [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ]
                                            ];
                                          Ty.path "usize"
                                        ]
                                    ],
                                    "call",
                                    []
                                  |),
                                  [
                                    commit_values;
                                    Value.Tuple
                                      [
                                        permuted_table_expression;
                                        M.read (| permuted_table_expression_max_bits |)
                                      ]
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              Value.StructTuple
                                "core::result::Result::Ok"
                                [
                                  Value.Tuple
                                    [
                                      Value.StructRecord
                                        "halo2_proofs::plonk::lookup::prover::Permuted"
                                        [
                                          ("compressed_input_expression",
                                            M.read (| compressed_input_expression |));
                                          ("permuted_input_expression",
                                            M.read (| permuted_input_expression |));
                                          ("compressed_table_expression",
                                            M.read (| compressed_table_expression |));
                                          ("permuted_table_expression",
                                            M.read (| permuted_table_expression |))
                                        ];
                                      Value.Array
                                        [
                                          M.read (| permuted_input_commitment |);
                                          M.read (| permuted_table_commitment |)
                                        ]
                                    ]
                                ]
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_commit_permuted :
          forall (F : Ty.t),
          M.IsAssociatedFunction (Self F) "commit_permuted" (commit_permuted F).
      End Impl_halo2_proofs_plonk_lookup_Argument_F.
      
      Module Impl_halo2_proofs_plonk_lookup_prover_Permuted_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::prover::Permuted") [ C ].
        
        (*
            pub(in crate::plonk) fn commit_product(
                self,
                pk: &ProvingKey<C>,
                params: &Params<C>,
                beta: ChallengeBeta<C>,
                gamma: ChallengeGamma<C>,
            ) -> Result<
                (
                    Polynomial<C::Scalar, LagrangeCoeff>,
                    Polynomial<C::Scalar, LagrangeCoeff>,
                    Vec<C::Scalar>,
                ),
                Error,
            > {
                let blinding_factors = pk.vk.cs.blinding_factors();
        
                // Goal is to compute the products of fractions
                //
                // Numerator: (\theta^{m-1} a_0(\omega^i) + \theta^{m-2} a_1(\omega^i) + ... + \theta a_{m-2}(\omega^i) + a_{m-1}(\omega^i) + \beta)
                //            * (\theta^{m-1} s_0(\omega^i) + \theta^{m-2} s_1(\omega^i) + ... + \theta s_{m-2}(\omega^i) + s_{m-1}(\omega^i) + \gamma)
                // Denominator: (a'(\omega^i) + \beta) (s'(\omega^i) + \gamma)
                //
                // where a_j(X) is the jth input expression in this lookup,
                // where a'(X) is the compression of the permuted input expressions,
                // s_j(X) is the jth table expression in this lookup,
                // s'(X) is the compression of the permuted table expressions,
                // and i is the ith row of the expression.
                let mut lookup_product = vec![C::Scalar::zero(); params.n as usize];
        
                #[cfg(not(feature = "cuda"))]
                {
                    // Denominator uses the permuted input expression and permuted table expression
                    parallelize(&mut lookup_product, |lookup_product, start| {
                        for ((lookup_product, permuted_input_value), permuted_table_value) in lookup_product
                            .iter_mut()
                            .zip(self.permuted_input_expression[start..].iter())
                            .zip(self.permuted_table_expression[start..].iter())
                        {
                            *lookup_product =
                                ( *beta + permuted_input_value) * &( *gamma + permuted_table_value);
                        }
                    });
        
                    // Batch invert to obtain the denominators for the lookup product
                    // polynomials
                    batch_invert(&mut lookup_product);
        
                    // Finish the computation of the entire fraction by computing the numerators
                    // (\theta^{m-1} a_0(\omega^i) + \theta^{m-2} a_1(\omega^i) + ... + \theta a_{m-2}(\omega^i) + a_{m-1}(\omega^i) + \beta)
                    // * (\theta^{m-1} s_0(\omega^i) + \theta^{m-2} s_1(\omega^i) + ... + \theta s_{m-2}(\omega^i) + s_{m-1}(\omega^i) + \gamma)
                    parallelize(&mut lookup_product, |product, start| {
                        for (i, product) in product.iter_mut().enumerate() {
                            let i = i + start;
        
                            *product *= &(self.compressed_input_expression[i] + &*beta);
                            *product *= &(self.compressed_table_expression[i] + &*gamma);
                        }
                    });
                }
        
                // Denominator uses the permuted input expression and permuted table expression
                for ((lookup_product, permuted_input_value), permuted_table_value) in lookup_product
                    .iter_mut()
                    .zip(self.permuted_input_expression.iter())
                    .zip(self.permuted_table_expression.iter())
                {
                    *lookup_product = ( *beta + permuted_input_value) * &( *gamma + permuted_table_value);
                }
        
                // Batch invert to obtain the denominators for the lookup product
                // polynomials
                lookup_product.batch_invert();
        
                // Finish the computation of the entire fraction by computing the numerators
                // (\theta^{m-1} a_0(\omega^i) + \theta^{m-2} a_1(\omega^i) + ... + \theta a_{m-2}(\omega^i) + a_{m-1}(\omega^i) + \beta)
                // * (\theta^{m-1} s_0(\omega^i) + \theta^{m-2} s_1(\omega^i) + ... + \theta s_{m-2}(\omega^i) + s_{m-1}(\omega^i) + \gamma)
                for ((lookup_product, compressed_input_value), compressed_table_value) in lookup_product
                    .iter_mut()
                    .zip(self.compressed_input_expression.iter())
                    .zip(self.compressed_table_expression.iter())
                {
                    *lookup_product *=
                        ( *beta + compressed_input_value) * &( *gamma + compressed_table_value);
                }
        
                /*
                #[cfg(feature = "cuda")]
                {
                    use ec_gpu_gen::fft::FftKernel;
                    use ec_gpu_gen::rust_gpu_tools::program_closures;
                    use ec_gpu_gen::rust_gpu_tools::Device;
                    use ec_gpu_gen::threadpool::Worker;
                    use ec_gpu_gen::EcResult;
                    use group::Curve;
                    use pairing::bn256::Fr;
        
                    let device = Device::all()[_gpu_idx];
                    let program = ec_gpu_gen::program!(device).expect("Cannot create programs!");
                    let kern = FftKernel::<Fr>::create(vec![program]).expect("Cannot initialize kernel!");
        
                    let compute_units = device.compute_units() as usize;
                    let local_work_size = 128usize;
                    let work_units =
                        (compute_units * local_work_size * 2) / local_work_size * local_work_size as usize;
                    let len = self.permuted_input_expression.len();
                    let slot_len = ((len + work_units - 1) / work_units) as usize;
        
                    let closures = program_closures!(|program,
                                                      input: (&[Fr], &[Fr], &[Fr], &[Fr], &mut [Fr])|
                     -> EcResult<()> {
                        let permuted_input = program.create_buffer_from_slice(input.0)?;
                        let permuted_table = program.create_buffer_from_slice(input.1)?;
                        let compressed_input = program.create_buffer_from_slice(input.2)?;
                        let compressed_table = program.create_buffer_from_slice(input.3)?;
                        let beta_gamma = program.create_buffer_from_slice(&vec![*beta, *gamma])?;
        
                        let global_work_size = work_units / local_work_size;
        
                        let kernel_name = format!("{}_calc_lookup_z", "Bn256_Fr");
                        let kernel = program.create_kernel(
                            &kernel_name,
                            global_work_size as usize,
                            local_work_size as usize,
                        )?;
                        kernel
                            .arg(&permuted_input)
                            .arg(&permuted_table)
                            .arg(&compressed_input)
                            .arg(&compressed_table)
                            .arg(&beta_gamma)
                            .arg(&(len as u32))
                            .arg(&(slot_len as u32))
                            .run()?;
        
                        let mut lookup_product_to_inv = vec![Fr::one(); params.n as usize];
                        let mut lookup_product_to_inv_packed = vec![Fr::zero(); work_units];
                        program.read_into_buffer(&permuted_input, input.4)?;
                        program.read_into_buffer(&permuted_table, &mut lookup_product_to_inv)?;
        
                        for i in 0..work_units.min((len + slot_len - 1) / slot_len) {
                            lookup_product_to_inv_packed[i] = lookup_product_to_inv[i * slot_len];
                        }
        
                        lookup_product_to_inv_packed.iter_mut().batch_invert();
        
                        for (i, lookup_product_to_inv) in
                            lookup_product_to_inv_packed.into_iter().enumerate()
                        {
                            for j in i * slot_len..((i + 1) * slot_len).min(len) {
                                input.4[j] *= lookup_product_to_inv;
                            }
                        }
        
                        Ok(())
                    });
        
                    kern.kernels[0]
                        .program
                        .run(closures, unsafe {
                            (
                                std::mem::transmute::<_, &[Fr]>(&self.permuted_input_expression[..]),
                                std::mem::transmute::<_, &[Fr]>(&self.permuted_table_expression[..]),
                                std::mem::transmute::<_, &[Fr]>(&self.compressed_input_expression[..]),
                                std::mem::transmute::<_, &[Fr]>(&self.compressed_table_expression[..]),
                                std::mem::transmute::<_, &mut [Fr]>(&mut lookup_product[..]),
                            )
                        })
                        .unwrap();
                }
                */
        
                // The product vector is a vector of products of fractions of the form
                //
                // Numerator: (\theta^{m-1} a_0(\omega^i) + \theta^{m-2} a_1(\omega^i) + ... + \theta a_{m-2}(\omega^i) + a_{m-1}(\omega^i) + \beta)
                //            * (\theta^{m-1} s_0(\omega^i) + \theta^{m-2} s_1(\omega^i) + ... + \theta s_{m-2}(\omega^i) + s_{m-1}(\omega^i) + \gamma)
                // Denominator: (a'(\omega^i) + \beta) (s'(\omega^i) + \gamma)
                //
                // where there are m input expressions and m table expressions,
                // a_j(\omega^i) is the jth input expression in this lookup,
                // a'j(\omega^i) is the permuted input expression,
                // s_j(\omega^i) is the jth table expression in this lookup,
                // s'(\omega^i) is the permuted table expression,
                // and i is the ith row of the expression.
                // Compute the evaluations of the lookup product polynomial
                // over our domain, starting with z[0] = 1
                let z = iter::once(C::Scalar::one())
                    .chain(lookup_product)
                    .scan(C::Scalar::one(), |state, cur| {
                        *state *= &cur;
                        Some( *state)
                    })
                    // Take all rows including the "last" row which should
                    // be a boolean (and ideally 1, else soundness is broken)
                    .take(params.n as usize - blinding_factors)
                    .collect::<Vec<_>>();
        
                #[cfg(feature = "sanity-checks")]
                // This test works only with intermediate representations in this method.
                // It can be used for debugging purposes.
                {
                    // While in Lagrange basis, check that product is correctly constructed
                    let u = (params.n as usize) - (blinding_factors + 1);
        
                    // l_0(X) * (1 - z(X)) = 0
                    assert_eq!(z[0], C::Scalar::one());
        
                    // z(\omega X) (a'(X) + \beta) (s'(X) + \gamma)
                    // - z(X) (\theta^{m-1} a_0(X) + ... + a_{m-1}(X) + \beta) (\theta^{m-1} s_0(X) + ... + s_{m-1}(X) + \gamma)
                    for i in 0..u {
                        let mut left = z[i + 1];
                        let permuted_input_value = &self.permuted_input_expression[i];
        
                        let permuted_table_value = &self.permuted_table_expression[i];
        
                        left *= &( *beta + permuted_input_value);
                        left *= &( *gamma + permuted_table_value);
        
                        let mut right = z[i];
                        let mut input_term = self.compressed_input_expression[i];
                        let mut table_term = self.compressed_table_expression[i];
        
                        input_term += &( *beta);
                        table_term += &( *gamma);
                        right *= &(input_term * &table_term);
        
                        assert_eq!(left, right);
                    }
        
                    // l_last(X) * (z(X)^2 - z(X)) = 0
                    // Assertion will fail only when soundness is broken, in which
                    // case this z[u] value will be zero. (bad!)
                    assert_eq!(z[u], C::Scalar::one());
                }
        
                Ok((
                    self.permuted_input_expression,
                    self.permuted_table_expression,
                    z,
                ))
            }
        *)
        Definition commit_product (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [], [ self; pk; params; beta; gamma ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let pk := M.alloc (| pk |) in
              let params := M.alloc (| params |) in
              let beta := M.alloc (| beta |) in
              let gamma := M.alloc (| gamma |) in
              M.read (|
                let blinding_factors :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                          [ Ty.associated ],
                        "blinding_factors",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| pk |),
                            "halo2_proofs::plonk::ProvingKey",
                            "vk"
                          |),
                          "halo2_proofs::plonk::VerifyingKey",
                          "cs"
                        |)
                      ]
                    |)
                  |) in
                let lookup_product :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::vec::from_elem", [ Ty.associated ] |),
                      [
                        M.call_closure (|
                          M.get_trait_method (| "ff::Field", Ty.associated, [], "zero", [] |),
                          []
                        |);
                        M.rust_cast
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| params |),
                              "halo2_proofs::poly::commitment::Params",
                              "n"
                            |)
                          |))
                      ]
                    |)
                  |) in
                let _ :=
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "halo2_proofs::arithmetic::parallelize",
                          [
                            Ty.associated;
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      [ Ty.apply (Ty.path "slice") [ Ty.associated ] ];
                                    Ty.path "usize"
                                  ]
                              ]
                              (Ty.tuple [])
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::DerefMut",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                              [],
                              "deref_mut",
                              []
                            |),
                            [ lookup_product ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0; α1 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let lookup_product := M.copy (| γ |) in
                                          M.match_operator (|
                                            M.alloc (| α1 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let start := M.copy (| γ |) in
                                                  M.read (|
                                                    M.use
                                                      (M.match_operator (|
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::iter::traits::collect::IntoIterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::iter::adapters::zip::Zip")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::iter::adapters::zip::Zip")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::slice::iter::IterMut")
                                                                        [ Ty.associated ];
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::slice::iter::Iter")
                                                                        [ Ty.associated ]
                                                                    ];
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::Iter")
                                                                    [ Ty.associated ]
                                                                ],
                                                              [],
                                                              "into_iter",
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::iter::traits::iterator::Iterator",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::iter::adapters::zip::Zip")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::slice::iter::IterMut")
                                                                        [ Ty.associated ];
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::slice::iter::Iter")
                                                                        [ Ty.associated ]
                                                                    ],
                                                                  [],
                                                                  "zip",
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::slice::iter::Iter")
                                                                      [ Ty.associated ]
                                                                  ]
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::slice::iter::IterMut")
                                                                        [ Ty.associated ],
                                                                      [],
                                                                      "zip",
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::slice::iter::Iter")
                                                                          [ Ty.associated ]
                                                                      ]
                                                                    |),
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            [ Ty.associated ],
                                                                          "iter_mut",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.read (|
                                                                            lookup_product
                                                                          |)
                                                                        ]
                                                                      |);
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            [ Ty.associated ],
                                                                          "iter",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::index::Index",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "halo2_proofs::poly::Polynomial")
                                                                                [
                                                                                  Ty.associated;
                                                                                  Ty.path
                                                                                    "halo2_proofs::poly::LagrangeCoeff"
                                                                                ],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::ops::range::RangeFrom")
                                                                                  [ Ty.path "usize"
                                                                                  ]
                                                                              ],
                                                                              "index",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.SubPointer.get_struct_record_field (|
                                                                                self,
                                                                                "halo2_proofs::plonk::lookup::prover::Permuted",
                                                                                "permuted_input_expression"
                                                                              |);
                                                                              Value.StructRecord
                                                                                "core::ops::range::RangeFrom"
                                                                                [
                                                                                  ("start",
                                                                                    M.read (|
                                                                                      start
                                                                                    |))
                                                                                ]
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    ]
                                                                  |);
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        [ Ty.associated ],
                                                                      "iter",
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::ops::index::Index",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::poly::Polynomial")
                                                                            [
                                                                              Ty.associated;
                                                                              Ty.path
                                                                                "halo2_proofs::poly::LagrangeCoeff"
                                                                            ],
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::ops::range::RangeFrom")
                                                                              [ Ty.path "usize" ]
                                                                          ],
                                                                          "index",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.SubPointer.get_struct_record_field (|
                                                                            self,
                                                                            "halo2_proofs::plonk::lookup::prover::Permuted",
                                                                            "permuted_table_expression"
                                                                          |);
                                                                          Value.StructRecord
                                                                            "core::ops::range::RangeFrom"
                                                                            [
                                                                              ("start",
                                                                                M.read (| start |))
                                                                            ]
                                                                        ]
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let iter := M.copy (| γ |) in
                                                              M.loop (|
                                                                ltac:(M.monadic
                                                                  (let _ :=
                                                                    M.match_operator (|
                                                                      M.alloc (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::iter::traits::iterator::Iterator",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::iter::adapters::zip::Zip")
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::iter::adapters::zip::Zip")
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::slice::iter::IterMut")
                                                                                      [
                                                                                        Ty.associated
                                                                                      ];
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::slice::iter::Iter")
                                                                                      [
                                                                                        Ty.associated
                                                                                      ]
                                                                                  ];
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::slice::iter::Iter")
                                                                                  [ Ty.associated ]
                                                                              ],
                                                                            [],
                                                                            "next",
                                                                            []
                                                                          |),
                                                                          [ iter ]
                                                                        |)
                                                                      |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.alloc (|
                                                                              M.never_to_any (|
                                                                                M.read (|
                                                                                  M.break (||)
                                                                                |)
                                                                              |)
                                                                            |)));
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let γ0_0 :=
                                                                              M.SubPointer.get_struct_tuple_field (|
                                                                                γ,
                                                                                "core::option::Option::Some",
                                                                                0
                                                                              |) in
                                                                            let γ1_0 :=
                                                                              M.SubPointer.get_tuple_field (|
                                                                                γ0_0,
                                                                                0
                                                                              |) in
                                                                            let γ1_1 :=
                                                                              M.SubPointer.get_tuple_field (|
                                                                                γ0_0,
                                                                                1
                                                                              |) in
                                                                            let γ2_0 :=
                                                                              M.SubPointer.get_tuple_field (|
                                                                                γ1_0,
                                                                                0
                                                                              |) in
                                                                            let γ2_1 :=
                                                                              M.SubPointer.get_tuple_field (|
                                                                                γ1_0,
                                                                                1
                                                                              |) in
                                                                            let lookup_product :=
                                                                              M.copy (| γ2_0 |) in
                                                                            let
                                                                                  permuted_input_value :=
                                                                              M.copy (| γ2_1 |) in
                                                                            let
                                                                                  permuted_table_value :=
                                                                              M.copy (| γ1_1 |) in
                                                                            let _ :=
                                                                              M.write (|
                                                                                M.read (|
                                                                                  lookup_product
                                                                                |),
                                                                                M.call_closure (|
                                                                                  M.get_trait_method (|
                                                                                    "core::ops::arith::Mul",
                                                                                    Ty.associated,
                                                                                    [
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "&")
                                                                                        [
                                                                                          Ty.associated
                                                                                        ]
                                                                                    ],
                                                                                    "mul",
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.call_closure (|
                                                                                      M.get_trait_method (|
                                                                                        "core::ops::arith::Add",
                                                                                        Ty.associated,
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "&")
                                                                                            [
                                                                                              Ty.associated
                                                                                            ]
                                                                                        ],
                                                                                        "add",
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.read (|
                                                                                          M.call_closure (|
                                                                                            M.get_trait_method (|
                                                                                              "core::ops::deref::Deref",
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "halo2_proofs::transcript::ChallengeScalar")
                                                                                                [
                                                                                                  C;
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::plonk::Beta"
                                                                                                ],
                                                                                              [],
                                                                                              "deref",
                                                                                              []
                                                                                            |),
                                                                                            [ beta ]
                                                                                          |)
                                                                                        |);
                                                                                        M.read (|
                                                                                          permuted_input_value
                                                                                        |)
                                                                                      ]
                                                                                    |);
                                                                                    M.alloc (|
                                                                                      M.call_closure (|
                                                                                        M.get_trait_method (|
                                                                                          "core::ops::arith::Add",
                                                                                          Ty.associated,
                                                                                          [
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "&")
                                                                                              [
                                                                                                Ty.associated
                                                                                              ]
                                                                                          ],
                                                                                          "add",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            M.call_closure (|
                                                                                              M.get_trait_method (|
                                                                                                "core::ops::deref::Deref",
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "halo2_proofs::transcript::ChallengeScalar")
                                                                                                  [
                                                                                                    C;
                                                                                                    Ty.path
                                                                                                      "halo2_proofs::plonk::Gamma"
                                                                                                  ],
                                                                                                [],
                                                                                                "deref",
                                                                                                []
                                                                                              |),
                                                                                              [
                                                                                                gamma
                                                                                              ]
                                                                                            |)
                                                                                          |);
                                                                                          M.read (|
                                                                                            permuted_table_value
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              |) in
                                                                            M.alloc (|
                                                                              Value.Tuple []
                                                                            |)))
                                                                      ]
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                              |)))
                                                        ]
                                                      |))
                                                  |)))
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    |) in
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "halo2_proofs::arithmetic::batch_invert",
                          [ Ty.associated ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::DerefMut",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                              [],
                              "deref_mut",
                              []
                            |),
                            [ lookup_product ]
                          |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "halo2_proofs::arithmetic::parallelize",
                          [
                            Ty.associated;
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      [ Ty.apply (Ty.path "slice") [ Ty.associated ] ];
                                    Ty.path "usize"
                                  ]
                              ]
                              (Ty.tuple [])
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::DerefMut",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                              [],
                              "deref_mut",
                              []
                            |),
                            [ lookup_product ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0; α1 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let product := M.copy (| γ |) in
                                          M.match_operator (|
                                            M.alloc (| α1 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let start := M.copy (| γ |) in
                                                  M.read (|
                                                    M.use
                                                      (M.match_operator (|
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::iter::traits::collect::IntoIterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::iter::adapters::enumerate::Enumerate")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::IterMut")
                                                                    [ Ty.associated ]
                                                                ],
                                                              [],
                                                              "into_iter",
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::iter::traits::iterator::Iterator",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::IterMut")
                                                                    [ Ty.associated ],
                                                                  [],
                                                                  "enumerate",
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        [ Ty.associated ],
                                                                      "iter_mut",
                                                                      []
                                                                    |),
                                                                    [ M.read (| product |) ]
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let iter := M.copy (| γ |) in
                                                              M.loop (|
                                                                ltac:(M.monadic
                                                                  (let _ :=
                                                                    M.match_operator (|
                                                                      M.alloc (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::iter::traits::iterator::Iterator",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::iter::adapters::enumerate::Enumerate")
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::slice::iter::IterMut")
                                                                                  [ Ty.associated ]
                                                                              ],
                                                                            [],
                                                                            "next",
                                                                            []
                                                                          |),
                                                                          [ iter ]
                                                                        |)
                                                                      |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.alloc (|
                                                                              M.never_to_any (|
                                                                                M.read (|
                                                                                  M.break (||)
                                                                                |)
                                                                              |)
                                                                            |)));
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let γ0_0 :=
                                                                              M.SubPointer.get_struct_tuple_field (|
                                                                                γ,
                                                                                "core::option::Option::Some",
                                                                                0
                                                                              |) in
                                                                            let γ1_0 :=
                                                                              M.SubPointer.get_tuple_field (|
                                                                                γ0_0,
                                                                                0
                                                                              |) in
                                                                            let γ1_1 :=
                                                                              M.SubPointer.get_tuple_field (|
                                                                                γ0_0,
                                                                                1
                                                                              |) in
                                                                            let i :=
                                                                              M.copy (| γ1_0 |) in
                                                                            let product :=
                                                                              M.copy (| γ1_1 |) in
                                                                            let i :=
                                                                              M.alloc (|
                                                                                BinOp.Panic.add (|
                                                                                  Integer.Usize,
                                                                                  M.read (| i |),
                                                                                  M.read (| start |)
                                                                                |)
                                                                              |) in
                                                                            let _ :=
                                                                              M.alloc (|
                                                                                M.call_closure (|
                                                                                  M.get_trait_method (|
                                                                                    "core::ops::arith::MulAssign",
                                                                                    Ty.associated,
                                                                                    [
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "&")
                                                                                        [
                                                                                          Ty.associated
                                                                                        ]
                                                                                    ],
                                                                                    "mul_assign",
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.read (|
                                                                                      product
                                                                                    |);
                                                                                    M.alloc (|
                                                                                      M.call_closure (|
                                                                                        M.get_trait_method (|
                                                                                          "core::ops::arith::Add",
                                                                                          Ty.associated,
                                                                                          [
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "&")
                                                                                              [
                                                                                                Ty.associated
                                                                                              ]
                                                                                          ],
                                                                                          "add",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            M.call_closure (|
                                                                                              M.get_trait_method (|
                                                                                                "core::ops::index::Index",
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "halo2_proofs::poly::Polynomial")
                                                                                                  [
                                                                                                    Ty.associated;
                                                                                                    Ty.path
                                                                                                      "halo2_proofs::poly::LagrangeCoeff"
                                                                                                  ],
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "usize"
                                                                                                ],
                                                                                                "index",
                                                                                                []
                                                                                              |),
                                                                                              [
                                                                                                M.SubPointer.get_struct_record_field (|
                                                                                                  self,
                                                                                                  "halo2_proofs::plonk::lookup::prover::Permuted",
                                                                                                  "compressed_input_expression"
                                                                                                |);
                                                                                                M.read (|
                                                                                                  i
                                                                                                |)
                                                                                              ]
                                                                                            |)
                                                                                          |);
                                                                                          M.call_closure (|
                                                                                            M.get_trait_method (|
                                                                                              "core::ops::deref::Deref",
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "halo2_proofs::transcript::ChallengeScalar")
                                                                                                [
                                                                                                  C;
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::plonk::Beta"
                                                                                                ],
                                                                                              [],
                                                                                              "deref",
                                                                                              []
                                                                                            |),
                                                                                            [ beta ]
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              |) in
                                                                            let _ :=
                                                                              M.alloc (|
                                                                                M.call_closure (|
                                                                                  M.get_trait_method (|
                                                                                    "core::ops::arith::MulAssign",
                                                                                    Ty.associated,
                                                                                    [
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "&")
                                                                                        [
                                                                                          Ty.associated
                                                                                        ]
                                                                                    ],
                                                                                    "mul_assign",
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.read (|
                                                                                      product
                                                                                    |);
                                                                                    M.alloc (|
                                                                                      M.call_closure (|
                                                                                        M.get_trait_method (|
                                                                                          "core::ops::arith::Add",
                                                                                          Ty.associated,
                                                                                          [
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "&")
                                                                                              [
                                                                                                Ty.associated
                                                                                              ]
                                                                                          ],
                                                                                          "add",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            M.call_closure (|
                                                                                              M.get_trait_method (|
                                                                                                "core::ops::index::Index",
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "halo2_proofs::poly::Polynomial")
                                                                                                  [
                                                                                                    Ty.associated;
                                                                                                    Ty.path
                                                                                                      "halo2_proofs::poly::LagrangeCoeff"
                                                                                                  ],
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "usize"
                                                                                                ],
                                                                                                "index",
                                                                                                []
                                                                                              |),
                                                                                              [
                                                                                                M.SubPointer.get_struct_record_field (|
                                                                                                  self,
                                                                                                  "halo2_proofs::plonk::lookup::prover::Permuted",
                                                                                                  "compressed_table_expression"
                                                                                                |);
                                                                                                M.read (|
                                                                                                  i
                                                                                                |)
                                                                                              ]
                                                                                            |)
                                                                                          |);
                                                                                          M.call_closure (|
                                                                                            M.get_trait_method (|
                                                                                              "core::ops::deref::Deref",
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "halo2_proofs::transcript::ChallengeScalar")
                                                                                                [
                                                                                                  C;
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::plonk::Gamma"
                                                                                                ],
                                                                                              [],
                                                                                              "deref",
                                                                                              []
                                                                                            |),
                                                                                            [ gamma
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              |) in
                                                                            M.alloc (|
                                                                              Value.Tuple []
                                                                            |)))
                                                                      ]
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                              |)))
                                                        ]
                                                      |))
                                                  |)))
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                let _ :=
                  M.use
                    (M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::zip::Zip")
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::IterMut")
                                      [ Ty.associated ];
                                    Ty.associated
                                  ];
                                Ty.associated
                              ],
                            [],
                            "into_iter",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::IterMut")
                                      [ Ty.associated ];
                                    Ty.associated
                                  ],
                                [],
                                "zip",
                                [ Ty.associated ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::slice::iter::IterMut")
                                      [ Ty.associated ],
                                    [],
                                    "zip",
                                    [ Ty.associated ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ Ty.associated ],
                                        "iter_mut",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::DerefMut",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                                            [],
                                            "deref_mut",
                                            []
                                          |),
                                          [ lookup_product ]
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "halo2_proofs::poly::Polynomial")
                                          [
                                            Ty.associated;
                                            Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                          ],
                                        "iter",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          self,
                                          "halo2_proofs::plonk::lookup::prover::Permuted",
                                          "permuted_input_expression"
                                        |)
                                      ]
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "halo2_proofs::poly::Polynomial")
                                      [ Ty.associated; Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                      ],
                                    "iter",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "halo2_proofs::plonk::lookup::prover::Permuted",
                                      "permuted_table_expression"
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let iter := M.copy (| γ |) in
                            M.loop (|
                              ltac:(M.monadic
                                (let _ :=
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::zip::Zip")
                                            [
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::zip::Zip")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::IterMut")
                                                    [ Ty.associated ];
                                                  Ty.associated
                                                ];
                                              Ty.associated
                                            ],
                                          [],
                                          "next",
                                          []
                                        |),
                                        [ iter ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                          let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                          let γ2_0 := M.SubPointer.get_tuple_field (| γ1_0, 0 |) in
                                          let γ2_1 := M.SubPointer.get_tuple_field (| γ1_0, 1 |) in
                                          let lookup_product := M.copy (| γ2_0 |) in
                                          let permuted_input_value := M.copy (| γ2_1 |) in
                                          let permuted_table_value := M.copy (| γ1_1 |) in
                                          let _ :=
                                            M.write (|
                                              M.read (| lookup_product |),
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::arith::Mul",
                                                  Ty.associated,
                                                  [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                  "mul",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::arith::Add",
                                                      Ty.associated,
                                                      [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                      "add",
                                                      []
                                                    |),
                                                    [
                                                      M.read (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::transcript::ChallengeScalar")
                                                              [
                                                                C;
                                                                Ty.path "halo2_proofs::plonk::Beta"
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ beta ]
                                                        |)
                                                      |);
                                                      M.read (| permuted_input_value |)
                                                    ]
                                                  |);
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::arith::Add",
                                                        Ty.associated,
                                                        [ Ty.apply (Ty.path "&") [ Ty.associated ]
                                                        ],
                                                        "add",
                                                        []
                                                      |),
                                                      [
                                                        M.read (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::deref::Deref",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "halo2_proofs::transcript::ChallengeScalar")
                                                                [
                                                                  C;
                                                                  Ty.path
                                                                    "halo2_proofs::plonk::Gamma"
                                                                ],
                                                              [],
                                                              "deref",
                                                              []
                                                            |),
                                                            [ gamma ]
                                                          |)
                                                        |);
                                                        M.read (| permuted_table_value |)
                                                      ]
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                            |)))
                      ]
                    |)) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "ff::batch::BatchInvert",
                        Ty.apply
                          (Ty.path "&mut")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                          ],
                        [ Ty.associated ],
                        "batch_invert",
                        []
                      |),
                      [ lookup_product ]
                    |)
                  |) in
                let _ :=
                  M.use
                    (M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::zip::Zip")
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::IterMut")
                                      [ Ty.associated ];
                                    Ty.associated
                                  ];
                                Ty.associated
                              ],
                            [],
                            "into_iter",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::IterMut")
                                      [ Ty.associated ];
                                    Ty.associated
                                  ],
                                [],
                                "zip",
                                [ Ty.associated ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::slice::iter::IterMut")
                                      [ Ty.associated ],
                                    [],
                                    "zip",
                                    [ Ty.associated ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ Ty.associated ],
                                        "iter_mut",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::DerefMut",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                                            [],
                                            "deref_mut",
                                            []
                                          |),
                                          [ lookup_product ]
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "halo2_proofs::poly::Polynomial")
                                          [
                                            Ty.associated;
                                            Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                          ],
                                        "iter",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          self,
                                          "halo2_proofs::plonk::lookup::prover::Permuted",
                                          "compressed_input_expression"
                                        |)
                                      ]
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "halo2_proofs::poly::Polynomial")
                                      [ Ty.associated; Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                      ],
                                    "iter",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "halo2_proofs::plonk::lookup::prover::Permuted",
                                      "compressed_table_expression"
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let iter := M.copy (| γ |) in
                            M.loop (|
                              ltac:(M.monadic
                                (let _ :=
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::zip::Zip")
                                            [
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::zip::Zip")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::IterMut")
                                                    [ Ty.associated ];
                                                  Ty.associated
                                                ];
                                              Ty.associated
                                            ],
                                          [],
                                          "next",
                                          []
                                        |),
                                        [ iter ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                          let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                          let γ2_0 := M.SubPointer.get_tuple_field (| γ1_0, 0 |) in
                                          let γ2_1 := M.SubPointer.get_tuple_field (| γ1_0, 1 |) in
                                          let lookup_product := M.copy (| γ2_0 |) in
                                          let compressed_input_value := M.copy (| γ2_1 |) in
                                          let compressed_table_value := M.copy (| γ1_1 |) in
                                          let _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::arith::MulAssign",
                                                  Ty.associated,
                                                  [ Ty.associated ],
                                                  "mul_assign",
                                                  []
                                                |),
                                                [
                                                  M.read (| lookup_product |);
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::arith::Mul",
                                                      Ty.associated,
                                                      [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                      "mul",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::arith::Add",
                                                          Ty.associated,
                                                          [ Ty.apply (Ty.path "&") [ Ty.associated ]
                                                          ],
                                                          "add",
                                                          []
                                                        |),
                                                        [
                                                          M.read (|
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::deref::Deref",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::transcript::ChallengeScalar")
                                                                  [
                                                                    C;
                                                                    Ty.path
                                                                      "halo2_proofs::plonk::Beta"
                                                                  ],
                                                                [],
                                                                "deref",
                                                                []
                                                              |),
                                                              [ beta ]
                                                            |)
                                                          |);
                                                          M.read (| compressed_input_value |)
                                                        ]
                                                      |);
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::arith::Add",
                                                            Ty.associated,
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [ Ty.associated ]
                                                            ],
                                                            "add",
                                                            []
                                                          |),
                                                          [
                                                            M.read (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::deref::Deref",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::transcript::ChallengeScalar")
                                                                    [
                                                                      C;
                                                                      Ty.path
                                                                        "halo2_proofs::plonk::Gamma"
                                                                    ],
                                                                  [],
                                                                  "deref",
                                                                  []
                                                                |),
                                                                [ gamma ]
                                                              |)
                                                            |);
                                                            M.read (| compressed_table_value |)
                                                          ]
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                            |)))
                      ]
                    |)) in
                let z :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::take::Take")
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::scan::Scan")
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::chain::Chain")
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::sources::once::Once")
                                      [ Ty.associated ];
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                                  ];
                                Ty.associated;
                                Ty.function
                                  [
                                    Ty.tuple
                                      [ Ty.apply (Ty.path "&mut") [ Ty.associated ]; Ty.associated ]
                                  ]
                                  (Ty.apply (Ty.path "core::option::Option") [ Ty.associated ])
                              ]
                          ],
                        [],
                        "collect",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::scan::Scan")
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::chain::Chain")
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::sources::once::Once")
                                      [ Ty.associated ];
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                                  ];
                                Ty.associated;
                                Ty.function
                                  [
                                    Ty.tuple
                                      [ Ty.apply (Ty.path "&mut") [ Ty.associated ]; Ty.associated ]
                                  ]
                                  (Ty.apply (Ty.path "core::option::Option") [ Ty.associated ])
                              ],
                            [],
                            "take",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::chain::Chain")
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::sources::once::Once")
                                      [ Ty.associated ];
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                                  ],
                                [],
                                "scan",
                                [
                                  Ty.associated;
                                  Ty.associated;
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [ Ty.apply (Ty.path "&mut") [ Ty.associated ]; Ty.associated
                                        ]
                                    ]
                                    (Ty.apply (Ty.path "core::option::Option") [ Ty.associated ])
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::sources::once::Once")
                                      [ Ty.associated ],
                                    [],
                                    "chain",
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::iter::sources::once::once",
                                        [ Ty.associated ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "ff::Field",
                                            Ty.associated,
                                            [],
                                            "one",
                                            []
                                          |),
                                          []
                                        |)
                                      ]
                                    |);
                                    M.read (| lookup_product |)
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "ff::Field",
                                    Ty.associated,
                                    [],
                                    "one",
                                    []
                                  |),
                                  []
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0; α1 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let state := M.copy (| γ |) in
                                                M.match_operator (|
                                                  M.alloc (| α1 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let cur := M.copy (| γ |) in
                                                        M.read (|
                                                          let _ :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::arith::MulAssign",
                                                                  Ty.associated,
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      [ Ty.associated ]
                                                                  ],
                                                                  "mul_assign",
                                                                  []
                                                                |),
                                                                [ M.read (| state |); cur ]
                                                              |)
                                                            |) in
                                                          M.alloc (|
                                                            Value.StructTuple
                                                              "core::option::Option::Some"
                                                              [ M.read (| M.read (| state |) |) ]
                                                          |)
                                                        |)))
                                                  ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end))
                              ]
                            |);
                            BinOp.Panic.sub (|
                              Integer.Usize,
                              M.rust_cast
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| params |),
                                    "halo2_proofs::poly::commitment::Params",
                                    "n"
                                  |)
                                |)),
                              M.read (| blinding_factors |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      Value.Tuple
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "halo2_proofs::plonk::lookup::prover::Permuted",
                              "permuted_input_expression"
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "halo2_proofs::plonk::lookup::prover::Permuted",
                              "permuted_table_expression"
                            |)
                          |);
                          M.read (| z |)
                        ]
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_commit_product :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "commit_product" (commit_product C).
      End Impl_halo2_proofs_plonk_lookup_prover_Permuted_C.
      
      Module Impl_halo2_proofs_plonk_lookup_prover_Committed_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::prover::Committed") [ C ].
        
        (*
            pub(in crate::plonk) fn evaluate(
                self,
                pk: &ProvingKey<C>,
                x: ChallengeX<C>,
            ) -> (Evaluated<C>, Vec<C::ScalarExt>) {
                let domain = &pk.vk.domain;
                let x_inv = domain.rotate_omega( *x, Rotation::prev());
                let x_next = domain.rotate_omega( *x, Rotation::next());
        
                let evals = vec![
                    (&self.product_poly, *x),
                    (&self.product_poly, x_next),
                    (&self.permuted_input_poly, *x),
                    (&self.permuted_input_poly, x_inv),
                    (&self.permuted_table_poly, *x),
                ]
                .into_par_iter()
                .map(|(a, b)| eval_polynomial_st(a, b))
                .collect();
        
                (Evaluated { constructed: self }, evals)
            }
        *)
        Definition evaluate (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [], [ self; pk; x ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let pk := M.alloc (| pk |) in
              let x := M.alloc (| x |) in
              M.read (|
                let domain :=
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| pk |),
                        "halo2_proofs::plonk::ProvingKey",
                        "vk"
                      |),
                      "halo2_proofs::plonk::VerifyingKey",
                      "domain"
                    |)
                  |) in
                let x_inv :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "halo2_proofs::poly::domain::EvaluationDomain")
                          [ Ty.associated ],
                        "rotate_omega",
                        []
                      |),
                      [
                        M.read (| domain |);
                        M.read (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "halo2_proofs::transcript::ChallengeScalar")
                                [ C; Ty.path "halo2_proofs::plonk::X" ],
                              [],
                              "deref",
                              []
                            |),
                            [ x ]
                          |)
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "halo2_proofs::poly::Rotation",
                            "prev",
                            []
                          |),
                          []
                        |)
                      ]
                    |)
                  |) in
                let x_next :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "halo2_proofs::poly::domain::EvaluationDomain")
                          [ Ty.associated ],
                        "rotate_omega",
                        []
                      |),
                      [
                        M.read (| domain |);
                        M.read (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "halo2_proofs::transcript::ChallengeScalar")
                                [ C; Ty.path "halo2_proofs::plonk::X" ],
                              [],
                              "deref",
                              []
                            |),
                            [ x ]
                          |)
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "halo2_proofs::poly::Rotation",
                            "next",
                            []
                          |),
                          []
                        |)
                      ]
                    |)
                  |) in
                let evals :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "rayon::iter::ParallelIterator",
                        Ty.apply
                          (Ty.path "rayon::iter::map::Map")
                          [
                            Ty.apply
                              (Ty.path "rayon::vec::IntoIter")
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::poly::Polynomial")
                                          [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]
                                      ];
                                    Ty.associated
                                  ]
                              ];
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::poly::Polynomial")
                                              [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]
                                          ];
                                        Ty.associated
                                      ]
                                  ]
                              ]
                              Ty.associated
                          ],
                        [],
                        "collect",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "rayon::iter::ParallelIterator",
                            Ty.apply
                              (Ty.path "rayon::vec::IntoIter")
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::poly::Polynomial")
                                          [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]
                                      ];
                                    Ty.associated
                                  ]
                              ],
                            [],
                            "map",
                            [
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            [
                                              Ty.apply
                                                (Ty.path "halo2_proofs::poly::Polynomial")
                                                [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff"
                                                ]
                                            ];
                                          Ty.associated
                                        ]
                                    ]
                                ]
                                Ty.associated;
                              Ty.associated
                            ]
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "rayon::iter::IntoParallelIterator",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::poly::Polynomial")
                                              [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]
                                          ];
                                        Ty.associated
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "into_par_iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.apply
                                                  (Ty.path "halo2_proofs::poly::Polynomial")
                                                  [
                                                    Ty.associated;
                                                    Ty.path "halo2_proofs::poly::Coeff"
                                                  ]
                                              ];
                                            Ty.associated
                                          ]
                                      ],
                                    "into_vec",
                                    [ Ty.path "alloc::alloc::Global" ]
                                  |),
                                  [
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.read (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::poly::Polynomial")
                                                              [
                                                                Ty.associated;
                                                                Ty.path "halo2_proofs::poly::Coeff"
                                                              ]
                                                          ];
                                                        Ty.associated
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            "new",
                                            []
                                          |),
                                          [
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  Value.Tuple
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        self,
                                                        "halo2_proofs::plonk::lookup::prover::Committed",
                                                        "product_poly"
                                                      |);
                                                      M.read (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::transcript::ChallengeScalar")
                                                              [ C; Ty.path "halo2_proofs::plonk::X"
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ x ]
                                                        |)
                                                      |)
                                                    ];
                                                  Value.Tuple
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        self,
                                                        "halo2_proofs::plonk::lookup::prover::Committed",
                                                        "product_poly"
                                                      |);
                                                      M.read (| x_next |)
                                                    ];
                                                  Value.Tuple
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        self,
                                                        "halo2_proofs::plonk::lookup::prover::Committed",
                                                        "permuted_input_poly"
                                                      |);
                                                      M.read (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::transcript::ChallengeScalar")
                                                              [ C; Ty.path "halo2_proofs::plonk::X"
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ x ]
                                                        |)
                                                      |)
                                                    ];
                                                  Value.Tuple
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        self,
                                                        "halo2_proofs::plonk::lookup::prover::Committed",
                                                        "permuted_input_poly"
                                                      |);
                                                      M.read (| x_inv |)
                                                    ];
                                                  Value.Tuple
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        self,
                                                        "halo2_proofs::plonk::lookup::prover::Committed",
                                                        "permuted_table_poly"
                                                      |);
                                                      M.read (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::transcript::ChallengeScalar")
                                                              [ C; Ty.path "halo2_proofs::plonk::X"
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ x ]
                                                        |)
                                                      |)
                                                    ]
                                                ]
                                            |)
                                          ]
                                        |)
                                      |))
                                  ]
                                |)
                              ]
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                            let a := M.copy (| γ0_0 |) in
                                            let b := M.copy (| γ0_1 |) in
                                            M.call_closure (|
                                              M.get_function (|
                                                "halo2_proofs::arithmetic::eval_polynomial_st",
                                                [ Ty.associated ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.apply
                                                      (Ty.path "halo2_proofs::poly::Polynomial")
                                                      [
                                                        Ty.associated;
                                                        Ty.path "halo2_proofs::poly::Coeff"
                                                      ],
                                                    [],
                                                    "deref",
                                                    []
                                                  |),
                                                  [ M.read (| a |) ]
                                                |);
                                                M.read (| b |)
                                              ]
                                            |)))
                                      ]
                                    |)
                                  | _ => M.impossible (||)
                                  end))
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.Tuple
                    [
                      Value.StructRecord
                        "halo2_proofs::plonk::lookup::prover::Evaluated"
                        [ ("constructed", M.read (| self |)) ];
                      M.read (| evals |)
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_evaluate :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "evaluate" (evaluate C).
      End Impl_halo2_proofs_plonk_lookup_prover_Committed_C.
      
      Module Impl_halo2_proofs_plonk_lookup_prover_Evaluated_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::prover::Evaluated") [ C ].
        
        (*
            pub(in crate::plonk) fn open<'a>(
                &'a self,
                pk: &'a ProvingKey<C>,
                x: ChallengeX<C>,
            ) -> impl Iterator<Item = ProverQuery<'a, C>> + Clone {
                let x_inv = pk.vk.domain.rotate_omega( *x, Rotation::prev());
                let x_next = pk.vk.domain.rotate_omega( *x, Rotation::next());
        
                iter::empty()
                    // Open lookup product commitments at x
                    .chain(Some(ProverQuery {
                        point: *x,
                        rotation: Rotation::cur(),
                        poly: &self.constructed.product_poly,
                    }))
                    // Open lookup input commitments at x
                    .chain(Some(ProverQuery {
                        point: *x,
                        rotation: Rotation::cur(),
                        poly: &self.constructed.permuted_input_poly,
                    }))
                    // Open lookup table commitments at x
                    .chain(Some(ProverQuery {
                        point: *x,
                        rotation: Rotation::cur(),
                        poly: &self.constructed.permuted_table_poly,
                    }))
                    // Open lookup input commitments at x_inv
                    .chain(Some(ProverQuery {
                        point: x_inv,
                        rotation: Rotation::prev(),
                        poly: &self.constructed.permuted_input_poly,
                    }))
                    // Open lookup product commitments at x_next
                    .chain(Some(ProverQuery {
                        point: x_next,
                        rotation: Rotation::next(),
                        poly: &self.constructed.product_poly,
                    }))
            }
        *)
        Definition open (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [], [ self; pk; x ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let pk := M.alloc (| pk |) in
              let x := M.alloc (| x |) in
              M.read (|
                let x_inv :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "halo2_proofs::poly::domain::EvaluationDomain")
                          [ Ty.associated ],
                        "rotate_omega",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| pk |),
                            "halo2_proofs::plonk::ProvingKey",
                            "vk"
                          |),
                          "halo2_proofs::plonk::VerifyingKey",
                          "domain"
                        |);
                        M.read (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "halo2_proofs::transcript::ChallengeScalar")
                                [ C; Ty.path "halo2_proofs::plonk::X" ],
                              [],
                              "deref",
                              []
                            |),
                            [ x ]
                          |)
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "halo2_proofs::poly::Rotation",
                            "prev",
                            []
                          |),
                          []
                        |)
                      ]
                    |)
                  |) in
                let x_next :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "halo2_proofs::poly::domain::EvaluationDomain")
                          [ Ty.associated ],
                        "rotate_omega",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| pk |),
                            "halo2_proofs::plonk::ProvingKey",
                            "vk"
                          |),
                          "halo2_proofs::plonk::VerifyingKey",
                          "domain"
                        |);
                        M.read (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "halo2_proofs::transcript::ChallengeScalar")
                                [ C; Ty.path "halo2_proofs::plonk::X" ],
                              [],
                              "deref",
                              []
                            |),
                            [ x ]
                          |)
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "halo2_proofs::poly::Rotation",
                            "next",
                            []
                          |),
                          []
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::chain::Chain")
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::chain::Chain")
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::chain::Chain")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                            [ C ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::option::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                            [ C ]
                                        ]
                                    ];
                                  Ty.apply
                                    (Ty.path "core::option::IntoIter")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                        [ C ]
                                    ]
                                ];
                              Ty.apply
                                (Ty.path "core::option::IntoIter")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                    [ C ]
                                ]
                            ];
                          Ty.apply
                            (Ty.path "core::option::IntoIter")
                            [ Ty.apply (Ty.path "halo2_proofs::poly::multiopen::ProverQuery") [ C ]
                            ]
                        ],
                      [],
                      "chain",
                      [
                        Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.apply (Ty.path "halo2_proofs::poly::multiopen::ProverQuery") [ C ] ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::chain::Chain")
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::chain::Chain")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                            [ C ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::option::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                            [ C ]
                                        ]
                                    ];
                                  Ty.apply
                                    (Ty.path "core::option::IntoIter")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                        [ C ]
                                    ]
                                ];
                              Ty.apply
                                (Ty.path "core::option::IntoIter")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                    [ C ]
                                ]
                            ],
                          [],
                          "chain",
                          [
                            Ty.apply
                              (Ty.path "core::option::Option")
                              [
                                Ty.apply
                                  (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                  [ C ]
                              ]
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::chain::Chain")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                            [ C ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::option::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                            [ C ]
                                        ]
                                    ];
                                  Ty.apply
                                    (Ty.path "core::option::IntoIter")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                        [ C ]
                                    ]
                                ],
                              [],
                              "chain",
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                      [ C ]
                                  ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                            [ C ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::option::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                            [ C ]
                                        ]
                                    ],
                                  [],
                                  "chain",
                                  [
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                          [ C ]
                                      ]
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                            [ C ]
                                        ],
                                      [],
                                      "chain",
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                              [ C ]
                                          ]
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_function (|
                                          "core::iter::sources::empty::empty",
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::poly::multiopen::ProverQuery")
                                              [ C ]
                                          ]
                                        |),
                                        []
                                      |);
                                      Value.StructTuple
                                        "core::option::Option::Some"
                                        [
                                          Value.StructRecord
                                            "halo2_proofs::poly::multiopen::ProverQuery"
                                            [
                                              ("point",
                                                M.read (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::transcript::ChallengeScalar")
                                                        [ C; Ty.path "halo2_proofs::plonk::X" ],
                                                      [],
                                                      "deref",
                                                      []
                                                    |),
                                                    [ x ]
                                                  |)
                                                |));
                                              ("rotation",
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "halo2_proofs::poly::Rotation",
                                                    "cur",
                                                    []
                                                  |),
                                                  []
                                                |));
                                              ("poly",
                                                M.SubPointer.get_struct_record_field (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "halo2_proofs::plonk::lookup::prover::Evaluated",
                                                    "constructed"
                                                  |),
                                                  "halo2_proofs::plonk::lookup::prover::Committed",
                                                  "product_poly"
                                                |))
                                            ]
                                        ]
                                    ]
                                  |);
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [
                                      Value.StructRecord
                                        "halo2_proofs::poly::multiopen::ProverQuery"
                                        [
                                          ("point",
                                            M.read (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::deref::Deref",
                                                  Ty.apply
                                                    (Ty.path
                                                      "halo2_proofs::transcript::ChallengeScalar")
                                                    [ C; Ty.path "halo2_proofs::plonk::X" ],
                                                  [],
                                                  "deref",
                                                  []
                                                |),
                                                [ x ]
                                              |)
                                            |));
                                          ("rotation",
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "halo2_proofs::poly::Rotation",
                                                "cur",
                                                []
                                              |),
                                              []
                                            |));
                                          ("poly",
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "halo2_proofs::plonk::lookup::prover::Evaluated",
                                                "constructed"
                                              |),
                                              "halo2_proofs::plonk::lookup::prover::Committed",
                                              "permuted_input_poly"
                                            |))
                                        ]
                                    ]
                                ]
                              |);
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  Value.StructRecord
                                    "halo2_proofs::poly::multiopen::ProverQuery"
                                    [
                                      ("point",
                                        M.read (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::deref::Deref",
                                              Ty.apply
                                                (Ty.path
                                                  "halo2_proofs::transcript::ChallengeScalar")
                                                [ C; Ty.path "halo2_proofs::plonk::X" ],
                                              [],
                                              "deref",
                                              []
                                            |),
                                            [ x ]
                                          |)
                                        |));
                                      ("rotation",
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "halo2_proofs::poly::Rotation",
                                            "cur",
                                            []
                                          |),
                                          []
                                        |));
                                      ("poly",
                                        M.SubPointer.get_struct_record_field (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::plonk::lookup::prover::Evaluated",
                                            "constructed"
                                          |),
                                          "halo2_proofs::plonk::lookup::prover::Committed",
                                          "permuted_table_poly"
                                        |))
                                    ]
                                ]
                            ]
                          |);
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              Value.StructRecord
                                "halo2_proofs::poly::multiopen::ProverQuery"
                                [
                                  ("point", M.read (| x_inv |));
                                  ("rotation",
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "halo2_proofs::poly::Rotation",
                                        "prev",
                                        []
                                      |),
                                      []
                                    |));
                                  ("poly",
                                    M.SubPointer.get_struct_record_field (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "halo2_proofs::plonk::lookup::prover::Evaluated",
                                        "constructed"
                                      |),
                                      "halo2_proofs::plonk::lookup::prover::Committed",
                                      "permuted_input_poly"
                                    |))
                                ]
                            ]
                        ]
                      |);
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          Value.StructRecord
                            "halo2_proofs::poly::multiopen::ProverQuery"
                            [
                              ("point", M.read (| x_next |));
                              ("rotation",
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "halo2_proofs::poly::Rotation",
                                    "next",
                                    []
                                  |),
                                  []
                                |));
                              ("poly",
                                M.SubPointer.get_struct_record_field (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "halo2_proofs::plonk::lookup::prover::Evaluated",
                                    "constructed"
                                  |),
                                  "halo2_proofs::plonk::lookup::prover::Committed",
                                  "product_poly"
                                |))
                            ]
                        ]
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_open :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "open" (open C).
      End Impl_halo2_proofs_plonk_lookup_prover_Evaluated_C.
      
      Axiom ExpressionPair :
        forall (F : Ty.t),
        (Ty.apply (Ty.path "halo2_proofs::plonk::lookup::prover::ExpressionPair") [ F ]) =
          (Ty.tuple
            [
              Ty.apply
                (Ty.path "halo2_proofs::poly::Polynomial")
                [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ];
              Ty.apply
                (Ty.path "halo2_proofs::poly::Polynomial")
                [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ];
              Ty.path "usize";
              Ty.path "usize"
            ]).
      
      (*
      fn sort_get_max<F: FieldExt>(value: &mut Vec<F>) -> F {
          let max = *value.iter().reduce(|a, b| a.max(b)).unwrap();
      
          value.sort_unstable_by(|a, b| unsafe {
              let a: &[u64; 4] = std::mem::transmute(a);
              let b: &[u64; 4] = std::mem::transmute(b);
              a.cmp(b)
          });
      
          max
      }
      *)
      Definition sort_get_max (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F ], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.read (|
              let max :=
                M.copy (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [ Ty.apply (Ty.path "&") [ F ] ],
                      "unwrap",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::slice::iter::Iter") [ F ],
                          [],
                          "reduce",
                          [
                            Ty.function
                              [
                                Ty.tuple
                                  [ Ty.apply (Ty.path "&") [ F ]; Ty.apply (Ty.path "&") [ F ] ]
                              ]
                              (Ty.apply (Ty.path "&") [ F ])
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ F ],
                              "iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ F; Ty.path "alloc::alloc::Global" ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ M.read (| value |) ]
                              |)
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0; α1 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let a := M.copy (| γ |) in
                                          M.match_operator (|
                                            M.alloc (| α1 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let b := M.copy (| γ |) in
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::cmp::Ord",
                                                      Ty.apply (Ty.path "&") [ F ],
                                                      [],
                                                      "max",
                                                      []
                                                    |),
                                                    [ M.read (| a |); M.read (| b |) ]
                                                  |)))
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ F ],
                      "sort_unstable_by",
                      [
                        Ty.function
                          [ Ty.tuple [ Ty.apply (Ty.path "&") [ F ]; Ty.apply (Ty.path "&") [ F ] ]
                          ]
                          (Ty.path "core::cmp::Ordering")
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::DerefMut",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ F; Ty.path "alloc::alloc::Global" ],
                          [],
                          "deref_mut",
                          []
                        |),
                        [ M.read (| value |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0; α1 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let a := M.copy (| γ |) in
                                      M.match_operator (|
                                        M.alloc (| α1 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let b := M.copy (| γ |) in
                                              M.read (|
                                                let a :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_function (|
                                                        "core::intrinsics::transmute",
                                                        [
                                                          Ty.apply (Ty.path "&") [ F ];
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "array")
                                                                [ Ty.path "u64" ]
                                                            ]
                                                        ]
                                                      |),
                                                      [ M.read (| a |) ]
                                                    |)
                                                  |) in
                                                let b :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_function (|
                                                        "core::intrinsics::transmute",
                                                        [
                                                          Ty.apply (Ty.path "&") [ F ];
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "array")
                                                                [ Ty.path "u64" ]
                                                            ]
                                                        ]
                                                      |),
                                                      [ M.read (| b |) ]
                                                    |)
                                                  |) in
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::cmp::Ord",
                                                      Ty.apply (Ty.path "array") [ Ty.path "u64" ],
                                                      [],
                                                      "cmp",
                                                      []
                                                    |),
                                                    [ M.read (| a |); M.read (| b |) ]
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    ]
                  |)
                |) in
              max
            |)))
        | _, _ => M.impossible
        end.
      
      (*
      fn permute_expression_pair<C: CurveAffine, R: RngCore>(
          pk: &ProvingKey<C>,
          params: &Params<C>,
          domain: &EvaluationDomain<C::Scalar>,
          mut rng: R,
          input_expression: &Polynomial<C::Scalar, LagrangeCoeff>,
          table_expression: &Polynomial<C::Scalar, LagrangeCoeff>,
      ) -> Result<ExpressionPair<C::Scalar>, Error> {
          let blinding_factors = pk.vk.cs.blinding_factors();
          let usable_rows = params.n as usize - (blinding_factors + 1);
      
          let mut permuted_input_expression: Vec<C::Scalar> = input_expression.to_vec();
          permuted_input_expression.truncate(usable_rows);
      
          let mut sorted_table_coeffs = table_expression.to_vec();
          sorted_table_coeffs.truncate(usable_rows);
      
          let max_input = sort_get_max(&mut permuted_input_expression);
          let max_table = sort_get_max(&mut sorted_table_coeffs);
      
          let mut permuted_table_coeffs = vec![None; usable_rows];
      
          let unique_input_values = permuted_input_expression
              .iter()
              .zip(permuted_table_coeffs.iter_mut())
              .enumerate()
              .filter_map(|(row, (input_value, table_value))| {
                  // If this is the first occurrence of `input_value` in the input expression
                  if row == 0 || *input_value != permuted_input_expression[row - 1] {
                      *table_value = Some( *input_value);
                      Some( *input_value)
                  } else {
                      None
                  }
              })
              .collect::<Vec<_>>();
      
          let mut i_unique_input_value = 0;
          let mut i_sorted_table_coeffs = 0;
          for v in permuted_table_coeffs.iter_mut() {
              while i_unique_input_value < unique_input_values.len()
                  && unique_input_values[i_unique_input_value]
                      == sorted_table_coeffs[i_sorted_table_coeffs]
              {
                  i_unique_input_value += 1;
                  i_sorted_table_coeffs += 1;
              }
              if v.is_none() {
                  *v = Some(sorted_table_coeffs[i_sorted_table_coeffs]);
                  i_sorted_table_coeffs += 1;
              }
          }
      
          while i_unique_input_value < unique_input_values.len()
              && unique_input_values[i_unique_input_value] == sorted_table_coeffs[i_sorted_table_coeffs]
          {
              i_unique_input_value += 1;
              i_sorted_table_coeffs += 1;
          }
      
          //assert!(i_unique_input_value == unique_input_values.len());
      
          let mut permuted_table_coeffs = permuted_table_coeffs
              .iter()
              .filter_map(|x| *x)
              .collect::<Vec<_>>();
      
          permuted_input_expression
              .extend((0..(blinding_factors + 1)).map(|_| C::Scalar::from(u16::rand(&mut rng) as u64)));
          permuted_table_coeffs
              .extend((0..(blinding_factors + 1)).map(|_| C::Scalar::from(u16::rand(&mut rng) as u64)));
          assert_eq!(permuted_input_expression.len(), params.n as usize);
          assert_eq!(permuted_table_coeffs.len(), params.n as usize);
      
          #[cfg(feature = "sanity-checks")]
          {
              let mut last = None;
              for (a, b) in permuted_input_expression
                  .iter()
                  .zip(permuted_table_coeffs.iter())
                  .take(usable_rows)
              {
                  if *a != *b {
                      assert_eq!( *a, last.unwrap());
                  }
                  last = Some( *a);
              }
          }
      
          let get_scalar_bits = |x: C::Scalar| {
              let repr = x.to_repr();
              let max_scalar_repr_ref: &[u8] = repr.as_ref();
              max_scalar_repr_ref
                  .iter()
                  .enumerate()
                  .fold(0, |acc, (idx, v)| {
                      if *v == 0 {
                          acc
                      } else {
                          idx * 8 + 8 - v.leading_zeros() as usize
                      }
                  })
          };
      
          Ok((
              domain.lagrange_from_vec(permuted_input_expression),
              domain.lagrange_from_vec(permuted_table_coeffs),
              16.max(get_scalar_bits(max_input)),
              16.max(get_scalar_bits(max_table)),
          ))
      }
      *)
      Definition permute_expression_pair (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ C; R ], [ pk; params; domain; rng; input_expression; table_expression ] =>
          ltac:(M.monadic
            (let pk := M.alloc (| pk |) in
            let params := M.alloc (| params |) in
            let domain := M.alloc (| domain |) in
            let rng := M.alloc (| rng |) in
            let input_expression := M.alloc (| input_expression |) in
            let table_expression := M.alloc (| table_expression |) in
            M.read (|
              let blinding_factors :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "halo2_proofs::plonk::circuit::ConstraintSystem")
                        [ Ty.associated ],
                      "blinding_factors",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| pk |),
                          "halo2_proofs::plonk::ProvingKey",
                          "vk"
                        |),
                        "halo2_proofs::plonk::VerifyingKey",
                        "cs"
                      |)
                    ]
                  |)
                |) in
              let usable_rows :=
                M.alloc (|
                  BinOp.Panic.sub (|
                    Integer.Usize,
                    M.rust_cast
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| params |),
                          "halo2_proofs::poly::commitment::Params",
                          "n"
                        |)
                      |)),
                    BinOp.Panic.add (|
                      Integer.Usize,
                      M.read (| blinding_factors |),
                      Value.Integer 1
                    |)
                  |)
                |) in
              let permuted_input_expression :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ Ty.associated ],
                      "to_vec",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "halo2_proofs::poly::Polynomial")
                            [ Ty.associated; Ty.path "halo2_proofs::poly::LagrangeCoeff" ],
                          [],
                          "deref",
                          []
                        |),
                        [ M.read (| input_expression |) ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                      "truncate",
                      []
                    |),
                    [ permuted_input_expression; M.read (| usable_rows |) ]
                  |)
                |) in
              let sorted_table_coeffs :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ Ty.associated ],
                      "to_vec",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "halo2_proofs::poly::Polynomial")
                            [ Ty.associated; Ty.path "halo2_proofs::poly::LagrangeCoeff" ],
                          [],
                          "deref",
                          []
                        |),
                        [ M.read (| table_expression |) ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                      "truncate",
                      []
                    |),
                    [ sorted_table_coeffs; M.read (| usable_rows |) ]
                  |)
                |) in
              let max_input :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "halo2_proofs::plonk::lookup::prover::sort_get_max",
                      [ Ty.associated ]
                    |),
                    [ permuted_input_expression ]
                  |)
                |) in
              let max_table :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "halo2_proofs::plonk::lookup::prover::sort_get_max",
                      [ Ty.associated ]
                    |),
                    [ sorted_table_coeffs ]
                  |)
                |) in
              let permuted_table_coeffs :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "alloc::vec::from_elem",
                      [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ]
                    |),
                    [ Value.StructTuple "core::option::Option::None" []; M.read (| usable_rows |) ]
                  |)
                |) in
              let unique_input_values :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::filter_map::FilterMap")
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                [
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.associated ];
                                  Ty.apply
                                    (Ty.path "core::slice::iter::IterMut")
                                    [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ]
                                ]
                            ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "usize";
                                      Ty.tuple
                                        [
                                          Ty.apply (Ty.path "&") [ Ty.associated ];
                                          Ty.apply
                                            (Ty.path "&mut")
                                            [
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [ Ty.associated ]
                                            ]
                                        ]
                                    ]
                                ]
                            ]
                            (Ty.apply (Ty.path "core::option::Option") [ Ty.associated ])
                        ],
                      [],
                      "collect",
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                [
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.associated ];
                                  Ty.apply
                                    (Ty.path "core::slice::iter::IterMut")
                                    [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ]
                                ]
                            ],
                          [],
                          "filter_map",
                          [
                            Ty.associated;
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "usize";
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [ Ty.associated ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [ Ty.associated ]
                                              ]
                                          ]
                                      ]
                                  ]
                              ]
                              (Ty.apply (Ty.path "core::option::Option") [ Ty.associated ])
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                [
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.associated ];
                                  Ty.apply
                                    (Ty.path "core::slice::iter::IterMut")
                                    [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ]
                                ],
                              [],
                              "enumerate",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.associated ],
                                  [],
                                  "zip",
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::IterMut")
                                      [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ]
                                      ]
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [ Ty.associated ],
                                      "iter",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [ permuted_input_expression ]
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.associated ]
                                        ],
                                      "iter_mut",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::DerefMut",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [ Ty.associated ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "deref_mut",
                                          []
                                        |),
                                        [ permuted_table_coeffs ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                          let row := M.copy (| γ0_0 |) in
                                          let γ1_0 := M.SubPointer.get_tuple_field (| γ0_1, 0 |) in
                                          let γ1_1 := M.SubPointer.get_tuple_field (| γ0_1, 1 |) in
                                          let input_value := M.copy (| γ1_0 |) in
                                          let table_value := M.copy (| γ1_1 |) in
                                          M.read (|
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          LogicalOp.or (|
                                                            BinOp.Pure.eq
                                                              (M.read (| row |))
                                                              (Value.Integer 0),
                                                            ltac:(M.monadic
                                                              (M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::cmp::PartialEq",
                                                                  Ty.associated,
                                                                  [ Ty.associated ],
                                                                  "ne",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| input_value |);
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::ops::index::Index",
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        [
                                                                          Ty.associated;
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ],
                                                                      [ Ty.path "usize" ],
                                                                      "index",
                                                                      []
                                                                    |),
                                                                    [
                                                                      permuted_input_expression;
                                                                      BinOp.Panic.sub (|
                                                                        Integer.Usize,
                                                                        M.read (| row |),
                                                                        Value.Integer 1
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)))
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    let _ :=
                                                      M.write (|
                                                        M.read (| table_value |),
                                                        Value.StructTuple
                                                          "core::option::Option::Some"
                                                          [ M.read (| M.read (| input_value |) |) ]
                                                      |) in
                                                    M.alloc (|
                                                      Value.StructTuple
                                                        "core::option::Option::Some"
                                                        [ M.read (| M.read (| input_value |) |) ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.alloc (|
                                                      Value.StructTuple
                                                        "core::option::Option::None"
                                                        []
                                                    |)))
                                              ]
                                            |)
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    ]
                  |)
                |) in
              let i_unique_input_value := M.alloc (| Value.Integer 0 |) in
              let i_sorted_table_coeffs := M.alloc (| Value.Integer 0 |) in
              let _ :=
                M.use
                  (M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "core::slice::iter::IterMut")
                            [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ],
                          [],
                          "into_iter",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ],
                              "iter_mut",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply (Ty.path "core::option::Option") [ Ty.associated ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "deref_mut",
                                  []
                                |),
                                [ permuted_table_coeffs ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            ltac:(M.monadic
                              (let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::slice::iter::IterMut")
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [ Ty.associated ]
                                          ],
                                        [],
                                        "next",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let v := M.copy (| γ0_0 |) in
                                        let _ :=
                                          M.loop (|
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            LogicalOp.and (|
                                                              BinOp.Pure.lt
                                                                (M.read (| i_unique_input_value |))
                                                                (M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      [
                                                                        Ty.associated;
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    "len",
                                                                    []
                                                                  |),
                                                                  [ unique_input_values ]
                                                                |)),
                                                              ltac:(M.monadic
                                                                (M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::cmp::PartialEq",
                                                                    Ty.associated,
                                                                    [ Ty.associated ],
                                                                    "eq",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::ops::index::Index",
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::vec::Vec")
                                                                          [
                                                                            Ty.associated;
                                                                            Ty.path
                                                                              "alloc::alloc::Global"
                                                                          ],
                                                                        [ Ty.path "usize" ],
                                                                        "index",
                                                                        []
                                                                      |),
                                                                      [
                                                                        unique_input_values;
                                                                        M.read (|
                                                                          i_unique_input_value
                                                                        |)
                                                                      ]
                                                                    |);
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::ops::index::Index",
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::vec::Vec")
                                                                          [
                                                                            Ty.associated;
                                                                            Ty.path
                                                                              "alloc::alloc::Global"
                                                                          ],
                                                                        [ Ty.path "usize" ],
                                                                        "index",
                                                                        []
                                                                      |),
                                                                      [
                                                                        sorted_table_coeffs;
                                                                        M.read (|
                                                                          i_sorted_table_coeffs
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  ]
                                                                |)))
                                                            |)
                                                          |)) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      let _ :=
                                                        let β := i_unique_input_value in
                                                        M.write (|
                                                          β,
                                                          BinOp.Panic.add (|
                                                            Integer.Usize,
                                                            M.read (| β |),
                                                            Value.Integer 1
                                                          |)
                                                        |) in
                                                      let _ :=
                                                        let β := i_sorted_table_coeffs in
                                                        M.write (|
                                                          β,
                                                          BinOp.Panic.add (|
                                                            Integer.Usize,
                                                            M.read (| β |),
                                                            Value.Integer 1
                                                          |)
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            let _ :=
                                                              M.alloc (|
                                                                M.never_to_any (|
                                                                  M.read (| M.break (||) |)
                                                                |)
                                                              |) in
                                                            M.alloc (| Value.Tuple [] |)
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)))
                                          |) in
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [ Ty.associated ],
                                                          "is_none",
                                                          []
                                                        |),
                                                        [ M.read (| v |) ]
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                let _ :=
                                                  M.write (|
                                                    M.read (| v |),
                                                    Value.StructTuple
                                                      "core::option::Option::Some"
                                                      [
                                                        M.read (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::index::Index",
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                [
                                                                  Ty.associated;
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              [ Ty.path "usize" ],
                                                              "index",
                                                              []
                                                            |),
                                                            [
                                                              sorted_table_coeffs;
                                                              M.read (| i_sorted_table_coeffs |)
                                                            ]
                                                          |)
                                                        |)
                                                      ]
                                                  |) in
                                                let _ :=
                                                  let β := i_sorted_table_coeffs in
                                                  M.write (|
                                                    β,
                                                    BinOp.Panic.add (|
                                                      Integer.Usize,
                                                      M.read (| β |),
                                                      Value.Integer 1
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |)) in
              let _ :=
                M.loop (|
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    BinOp.Pure.lt
                                      (M.read (| i_unique_input_value |))
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                                          "len",
                                          []
                                        |),
                                        [ unique_input_values ]
                                      |)),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.associated,
                                          [ Ty.associated ],
                                          "eq",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                                              [ Ty.path "usize" ],
                                              "index",
                                              []
                                            |),
                                            [ unique_input_values; M.read (| i_unique_input_value |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                                              [ Ty.path "usize" ],
                                              "index",
                                              []
                                            |),
                                            [
                                              sorted_table_coeffs;
                                              M.read (| i_sorted_table_coeffs |)
                                            ]
                                          |)
                                        ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              let β := i_unique_input_value in
                              M.write (|
                                β,
                                BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                              |) in
                            let _ :=
                              let β := i_sorted_table_coeffs in
                              M.write (|
                                β,
                                BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let _ :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              let permuted_table_coeffs :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::filter_map::FilterMap")
                        [
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ]
                                ]
                            ]
                            (Ty.apply (Ty.path "core::option::Option") [ Ty.associated ])
                        ],
                      [],
                      "collect",
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ],
                          [],
                          "filter_map",
                          [
                            Ty.associated;
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ]
                                      ]
                                  ]
                              ]
                              (Ty.apply (Ty.path "core::option::Option") [ Ty.associated ])
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ],
                              "iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply (Ty.path "core::option::Option") [ Ty.associated ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ permuted_table_coeffs ]
                              |)
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x := M.copy (| γ |) in
                                          M.read (| M.read (| x |) |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                      [ Ty.associated ],
                      "extend",
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::map::Map")
                          [
                            Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ];
                            Ty.function [ Ty.tuple [ Ty.path "usize" ] ] Ty.associated
                          ]
                      ]
                    |),
                    [
                      permuted_input_expression;
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ],
                          [],
                          "map",
                          [
                            Ty.associated;
                            Ty.function [ Ty.tuple [ Ty.path "usize" ] ] Ty.associated
                          ]
                        |),
                        [
                          Value.StructRecord
                            "core::ops::range::Range"
                            [
                              ("start", Value.Integer 0);
                              ("end_",
                                BinOp.Panic.add (|
                                  Integer.Usize,
                                  M.read (| blinding_factors |),
                                  Value.Integer 1
                                |))
                            ];
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.call_closure (|
                                            M.get_trait_method (|
                                              "core::convert::From",
                                              Ty.associated,
                                              [ Ty.path "u64" ],
                                              "from",
                                              []
                                            |),
                                            [
                                              M.rust_cast
                                                (M.call_closure (|
                                                  M.get_trait_method (|
                                                    "ark_std::rand_helper::UniformRand",
                                                    Ty.path "u16",
                                                    [],
                                                    "rand",
                                                    [ R ]
                                                  |),
                                                  [ rng ]
                                                |))
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                      [ Ty.associated ],
                      "extend",
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::map::Map")
                          [
                            Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ];
                            Ty.function [ Ty.tuple [ Ty.path "usize" ] ] Ty.associated
                          ]
                      ]
                    |),
                    [
                      permuted_table_coeffs;
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ],
                          [],
                          "map",
                          [
                            Ty.associated;
                            Ty.function [ Ty.tuple [ Ty.path "usize" ] ] Ty.associated
                          ]
                        |),
                        [
                          Value.StructRecord
                            "core::ops::range::Range"
                            [
                              ("start", Value.Integer 0);
                              ("end_",
                                BinOp.Panic.add (|
                                  Integer.Usize,
                                  M.read (| blinding_factors |),
                                  Value.Integer 1
                                |))
                            ];
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.call_closure (|
                                            M.get_trait_method (|
                                              "core::convert::From",
                                              Ty.associated,
                                              [ Ty.path "u64" ],
                                              "from",
                                              []
                                            |),
                                            [
                                              M.rust_cast
                                                (M.call_closure (|
                                                  M.get_trait_method (|
                                                    "ark_std::rand_helper::UniformRand",
                                                    Ty.path "u16",
                                                    [],
                                                    "rand",
                                                    [ R ]
                                                  |),
                                                  [ rng ]
                                                |))
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    Value.Tuple
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                              "len",
                              []
                            |),
                            [ permuted_input_expression ]
                          |)
                        |);
                        M.alloc (|
                          M.rust_cast
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| params |),
                                "halo2_proofs::poly::commitment::Params",
                                "n"
                              |)
                            |))
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (BinOp.Pure.eq
                                          (M.read (| M.read (| left_val |) |))
                                          (M.read (| M.read (| right_val |) |)))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let kind :=
                                        M.alloc (|
                                          Value.StructTuple "core::panicking::AssertKind::Eq" []
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.read (| left_val |);
                                            M.read (| right_val |);
                                            Value.StructTuple "core::option::Option::None" []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    Value.Tuple
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.associated; Ty.path "alloc::alloc::Global" ],
                              "len",
                              []
                            |),
                            [ permuted_table_coeffs ]
                          |)
                        |);
                        M.alloc (|
                          M.rust_cast
                            (M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| params |),
                                "halo2_proofs::poly::commitment::Params",
                                "n"
                              |)
                            |))
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (BinOp.Pure.eq
                                          (M.read (| M.read (| left_val |) |))
                                          (M.read (| M.read (| right_val |) |)))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let kind :=
                                        M.alloc (|
                                          Value.StructTuple "core::panicking::AssertKind::Eq" []
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.read (| left_val |);
                                            M.read (| right_val |);
                                            Value.StructTuple "core::option::Option::None" []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |) in
              let get_scalar_bits :=
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let x := M.copy (| γ |) in
                                  M.read (|
                                    let repr :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "ff::PrimeField",
                                            Ty.associated,
                                            [],
                                            "to_repr",
                                            []
                                          |),
                                          [ x ]
                                        |)
                                      |) in
                                    let max_scalar_repr_ref :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::convert::AsRef",
                                            Ty.associated,
                                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                                            "as_ref",
                                            []
                                          |),
                                          [ repr ]
                                        |)
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [ Ty.path "u8" ]
                                            ],
                                          [],
                                          "fold",
                                          [
                                            Ty.path "usize";
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path "usize";
                                                    Ty.tuple
                                                      [
                                                        Ty.path "usize";
                                                        Ty.apply (Ty.path "&") [ Ty.path "u8" ]
                                                      ]
                                                  ]
                                              ]
                                              (Ty.path "usize")
                                          ]
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [ Ty.path "u8" ],
                                              [],
                                              "enumerate",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                                                  "iter",
                                                  []
                                                |),
                                                [ M.read (| max_scalar_repr_ref |) ]
                                              |)
                                            ]
                                          |);
                                          Value.Integer 0;
                                          M.closure
                                            (fun γ =>
                                              ltac:(M.monadic
                                                match γ with
                                                | [ α0; α1 ] =>
                                                  M.match_operator (|
                                                    M.alloc (| α0 |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let acc := M.copy (| γ |) in
                                                          M.match_operator (|
                                                            M.alloc (| α1 |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      0
                                                                    |) in
                                                                  let γ0_1 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      1
                                                                    |) in
                                                                  let idx := M.copy (| γ0_0 |) in
                                                                  let v := M.copy (| γ0_1 |) in
                                                                  M.read (|
                                                                    M.match_operator (|
                                                                      M.alloc (| Value.Tuple [] |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let γ :=
                                                                              M.use
                                                                                (M.alloc (|
                                                                                  BinOp.Pure.eq
                                                                                    (M.read (|
                                                                                      M.read (| v |)
                                                                                    |))
                                                                                    (Value.Integer
                                                                                      0)
                                                                                |)) in
                                                                            let _ :=
                                                                              M.is_constant_or_break_match (|
                                                                                M.read (| γ |),
                                                                                Value.Bool true
                                                                              |) in
                                                                            acc));
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.alloc (|
                                                                              BinOp.Panic.sub (|
                                                                                Integer.Usize,
                                                                                BinOp.Panic.add (|
                                                                                  Integer.Usize,
                                                                                  BinOp.Panic.mul (|
                                                                                    Integer.Usize,
                                                                                    M.read (|
                                                                                      idx
                                                                                    |),
                                                                                    Value.Integer 8
                                                                                  |),
                                                                                  Value.Integer 8
                                                                                |),
                                                                                M.rust_cast
                                                                                  (M.call_closure (|
                                                                                    M.get_associated_function (|
                                                                                      Ty.path "u8",
                                                                                      "leading_zeros",
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.read (|
                                                                                        M.read (|
                                                                                          v
                                                                                        |)
                                                                                      |)
                                                                                    ]
                                                                                  |))
                                                                              |)
                                                                            |)))
                                                                      ]
                                                                    |)
                                                                  |)))
                                                            ]
                                                          |)))
                                                    ]
                                                  |)
                                                | _ => M.impossible (||)
                                                end))
                                        ]
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |) in
              M.alloc (|
                Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    Value.Tuple
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::poly::domain::EvaluationDomain")
                              [ Ty.associated ],
                            "lagrange_from_vec",
                            []
                          |),
                          [ M.read (| domain |); M.read (| permuted_input_expression |) ]
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "halo2_proofs::poly::domain::EvaluationDomain")
                              [ Ty.associated ],
                            "lagrange_from_vec",
                            []
                          |),
                          [ M.read (| domain |); M.read (| permuted_table_coeffs |) ]
                        |);
                        M.call_closure (|
                          M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], "max", [] |),
                          [
                            Value.Integer 16;
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::Fn",
                                Ty.function [ Ty.tuple [ Ty.associated ] ] (Ty.path "usize"),
                                [ Ty.tuple [ Ty.associated ] ],
                                "call",
                                []
                              |),
                              [ get_scalar_bits; Value.Tuple [ M.read (| max_input |) ] ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], "max", [] |),
                          [
                            Value.Integer 16;
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::Fn",
                                Ty.function [ Ty.tuple [ Ty.associated ] ] (Ty.path "usize"),
                                [ Ty.tuple [ Ty.associated ] ],
                                "call",
                                []
                              |),
                              [ get_scalar_bits; Value.Tuple [ M.read (| max_table |) ] ]
                            |)
                          ]
                        |)
                      ]
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
    End prover.
  End lookup.
End plonk.
