(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module plonk.
  Module lookup.
    Module verifier.
      (* StructRecord
        {
          name := "PermutationCommitments";
          ty_params := [ "C" ];
          fields := [ ("permuted_input_commitment", C); ("permuted_table_commitment", C) ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_plonk_lookup_verifier_PermutationCommitments_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::verifier::PermutationCommitments") [ C ].
        
        (* Debug *)
        Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field2_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "PermutationCommitments" |);
                  M.read (| Value.String "permuted_input_commitment" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::lookup::verifier::PermutationCommitments",
                      "permuted_input_commitment"
                    |));
                  M.read (| Value.String "permuted_table_commitment" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::lookup::verifier::PermutationCommitments",
                        "permuted_table_commitment"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (C : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self C)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_plonk_lookup_verifier_PermutationCommitments_C.
      
      (* StructRecord
        {
          name := "Committed";
          ty_params := [ "C" ];
          fields :=
            [
              ("permuted",
                Ty.apply
                  (Ty.path "halo2_proofs::plonk::lookup::verifier::PermutationCommitments")
                  [ C ]);
              ("product_commitment", C)
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_plonk_lookup_verifier_Committed_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::verifier::Committed") [ C ].
        
        (* Debug *)
        Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field2_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "Committed" |);
                  M.read (| Value.String "permuted" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::lookup::verifier::Committed",
                      "permuted"
                    |));
                  M.read (| Value.String "product_commitment" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::lookup::verifier::Committed",
                        "product_commitment"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (C : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self C)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_plonk_lookup_verifier_Committed_C.
      
      (* StructRecord
        {
          name := "Evaluated";
          ty_params := [ "C" ];
          fields :=
            [
              ("committed",
                Ty.apply (Ty.path "halo2_proofs::plonk::lookup::verifier::Committed") [ C ]);
              ("product_eval", Ty.associated);
              ("product_next_eval", Ty.associated);
              ("permuted_input_eval", Ty.associated);
              ("permuted_input_inv_eval", Ty.associated);
              ("permuted_table_eval", Ty.associated)
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_plonk_lookup_verifier_Evaluated_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::verifier::Evaluated") [ C ].
        
        (* Debug *)
        Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let names :=
                  M.alloc (|
                    M.alloc (|
                      Value.Array
                        [
                          M.read (| Value.String "committed" |);
                          M.read (| Value.String "product_eval" |);
                          M.read (| Value.String "product_next_eval" |);
                          M.read (| Value.String "permuted_input_eval" |);
                          M.read (| Value.String "permuted_input_inv_eval" |);
                          M.read (| Value.String "permuted_table_eval" |)
                        ]
                    |)
                  |) in
                let values :=
                  M.alloc (|
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        Value.Array
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                "committed"
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                "product_eval"
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                "product_next_eval"
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                "permuted_input_eval"
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                "permuted_input_inv_eval"
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                  "permuted_table_eval"
                                |)
                              |))
                          ]
                      |))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "debug_struct_fields_finish",
                      []
                    |),
                    [
                      M.read (| f |);
                      M.read (| Value.String "Evaluated" |);
                      (* Unsize *) M.pointer_coercion (M.read (| names |));
                      M.read (| values |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (C : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self C)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_plonk_lookup_verifier_Evaluated_C.
      
      Module Impl_halo2_proofs_plonk_lookup_Argument_F.
        Definition Self (F : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::Argument") [ F ].
        
        (*
            pub fn read_permuted_commitments<
                C: CurveAffine,
                E: EncodedChallenge<C>,
                T: TranscriptRead<C, E>,
            >(
                &self,
                transcript: &mut T,
            ) -> Result<PermutationCommitments<C>, Error> {
                let permuted_input_commitment = transcript.read_point()?;
                let permuted_table_commitment = transcript.read_point()?;
        
                Ok(PermutationCommitments {
                    permuted_input_commitment,
                    permuted_table_commitment,
                })
            }
        *)
        Definition read_permuted_commitments (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match τ, α with
          | [ C; E; T ], [ self; transcript ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let transcript := M.alloc (| transcript |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let permuted_input_commitment :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ C; Ty.path "std::io::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_point",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::lookup::verifier::PermutationCommitments")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let permuted_table_commitment :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ C; Ty.path "std::io::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_point",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::lookup::verifier::PermutationCommitments")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "halo2_proofs::plonk::lookup::verifier::PermutationCommitments"
                            [
                              ("permuted_input_commitment", M.read (| permuted_input_commitment |));
                              ("permuted_table_commitment", M.read (| permuted_table_commitment |))
                            ]
                        ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_read_permuted_commitments :
          forall (F : Ty.t),
          M.IsAssociatedFunction (Self F) "read_permuted_commitments" (read_permuted_commitments F).
      End Impl_halo2_proofs_plonk_lookup_Argument_F.
      
      Module Impl_halo2_proofs_plonk_lookup_verifier_PermutationCommitments_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::verifier::PermutationCommitments") [ C ].
        
        (*
            pub fn read_product_commitment<E: EncodedChallenge<C>, T: TranscriptRead<C, E>>(
                self,
                transcript: &mut T,
            ) -> Result<Committed<C>, Error> {
                let product_commitment = transcript.read_point()?;
        
                Ok(Committed {
                    permuted: self,
                    product_commitment,
                })
            }
        *)
        Definition read_product_commitment (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [ E; T ], [ self; transcript ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let transcript := M.alloc (| transcript |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let product_commitment :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ C; Ty.path "std::io::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_point",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::lookup::verifier::Committed")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "halo2_proofs::plonk::lookup::verifier::Committed"
                            [
                              ("permuted", M.read (| self |));
                              ("product_commitment", M.read (| product_commitment |))
                            ]
                        ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_read_product_commitment :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "read_product_commitment" (read_product_commitment C).
      End Impl_halo2_proofs_plonk_lookup_verifier_PermutationCommitments_C.
      
      Module Impl_halo2_proofs_plonk_lookup_verifier_Committed_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::verifier::Committed") [ C ].
        
        (*
            pub fn evaluate<E: EncodedChallenge<C>, T: TranscriptRead<C, E>>(
                self,
                transcript: &mut T,
            ) -> Result<Evaluated<C>, Error> {
                let product_eval = transcript.read_scalar()?;
                let product_next_eval = transcript.read_scalar()?;
                let permuted_input_eval = transcript.read_scalar()?;
                let permuted_input_inv_eval = transcript.read_scalar()?;
                let permuted_table_eval = transcript.read_scalar()?;
        
                Ok(Evaluated {
                    committed: self,
                    product_eval,
                    product_next_eval,
                    permuted_input_eval,
                    permuted_input_inv_eval,
                    permuted_table_eval,
                })
            }
        *)
        Definition evaluate (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [ E; T ], [ self; transcript ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let transcript := M.alloc (| transcript |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let product_eval :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.associated; Ty.path "std::io::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_scalar",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::lookup::verifier::Evaluated")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let product_next_eval :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.associated; Ty.path "std::io::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_scalar",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::lookup::verifier::Evaluated")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let permuted_input_eval :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.associated; Ty.path "std::io::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_scalar",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::lookup::verifier::Evaluated")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let permuted_input_inv_eval :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.associated; Ty.path "std::io::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_scalar",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::lookup::verifier::Evaluated")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let permuted_table_eval :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.associated; Ty.path "std::io::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_scalar",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::lookup::verifier::Evaluated")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "halo2_proofs::plonk::lookup::verifier::Evaluated"
                            [
                              ("committed", M.read (| self |));
                              ("product_eval", M.read (| product_eval |));
                              ("product_next_eval", M.read (| product_next_eval |));
                              ("permuted_input_eval", M.read (| permuted_input_eval |));
                              ("permuted_input_inv_eval", M.read (| permuted_input_inv_eval |));
                              ("permuted_table_eval", M.read (| permuted_table_eval |))
                            ]
                        ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_evaluate :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "evaluate" (evaluate C).
      End Impl_halo2_proofs_plonk_lookup_verifier_Committed_C.
      
      Module Impl_halo2_proofs_plonk_lookup_verifier_Evaluated_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::lookup::verifier::Evaluated") [ C ].
        
        (*
            pub(in crate::plonk) fn expressions<'a>(
                &'a self,
                l_0: C::Scalar,
                l_last: C::Scalar,
                l_blind: C::Scalar,
                argument: &'a Argument<C::Scalar>,
                theta: ChallengeTheta<C>,
                beta: ChallengeBeta<C>,
                gamma: ChallengeGamma<C>,
                advice_evals: &[C::Scalar],
                fixed_evals: &[C::Scalar],
                instance_evals: &[C::Scalar],
            ) -> impl Iterator<Item = C::Scalar> + 'a {
                let active_rows = C::Scalar::one() - (l_last + l_blind);
        
                let product_expression = || {
                    // z(\omega X) (a'(X) + \beta) (s'(X) + \gamma)
                    // - z(X) (\theta^{m-1} a_0(X) + ... + a_{m-1}(X) + \beta) (\theta^{m-1} s_0(X) + ... + s_{m-1}(X) + \gamma)
                    let left = self.product_next_eval
                        * &(self.permuted_input_eval + &*beta)
                        * &(self.permuted_table_eval + &*gamma);
        
                    let compress_expressions = |expressions: &[Expression<C::Scalar>]| {
                        expressions
                            .iter()
                            .map(|expression| {
                                expression.evaluate(
                                    &|scalar| scalar,
                                    &|_| panic!("virtual selectors are removed during optimization"),
                                    &|index, _, _| fixed_evals[index],
                                    &|index, _, _| advice_evals[index],
                                    &|index, _, _| instance_evals[index],
                                    &|a| -a,
                                    &|a, b| a + &b,
                                    &|a, b| a() * &b(),
                                    &|a, scalar| a * &scalar,
                                )
                            })
                            .fold(C::Scalar::zero(), |acc, eval| acc * &*theta + &eval)
                    };
                    let right = self.product_eval
                        * &(compress_expressions(&argument.input_expressions) + &*beta)
                        * &(compress_expressions(&argument.table_expressions) + &*gamma);
        
                    (left - &right) * &active_rows
                };
        
                std::iter::empty()
                    .chain(
                        // l_0(X) * (1 - z'(X)) = 0
                        Some(l_0 * &(C::Scalar::one() - &self.product_eval)),
                    )
                    .chain(
                        // l_last(X) * (z(X)^2 - z(X)) = 0
                        Some(l_last * &(self.product_eval.square() - &self.product_eval)),
                    )
                    .chain(
                        // (1 - (l_last(X) + l_blind(X))) * (
                        //   z(\omega X) (a'(X) + \beta) (s'(X) + \gamma)
                        //   - z(X) (\theta^{m-1} a_0(X) + ... + a_{m-1}(X) + \beta) (\theta^{m-1} s_0(X) + ... + s_{m-1}(X) + \gamma)
                        // ) = 0
                        Some(product_expression()),
                    )
                    .chain(Some(
                        // l_0(X) * (a'(X) - s'(X)) = 0
                        l_0 * &(self.permuted_input_eval - &self.permuted_table_eval),
                    ))
                    .chain(Some(
                        // (1 - (l_last(X) + l_blind(X))) * (a′(X) − s′(X))⋅(a′(X) − a′(\omega^{-1} X)) = 0
                        (self.permuted_input_eval - &self.permuted_table_eval)
                            * &(self.permuted_input_eval - &self.permuted_input_inv_eval)
                            * &active_rows,
                    ))
            }
        *)
        Definition expressions (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [],
              [
                self;
                l_0;
                l_last;
                l_blind;
                argument;
                theta;
                beta;
                gamma;
                advice_evals;
                fixed_evals;
                instance_evals
              ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let l_0 := M.alloc (| l_0 |) in
              let l_last := M.alloc (| l_last |) in
              let l_blind := M.alloc (| l_blind |) in
              let argument := M.alloc (| argument |) in
              let theta := M.alloc (| theta |) in
              let beta := M.alloc (| beta |) in
              let gamma := M.alloc (| gamma |) in
              let advice_evals := M.alloc (| advice_evals |) in
              let fixed_evals := M.alloc (| fixed_evals |) in
              let instance_evals := M.alloc (| instance_evals |) in
              M.read (|
                let active_rows :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.associated,
                        [ Ty.associated ],
                        "sub",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (| "ff::Field", Ty.associated, [], "one", [] |),
                          []
                        |);
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::arith::Add",
                            Ty.associated,
                            [ Ty.associated ],
                            "add",
                            []
                          |),
                          [ M.read (| l_last |); M.read (| l_blind |) ]
                        |)
                      ]
                    |)
                  |) in
                let product_expression :=
                  M.alloc (|
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.read (|
                                      let left :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.associated,
                                              [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                              "mul",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::arith::Mul",
                                                  Ty.associated,
                                                  [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                  "mul",
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                                      "product_next_eval"
                                                    |)
                                                  |);
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::arith::Add",
                                                        Ty.associated,
                                                        [ Ty.apply (Ty.path "&") [ Ty.associated ]
                                                        ],
                                                        "add",
                                                        []
                                                      |),
                                                      [
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.read (| self |),
                                                            "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                                            "permuted_input_eval"
                                                          |)
                                                        |);
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::transcript::ChallengeScalar")
                                                              [
                                                                C;
                                                                Ty.path "halo2_proofs::plonk::Beta"
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ beta ]
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                ]
                                              |);
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Add",
                                                    Ty.associated,
                                                    [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                    "add",
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                                        "permuted_table_eval"
                                                      |)
                                                    |);
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::deref::Deref",
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::transcript::ChallengeScalar")
                                                          [ C; Ty.path "halo2_proofs::plonk::Gamma"
                                                          ],
                                                        [],
                                                        "deref",
                                                        []
                                                      |),
                                                      [ gamma ]
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        |) in
                                      let compress_expressions :=
                                        M.alloc (|
                                          M.closure
                                            (fun γ =>
                                              ltac:(M.monadic
                                                match γ with
                                                | [ α0 ] =>
                                                  M.match_operator (|
                                                    M.alloc (| α0 |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let expressions := M.copy (| γ |) in
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::iter::traits::iterator::Iterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::iter::adapters::map::Map")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::Iter")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Expression")
                                                                        [ Ty.associated ]
                                                                    ];
                                                                  Ty.function
                                                                    [
                                                                      Ty.tuple
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "halo2_proofs::plonk::circuit::Expression")
                                                                                [ Ty.associated ]
                                                                            ]
                                                                        ]
                                                                    ]
                                                                    Ty.associated
                                                                ],
                                                              [],
                                                              "fold",
                                                              [
                                                                Ty.associated;
                                                                Ty.function
                                                                  [
                                                                    Ty.tuple
                                                                      [ Ty.associated; Ty.associated
                                                                      ]
                                                                  ]
                                                                  Ty.associated
                                                              ]
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::iter::traits::iterator::Iterator",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::Iter")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Expression")
                                                                        [ Ty.associated ]
                                                                    ],
                                                                  [],
                                                                  "map",
                                                                  [
                                                                    Ty.associated;
                                                                    Ty.function
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "halo2_proofs::plonk::circuit::Expression")
                                                                                  [ Ty.associated ]
                                                                              ]
                                                                          ]
                                                                      ]
                                                                      Ty.associated
                                                                  ]
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::plonk::circuit::Expression")
                                                                            [ Ty.associated ]
                                                                        ],
                                                                      "iter",
                                                                      []
                                                                    |),
                                                                    [ M.read (| expressions |) ]
                                                                  |);
                                                                  M.closure
                                                                    (fun γ =>
                                                                      ltac:(M.monadic
                                                                        match γ with
                                                                        | [ α0 ] =>
                                                                          M.match_operator (|
                                                                            M.alloc (| α0 |),
                                                                            [
                                                                              fun γ =>
                                                                                ltac:(M.monadic
                                                                                  (let expression :=
                                                                                    M.copy (|
                                                                                      γ
                                                                                    |) in
                                                                                  M.call_closure (|
                                                                                    M.get_associated_function (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "halo2_proofs::plonk::circuit::Expression")
                                                                                        [
                                                                                          Ty.associated
                                                                                        ],
                                                                                      "evaluate",
                                                                                      [
                                                                                        Ty.associated;
                                                                                        Ty.function
                                                                                          [
                                                                                            Ty.tuple
                                                                                              [
                                                                                                Ty.associated
                                                                                              ]
                                                                                          ]
                                                                                          Ty.associated;
                                                                                        Ty.function
                                                                                          [
                                                                                            Ty.tuple
                                                                                              [
                                                                                                Ty.path
                                                                                                  "halo2_proofs::plonk::circuit::Selector"
                                                                                              ]
                                                                                          ]
                                                                                          Ty.associated;
                                                                                        Ty.function
                                                                                          [
                                                                                            Ty.tuple
                                                                                              [
                                                                                                Ty.path
                                                                                                  "usize";
                                                                                                Ty.path
                                                                                                  "usize";
                                                                                                Ty.path
                                                                                                  "halo2_proofs::poly::Rotation"
                                                                                              ]
                                                                                          ]
                                                                                          Ty.associated;
                                                                                        Ty.function
                                                                                          [
                                                                                            Ty.tuple
                                                                                              [
                                                                                                Ty.path
                                                                                                  "usize";
                                                                                                Ty.path
                                                                                                  "usize";
                                                                                                Ty.path
                                                                                                  "halo2_proofs::poly::Rotation"
                                                                                              ]
                                                                                          ]
                                                                                          Ty.associated;
                                                                                        Ty.function
                                                                                          [
                                                                                            Ty.tuple
                                                                                              [
                                                                                                Ty.path
                                                                                                  "usize";
                                                                                                Ty.path
                                                                                                  "usize";
                                                                                                Ty.path
                                                                                                  "halo2_proofs::poly::Rotation"
                                                                                              ]
                                                                                          ]
                                                                                          Ty.associated;
                                                                                        Ty.function
                                                                                          [
                                                                                            Ty.tuple
                                                                                              [
                                                                                                Ty.associated
                                                                                              ]
                                                                                          ]
                                                                                          Ty.associated;
                                                                                        Ty.function
                                                                                          [
                                                                                            Ty.tuple
                                                                                              [
                                                                                                Ty.associated;
                                                                                                Ty.associated
                                                                                              ]
                                                                                          ]
                                                                                          Ty.associated;
                                                                                        Ty.function
                                                                                          [
                                                                                            Ty.tuple
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "&")
                                                                                                  [
                                                                                                    Ty.dyn
                                                                                                      [
                                                                                                        ("core::ops::function::Fn::Trait",
                                                                                                          [])
                                                                                                      ]
                                                                                                  ];
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "&")
                                                                                                  [
                                                                                                    Ty.dyn
                                                                                                      [
                                                                                                        ("core::ops::function::Fn::Trait",
                                                                                                          [])
                                                                                                      ]
                                                                                                  ]
                                                                                              ]
                                                                                          ]
                                                                                          Ty.associated;
                                                                                        Ty.function
                                                                                          [
                                                                                            Ty.tuple
                                                                                              [
                                                                                                Ty.associated;
                                                                                                Ty.associated
                                                                                              ]
                                                                                          ]
                                                                                          Ty.associated
                                                                                      ]
                                                                                    |),
                                                                                    [
                                                                                      M.read (|
                                                                                        expression
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.closure
                                                                                          (fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              match
                                                                                                γ
                                                                                              with
                                                                                              | [ α0
                                                                                                  ] =>
                                                                                                M.match_operator (|
                                                                                                  M.alloc (|
                                                                                                    α0
                                                                                                  |),
                                                                                                  [
                                                                                                    fun
                                                                                                        γ =>
                                                                                                      ltac:(M.monadic
                                                                                                        (let
                                                                                                              scalar :=
                                                                                                          M.copy (|
                                                                                                            γ
                                                                                                          |) in
                                                                                                        M.read (|
                                                                                                          scalar
                                                                                                        |)))
                                                                                                  ]
                                                                                                |)
                                                                                              | _ =>
                                                                                                M.impossible (||)
                                                                                              end))
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.closure
                                                                                          (fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              match
                                                                                                γ
                                                                                              with
                                                                                              | [ α0
                                                                                                  ] =>
                                                                                                M.match_operator (|
                                                                                                  M.alloc (|
                                                                                                    α0
                                                                                                  |),
                                                                                                  [
                                                                                                    fun
                                                                                                        γ =>
                                                                                                      ltac:(M.monadic
                                                                                                        (M.never_to_any (|
                                                                                                          M.call_closure (|
                                                                                                            M.get_function (|
                                                                                                              "std::panicking::begin_panic",
                                                                                                              [
                                                                                                                Ty.apply
                                                                                                                  (Ty.path
                                                                                                                    "&")
                                                                                                                  [
                                                                                                                    Ty.path
                                                                                                                      "str"
                                                                                                                  ]
                                                                                                              ]
                                                                                                            |),
                                                                                                            [
                                                                                                              M.read (|
                                                                                                                Value.String
                                                                                                                  "virtual selectors are removed during optimization"
                                                                                                              |)
                                                                                                            ]
                                                                                                          |)
                                                                                                        |)))
                                                                                                  ]
                                                                                                |)
                                                                                              | _ =>
                                                                                                M.impossible (||)
                                                                                              end))
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.closure
                                                                                          (fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              match
                                                                                                γ
                                                                                              with
                                                                                              | [
                                                                                                    α0;
                                                                                                    α1;
                                                                                                    α2
                                                                                                  ] =>
                                                                                                M.match_operator (|
                                                                                                  M.alloc (|
                                                                                                    α0
                                                                                                  |),
                                                                                                  [
                                                                                                    fun
                                                                                                        γ =>
                                                                                                      ltac:(M.monadic
                                                                                                        (let
                                                                                                              index :=
                                                                                                          M.copy (|
                                                                                                            γ
                                                                                                          |) in
                                                                                                        M.match_operator (|
                                                                                                          M.alloc (|
                                                                                                            α1
                                                                                                          |),
                                                                                                          [
                                                                                                            fun
                                                                                                                γ =>
                                                                                                              ltac:(M.monadic
                                                                                                                (M.match_operator (|
                                                                                                                  M.alloc (|
                                                                                                                    α2
                                                                                                                  |),
                                                                                                                  [
                                                                                                                    fun
                                                                                                                        γ =>
                                                                                                                      ltac:(M.monadic
                                                                                                                        (M.read (|
                                                                                                                          M.SubPointer.get_array_field (|
                                                                                                                            M.read (|
                                                                                                                              fixed_evals
                                                                                                                            |),
                                                                                                                            index
                                                                                                                          |)
                                                                                                                        |)))
                                                                                                                  ]
                                                                                                                |)))
                                                                                                          ]
                                                                                                        |)))
                                                                                                  ]
                                                                                                |)
                                                                                              | _ =>
                                                                                                M.impossible (||)
                                                                                              end))
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.closure
                                                                                          (fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              match
                                                                                                γ
                                                                                              with
                                                                                              | [
                                                                                                    α0;
                                                                                                    α1;
                                                                                                    α2
                                                                                                  ] =>
                                                                                                M.match_operator (|
                                                                                                  M.alloc (|
                                                                                                    α0
                                                                                                  |),
                                                                                                  [
                                                                                                    fun
                                                                                                        γ =>
                                                                                                      ltac:(M.monadic
                                                                                                        (let
                                                                                                              index :=
                                                                                                          M.copy (|
                                                                                                            γ
                                                                                                          |) in
                                                                                                        M.match_operator (|
                                                                                                          M.alloc (|
                                                                                                            α1
                                                                                                          |),
                                                                                                          [
                                                                                                            fun
                                                                                                                γ =>
                                                                                                              ltac:(M.monadic
                                                                                                                (M.match_operator (|
                                                                                                                  M.alloc (|
                                                                                                                    α2
                                                                                                                  |),
                                                                                                                  [
                                                                                                                    fun
                                                                                                                        γ =>
                                                                                                                      ltac:(M.monadic
                                                                                                                        (M.read (|
                                                                                                                          M.SubPointer.get_array_field (|
                                                                                                                            M.read (|
                                                                                                                              advice_evals
                                                                                                                            |),
                                                                                                                            index
                                                                                                                          |)
                                                                                                                        |)))
                                                                                                                  ]
                                                                                                                |)))
                                                                                                          ]
                                                                                                        |)))
                                                                                                  ]
                                                                                                |)
                                                                                              | _ =>
                                                                                                M.impossible (||)
                                                                                              end))
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.closure
                                                                                          (fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              match
                                                                                                γ
                                                                                              with
                                                                                              | [
                                                                                                    α0;
                                                                                                    α1;
                                                                                                    α2
                                                                                                  ] =>
                                                                                                M.match_operator (|
                                                                                                  M.alloc (|
                                                                                                    α0
                                                                                                  |),
                                                                                                  [
                                                                                                    fun
                                                                                                        γ =>
                                                                                                      ltac:(M.monadic
                                                                                                        (let
                                                                                                              index :=
                                                                                                          M.copy (|
                                                                                                            γ
                                                                                                          |) in
                                                                                                        M.match_operator (|
                                                                                                          M.alloc (|
                                                                                                            α1
                                                                                                          |),
                                                                                                          [
                                                                                                            fun
                                                                                                                γ =>
                                                                                                              ltac:(M.monadic
                                                                                                                (M.match_operator (|
                                                                                                                  M.alloc (|
                                                                                                                    α2
                                                                                                                  |),
                                                                                                                  [
                                                                                                                    fun
                                                                                                                        γ =>
                                                                                                                      ltac:(M.monadic
                                                                                                                        (M.read (|
                                                                                                                          M.SubPointer.get_array_field (|
                                                                                                                            M.read (|
                                                                                                                              instance_evals
                                                                                                                            |),
                                                                                                                            index
                                                                                                                          |)
                                                                                                                        |)))
                                                                                                                  ]
                                                                                                                |)))
                                                                                                          ]
                                                                                                        |)))
                                                                                                  ]
                                                                                                |)
                                                                                              | _ =>
                                                                                                M.impossible (||)
                                                                                              end))
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.closure
                                                                                          (fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              match
                                                                                                γ
                                                                                              with
                                                                                              | [ α0
                                                                                                  ] =>
                                                                                                M.match_operator (|
                                                                                                  M.alloc (|
                                                                                                    α0
                                                                                                  |),
                                                                                                  [
                                                                                                    fun
                                                                                                        γ =>
                                                                                                      ltac:(M.monadic
                                                                                                        (let
                                                                                                              a :=
                                                                                                          M.copy (|
                                                                                                            γ
                                                                                                          |) in
                                                                                                        M.call_closure (|
                                                                                                          M.get_trait_method (|
                                                                                                            "core::ops::arith::Neg",
                                                                                                            Ty.associated,
                                                                                                            [],
                                                                                                            "neg",
                                                                                                            []
                                                                                                          |),
                                                                                                          [
                                                                                                            M.read (|
                                                                                                              a
                                                                                                            |)
                                                                                                          ]
                                                                                                        |)))
                                                                                                  ]
                                                                                                |)
                                                                                              | _ =>
                                                                                                M.impossible (||)
                                                                                              end))
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.closure
                                                                                          (fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              match
                                                                                                γ
                                                                                              with
                                                                                              | [
                                                                                                    α0;
                                                                                                    α1
                                                                                                  ] =>
                                                                                                M.match_operator (|
                                                                                                  M.alloc (|
                                                                                                    α0
                                                                                                  |),
                                                                                                  [
                                                                                                    fun
                                                                                                        γ =>
                                                                                                      ltac:(M.monadic
                                                                                                        (let
                                                                                                              a :=
                                                                                                          M.copy (|
                                                                                                            γ
                                                                                                          |) in
                                                                                                        M.match_operator (|
                                                                                                          M.alloc (|
                                                                                                            α1
                                                                                                          |),
                                                                                                          [
                                                                                                            fun
                                                                                                                γ =>
                                                                                                              ltac:(M.monadic
                                                                                                                (let
                                                                                                                      b :=
                                                                                                                  M.copy (|
                                                                                                                    γ
                                                                                                                  |) in
                                                                                                                M.call_closure (|
                                                                                                                  M.get_trait_method (|
                                                                                                                    "core::ops::arith::Add",
                                                                                                                    Ty.associated,
                                                                                                                    [
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "&")
                                                                                                                        [
                                                                                                                          Ty.associated
                                                                                                                        ]
                                                                                                                    ],
                                                                                                                    "add",
                                                                                                                    []
                                                                                                                  |),
                                                                                                                  [
                                                                                                                    M.read (|
                                                                                                                      a
                                                                                                                    |);
                                                                                                                    b
                                                                                                                  ]
                                                                                                                |)))
                                                                                                          ]
                                                                                                        |)))
                                                                                                  ]
                                                                                                |)
                                                                                              | _ =>
                                                                                                M.impossible (||)
                                                                                              end))
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.closure
                                                                                          (fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              match
                                                                                                γ
                                                                                              with
                                                                                              | [
                                                                                                    α0;
                                                                                                    α1
                                                                                                  ] =>
                                                                                                M.match_operator (|
                                                                                                  M.alloc (|
                                                                                                    α0
                                                                                                  |),
                                                                                                  [
                                                                                                    fun
                                                                                                        γ =>
                                                                                                      ltac:(M.monadic
                                                                                                        (let
                                                                                                              a :=
                                                                                                          M.copy (|
                                                                                                            γ
                                                                                                          |) in
                                                                                                        M.match_operator (|
                                                                                                          M.alloc (|
                                                                                                            α1
                                                                                                          |),
                                                                                                          [
                                                                                                            fun
                                                                                                                γ =>
                                                                                                              ltac:(M.monadic
                                                                                                                (let
                                                                                                                      b :=
                                                                                                                  M.copy (|
                                                                                                                    γ
                                                                                                                  |) in
                                                                                                                M.call_closure (|
                                                                                                                  M.get_trait_method (|
                                                                                                                    "core::ops::arith::Mul",
                                                                                                                    Ty.associated,
                                                                                                                    [
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "&")
                                                                                                                        [
                                                                                                                          Ty.associated
                                                                                                                        ]
                                                                                                                    ],
                                                                                                                    "mul",
                                                                                                                    []
                                                                                                                  |),
                                                                                                                  [
                                                                                                                    M.call_closure (|
                                                                                                                      M.get_trait_method (|
                                                                                                                        "core::ops::function::Fn",
                                                                                                                        Ty.dyn
                                                                                                                          [
                                                                                                                            ("core::ops::function::Fn::Trait",
                                                                                                                              [])
                                                                                                                          ],
                                                                                                                        [
                                                                                                                          Ty.tuple
                                                                                                                            []
                                                                                                                        ],
                                                                                                                        "call",
                                                                                                                        []
                                                                                                                      |),
                                                                                                                      [
                                                                                                                        M.read (|
                                                                                                                          a
                                                                                                                        |);
                                                                                                                        Value.Tuple
                                                                                                                          []
                                                                                                                      ]
                                                                                                                    |);
                                                                                                                    M.alloc (|
                                                                                                                      M.call_closure (|
                                                                                                                        M.get_trait_method (|
                                                                                                                          "core::ops::function::Fn",
                                                                                                                          Ty.dyn
                                                                                                                            [
                                                                                                                              ("core::ops::function::Fn::Trait",
                                                                                                                                [])
                                                                                                                            ],
                                                                                                                          [
                                                                                                                            Ty.tuple
                                                                                                                              []
                                                                                                                          ],
                                                                                                                          "call",
                                                                                                                          []
                                                                                                                        |),
                                                                                                                        [
                                                                                                                          M.read (|
                                                                                                                            b
                                                                                                                          |);
                                                                                                                          Value.Tuple
                                                                                                                            []
                                                                                                                        ]
                                                                                                                      |)
                                                                                                                    |)
                                                                                                                  ]
                                                                                                                |)))
                                                                                                          ]
                                                                                                        |)))
                                                                                                  ]
                                                                                                |)
                                                                                              | _ =>
                                                                                                M.impossible (||)
                                                                                              end))
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.closure
                                                                                          (fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              match
                                                                                                γ
                                                                                              with
                                                                                              | [
                                                                                                    α0;
                                                                                                    α1
                                                                                                  ] =>
                                                                                                M.match_operator (|
                                                                                                  M.alloc (|
                                                                                                    α0
                                                                                                  |),
                                                                                                  [
                                                                                                    fun
                                                                                                        γ =>
                                                                                                      ltac:(M.monadic
                                                                                                        (let
                                                                                                              a :=
                                                                                                          M.copy (|
                                                                                                            γ
                                                                                                          |) in
                                                                                                        M.match_operator (|
                                                                                                          M.alloc (|
                                                                                                            α1
                                                                                                          |),
                                                                                                          [
                                                                                                            fun
                                                                                                                γ =>
                                                                                                              ltac:(M.monadic
                                                                                                                (let
                                                                                                                      scalar :=
                                                                                                                  M.copy (|
                                                                                                                    γ
                                                                                                                  |) in
                                                                                                                M.call_closure (|
                                                                                                                  M.get_trait_method (|
                                                                                                                    "core::ops::arith::Mul",
                                                                                                                    Ty.associated,
                                                                                                                    [
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "&")
                                                                                                                        [
                                                                                                                          Ty.associated
                                                                                                                        ]
                                                                                                                    ],
                                                                                                                    "mul",
                                                                                                                    []
                                                                                                                  |),
                                                                                                                  [
                                                                                                                    M.read (|
                                                                                                                      a
                                                                                                                    |);
                                                                                                                    scalar
                                                                                                                  ]
                                                                                                                |)))
                                                                                                          ]
                                                                                                        |)))
                                                                                                  ]
                                                                                                |)
                                                                                              | _ =>
                                                                                                M.impossible (||)
                                                                                              end))
                                                                                      |)
                                                                                    ]
                                                                                  |)))
                                                                            ]
                                                                          |)
                                                                        | _ => M.impossible (||)
                                                                        end))
                                                                ]
                                                              |);
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "ff::Field",
                                                                  Ty.associated,
                                                                  [],
                                                                  "zero",
                                                                  []
                                                                |),
                                                                []
                                                              |);
                                                              M.closure
                                                                (fun γ =>
                                                                  ltac:(M.monadic
                                                                    match γ with
                                                                    | [ α0; α1 ] =>
                                                                      M.match_operator (|
                                                                        M.alloc (| α0 |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let acc :=
                                                                                M.copy (| γ |) in
                                                                              M.match_operator (|
                                                                                M.alloc (| α1 |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let eval :=
                                                                                        M.copy (|
                                                                                          γ
                                                                                        |) in
                                                                                      M.call_closure (|
                                                                                        M.get_trait_method (|
                                                                                          "core::ops::arith::Add",
                                                                                          Ty.associated,
                                                                                          [
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "&")
                                                                                              [
                                                                                                Ty.associated
                                                                                              ]
                                                                                          ],
                                                                                          "add",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            M.get_trait_method (|
                                                                                              "core::ops::arith::Mul",
                                                                                              Ty.associated,
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "&")
                                                                                                  [
                                                                                                    Ty.associated
                                                                                                  ]
                                                                                              ],
                                                                                              "mul",
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              M.read (|
                                                                                                acc
                                                                                              |);
                                                                                              M.call_closure (|
                                                                                                M.get_trait_method (|
                                                                                                  "core::ops::deref::Deref",
                                                                                                  Ty.apply
                                                                                                    (Ty.path
                                                                                                      "halo2_proofs::transcript::ChallengeScalar")
                                                                                                    [
                                                                                                      C;
                                                                                                      Ty.path
                                                                                                        "halo2_proofs::plonk::Theta"
                                                                                                    ],
                                                                                                  [],
                                                                                                  "deref",
                                                                                                  []
                                                                                                |),
                                                                                                [
                                                                                                  theta
                                                                                                ]
                                                                                              |)
                                                                                            ]
                                                                                          |);
                                                                                          eval
                                                                                        ]
                                                                                      |)))
                                                                                ]
                                                                              |)))
                                                                        ]
                                                                      |)
                                                                    | _ => M.impossible (||)
                                                                    end))
                                                            ]
                                                          |)))
                                                    ]
                                                  |)
                                                | _ => M.impossible (||)
                                                end))
                                        |) in
                                      let right :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.associated,
                                              [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                              "mul",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::arith::Mul",
                                                  Ty.associated,
                                                  [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                  "mul",
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                                      "product_eval"
                                                    |)
                                                  |);
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::arith::Add",
                                                        Ty.associated,
                                                        [ Ty.apply (Ty.path "&") [ Ty.associated ]
                                                        ],
                                                        "add",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::function::Fn",
                                                            Ty.function
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "slice")
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "halo2_proofs::plonk::circuit::Expression")
                                                                              [ Ty.associated ]
                                                                          ]
                                                                      ]
                                                                  ]
                                                              ]
                                                              Ty.associated,
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "halo2_proofs::plonk::circuit::Expression")
                                                                            [ Ty.associated ]
                                                                        ]
                                                                    ]
                                                                ]
                                                            ],
                                                            "call",
                                                            []
                                                          |),
                                                          [
                                                            compress_expressions;
                                                            Value.Tuple
                                                              [
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::deref::Deref",
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Expression")
                                                                          [ Ty.associated ];
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    [],
                                                                    "deref",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.SubPointer.get_struct_record_field (|
                                                                      M.read (| argument |),
                                                                      "halo2_proofs::plonk::lookup::Argument",
                                                                      "input_expressions"
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                          ]
                                                        |);
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::transcript::ChallengeScalar")
                                                              [
                                                                C;
                                                                Ty.path "halo2_proofs::plonk::Beta"
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ beta ]
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                ]
                                              |);
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Add",
                                                    Ty.associated,
                                                    [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                    "add",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::function::Fn",
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "halo2_proofs::plonk::circuit::Expression")
                                                                          [ Ty.associated ]
                                                                      ]
                                                                  ]
                                                              ]
                                                          ]
                                                          Ty.associated,
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "halo2_proofs::plonk::circuit::Expression")
                                                                        [ Ty.associated ]
                                                                    ]
                                                                ]
                                                            ]
                                                        ],
                                                        "call",
                                                        []
                                                      |),
                                                      [
                                                        compress_expressions;
                                                        Value.Tuple
                                                          [
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::deref::Deref",
                                                                Ty.apply
                                                                  (Ty.path "alloc::vec::Vec")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::circuit::Expression")
                                                                      [ Ty.associated ];
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                [],
                                                                "deref",
                                                                []
                                                              |),
                                                              [
                                                                M.SubPointer.get_struct_record_field (|
                                                                  M.read (| argument |),
                                                                  "halo2_proofs::plonk::lookup::Argument",
                                                                  "table_expressions"
                                                                |)
                                                              ]
                                                            |)
                                                          ]
                                                      ]
                                                    |);
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::deref::Deref",
                                                        Ty.apply
                                                          (Ty.path
                                                            "halo2_proofs::transcript::ChallengeScalar")
                                                          [ C; Ty.path "halo2_proofs::plonk::Gamma"
                                                          ],
                                                        [],
                                                        "deref",
                                                        []
                                                      |),
                                                      [ gamma ]
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::arith::Mul",
                                            Ty.associated,
                                            [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                            "mul",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::arith::Sub",
                                                Ty.associated,
                                                [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                "sub",
                                                []
                                              |),
                                              [ M.read (| left |); right ]
                                            |);
                                            active_rows
                                          ]
                                        |)
                                      |)
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::chain::Chain")
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::chain::Chain")
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::chain::Chain")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [ Ty.associated ];
                                      Ty.apply (Ty.path "core::option::IntoIter") [ Ty.associated ]
                                    ];
                                  Ty.apply (Ty.path "core::option::IntoIter") [ Ty.associated ]
                                ];
                              Ty.apply (Ty.path "core::option::IntoIter") [ Ty.associated ]
                            ];
                          Ty.apply (Ty.path "core::option::IntoIter") [ Ty.associated ]
                        ],
                      [],
                      "chain",
                      [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::chain::Chain")
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::chain::Chain")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [ Ty.associated ];
                                      Ty.apply (Ty.path "core::option::IntoIter") [ Ty.associated ]
                                    ];
                                  Ty.apply (Ty.path "core::option::IntoIter") [ Ty.associated ]
                                ];
                              Ty.apply (Ty.path "core::option::IntoIter") [ Ty.associated ]
                            ],
                          [],
                          "chain",
                          [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::chain::Chain")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [ Ty.associated ];
                                      Ty.apply (Ty.path "core::option::IntoIter") [ Ty.associated ]
                                    ];
                                  Ty.apply (Ty.path "core::option::IntoIter") [ Ty.associated ]
                                ],
                              [],
                              "chain",
                              [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [ Ty.associated ];
                                      Ty.apply (Ty.path "core::option::IntoIter") [ Ty.associated ]
                                    ],
                                  [],
                                  "chain",
                                  [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ] ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [ Ty.associated ],
                                      [],
                                      "chain",
                                      [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ]
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_function (|
                                          "core::iter::sources::empty::empty",
                                          [ Ty.associated ]
                                        |),
                                        []
                                      |);
                                      Value.StructTuple
                                        "core::option::Option::Some"
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.associated,
                                              [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                              "mul",
                                              []
                                            |),
                                            [
                                              M.read (| l_0 |);
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Sub",
                                                    Ty.associated,
                                                    [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                    "sub",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "ff::Field",
                                                        Ty.associated,
                                                        [],
                                                        "one",
                                                        []
                                                      |),
                                                      []
                                                    |);
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                                      "product_eval"
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    ]
                                  |);
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::arith::Mul",
                                          Ty.associated,
                                          [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                          "mul",
                                          []
                                        |),
                                        [
                                          M.read (| l_last |);
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::arith::Sub",
                                                Ty.associated,
                                                [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                "sub",
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "ff::Field",
                                                    Ty.associated,
                                                    [],
                                                    "square",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                                      "product_eval"
                                                    |)
                                                  ]
                                                |);
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                                  "product_eval"
                                                |)
                                              ]
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                ]
                              |);
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::function::Fn",
                                      Ty.function [ Ty.tuple [] ] Ty.associated,
                                      [ Ty.tuple [] ],
                                      "call",
                                      []
                                    |),
                                    [ product_expression; Value.Tuple [] ]
                                  |)
                                ]
                            ]
                          |);
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::arith::Mul",
                                  Ty.associated,
                                  [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                  "mul",
                                  []
                                |),
                                [
                                  M.read (| l_0 |);
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::arith::Sub",
                                        Ty.associated,
                                        [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                        "sub",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                            "permuted_input_eval"
                                          |)
                                        |);
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                          "permuted_table_eval"
                                        |)
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        ]
                      |);
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              Ty.associated,
                              [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                              "mul",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::arith::Mul",
                                  Ty.associated,
                                  [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                  "mul",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::arith::Sub",
                                      Ty.associated,
                                      [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                      "sub",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                          "permuted_input_eval"
                                        |)
                                      |);
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                        "permuted_table_eval"
                                      |)
                                    ]
                                  |);
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::arith::Sub",
                                        Ty.associated,
                                        [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                        "sub",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                            "permuted_input_eval"
                                          |)
                                        |);
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                          "permuted_input_inv_eval"
                                        |)
                                      ]
                                    |)
                                  |)
                                ]
                              |);
                              active_rows
                            ]
                          |)
                        ]
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_expressions :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "expressions" (expressions C).
        
        (*
            pub(in crate::plonk) fn queries<'r>(
                &'r self,
                vk: &'r VerifyingKey<C>,
                x: ChallengeX<C>,
            ) -> impl Iterator<Item = VerifierQuery<'r, C>> + Clone {
                let x_inv = vk.domain.rotate_omega( *x, Rotation::prev());
                let x_next = vk.domain.rotate_omega( *x, Rotation::next());
        
                iter::empty()
                    // Open lookup product commitment at x
                    .chain(Some(VerifierQuery::new_commitment(
                        &self.committed.product_commitment,
                        *x,
                        Rotation::cur(),
                        self.product_eval,
                    )))
                    // Open lookup input commitments at x
                    .chain(Some(VerifierQuery::new_commitment(
                        &self.committed.permuted.permuted_input_commitment,
                        *x,
                        Rotation::cur(),
                        self.permuted_input_eval,
                    )))
                    // Open lookup table commitments at x
                    .chain(Some(VerifierQuery::new_commitment(
                        &self.committed.permuted.permuted_table_commitment,
                        *x,
                        Rotation::cur(),
                        self.permuted_table_eval,
                    )))
                    // Open lookup input commitments at \omega^{-1} x
                    .chain(Some(VerifierQuery::new_commitment(
                        &self.committed.permuted.permuted_input_commitment,
                        x_inv,
                        Rotation::prev(),
                        self.permuted_input_inv_eval,
                    )))
                    // Open lookup product commitment at \omega x
                    .chain(Some(VerifierQuery::new_commitment(
                        &self.committed.product_commitment,
                        x_next,
                        Rotation::next(),
                        self.product_next_eval,
                    )))
            }
        *)
        Definition queries (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [], [ self; vk; x ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let vk := M.alloc (| vk |) in
              let x := M.alloc (| x |) in
              M.read (|
                let x_inv :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "halo2_proofs::poly::domain::EvaluationDomain")
                          [ Ty.associated ],
                        "rotate_omega",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| vk |),
                          "halo2_proofs::plonk::VerifyingKey",
                          "domain"
                        |);
                        M.read (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "halo2_proofs::transcript::ChallengeScalar")
                                [ C; Ty.path "halo2_proofs::plonk::X" ],
                              [],
                              "deref",
                              []
                            |),
                            [ x ]
                          |)
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "halo2_proofs::poly::Rotation",
                            "prev",
                            []
                          |),
                          []
                        |)
                      ]
                    |)
                  |) in
                let x_next :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "halo2_proofs::poly::domain::EvaluationDomain")
                          [ Ty.associated ],
                        "rotate_omega",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| vk |),
                          "halo2_proofs::plonk::VerifyingKey",
                          "domain"
                        |);
                        M.read (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "halo2_proofs::transcript::ChallengeScalar")
                                [ C; Ty.path "halo2_proofs::plonk::X" ],
                              [],
                              "deref",
                              []
                            |),
                            [ x ]
                          |)
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "halo2_proofs::poly::Rotation",
                            "next",
                            []
                          |),
                          []
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::chain::Chain")
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::chain::Chain")
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::chain::Chain")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                            [ C ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::option::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                            [ C ]
                                        ]
                                    ];
                                  Ty.apply
                                    (Ty.path "core::option::IntoIter")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                        [ C ]
                                    ]
                                ];
                              Ty.apply
                                (Ty.path "core::option::IntoIter")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                    [ C ]
                                ]
                            ];
                          Ty.apply
                            (Ty.path "core::option::IntoIter")
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                [ C ]
                            ]
                        ],
                      [],
                      "chain",
                      [
                        Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ]
                          ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::chain::Chain")
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::chain::Chain")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                            [ C ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::option::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                            [ C ]
                                        ]
                                    ];
                                  Ty.apply
                                    (Ty.path "core::option::IntoIter")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                        [ C ]
                                    ]
                                ];
                              Ty.apply
                                (Ty.path "core::option::IntoIter")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                    [ C ]
                                ]
                            ],
                          [],
                          "chain",
                          [
                            Ty.apply
                              (Ty.path "core::option::Option")
                              [
                                Ty.apply
                                  (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                  [ C ]
                              ]
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::chain::Chain")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                            [ C ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::option::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                            [ C ]
                                        ]
                                    ];
                                  Ty.apply
                                    (Ty.path "core::option::IntoIter")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                        [ C ]
                                    ]
                                ],
                              [],
                              "chain",
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                      [ C ]
                                  ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::chain::Chain")
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                            [ C ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::option::IntoIter")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                            [ C ]
                                        ]
                                    ],
                                  [],
                                  "chain",
                                  [
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                          [ C ]
                                      ]
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::sources::empty::Empty")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                            [ C ]
                                        ],
                                      [],
                                      "chain",
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "halo2_proofs::poly::multiopen::VerifierQuery")
                                              [ C ]
                                          ]
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_function (|
                                          "core::iter::sources::empty::empty",
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "halo2_proofs::poly::multiopen::VerifierQuery")
                                              [ C ]
                                          ]
                                        |),
                                        []
                                      |);
                                      Value.StructTuple
                                        "core::option::Option::Some"
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "halo2_proofs::poly::multiopen::VerifierQuery")
                                                [ C ],
                                              "new_commitment",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                                  "committed"
                                                |),
                                                "halo2_proofs::plonk::lookup::verifier::Committed",
                                                "product_commitment"
                                              |);
                                              M.read (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::transcript::ChallengeScalar")
                                                      [ C; Ty.path "halo2_proofs::plonk::X" ],
                                                    [],
                                                    "deref",
                                                    []
                                                  |),
                                                  [ x ]
                                                |)
                                              |);
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "halo2_proofs::poly::Rotation",
                                                  "cur",
                                                  []
                                                |),
                                                []
                                              |);
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                                  "product_eval"
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    ]
                                  |);
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                            [ C ],
                                          "new_commitment",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                                "committed"
                                              |),
                                              "halo2_proofs::plonk::lookup::verifier::Committed",
                                              "permuted"
                                            |),
                                            "halo2_proofs::plonk::lookup::verifier::PermutationCommitments",
                                            "permuted_input_commitment"
                                          |);
                                          M.read (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::transcript::ChallengeScalar")
                                                  [ C; Ty.path "halo2_proofs::plonk::X" ],
                                                [],
                                                "deref",
                                                []
                                              |),
                                              [ x ]
                                            |)
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "halo2_proofs::poly::Rotation",
                                              "cur",
                                              []
                                            |),
                                            []
                                          |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                              "permuted_input_eval"
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                ]
                              |);
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                        [ C ],
                                      "new_commitment",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                            "committed"
                                          |),
                                          "halo2_proofs::plonk::lookup::verifier::Committed",
                                          "permuted"
                                        |),
                                        "halo2_proofs::plonk::lookup::verifier::PermutationCommitments",
                                        "permuted_table_commitment"
                                      |);
                                      M.read (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "halo2_proofs::transcript::ChallengeScalar")
                                              [ C; Ty.path "halo2_proofs::plonk::X" ],
                                            [],
                                            "deref",
                                            []
                                          |),
                                          [ x ]
                                        |)
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "halo2_proofs::poly::Rotation",
                                          "cur",
                                          []
                                        |),
                                        []
                                      |);
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                          "permuted_table_eval"
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                            ]
                          |);
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                    [ C ],
                                  "new_commitment",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                        "committed"
                                      |),
                                      "halo2_proofs::plonk::lookup::verifier::Committed",
                                      "permuted"
                                    |),
                                    "halo2_proofs::plonk::lookup::verifier::PermutationCommitments",
                                    "permuted_input_commitment"
                                  |);
                                  M.read (| x_inv |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "halo2_proofs::poly::Rotation",
                                      "prev",
                                      []
                                    |),
                                    []
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                      "permuted_input_inv_eval"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        ]
                      |);
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                [ C ],
                              "new_commitment",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                  "committed"
                                |),
                                "halo2_proofs::plonk::lookup::verifier::Committed",
                                "product_commitment"
                              |);
                              M.read (| x_next |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "halo2_proofs::poly::Rotation",
                                  "next",
                                  []
                                |),
                                []
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::plonk::lookup::verifier::Evaluated",
                                  "product_next_eval"
                                |)
                              |)
                            ]
                          |)
                        ]
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_queries :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "queries" (queries C).
      End Impl_halo2_proofs_plonk_lookup_verifier_Evaluated_C.
    End verifier.
  End lookup.
End plonk.
