(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module plonk.
  Module permutation.
    (* StructRecord
      {
        name := "Argument";
        ty_params := [];
        fields :=
          [
            ("columns",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_for_halo2_proofs_plonk_permutation_Argument.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::permutation::Argument".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Argument" |);
                M.read (| Value.String "columns" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::permutation::Argument",
                      "columns"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_halo2_proofs_plonk_permutation_Argument.
    
    Module Impl_core_clone_Clone_for_halo2_proofs_plonk_permutation_Argument.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::permutation::Argument".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::plonk::permutation::Argument"
              [
                ("columns",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::permutation::Argument",
                        "columns"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_halo2_proofs_plonk_permutation_Argument.
    
    Module Impl_halo2_proofs_plonk_permutation_Argument.
      Definition Self : Ty.t := Ty.path "halo2_proofs::plonk::permutation::Argument".
      
      (*
          pub(crate) fn new() -> Self {
              Argument { columns: vec![] }
          }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "halo2_proofs::plonk::permutation::Argument"
              [
                ("columns",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                            [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
          pub(crate) fn required_degree(&self) -> usize {
              // degree 2:
              // l_0(X) * (1 - z(X)) = 0
              //
              // We will fit as many polynomials p_i(X) as possible
              // into the required degree of the circuit, so the
              // following will not affect the required degree of
              // this middleware.
              //
              // (1 - (l_last(X) + l_blind(X))) * (
              //   z(\omega X) \prod (p(X) + \beta s_i(X) + \gamma)
              // - z(X) \prod (p(X) + \delta^i \beta X + \gamma)
              // )
              //
              // On the first sets of columns, except the first
              // set, we will do
              //
              // l_0(X) * (z(X) - z'(\omega^(last) X)) = 0
              //
              // where z'(X) is the permutation for the previous set
              // of columns.
              //
              // On the final set of columns, we will do
              //
              // degree 3:
              // l_last(X) * (z'(X)^2 - z'(X)) = 0
              //
              // which will allow the last value to be zero to
              // ensure the argument is perfectly complete.
      
              // There are constraints of degree 3 regardless of the
              // number of columns involved.
              3
          }
      *)
      Definition required_degree (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Integer 3))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_required_degree :
        M.IsAssociatedFunction Self "required_degree" required_degree.
      
      (*
          pub(crate) fn add_column(&mut self, column: Column<Any>) {
              if !self.columns.contains(&column) {
                  self.columns.push(column);
              }
          }
      *)
      Definition add_column (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; column ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let column := M.alloc (| column |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::circuit::Column")
                                        [ Ty.path "halo2_proofs::plonk::circuit::Any" ]
                                    ],
                                  "contains",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::circuit::Column")
                                            [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "halo2_proofs::plonk::permutation::Argument",
                                        "columns"
                                      |)
                                    ]
                                  |);
                                  column
                                ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::circuit::Column")
                                    [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "push",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::permutation::Argument",
                                "columns"
                              |);
                              M.read (| column |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_add_column : M.IsAssociatedFunction Self "add_column" add_column.
      
      (*
          pub(crate) fn get_columns(&self) -> Vec<Column<Any>> {
              self.columns.clone()
          }
      *)
      Definition get_columns (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::clone::Clone",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.apply
                      (Ty.path "halo2_proofs::plonk::circuit::Column")
                      [ Ty.path "halo2_proofs::plonk::circuit::Any" ];
                    Ty.path "alloc::alloc::Global"
                  ],
                [],
                "clone",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::plonk::permutation::Argument",
                  "columns"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_columns : M.IsAssociatedFunction Self "get_columns" get_columns.
    End Impl_halo2_proofs_plonk_permutation_Argument.
    
    (* StructRecord
      {
        name := "VerifyingKey";
        ty_params := [ "C" ];
        fields :=
          [
            ("commitments",
              Ty.apply (Ty.path "alloc::vec::Vec") [ C; Ty.path "alloc::alloc::Global" ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_plonk_permutation_VerifyingKey_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::permutation::VerifyingKey") [ C ].
      
      (* Debug *)
      Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "VerifyingKey" |);
                M.read (| Value.String "commitments" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::permutation::VerifyingKey",
                      "commitments"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_plonk_permutation_VerifyingKey_C.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_plonk_permutation_VerifyingKey_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::permutation::VerifyingKey") [ C ].
      
      (* Clone *)
      Definition clone (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::plonk::permutation::VerifyingKey"
              [
                ("commitments",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "alloc::vec::Vec") [ C; Ty.path "alloc::alloc::Global" ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::plonk::permutation::VerifyingKey",
                        "commitments"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone C)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_plonk_permutation_VerifyingKey_C.
    
    Module Impl_halo2_proofs_plonk_permutation_VerifyingKey_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::permutation::VerifyingKey") [ C ].
      
      (*
          pub fn write<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
              for commitment in &self.commitments {
                  writer.write_all(commitment.to_bytes().as_ref())?;
              }
      
              Ok(())
          }
      *)
      Definition write (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [ W ], [ self; writer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let writer := M.alloc (| writer |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.use
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "&")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ C; Ty.path "alloc::alloc::Global" ]
                                ],
                              [],
                              "into_iter",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::permutation::VerifyingKey",
                                "commitments"
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                ltac:(M.monadic
                                  (let _ :=
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply (Ty.path "core::slice::iter::Iter") [ C ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let commitment := M.copy (| γ0_0 |) in
                                            let _ :=
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.tuple [];
                                                          Ty.path "std::io::error::Error"
                                                        ],
                                                      [],
                                                      "branch",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "std::io::Write",
                                                          W,
                                                          [],
                                                          "write_all",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| writer |);
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::convert::AsRef",
                                                              Ty.associated,
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  [ Ty.path "u8" ]
                                                              ],
                                                              "as_ref",
                                                              []
                                                            |),
                                                            [
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "group::GroupEncoding",
                                                                    C,
                                                                    [],
                                                                    "to_bytes",
                                                                    []
                                                                  |),
                                                                  [ M.read (| commitment |) ]
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.tuple [];
                                                                      Ty.path
                                                                        "std::io::error::Error"
                                                                    ],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible";
                                                                        Ty.path
                                                                          "std::io::error::Error"
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |)) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_write :
        forall (C : Ty.t),
        M.IsAssociatedFunction (Self C) "write" (write C).
      
      (*
          pub fn read<R: io::Read>(reader: &mut R, argument: &Argument) -> io::Result<Self> {
              let commitments = (0..argument.columns.len())
                  .map(|_| C::read(reader))
                  .collect::<Result<Vec<_>, _>>()?;
              Ok(VerifyingKey { commitments })
          }
      *)
      Definition read (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [ R ], [ reader; argument ] =>
          ltac:(M.monadic
            (let reader := M.alloc (| reader |) in
            let argument := M.alloc (| argument |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let commitments :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ C; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "std::io::error::Error"
                                ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        [ Ty.path "usize" ];
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ C; Ty.path "std::io::error::Error" ])
                                    ],
                                  [],
                                  "collect",
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ C; Ty.path "alloc::alloc::Global" ];
                                        Ty.path "std::io::error::Error"
                                      ]
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        [ Ty.path "usize" ],
                                      [],
                                      "map",
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ C; Ty.path "std::io::error::Error" ];
                                        Ty.function
                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                          (Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ C; Ty.path "std::io::error::Error" ])
                                      ]
                                    |),
                                    [
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [
                                          ("start", Value.Integer 0);
                                          ("end_",
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "halo2_proofs::plonk::circuit::Column")
                                                      [ Ty.path "halo2_proofs::plonk::circuit::Any"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                "len",
                                                []
                                              |),
                                              [
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| argument |),
                                                  "halo2_proofs::plonk::permutation::Argument",
                                                  "columns"
                                                |)
                                              ]
                                            |))
                                        ];
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.call_closure (|
                                                        M.get_trait_method (|
                                                          "halo2_proofs::helpers::CurveRead",
                                                          C,
                                                          [],
                                                          "read",
                                                          [ R ]
                                                        |),
                                                        [ M.read (| reader |) ]
                                                      |)))
                                                ]
                                              |)
                                            | _ => M.impossible (||)
                                            end))
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "halo2_proofs::plonk::permutation::VerifyingKey")
                                                [ C ];
                                              Ty.path "std::io::error::Error"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "std::io::error::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [
                        Value.StructRecord
                          "halo2_proofs::plonk::permutation::VerifyingKey"
                          [ ("commitments", M.read (| commitments |)) ]
                      ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_read :
        forall (C : Ty.t),
        M.IsAssociatedFunction (Self C) "read" (read C).
    End Impl_halo2_proofs_plonk_permutation_VerifyingKey_C.
    
    (* StructRecord
      {
        name := "ProvingKey";
        ty_params := [ "C" ];
        fields :=
          [
            ("permutations",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::poly::Polynomial")
                    [ Ty.associated; Ty.path "halo2_proofs::poly::LagrangeCoeff" ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("polys",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::poly::Polynomial")
                    [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("cosets",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::poly::Polynomial")
                    [ Ty.associated; Ty.path "halo2_proofs::poly::ExtendedLagrangeCoeff" ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_plonk_permutation_ProvingKey_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::plonk::permutation::ProvingKey") [ C ].
      
      (* Debug *)
      Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "ProvingKey" |);
                M.read (| Value.String "permutations" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::permutation::ProvingKey",
                    "permutations"
                  |));
                M.read (| Value.String "polys" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::plonk::permutation::ProvingKey",
                    "polys"
                  |));
                M.read (| Value.String "cosets" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::plonk::permutation::ProvingKey",
                      "cosets"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_plonk_permutation_ProvingKey_C.
  End permutation.
End plonk.
