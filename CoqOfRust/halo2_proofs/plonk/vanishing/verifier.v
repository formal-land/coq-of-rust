(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module plonk.
  Module vanishing.
    Module verifier.
      (* StructRecord
        {
          name := "Committed";
          ty_params := [ "C" ];
          fields := [ ("random_poly_commitment", C) ];
        } *)
      
      (* StructRecord
        {
          name := "Constructed";
          ty_params := [ "C" ];
          fields :=
            [
              ("h_commitments",
                Ty.apply (Ty.path "alloc::vec::Vec") [ C; Ty.path "alloc::alloc::Global" ]);
              ("random_poly_commitment", C)
            ];
        } *)
      
      (* StructRecord
        {
          name := "PartiallyEvaluated";
          ty_params := [ "C" ];
          fields :=
            [
              ("h_commitments",
                Ty.apply (Ty.path "alloc::vec::Vec") [ C; Ty.path "alloc::alloc::Global" ]);
              ("random_poly_commitment", C);
              ("random_eval", Ty.associated)
            ];
        } *)
      
      (* StructRecord
        {
          name := "Evaluated";
          ty_params := [ "C" ];
          fields :=
            [
              ("h_commitment", Ty.apply (Ty.path "halo2_proofs::poly::msm::MSM") [ C ]);
              ("random_poly_commitment", C);
              ("expected_h_eval", Ty.associated);
              ("random_eval", Ty.associated)
            ];
        } *)
      
      Module Impl_halo2_proofs_plonk_vanishing_Argument_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::vanishing::Argument") [ C ].
        
        (*
            pub(in crate::plonk) fn read_commitments_before_y<
                E: EncodedChallenge<C>,
                T: TranscriptRead<C, E>,
            >(
                transcript: &mut T,
            ) -> Result<Committed<C>, Error> {
                let random_poly_commitment = transcript.read_point()?;
        
                Ok(Committed {
                    random_poly_commitment,
                })
            }
        *)
        Definition read_commitments_before_y (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [ E; T ], [ transcript ] =>
            ltac:(M.monadic
              (let transcript := M.alloc (| transcript |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let random_poly_commitment :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ C; Ty.path "std::io::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_point",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::vanishing::verifier::Committed")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "halo2_proofs::plonk::vanishing::verifier::Committed"
                            [ ("random_poly_commitment", M.read (| random_poly_commitment |)) ]
                        ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_read_commitments_before_y :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "read_commitments_before_y" (read_commitments_before_y C).
      End Impl_halo2_proofs_plonk_vanishing_Argument_C.
      
      Module Impl_halo2_proofs_plonk_vanishing_verifier_Committed_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::vanishing::verifier::Committed") [ C ].
        
        (*
            pub(in crate::plonk) fn read_commitments_after_y<
                E: EncodedChallenge<C>,
                T: TranscriptRead<C, E>,
            >(
                self,
                vk: &VerifyingKey<C>,
                transcript: &mut T,
            ) -> Result<Constructed<C>, Error> {
                // Obtain a commitment to h(X) in the form of multiple pieces of degree n - 1
                let h_commitments = read_n_points(transcript, vk.domain.get_quotient_poly_degree())?;
        
                Ok(Constructed {
                    h_commitments,
                    random_poly_commitment: self.random_poly_commitment,
                })
            }
        *)
        Definition read_commitments_after_y (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [ E; T ], [ self; vk; transcript ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let vk := M.alloc (| vk |) in
              let transcript := M.alloc (| transcript |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let h_commitments :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [ C; Ty.path "alloc::alloc::Global" ];
                                    Ty.path "std::io::error::Error"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_function (|
                                    "halo2_proofs::transcript::read_n_points",
                                    [ C; E; T ]
                                  |),
                                  [
                                    M.read (| transcript |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "halo2_proofs::poly::domain::EvaluationDomain")
                                          [ Ty.associated ],
                                        "get_quotient_poly_degree",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| vk |),
                                          "halo2_proofs::plonk::VerifyingKey",
                                          "domain"
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::vanishing::verifier::Constructed")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "halo2_proofs::plonk::vanishing::verifier::Constructed"
                            [
                              ("h_commitments", M.read (| h_commitments |));
                              ("random_poly_commitment",
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "halo2_proofs::plonk::vanishing::verifier::Committed",
                                    "random_poly_commitment"
                                  |)
                                |))
                            ]
                        ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_read_commitments_after_y :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "read_commitments_after_y" (read_commitments_after_y C).
      End Impl_halo2_proofs_plonk_vanishing_verifier_Committed_C.
      
      Module Impl_halo2_proofs_plonk_vanishing_verifier_Constructed_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::vanishing::verifier::Constructed") [ C ].
        
        (*
            pub(in crate::plonk) fn evaluate_after_x<E: EncodedChallenge<C>, T: TranscriptRead<C, E>>(
                self,
                transcript: &mut T,
            ) -> Result<PartiallyEvaluated<C>, Error> {
                let random_eval = transcript.read_scalar()?;
        
                Ok(PartiallyEvaluated {
                    h_commitments: self.h_commitments,
                    random_poly_commitment: self.random_poly_commitment,
                    random_eval,
                })
            }
        *)
        Definition evaluate_after_x (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [ E; T ], [ self; transcript ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let transcript := M.alloc (| transcript |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let random_eval :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.associated; Ty.path "std::io::error::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_scalar",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "halo2_proofs::plonk::vanishing::verifier::PartiallyEvaluated")
                                                  [ C ];
                                                Ty.path "halo2_proofs::plonk::error::Error"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "std::io::error::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "halo2_proofs::plonk::vanishing::verifier::PartiallyEvaluated"
                            [
                              ("h_commitments",
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "halo2_proofs::plonk::vanishing::verifier::Constructed",
                                    "h_commitments"
                                  |)
                                |));
                              ("random_poly_commitment",
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "halo2_proofs::plonk::vanishing::verifier::Constructed",
                                    "random_poly_commitment"
                                  |)
                                |));
                              ("random_eval", M.read (| random_eval |))
                            ]
                        ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_evaluate_after_x :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "evaluate_after_x" (evaluate_after_x C).
      End Impl_halo2_proofs_plonk_vanishing_verifier_Constructed_C.
      
      Module Impl_halo2_proofs_plonk_vanishing_verifier_PartiallyEvaluated_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::vanishing::verifier::PartiallyEvaluated") [ C ].
        
        (*
            pub(in crate::plonk) fn verify(
                self,
                expressions: impl Iterator<Item = C::Scalar>,
                y: ChallengeY<C>,
                xn: C::Scalar,
            ) -> Evaluated<C> {
                let expected_h_eval = expressions.fold(C::Scalar::zero(), |h_eval, v| h_eval * &*y + &v);
                let expected_h_eval = expected_h_eval * ((xn - C::Scalar::one()).invert().unwrap());
        
                let h_commitment =
                    self.h_commitments
                        .iter()
                        .rev()
                        .fold(MSM::new(), |mut acc, commitment| {
                            acc.scale(xn);
                            acc.append_term(C::Scalar::one(), *commitment);
                            acc
                        });
        
                Evaluated {
                    expected_h_eval,
                    h_commitment,
                    random_poly_commitment: self.random_poly_commitment,
                    random_eval: self.random_eval,
                }
            }
        *)
        Definition verify (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [ impl_Iterator_Item___C_Scalar_ ], [ self; expressions; y; xn ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let expressions := M.alloc (| expressions |) in
              let y := M.alloc (| y |) in
              let xn := M.alloc (| xn |) in
              M.read (|
                let expected_h_eval :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        impl_Iterator_Item___C_Scalar_,
                        [],
                        "fold",
                        [
                          Ty.associated;
                          Ty.function [ Ty.tuple [ Ty.associated; Ty.associated ] ] Ty.associated
                        ]
                      |),
                      [
                        M.read (| expressions |);
                        M.call_closure (|
                          M.get_trait_method (| "ff::Field", Ty.associated, [], "zero", [] |),
                          []
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0; α1 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let h_eval := M.copy (| γ |) in
                                        M.match_operator (|
                                          M.alloc (| α1 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let v := M.copy (| γ |) in
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Add",
                                                    Ty.associated,
                                                    [ Ty.apply (Ty.path "&") [ Ty.associated ] ],
                                                    "add",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::arith::Mul",
                                                        Ty.associated,
                                                        [ Ty.apply (Ty.path "&") [ Ty.associated ]
                                                        ],
                                                        "mul",
                                                        []
                                                      |),
                                                      [
                                                        M.read (| h_eval |);
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::transcript::ChallengeScalar")
                                                              [ C; Ty.path "halo2_proofs::plonk::Y"
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ y ]
                                                        |)
                                                      ]
                                                    |);
                                                    v
                                                  ]
                                                |)))
                                          ]
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  |) in
                let expected_h_eval :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.associated,
                        [ Ty.associated ],
                        "mul",
                        []
                      |),
                      [
                        M.read (| expected_h_eval |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "subtle::CtOption") [ Ty.associated ],
                            "unwrap",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (| "ff::Field", Ty.associated, [], "invert", [] |),
                              [
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::arith::Sub",
                                      Ty.associated,
                                      [ Ty.associated ],
                                      "sub",
                                      []
                                    |),
                                    [
                                      M.read (| xn |);
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "ff::Field",
                                          Ty.associated,
                                          [],
                                          "one",
                                          []
                                        |),
                                        []
                                      |)
                                    ]
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let h_commitment :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::rev::Rev")
                          [ Ty.apply (Ty.path "core::slice::iter::Iter") [ C ] ],
                        [],
                        "fold",
                        [
                          Ty.apply (Ty.path "halo2_proofs::poly::msm::MSM") [ C ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply (Ty.path "halo2_proofs::poly::msm::MSM") [ C ];
                                  Ty.apply (Ty.path "&") [ C ]
                                ]
                            ]
                            (Ty.apply (Ty.path "halo2_proofs::poly::msm::MSM") [ C ])
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::slice::iter::Iter") [ C ],
                            [],
                            "rev",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ C ],
                                "iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [ C; Ty.path "alloc::alloc::Global" ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "halo2_proofs::plonk::vanishing::verifier::PartiallyEvaluated",
                                      "h_commitments"
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "halo2_proofs::poly::msm::MSM") [ C ],
                            "new",
                            []
                          |),
                          []
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0; α1 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let acc := M.copy (| γ |) in
                                        M.match_operator (|
                                          M.alloc (| α1 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let commitment := M.copy (| γ |) in
                                                M.read (|
                                                  let _ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "halo2_proofs::poly::msm::MSM")
                                                            [ C ],
                                                          "scale",
                                                          []
                                                        |),
                                                        [ acc; M.read (| xn |) ]
                                                      |)
                                                    |) in
                                                  let _ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "halo2_proofs::poly::msm::MSM")
                                                            [ C ],
                                                          "append_term",
                                                          []
                                                        |),
                                                        [
                                                          acc;
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "ff::Field",
                                                              Ty.associated,
                                                              [],
                                                              "one",
                                                              []
                                                            |),
                                                            []
                                                          |);
                                                          M.read (| M.read (| commitment |) |)
                                                        ]
                                                      |)
                                                    |) in
                                                  acc
                                                |)))
                                          ]
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "halo2_proofs::plonk::vanishing::verifier::Evaluated"
                    [
                      ("expected_h_eval", M.read (| expected_h_eval |));
                      ("h_commitment", M.read (| h_commitment |));
                      ("random_poly_commitment",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "halo2_proofs::plonk::vanishing::verifier::PartiallyEvaluated",
                            "random_poly_commitment"
                          |)
                        |));
                      ("random_eval",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "halo2_proofs::plonk::vanishing::verifier::PartiallyEvaluated",
                            "random_eval"
                          |)
                        |))
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_verify :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "verify" (verify C).
      End Impl_halo2_proofs_plonk_vanishing_verifier_PartiallyEvaluated_C.
      
      Module Impl_halo2_proofs_plonk_vanishing_verifier_Evaluated_C.
        Definition Self (C : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::plonk::vanishing::verifier::Evaluated") [ C ].
        
        (*
            pub(in crate::plonk) fn queries<'r>(
                &'r self,
                x: ChallengeX<C>,
            ) -> impl Iterator<Item = VerifierQuery<'r, C>> + Clone
            where
                'params: 'r,
            {
                iter::empty()
                    .chain(Some(VerifierQuery::new_msm(
                        &self.h_commitment,
                        *x,
                        Rotation::cur(),
                        self.expected_h_eval,
                    )))
                    .chain(Some(VerifierQuery::new_commitment(
                        &self.random_poly_commitment,
                        *x,
                        Rotation::cur(),
                        self.random_eval,
                    )))
            }
        *)
        Definition queries (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self C in
          match τ, α with
          | [], [ self; x ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let x := M.alloc (| x |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::chain::Chain")
                    [
                      Ty.apply
                        (Ty.path "core::iter::sources::empty::Empty")
                        [ Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ] ];
                      Ty.apply
                        (Ty.path "core::option::IntoIter")
                        [ Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ] ]
                    ],
                  [],
                  "chain",
                  [
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ] ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::sources::empty::Empty")
                        [ Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ] ],
                      [],
                      "chain",
                      [
                        Ty.apply
                          (Ty.path "core::option::Option")
                          [ Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ]
                          ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_function (|
                          "core::iter::sources::empty::empty",
                          [ Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ]
                          ]
                        |),
                        []
                      |);
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery")
                                [ C ],
                              "new_msm",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::plonk::vanishing::verifier::Evaluated",
                                "h_commitment"
                              |);
                              M.read (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "halo2_proofs::transcript::ChallengeScalar")
                                      [ C; Ty.path "halo2_proofs::plonk::X" ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [ x ]
                                |)
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "halo2_proofs::poly::Rotation",
                                  "cur",
                                  []
                                |),
                                []
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::plonk::vanishing::verifier::Evaluated",
                                  "expected_h_eval"
                                |)
                              |)
                            ]
                          |)
                        ]
                    ]
                  |);
                  Value.StructTuple
                    "core::option::Option::Some"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ],
                          "new_commitment",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "halo2_proofs::plonk::vanishing::verifier::Evaluated",
                            "random_poly_commitment"
                          |);
                          M.read (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "halo2_proofs::transcript::ChallengeScalar")
                                  [ C; Ty.path "halo2_proofs::plonk::X" ],
                                [],
                                "deref",
                                []
                              |),
                              [ x ]
                            |)
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "halo2_proofs::poly::Rotation",
                              "cur",
                              []
                            |),
                            []
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "halo2_proofs::plonk::vanishing::verifier::Evaluated",
                              "random_eval"
                            |)
                          |)
                        ]
                      |)
                    ]
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_queries :
          forall (C : Ty.t),
          M.IsAssociatedFunction (Self C) "queries" (queries C).
      End Impl_halo2_proofs_plonk_vanishing_verifier_Evaluated_C.
    End verifier.
  End vanishing.
End plonk.
