(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module poly.
  (*
  Enum Error
  {
    ty_params := [];
    variants :=
      [
        {
          name := "OpeningError";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "SamplingError";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_halo2_proofs_poly_Error.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Error".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| Value.String "OpeningError" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| Value.String "SamplingError" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_halo2_proofs_poly_Error.
  
  (* Trait *)
  (* Empty module 'Basis' *)
  
  (* StructTuple
    {
      name := "Coeff";
      ty_params := [];
      fields := [];
    } *)
  
  Module Impl_core_clone_Clone_for_halo2_proofs_poly_Coeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Coeff".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_halo2_proofs_poly_Coeff.
  
  Module Impl_core_marker_Copy_for_halo2_proofs_poly_Coeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Coeff".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_halo2_proofs_poly_Coeff.
  
  Module Impl_core_fmt_Debug_for_halo2_proofs_poly_Coeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Coeff".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [ M.read (| f |); M.read (| Value.String "Coeff" |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_halo2_proofs_poly_Coeff.
  
  Module Impl_halo2_proofs_poly_Basis_for_halo2_proofs_poly_Coeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Coeff".
    
    Axiom Implements :
      M.IsTraitInstance
        "halo2_proofs::poly::Basis"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_halo2_proofs_poly_Basis_for_halo2_proofs_poly_Coeff.
  
  (* StructTuple
    {
      name := "LagrangeCoeff";
      ty_params := [];
      fields := [];
    } *)
  
  Module Impl_core_clone_Clone_for_halo2_proofs_poly_LagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::LagrangeCoeff".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_halo2_proofs_poly_LagrangeCoeff.
  
  Module Impl_core_marker_Copy_for_halo2_proofs_poly_LagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::LagrangeCoeff".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_halo2_proofs_poly_LagrangeCoeff.
  
  Module Impl_core_fmt_Debug_for_halo2_proofs_poly_LagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::LagrangeCoeff".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [ M.read (| f |); M.read (| Value.String "LagrangeCoeff" |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_halo2_proofs_poly_LagrangeCoeff.
  
  Module Impl_halo2_proofs_poly_Basis_for_halo2_proofs_poly_LagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::LagrangeCoeff".
    
    Axiom Implements :
      M.IsTraitInstance
        "halo2_proofs::poly::Basis"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_halo2_proofs_poly_Basis_for_halo2_proofs_poly_LagrangeCoeff.
  
  (* StructTuple
    {
      name := "ExtendedLagrangeCoeff";
      ty_params := [];
      fields := [];
    } *)
  
  Module Impl_core_clone_Clone_for_halo2_proofs_poly_ExtendedLagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::ExtendedLagrangeCoeff".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_halo2_proofs_poly_ExtendedLagrangeCoeff.
  
  Module Impl_core_marker_Copy_for_halo2_proofs_poly_ExtendedLagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::ExtendedLagrangeCoeff".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_halo2_proofs_poly_ExtendedLagrangeCoeff.
  
  Module Impl_core_fmt_Debug_for_halo2_proofs_poly_ExtendedLagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::ExtendedLagrangeCoeff".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [ M.read (| f |); M.read (| Value.String "ExtendedLagrangeCoeff" |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_halo2_proofs_poly_ExtendedLagrangeCoeff.
  
  Module Impl_halo2_proofs_poly_Basis_for_halo2_proofs_poly_ExtendedLagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::ExtendedLagrangeCoeff".
    
    Axiom Implements :
      M.IsTraitInstance
        "halo2_proofs::poly::Basis"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_halo2_proofs_poly_Basis_for_halo2_proofs_poly_ExtendedLagrangeCoeff.
  
  (* StructTuple
    {
      name := "PreparedExtendedLagrangeCoeff";
      ty_params := [];
      fields := [];
    } *)
  
  Module Impl_core_clone_Clone_for_halo2_proofs_poly_PreparedExtendedLagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::PreparedExtendedLagrangeCoeff".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_halo2_proofs_poly_PreparedExtendedLagrangeCoeff.
  
  Module Impl_core_marker_Copy_for_halo2_proofs_poly_PreparedExtendedLagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::PreparedExtendedLagrangeCoeff".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_halo2_proofs_poly_PreparedExtendedLagrangeCoeff.
  
  Module Impl_core_fmt_Debug_for_halo2_proofs_poly_PreparedExtendedLagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::PreparedExtendedLagrangeCoeff".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [ M.read (| f |); M.read (| Value.String "PreparedExtendedLagrangeCoeff" |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_halo2_proofs_poly_PreparedExtendedLagrangeCoeff.
  
  Module Impl_halo2_proofs_poly_Basis_for_halo2_proofs_poly_PreparedExtendedLagrangeCoeff.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::PreparedExtendedLagrangeCoeff".
    
    Axiom Implements :
      M.IsTraitInstance
        "halo2_proofs::poly::Basis"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_halo2_proofs_poly_Basis_for_halo2_proofs_poly_PreparedExtendedLagrangeCoeff.
  
  (* StructRecord
    {
      name := "Polynomial";
      ty_params := [ "F"; "B" ];
      fields :=
        [
          ("values", Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ]);
          ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ B ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_core_clone_Clone_B_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (* Clone *)
    Definition clone (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "halo2_proofs::poly::Polynomial"
            [
              ("values",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::Polynomial",
                      "values"
                    |)
                  ]
                |));
              ("_marker",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::marker::PhantomData") [ B ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::Polynomial",
                      "_marker"
                    |)
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self F B)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone F B)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_where_core_clone_Clone_B_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_core_fmt_Debug_B_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (* Debug *)
    Definition fmt (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "Polynomial" |);
              M.read (| Value.String "values" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::poly::Polynomial",
                  "values"
                |));
              M.read (| Value.String "_marker" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::Polynomial",
                    "_marker"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self F B)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F B)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_core_fmt_Debug_B_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_ops_index_Index_usize_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*     type Output = F; *)
    Definition _Output (F B : Ty.t) : Ty.t := F.
    
    (*
        fn index(&self, index: usize) -> &F {
            self.values.index(index)
        }
    *)
    Definition index (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::Index",
              Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
              [ Ty.path "usize" ],
              "index",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::Polynomial",
                "values"
              |);
              M.read (| index |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::index::Index"
        (Self F B)
        (* Trait polymorphic types *) [ (* Idx *) Ty.path "usize" ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F B)); ("index", InstanceField.Method (index F B)) ].
  End Impl_core_ops_index_Index_usize_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_ops_index_IndexMut_usize_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*
        fn index_mut(&mut self, index: usize) -> &mut F {
            self.values.index_mut(index)
        }
    *)
    Definition index_mut (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::IndexMut",
              Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
              [ Ty.path "usize" ],
              "index_mut",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::Polynomial",
                "values"
              |);
              M.read (| index |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::index::IndexMut"
        (Self F B)
        (* Trait polymorphic types *) [ (* Idx *) Ty.path "usize" ]
        (* Instance *) [ ("index_mut", InstanceField.Method (index_mut F B)) ].
  End Impl_core_ops_index_IndexMut_usize_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_ops_index_Index_core_ops_range_RangeFrom_usize_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*     type Output = [F]; *)
    Definition _Output (F B : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [ F ].
    
    (*
        fn index(&self, index: RangeFrom<usize>) -> &[F] {
            self.values.index(index)
        }
    *)
    Definition index (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::Index",
              Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
              [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ] ],
              "index",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::Polynomial",
                "values"
              |);
              M.read (| index |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::index::Index"
        (Self F B)
        (* Trait polymorphic types *)
        [ (* Idx *) Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ] ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F B)); ("index", InstanceField.Method (index F B)) ].
  End Impl_core_ops_index_Index_core_ops_range_RangeFrom_usize_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_ops_index_IndexMut_core_ops_range_RangeFrom_usize_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*
        fn index_mut(&mut self, index: RangeFrom<usize>) -> &mut [F] {
            self.values.index_mut(index)
        }
    *)
    Definition index_mut (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::IndexMut",
              Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
              [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ] ],
              "index_mut",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::Polynomial",
                "values"
              |);
              M.read (| index |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::index::IndexMut"
        (Self F B)
        (* Trait polymorphic types *)
        [ (* Idx *) Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ] ]
        (* Instance *) [ ("index_mut", InstanceField.Method (index_mut F B)) ].
  End Impl_core_ops_index_IndexMut_core_ops_range_RangeFrom_usize_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_ops_index_Index_core_ops_range_RangeFull_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*     type Output = [F]; *)
    Definition _Output (F B : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [ F ].
    
    (*
        fn index(&self, index: RangeFull) -> &[F] {
            self.values.index(index)
        }
    *)
    Definition index (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::Index",
              Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
              [ Ty.path "core::ops::range::RangeFull" ],
              "index",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::Polynomial",
                "values"
              |);
              M.read (| index |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::index::Index"
        (Self F B)
        (* Trait polymorphic types *) [ (* Idx *) Ty.path "core::ops::range::RangeFull" ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F B)); ("index", InstanceField.Method (index F B)) ].
  End Impl_core_ops_index_Index_core_ops_range_RangeFull_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_ops_index_IndexMut_core_ops_range_RangeFull_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*
        fn index_mut(&mut self, index: RangeFull) -> &mut [F] {
            self.values.index_mut(index)
        }
    *)
    Definition index_mut (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::IndexMut",
              Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
              [ Ty.path "core::ops::range::RangeFull" ],
              "index_mut",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::Polynomial",
                "values"
              |);
              M.read (| index |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::index::IndexMut"
        (Self F B)
        (* Trait polymorphic types *) [ (* Idx *) Ty.path "core::ops::range::RangeFull" ]
        (* Instance *) [ ("index_mut", InstanceField.Method (index_mut F B)) ].
  End Impl_core_ops_index_IndexMut_core_ops_range_RangeFull_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_ops_deref_Deref_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*     type Target = [F]; *)
    Definition _Target (F B : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [ F ].
    
    (*
        fn deref(&self) -> &[F] {
            &self.values[..]
        }
    *)
    Definition deref (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::Index",
              Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
              [ Ty.path "core::ops::range::RangeFull" ],
              "index",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::Polynomial",
                "values"
              |);
              Value.StructTuple "core::ops::range::RangeFull" []
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (Self F B)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target F B)); ("deref", InstanceField.Method (deref F B)) ].
  End Impl_core_ops_deref_Deref_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_ops_deref_DerefMut_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*
        fn deref_mut(&mut self) -> &mut [F] {
            &mut self.values[..]
        }
    *)
    Definition deref_mut (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::IndexMut",
              Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
              [ Ty.path "core::ops::range::RangeFull" ],
              "index_mut",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::Polynomial",
                "values"
              |);
              Value.StructTuple "core::ops::range::RangeFull" []
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefMut"
        (Self F B)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("deref_mut", InstanceField.Method (deref_mut F B)) ].
  End Impl_core_ops_deref_DerefMut_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*
        pub fn new(values: Vec<F>) -> Self {
            Polynomial {
                values,
                _marker: PhantomData,
            }
        }
    *)
    Definition new (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ values ] =>
        ltac:(M.monadic
          (let values := M.alloc (| values |) in
          Value.StructRecord
            "halo2_proofs::poly::Polynomial"
            [
              ("values", M.read (| values |));
              ("_marker", Value.StructTuple "core::marker::PhantomData" [])
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new :
      forall (F B : Ty.t),
      M.IsAssociatedFunction (Self F B) "new" (new F B).
    
    (*
        pub fn iter(&self) -> impl Iterator<Item = &F> {
            self.values.iter()
        }
    *)
    Definition iter (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.apply (Ty.path "slice") [ F ], "iter", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                  [],
                  "deref",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::Polynomial",
                    "values"
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_iter :
      forall (F B : Ty.t),
      M.IsAssociatedFunction (Self F B) "iter" (iter F B).
    
    (*
        pub fn iter_mut(&mut self) -> impl Iterator<Item = &mut F> {
            self.values.iter_mut()
        }
    *)
    Definition iter_mut (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.apply (Ty.path "slice") [ F ], "iter_mut", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::DerefMut",
                  Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                  [],
                  "deref_mut",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::Polynomial",
                    "values"
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_iter_mut :
      forall (F B : Ty.t),
      M.IsAssociatedFunction (Self F B) "iter_mut" (iter_mut F B).
    
    (*
        pub fn num_coeffs(&self) -> usize {
            self.values.len()
        }
    *)
    Definition num_coeffs (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
              "len",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::Polynomial",
                "values"
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_num_coeffs :
      forall (F B : Ty.t),
      M.IsAssociatedFunction (Self F B) "num_coeffs" (num_coeffs F B).
  End Impl_halo2_proofs_poly_Polynomial_F_B.
  
  (*
  pub(crate) fn batch_invert_assigned<F: FieldExt>(
      assigned: Vec<Polynomial<Assigned<F>, LagrangeCoeff>>,
  ) -> Vec<Polynomial<F, LagrangeCoeff>> {
      let mut assigned_denominators: Vec<_> = assigned
          .par_iter()
          .map(|f| {
              f.iter()
                  .map(|value| value.denominator())
                  .collect::<Vec<_>>()
          })
          .collect();
  
      assigned_denominators.par_iter_mut().for_each(|f| {
          f.iter_mut()
              // If the denominator is trivial, we can skip it, reducing the
              // size of the batch inversion.
              .filter_map(|d| d.as_mut())
              .batch_invert();
      });
  
      assigned
          .iter()
          .zip(assigned_denominators.into_iter())
          .map(|(poly, inv_denoms)| poly.invert(inv_denoms))
          .collect()
  }
  *)
  Definition batch_invert_assigned (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ F ], [ assigned ] =>
      ltac:(M.monadic
        (let assigned := M.alloc (| assigned |) in
        M.read (|
          let assigned_denominators :=
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "rayon::iter::ParallelIterator",
                  Ty.apply
                    (Ty.path "rayon::iter::map::Map")
                    [
                      Ty.apply
                        (Ty.path "rayon::slice::Iter")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::poly::Polynomial")
                            [
                              Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
                              Ty.path "halo2_proofs::poly::LagrangeCoeff"
                            ]
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "&")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::poly::Polynomial")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                        [ F ];
                                      Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                    ]
                                ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.apply (Ty.path "core::option::Option") [ F ];
                            Ty.path "alloc::alloc::Global"
                          ])
                    ],
                  [],
                  "collect",
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.apply (Ty.path "core::option::Option") [ F ];
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "rayon::iter::ParallelIterator",
                      Ty.apply
                        (Ty.path "rayon::slice::Iter")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::poly::Polynomial")
                            [
                              Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
                              Ty.path "halo2_proofs::poly::LagrangeCoeff"
                            ]
                        ],
                      [],
                      "map",
                      [
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::poly::Polynomial")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                          [ F ];
                                        Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                      ]
                                  ]
                              ]
                          ]
                          (Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.apply (Ty.path "core::option::Option") [ F ];
                              Ty.path "alloc::alloc::Global"
                            ]);
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.apply (Ty.path "core::option::Option") [ F ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "rayon::iter::IntoParallelRefIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.apply
                                (Ty.path "halo2_proofs::poly::Polynomial")
                                [
                                  Ty.apply
                                    (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                    [ F ];
                                  Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "par_iter",
                          []
                        |),
                        [ assigned ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let f := M.copy (| γ |) in
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::map::Map")
                                            [
                                              Ty.associated;
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::plonk::assigned::Assigned")
                                                            [ F ]
                                                        ]
                                                    ]
                                                ]
                                                (Ty.apply (Ty.path "core::option::Option") [ F ])
                                            ],
                                          [],
                                          "collect",
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.apply (Ty.path "core::option::Option") [ F ];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ]
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.associated,
                                              [],
                                              "map",
                                              [
                                                Ty.apply (Ty.path "core::option::Option") [ F ];
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::plonk::assigned::Assigned")
                                                              [ F ]
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.apply (Ty.path "core::option::Option") [ F ])
                                              ]
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "halo2_proofs::poly::Polynomial")
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "halo2_proofs::plonk::assigned::Assigned")
                                                        [ F ];
                                                      Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                                    ],
                                                  "iter",
                                                  []
                                                |),
                                                [ M.read (| f |) ]
                                              |);
                                              M.closure
                                                (fun γ =>
                                                  ltac:(M.monadic
                                                    match γ with
                                                    | [ α0 ] =>
                                                      M.match_operator (|
                                                        M.alloc (| α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let value := M.copy (| γ |) in
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "halo2_proofs::plonk::assigned::Assigned")
                                                                    [ F ],
                                                                  "denominator",
                                                                  []
                                                                |),
                                                                [ M.read (| value |) ]
                                                              |)))
                                                        ]
                                                      |)
                                                    | _ => M.impossible (||)
                                                    end))
                                            ]
                                          |)
                                        ]
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    ]
                  |)
                ]
              |)
            |) in
          let _ :=
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "rayon::iter::ParallelIterator",
                  Ty.apply
                    (Ty.path "rayon::slice::IterMut")
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply (Ty.path "core::option::Option") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                  [],
                  "for_each",
                  [
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply (Ty.path "core::option::Option") [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ]
                          ]
                      ]
                      (Ty.tuple [])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "rayon::iter::IntoParallelRefMutIterator",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.apply (Ty.path "core::option::Option") [ F ];
                              Ty.path "alloc::alloc::Global"
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "par_iter_mut",
                      []
                    |),
                    [ assigned_denominators ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let f := M.copy (| γ |) in
                                  M.read (|
                                    let _ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "ff::batch::BatchInvert",
                                            Ty.apply
                                              (Ty.path
                                                "core::iter::adapters::filter_map::FilterMap")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::IterMut")
                                                  [ Ty.apply (Ty.path "core::option::Option") [ F ]
                                                  ];
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&mut")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              [ F ]
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    [ Ty.apply (Ty.path "&mut") [ F ] ])
                                              ],
                                            [ F ],
                                            "batch_invert",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::IterMut")
                                                  [ Ty.apply (Ty.path "core::option::Option") [ F ]
                                                  ],
                                                [],
                                                "filter_map",
                                                [
                                                  Ty.apply (Ty.path "&mut") [ F ];
                                                  Ty.function
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&mut")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                [ F ]
                                                            ]
                                                        ]
                                                    ]
                                                    (Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [ Ty.apply (Ty.path "&mut") [ F ] ])
                                                ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "slice")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          [ F ]
                                                      ],
                                                    "iter_mut",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::deref::DerefMut",
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              [ F ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        [],
                                                        "deref_mut",
                                                        []
                                                      |),
                                                      [ M.read (| f |) ]
                                                    |)
                                                  ]
                                                |);
                                                M.closure
                                                  (fun γ =>
                                                    ltac:(M.monadic
                                                      match γ with
                                                      | [ α0 ] =>
                                                        M.match_operator (|
                                                          M.alloc (| α0 |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let d := M.copy (| γ |) in
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      [ F ],
                                                                    "as_mut",
                                                                    []
                                                                  |),
                                                                  [ M.read (| d |) ]
                                                                |)))
                                                          ]
                                                        |)
                                                      | _ => M.impossible (||)
                                                      end))
                                              ]
                                            |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      [
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          [
                            Ty.apply
                              (Ty.path "halo2_proofs::poly::Polynomial")
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
                                Ty.path "halo2_proofs::poly::LagrangeCoeff"
                              ]
                          ];
                        Ty.apply
                          (Ty.path "alloc::vec::into_iter::IntoIter")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.apply (Ty.path "core::option::Option") [ F ];
                                Ty.path "alloc::alloc::Global"
                              ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::poly::Polynomial")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                          [ F ];
                                        Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                      ]
                                  ];
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply (Ty.path "core::option::Option") [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ]
                          ]
                      ]
                      (Ty.apply
                        (Ty.path "halo2_proofs::poly::Polynomial")
                        [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ])
                  ],
                [],
                "collect",
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [
                      Ty.apply
                        (Ty.path "halo2_proofs::poly::Polynomial")
                        [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ]
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      [
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          [
                            Ty.apply
                              (Ty.path "halo2_proofs::poly::Polynomial")
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
                                Ty.path "halo2_proofs::poly::LagrangeCoeff"
                              ]
                          ];
                        Ty.apply
                          (Ty.path "alloc::vec::into_iter::IntoIter")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.apply (Ty.path "core::option::Option") [ F ];
                                Ty.path "alloc::alloc::Global"
                              ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ],
                    [],
                    "map",
                    [
                      Ty.apply
                        (Ty.path "halo2_proofs::poly::Polynomial")
                        [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [
                                      Ty.apply
                                        (Ty.path "halo2_proofs::poly::Polynomial")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                            [ F ];
                                          Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                        ]
                                    ];
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.apply (Ty.path "core::option::Option") [ F ];
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "halo2_proofs::poly::Polynomial")
                          [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          [
                            Ty.apply
                              (Ty.path "halo2_proofs::poly::Polynomial")
                              [
                                Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
                                Ty.path "halo2_proofs::poly::LagrangeCoeff"
                              ]
                          ],
                        [],
                        "zip",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::into_iter::IntoIter")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.apply (Ty.path "core::option::Option") [ F ];
                                  Ty.path "alloc::alloc::Global"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [
                                Ty.apply
                                  (Ty.path "halo2_proofs::poly::Polynomial")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                      [ F ];
                                    Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                  ]
                              ],
                            "iter",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::poly::Polynomial")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                          [ F ];
                                        Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "deref",
                                []
                              |),
                              [ assigned ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply (Ty.path "core::option::Option") [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            "into_iter",
                            []
                          |),
                          [ M.read (| assigned_denominators |) ]
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let poly := M.copy (| γ0_0 |) in
                                    let inv_denoms := M.copy (| γ0_1 |) in
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "halo2_proofs::poly::Polynomial")
                                          [
                                            Ty.apply
                                              (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                              [ F ];
                                            Ty.path "halo2_proofs::poly::LagrangeCoeff"
                                          ],
                                        "invert",
                                        []
                                      |),
                                      [ M.read (| poly |); M.read (| inv_denoms |) ]
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end))
                  ]
                |)
              ]
            |)
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Module Impl_halo2_proofs_poly_Polynomial_halo2_proofs_plonk_assigned_Assigned_F_halo2_proofs_poly_LagrangeCoeff.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "halo2_proofs::poly::Polynomial")
        [
          Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ];
          Ty.path "halo2_proofs::poly::LagrangeCoeff"
        ].
    
    (*
        pub(crate) fn invert(&self, inv_denoms: Vec<Option<F>>) -> Polynomial<F, LagrangeCoeff> {
            Polynomial {
                values: self
                    .values
                    .par_iter()
                    .zip(inv_denoms.into_par_iter())
                    .map(|(a, inv_den)| {
                        inv_den.map_or_else(|| a.numerator(), |inv_den| a.numerator() * inv_den)
                    })
                    .collect(),
                _marker: self._marker,
            }
        }
    *)
    Definition invert (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [], [ self; inv_denoms ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let inv_denoms := M.alloc (| inv_denoms |) in
          Value.StructRecord
            "halo2_proofs::poly::Polynomial"
            [
              ("values",
                M.call_closure (|
                  M.get_trait_method (|
                    "rayon::iter::ParallelIterator",
                    Ty.apply
                      (Ty.path "rayon::iter::map::Map")
                      [
                        Ty.apply
                          (Ty.path "rayon::iter::zip::Zip")
                          [
                            Ty.apply
                              (Ty.path "rayon::slice::Iter")
                              [ Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ]
                              ];
                            Ty.apply
                              (Ty.path "rayon::vec::IntoIter")
                              [ Ty.apply (Ty.path "core::option::Option") [ F ] ]
                          ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.apply
                                          (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                          [ F ]
                                      ];
                                    Ty.apply (Ty.path "core::option::Option") [ F ]
                                  ]
                              ]
                          ]
                          F
                      ],
                    [],
                    "collect",
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ] ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "rayon::iter::ParallelIterator",
                        Ty.apply
                          (Ty.path "rayon::iter::zip::Zip")
                          [
                            Ty.apply
                              (Ty.path "rayon::slice::Iter")
                              [ Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ]
                              ];
                            Ty.apply
                              (Ty.path "rayon::vec::IntoIter")
                              [ Ty.apply (Ty.path "core::option::Option") [ F ] ]
                          ],
                        [],
                        "map",
                        [
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [
                                          Ty.apply
                                            (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                            [ F ]
                                        ];
                                      Ty.apply (Ty.path "core::option::Option") [ F ]
                                    ]
                                ]
                            ]
                            F;
                          F
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "rayon::iter::IndexedParallelIterator",
                            Ty.apply
                              (Ty.path "rayon::slice::Iter")
                              [ Ty.apply (Ty.path "halo2_proofs::plonk::assigned::Assigned") [ F ]
                              ],
                            [],
                            "zip",
                            [
                              Ty.apply
                                (Ty.path "rayon::vec::IntoIter")
                                [ Ty.apply (Ty.path "core::option::Option") [ F ] ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "rayon::iter::IntoParallelRefIterator",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply
                                      (Ty.path "halo2_proofs::plonk::assigned::Assigned")
                                      [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "par_iter",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "halo2_proofs::poly::Polynomial",
                                  "values"
                                |)
                              ]
                            |);
                            M.call_closure (|
                              M.get_trait_method (|
                                "rayon::iter::IntoParallelIterator",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply (Ty.path "core::option::Option") [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "into_par_iter",
                                []
                              |),
                              [ M.read (| inv_denoms |) ]
                            |)
                          ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let a := M.copy (| γ0_0 |) in
                                        let inv_den := M.copy (| γ0_1 |) in
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "core::option::Option") [ F ],
                                            "map_or_else",
                                            [
                                              F;
                                              Ty.function [ Ty.tuple [] ] F;
                                              Ty.function [ Ty.tuple [ F ] ] F
                                            ]
                                          |),
                                          [
                                            M.read (| inv_den |);
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    M.match_operator (|
                                                      M.alloc (| α0 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "halo2_proofs::plonk::assigned::Assigned")
                                                                  [ F ],
                                                                "numerator",
                                                                []
                                                              |),
                                                              [ M.read (| a |) ]
                                                            |)))
                                                      ]
                                                    |)
                                                  | _ => M.impossible (||)
                                                  end));
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    M.match_operator (|
                                                      M.alloc (| α0 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let inv_den := M.copy (| γ |) in
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::arith::Mul",
                                                                F,
                                                                [ F ],
                                                                "mul",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "halo2_proofs::plonk::assigned::Assigned")
                                                                      [ F ],
                                                                    "numerator",
                                                                    []
                                                                  |),
                                                                  [ M.read (| a |) ]
                                                                |);
                                                                M.read (| inv_den |)
                                                              ]
                                                            |)))
                                                      ]
                                                    |)
                                                  | _ => M.impossible (||)
                                                  end))
                                          ]
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  ]
                |));
              ("_marker",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::Polynomial",
                    "_marker"
                  |)
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_invert :
      forall (F : Ty.t),
      M.IsAssociatedFunction (Self F) "invert" (invert F).
  End Impl_halo2_proofs_poly_Polynomial_halo2_proofs_plonk_assigned_Assigned_F_halo2_proofs_poly_LagrangeCoeff.
  
  Module Impl_core_ops_arith_Add_where_ff_Field_F_where_halo2_proofs_poly_Basis_B_ref__halo2_proofs_poly_Polynomial_F_B_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*     type Output = Polynomial<F, B>; *)
    Definition _Output (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*
        fn add(mut self, rhs: &'a Polynomial<F, B>) -> Polynomial<F, B> {
            parallelize(&mut self.values, |lhs, start| {
                for (lhs, rhs) in lhs.iter_mut().zip(rhs.values[start..].iter()) {
                    *lhs += *rhs;
                }
            });
    
            self
        }
    *)
    Definition add (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "halo2_proofs::arithmetic::parallelize",
                    [
                      F;
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ F ] ];
                              Ty.path "usize"
                            ]
                        ]
                        (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "halo2_proofs::poly::Polynomial",
                          "values"
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0; α1 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let lhs := M.copy (| γ |) in
                                    M.match_operator (|
                                      M.alloc (| α1 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let start := M.copy (| γ |) in
                                            M.read (|
                                              M.use
                                                (M.match_operator (|
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::iter::traits::collect::IntoIterator",
                                                        Ty.apply
                                                          (Ty.path "core::iter::adapters::zip::Zip")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::IterMut")
                                                              [ F ];
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::Iter")
                                                              [ F ]
                                                          ],
                                                        [],
                                                        "into_iter",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::iter::traits::iterator::Iterator",
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::IterMut")
                                                              [ F ],
                                                            [],
                                                            "zip",
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::slice::iter::Iter")
                                                                [ F ]
                                                            ]
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply (Ty.path "slice") [ F ],
                                                                "iter_mut",
                                                                []
                                                              |),
                                                              [ M.read (| lhs |) ]
                                                            |);
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply (Ty.path "slice") [ F ],
                                                                "iter",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::index::Index",
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      [
                                                                        F;
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::ops::range::RangeFrom")
                                                                        [ Ty.path "usize" ]
                                                                    ],
                                                                    "index",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.SubPointer.get_struct_record_field (|
                                                                      M.read (| rhs |),
                                                                      "halo2_proofs::poly::Polynomial",
                                                                      "values"
                                                                    |);
                                                                    Value.StructRecord
                                                                      "core::ops::range::RangeFrom"
                                                                      [
                                                                        ("start",
                                                                          M.read (| start |))
                                                                      ]
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let iter := M.copy (| γ |) in
                                                        M.loop (|
                                                          ltac:(M.monadic
                                                            (let _ :=
                                                              M.match_operator (|
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::iter::adapters::zip::Zip")
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::slice::iter::IterMut")
                                                                            [ F ];
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::slice::iter::Iter")
                                                                            [ F ]
                                                                        ],
                                                                      [],
                                                                      "next",
                                                                      []
                                                                    |),
                                                                    [ iter ]
                                                                  |)
                                                                |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (M.alloc (|
                                                                        M.never_to_any (|
                                                                          M.read (| M.break (||) |)
                                                                        |)
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ0_0 :=
                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                          γ,
                                                                          "core::option::Option::Some",
                                                                          0
                                                                        |) in
                                                                      let γ1_0 :=
                                                                        M.SubPointer.get_tuple_field (|
                                                                          γ0_0,
                                                                          0
                                                                        |) in
                                                                      let γ1_1 :=
                                                                        M.SubPointer.get_tuple_field (|
                                                                          γ0_0,
                                                                          1
                                                                        |) in
                                                                      let lhs :=
                                                                        M.copy (| γ1_0 |) in
                                                                      let rhs :=
                                                                        M.copy (| γ1_1 |) in
                                                                      let _ :=
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::arith::AddAssign",
                                                                              F,
                                                                              [ F ],
                                                                              "add_assign",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.read (| lhs |);
                                                                              M.read (|
                                                                                M.read (| rhs |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |) in
                                                                      M.alloc (| Value.Tuple [] |)))
                                                                ]
                                                              |) in
                                                            M.alloc (| Value.Tuple [] |)))
                                                        |)))
                                                  ]
                                                |))
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end))
                  ]
                |)
              |) in
            self
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Add"
        (Self F B)
        (* Trait polymorphic types *)
        [
          (* Rhs *)
          Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ] ]
        ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F B)); ("add", InstanceField.Method (add F B)) ].
  End Impl_core_ops_arith_Add_where_ff_Field_F_where_halo2_proofs_poly_Basis_B_ref__halo2_proofs_poly_Polynomial_F_B_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_ops_arith_Sub_where_ff_Field_F_where_halo2_proofs_poly_Basis_B_ref__halo2_proofs_poly_Polynomial_F_B_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*     type Output = Polynomial<F, B>; *)
    Definition _Output (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*
        fn sub(mut self, rhs: &'a Polynomial<F, B>) -> Polynomial<F, B> {
            parallelize(&mut self.values, |lhs, start| {
                for (lhs, rhs) in lhs.iter_mut().zip(rhs.values[start..].iter()) {
                    *lhs -= *rhs;
                }
            });
    
            self
        }
    *)
    Definition sub (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "halo2_proofs::arithmetic::parallelize",
                    [
                      F;
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ F ] ];
                              Ty.path "usize"
                            ]
                        ]
                        (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "halo2_proofs::poly::Polynomial",
                          "values"
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0; α1 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let lhs := M.copy (| γ |) in
                                    M.match_operator (|
                                      M.alloc (| α1 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let start := M.copy (| γ |) in
                                            M.read (|
                                              M.use
                                                (M.match_operator (|
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::iter::traits::collect::IntoIterator",
                                                        Ty.apply
                                                          (Ty.path "core::iter::adapters::zip::Zip")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::IterMut")
                                                              [ F ];
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::Iter")
                                                              [ F ]
                                                          ],
                                                        [],
                                                        "into_iter",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::iter::traits::iterator::Iterator",
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::IterMut")
                                                              [ F ],
                                                            [],
                                                            "zip",
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::slice::iter::Iter")
                                                                [ F ]
                                                            ]
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply (Ty.path "slice") [ F ],
                                                                "iter_mut",
                                                                []
                                                              |),
                                                              [ M.read (| lhs |) ]
                                                            |);
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply (Ty.path "slice") [ F ],
                                                                "iter",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::index::Index",
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      [
                                                                        F;
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::ops::range::RangeFrom")
                                                                        [ Ty.path "usize" ]
                                                                    ],
                                                                    "index",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.SubPointer.get_struct_record_field (|
                                                                      M.read (| rhs |),
                                                                      "halo2_proofs::poly::Polynomial",
                                                                      "values"
                                                                    |);
                                                                    Value.StructRecord
                                                                      "core::ops::range::RangeFrom"
                                                                      [
                                                                        ("start",
                                                                          M.read (| start |))
                                                                      ]
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let iter := M.copy (| γ |) in
                                                        M.loop (|
                                                          ltac:(M.monadic
                                                            (let _ :=
                                                              M.match_operator (|
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::iter::adapters::zip::Zip")
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::slice::iter::IterMut")
                                                                            [ F ];
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::slice::iter::Iter")
                                                                            [ F ]
                                                                        ],
                                                                      [],
                                                                      "next",
                                                                      []
                                                                    |),
                                                                    [ iter ]
                                                                  |)
                                                                |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (M.alloc (|
                                                                        M.never_to_any (|
                                                                          M.read (| M.break (||) |)
                                                                        |)
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ0_0 :=
                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                          γ,
                                                                          "core::option::Option::Some",
                                                                          0
                                                                        |) in
                                                                      let γ1_0 :=
                                                                        M.SubPointer.get_tuple_field (|
                                                                          γ0_0,
                                                                          0
                                                                        |) in
                                                                      let γ1_1 :=
                                                                        M.SubPointer.get_tuple_field (|
                                                                          γ0_0,
                                                                          1
                                                                        |) in
                                                                      let lhs :=
                                                                        M.copy (| γ1_0 |) in
                                                                      let rhs :=
                                                                        M.copy (| γ1_1 |) in
                                                                      let _ :=
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::arith::SubAssign",
                                                                              F,
                                                                              [ F ],
                                                                              "sub_assign",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.read (| lhs |);
                                                                              M.read (|
                                                                                M.read (| rhs |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |) in
                                                                      M.alloc (| Value.Tuple [] |)))
                                                                ]
                                                              |) in
                                                            M.alloc (| Value.Tuple [] |)))
                                                        |)))
                                                  ]
                                                |))
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end))
                  ]
                |)
              |) in
            self
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (Self F B)
        (* Trait polymorphic types *)
        [
          (* Rhs *)
          Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ] ]
        ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F B)); ("sub", InstanceField.Method (sub F B)) ].
  End Impl_core_ops_arith_Sub_where_ff_Field_F_where_halo2_proofs_poly_Basis_B_ref__halo2_proofs_poly_Polynomial_F_B_for_halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_halo2_proofs_poly_Polynomial_F_halo2_proofs_poly_LagrangeCoeff.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "halo2_proofs::poly::Polynomial")
        [ F; Ty.path "halo2_proofs::poly::LagrangeCoeff" ].
    
    (*
        pub fn rotate(&self, rotation: Rotation) -> Polynomial<F, LagrangeCoeff> {
            let mut values = self.values.clone();
            if rotation.0 < 0 {
                values.rotate_right((-rotation.0) as usize);
            } else {
                values.rotate_left(rotation.0 as usize);
            }
            Polynomial {
                values,
                _marker: PhantomData,
            }
        }
    *)
    Definition rotate (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [], [ self; rotation ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rotation := M.alloc (| rotation |) in
          M.read (|
            let values :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::Polynomial",
                      "values"
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.read (|
                                M.SubPointer.get_struct_tuple_field (|
                                  rotation,
                                  "halo2_proofs::poly::Rotation",
                                  0
                                |)
                              |))
                              (Value.Integer 0)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ F ],
                              "rotate_right",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ F; Ty.path "alloc::alloc::Global" ],
                                  [],
                                  "deref_mut",
                                  []
                                |),
                                [ values ]
                              |);
                              M.rust_cast
                                (UnOp.Panic.neg (|
                                  Integer.I32,
                                  M.read (|
                                    M.SubPointer.get_struct_tuple_field (|
                                      rotation,
                                      "halo2_proofs::poly::Rotation",
                                      0
                                    |)
                                  |)
                                |))
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ F ],
                              "rotate_left",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ F; Ty.path "alloc::alloc::Global" ],
                                  [],
                                  "deref_mut",
                                  []
                                |),
                                [ values ]
                              |);
                              M.rust_cast
                                (M.read (|
                                  M.SubPointer.get_struct_tuple_field (|
                                    rotation,
                                    "halo2_proofs::poly::Rotation",
                                    0
                                  |)
                                |))
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "halo2_proofs::poly::Polynomial"
                [
                  ("values", M.read (| values |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rotate :
      forall (F : Ty.t),
      M.IsAssociatedFunction (Self F) "rotate" (rotate F).
  End Impl_halo2_proofs_poly_Polynomial_F_halo2_proofs_poly_LagrangeCoeff.
  
  Module Impl_core_ops_arith_Sub_where_ff_Field_F_where_halo2_proofs_poly_Basis_B_F_for_ref__halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ] ].
    
    (*     type Output = Polynomial<F, B>; *)
    Definition _Output (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*
        fn sub(self, rhs: F) -> Polynomial<F, B> {
            let mut res = self.clone();
            res.values[0] -= rhs;
            res
        }
    *)
    Definition sub (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let res :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ],
                    [],
                    "clone",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::SubAssign",
                    F,
                    [ F ],
                    "sub_assign",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::index::IndexMut",
                        Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                        [ Ty.path "usize" ],
                        "index_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          res,
                          "halo2_proofs::poly::Polynomial",
                          "values"
                        |);
                        Value.Integer 0
                      ]
                    |);
                    M.read (| rhs |)
                  ]
                |)
              |) in
            res
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (Self F B)
        (* Trait polymorphic types *) [ (* Rhs *) F ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F B)); ("sub", InstanceField.Method (sub F B)) ].
  End Impl_core_ops_arith_Sub_where_ff_Field_F_where_halo2_proofs_poly_Basis_B_F_for_ref__halo2_proofs_poly_Polynomial_F_B.
  
  Module Impl_core_ops_arith_Mul_where_ff_Field_F_where_halo2_proofs_poly_Basis_B_F_for_halo2_proofs_poly_Polynomial_F_B.
    Definition Self (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*     type Output = Polynomial<F, B>; *)
    Definition _Output (F B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::poly::Polynomial") [ F; B ].
    
    (*
        fn mul(mut self, rhs: F) -> Polynomial<F, B> {
            parallelize(&mut self.values, |lhs, _| {
                for lhs in lhs.iter_mut() {
                    *lhs *= rhs;
                }
            });
    
            self
        }
    *)
    Definition mul (F B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F B in
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "halo2_proofs::arithmetic::parallelize",
                    [
                      F;
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ F ] ];
                              Ty.path "usize"
                            ]
                        ]
                        (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "halo2_proofs::poly::Polynomial",
                          "values"
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0; α1 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let lhs := M.copy (| γ |) in
                                    M.match_operator (|
                                      M.alloc (| α1 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.read (|
                                              M.use
                                                (M.match_operator (|
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::iter::traits::collect::IntoIterator",
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::IterMut")
                                                          [ F ],
                                                        [],
                                                        "into_iter",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [ F ],
                                                            "iter_mut",
                                                            []
                                                          |),
                                                          [ M.read (| lhs |) ]
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let iter := M.copy (| γ |) in
                                                        M.loop (|
                                                          ltac:(M.monadic
                                                            (let _ :=
                                                              M.match_operator (|
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::slice::iter::IterMut")
                                                                        [ F ],
                                                                      [],
                                                                      "next",
                                                                      []
                                                                    |),
                                                                    [ iter ]
                                                                  |)
                                                                |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (M.alloc (|
                                                                        M.never_to_any (|
                                                                          M.read (| M.break (||) |)
                                                                        |)
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ0_0 :=
                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                          γ,
                                                                          "core::option::Option::Some",
                                                                          0
                                                                        |) in
                                                                      let lhs :=
                                                                        M.copy (| γ0_0 |) in
                                                                      let _ :=
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::arith::MulAssign",
                                                                              F,
                                                                              [ F ],
                                                                              "mul_assign",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.read (| lhs |);
                                                                              M.read (| rhs |)
                                                                            ]
                                                                          |)
                                                                        |) in
                                                                      M.alloc (| Value.Tuple [] |)))
                                                                ]
                                                              |) in
                                                            M.alloc (| Value.Tuple [] |)))
                                                        |)))
                                                  ]
                                                |))
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end))
                  ]
                |)
              |) in
            self
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F B : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (Self F B)
        (* Trait polymorphic types *) [ (* Rhs *) F ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F B)); ("mul", InstanceField.Method (mul F B)) ].
  End Impl_core_ops_arith_Mul_where_ff_Field_F_where_halo2_proofs_poly_Basis_B_F_for_halo2_proofs_poly_Polynomial_F_B.
  
  (* StructTuple
    {
      name := "Rotation";
      ty_params := [];
      fields := [ Ty.path "i32" ];
    } *)
  
  Module Impl_core_marker_Copy_for_halo2_proofs_poly_Rotation.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Rotation".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_halo2_proofs_poly_Rotation.
  
  Module Impl_core_clone_Clone_for_halo2_proofs_poly_Rotation.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Rotation".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_halo2_proofs_poly_Rotation.
  
  Module Impl_core_fmt_Debug_for_halo2_proofs_poly_Rotation.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Rotation".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "Rotation" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::Rotation",
                    0
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_halo2_proofs_poly_Rotation.
  
  Module Impl_core_marker_StructuralPartialEq_for_halo2_proofs_poly_Rotation.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Rotation".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_halo2_proofs_poly_Rotation.
  
  Module Impl_core_cmp_PartialEq_for_halo2_proofs_poly_Rotation.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Rotation".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          BinOp.Pure.eq
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "halo2_proofs::poly::Rotation",
                0
              |)
            |))
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "halo2_proofs::poly::Rotation",
                0
              |)
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_halo2_proofs_poly_Rotation.
  
  Module Impl_core_cmp_PartialOrd_for_halo2_proofs_poly_Rotation.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Rotation".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "i32",
              [ Ty.path "i32" ],
              "partial_cmp",
              []
            |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "halo2_proofs::poly::Rotation",
                0
              |);
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "halo2_proofs::poly::Rotation",
                0
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_halo2_proofs_poly_Rotation.
  
  Module Impl_core_marker_StructuralEq_for_halo2_proofs_poly_Rotation.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Rotation".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_halo2_proofs_poly_Rotation.
  
  Module Impl_core_cmp_Eq_for_halo2_proofs_poly_Rotation.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Rotation".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_halo2_proofs_poly_Rotation.
  
  Module Impl_core_cmp_Ord_for_halo2_proofs_poly_Rotation.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Rotation".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::Ord", Ty.path "i32", [], "cmp", [] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "halo2_proofs::poly::Rotation",
                0
              |);
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "halo2_proofs::poly::Rotation",
                0
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_halo2_proofs_poly_Rotation.
  
  Module Impl_halo2_proofs_poly_Rotation.
    Definition Self : Ty.t := Ty.path "halo2_proofs::poly::Rotation".
    
    (*
        pub fn cur() -> Rotation {
            Rotation(0)
        }
    *)
    Definition cur (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic (Value.StructTuple "halo2_proofs::poly::Rotation" [ Value.Integer 0 ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_cur : M.IsAssociatedFunction Self "cur" cur.
    
    (*
        pub fn prev() -> Rotation {
            Rotation(-1)
        }
    *)
    Definition prev (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic (Value.StructTuple "halo2_proofs::poly::Rotation" [ Value.Integer (-1) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_prev : M.IsAssociatedFunction Self "prev" prev.
    
    (*
        pub fn next() -> Rotation {
            Rotation(1)
        }
    *)
    Definition next (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic (Value.StructTuple "halo2_proofs::poly::Rotation" [ Value.Integer 1 ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next : M.IsAssociatedFunction Self "next" next.
  End Impl_halo2_proofs_poly_Rotation.
End poly.
