(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module poly.
  Module multiopen.
    (* StructRecord
      {
        name := "Decider";
        ty_params := [ "E" ];
        fields := [ ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ E ]) ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_E_where_pairing_bn256_arithmetic_pairing_MultiMillerLoop_E_for_halo2_proofs_poly_multiopen_Decider_E.
      Definition Self (E : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::Decider") [ E ].
      
      (* Debug *)
      Definition fmt (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self E in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Decider" |);
                M.read (| Value.String "_marker" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::Decider",
                      "_marker"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (E : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self E)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt E)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_E_where_pairing_bn256_arithmetic_pairing_MultiMillerLoop_E_for_halo2_proofs_poly_multiopen_Decider_E.
    
    Module Impl_halo2_proofs_poly_multiopen_Decider_E.
      Definition Self (E : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::Decider") [ E ].
      
      (*
          fn prepare(params: &ParamsVerifier<E>) -> (E::G2Prepared, E::G2Prepared) {
              let s_g2_prepared = E::G2Prepared::from(params.s_g2);
              let n_g2_prepared = E::G2Prepared::from(-params.g2);
              (s_g2_prepared, n_g2_prepared)
          }
      *)
      Definition prepare (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self E in
        match τ, α with
        | [], [ params ] =>
          ltac:(M.monadic
            (let params := M.alloc (| params |) in
            M.read (|
              let s_g2_prepared :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.associated,
                      [ Ty.associated ],
                      "from",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| params |),
                          "halo2_proofs::poly::commitment::ParamsVerifier",
                          "s_g2"
                        |)
                      |)
                    ]
                  |)
                |) in
              let n_g2_prepared :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.associated,
                      [ Ty.associated ],
                      "from",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::arith::Neg",
                          Ty.associated,
                          [],
                          "neg",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| params |),
                              "halo2_proofs::poly::commitment::ParamsVerifier",
                              "g2"
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [ M.read (| s_g2_prepared |); M.read (| n_g2_prepared |) ] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_prepare :
        forall (E : Ty.t),
        M.IsAssociatedFunction (Self E) "prepare" (prepare E).
      
      (*
          fn pairing_check(terms: &[(&E::G1Affine, &E::G2Prepared); 2]) -> bool {
              bool::from(
                  E::multi_miller_loop(&terms[..])
                      .final_exponentiation()
                      .is_identity(),
              )
          }
      *)
      Definition pairing_check (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self E in
        match τ, α with
        | [], [ terms ] =>
          ltac:(M.monadic
            (let terms := M.alloc (| terms |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::convert::From",
                Ty.path "bool",
                [ Ty.path "subtle::Choice" ],
                "from",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "group::Group", Ty.associated, [], "is_identity", [] |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "pairing_bn256::arithmetic::pairing::MillerLoopResult",
                          Ty.associated,
                          [],
                          "final_exponentiation",
                          []
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "pairing_bn256::arithmetic::pairing::MultiMillerLoop",
                                E,
                                [],
                                "multi_miller_loop",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::index::Index",
                                    Ty.apply
                                      (Ty.path "array")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [ Ty.associated ];
                                            Ty.apply (Ty.path "&") [ Ty.associated ]
                                          ]
                                      ],
                                    [ Ty.path "core::ops::range::RangeFull" ],
                                    "index",
                                    []
                                  |),
                                  [
                                    M.read (| terms |);
                                    Value.StructTuple "core::ops::range::RangeFull" []
                                  ]
                                |)
                              ]
                            |)
                          |)
                        ]
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pairing_check :
        forall (E : Ty.t),
        M.IsAssociatedFunction (Self E) "pairing_check" (pairing_check E).
      
      (*
          pub fn verify(params: &ParamsVerifier<E>, msm: PairMSM<E::G1Affine>) -> bool {
              let (s_g2, n_g2) = Self::prepare(params);
              let (left, right) = msm.eval();
              let (term_1, term_2) = ((&left, &s_g2), (&right, &n_g2));
              Self::pairing_check(&[term_1, term_2])
          }
      *)
      Definition verify (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self E in
        match τ, α with
        | [], [ params; msm ] =>
          ltac:(M.monadic
            (let params := M.alloc (| params |) in
            let msm := M.alloc (| msm |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "halo2_proofs::poly::multiopen::Decider") [ E ],
                      "prepare",
                      []
                    |),
                    [ M.read (| params |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let s_g2 := M.copy (| γ0_0 |) in
                      let n_g2 := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "halo2_proofs::poly::msm::PairMSM")
                                [ Ty.associated ],
                              "eval",
                              []
                            |),
                            [ msm ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let left := M.copy (| γ0_0 |) in
                              let right := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (|
                                  Value.Tuple
                                    [ Value.Tuple [ left; s_g2 ]; Value.Tuple [ right; n_g2 ] ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let term_1 := M.copy (| γ0_0 |) in
                                      let term_2 := M.copy (| γ0_1 |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "halo2_proofs::poly::multiopen::Decider")
                                              [ E ],
                                            "pairing_check",
                                            []
                                          |),
                                          [
                                            M.alloc (|
                                              Value.Array
                                                [ M.read (| term_1 |); M.read (| term_2 |) ]
                                            |)
                                          ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_verify :
        forall (E : Ty.t),
        M.IsAssociatedFunction (Self E) "verify" (verify E).
    End Impl_halo2_proofs_poly_multiopen_Decider_E.
    
    (* StructRecord
      {
        name := "ProverQuery";
        ty_params := [ "C" ];
        fields :=
          [
            ("point", Ty.associated);
            ("rotation", Ty.path "halo2_proofs::poly::Rotation");
            ("poly",
              Ty.apply
                (Ty.path "&")
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::poly::Polynomial")
                    [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]
                ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_poly_multiopen_ProverQuery_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::ProverQuery") [ C ].
      
      (* Debug *)
      Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "ProverQuery" |);
                M.read (| Value.String "point" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::multiopen::ProverQuery",
                    "point"
                  |));
                M.read (| Value.String "rotation" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::multiopen::ProverQuery",
                    "rotation"
                  |));
                M.read (| Value.String "poly" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::ProverQuery",
                      "poly"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_poly_multiopen_ProverQuery_C.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_associated_type_where_core_clone_Clone_associated_type_for_halo2_proofs_poly_multiopen_ProverQuery_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::ProverQuery") [ C ].
      
      (* Clone *)
      Definition clone (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::poly::multiopen::ProverQuery"
              [
                ("point",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Ty.associated, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::ProverQuery",
                        "point"
                      |)
                    ]
                  |));
                ("rotation",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "halo2_proofs::poly::Rotation",
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::ProverQuery",
                        "rotation"
                      |)
                    ]
                  |));
                ("poly",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "&")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::poly::Polynomial")
                            [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::ProverQuery",
                        "poly"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone C)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_associated_type_where_core_clone_Clone_associated_type_for_halo2_proofs_poly_multiopen_ProverQuery_C.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_marker_Copy_associated_type_where_core_marker_Copy_associated_type_for_halo2_proofs_poly_multiopen_ProverQuery_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::ProverQuery") [ C ].
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_marker_Copy_associated_type_where_core_marker_Copy_associated_type_for_halo2_proofs_poly_multiopen_ProverQuery_C.
    
    (* StructRecord
      {
        name := "VerifierQuery";
        ty_params := [ "C" ];
        fields :=
          [
            ("point", Ty.associated);
            ("rotation", Ty.path "halo2_proofs::poly::Rotation");
            ("commitment",
              Ty.apply (Ty.path "halo2_proofs::poly::multiopen::CommitmentReference") [ C ]);
            ("eval", Ty.associated)
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_poly_multiopen_VerifierQuery_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ].
      
      (* Debug *)
      Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field4_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "VerifierQuery" |);
                M.read (| Value.String "point" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::multiopen::VerifierQuery",
                    "point"
                  |));
                M.read (| Value.String "rotation" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::multiopen::VerifierQuery",
                    "rotation"
                  |));
                M.read (| Value.String "commitment" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::multiopen::VerifierQuery",
                    "commitment"
                  |));
                M.read (| Value.String "eval" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::VerifierQuery",
                      "eval"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_where_core_fmt_Debug_associated_type_for_halo2_proofs_poly_multiopen_VerifierQuery_C.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_associated_type_where_core_clone_Clone_associated_type_for_halo2_proofs_poly_multiopen_VerifierQuery_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ].
      
      (* Clone *)
      Definition clone (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::poly::multiopen::VerifierQuery"
              [
                ("point",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Ty.associated, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::VerifierQuery",
                        "point"
                      |)
                    ]
                  |));
                ("rotation",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "halo2_proofs::poly::Rotation",
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::VerifierQuery",
                        "rotation"
                      |)
                    ]
                  |));
                ("commitment",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "halo2_proofs::poly::multiopen::CommitmentReference") [ C ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::VerifierQuery",
                        "commitment"
                      |)
                    ]
                  |));
                ("eval",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", Ty.associated, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::VerifierQuery",
                        "eval"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone C)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_associated_type_where_core_clone_Clone_associated_type_for_halo2_proofs_poly_multiopen_VerifierQuery_C.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_marker_Copy_associated_type_where_core_marker_Copy_associated_type_for_halo2_proofs_poly_multiopen_VerifierQuery_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ].
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_marker_Copy_associated_type_where_core_marker_Copy_associated_type_for_halo2_proofs_poly_multiopen_VerifierQuery_C.
    
    Module Impl_halo2_proofs_poly_multiopen_VerifierQuery_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ].
      
      (*
          pub fn new_commitment(
              commitment: &'r C,
              point: C::Scalar,
              rotation: Rotation,
              eval: C::Scalar,
          ) -> Self {
              VerifierQuery {
                  point,
                  rotation,
                  eval,
                  commitment: CommitmentReference::Commitment(commitment),
              }
          }
      *)
      Definition new_commitment (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ commitment; point; rotation; eval ] =>
          ltac:(M.monadic
            (let commitment := M.alloc (| commitment |) in
            let point := M.alloc (| point |) in
            let rotation := M.alloc (| rotation |) in
            let eval := M.alloc (| eval |) in
            Value.StructRecord
              "halo2_proofs::poly::multiopen::VerifierQuery"
              [
                ("point", M.read (| point |));
                ("rotation", M.read (| rotation |));
                ("eval", M.read (| eval |));
                ("commitment",
                  Value.StructTuple
                    "halo2_proofs::poly::multiopen::CommitmentReference::Commitment"
                    [ M.read (| commitment |) ])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_commitment :
        forall (C : Ty.t),
        M.IsAssociatedFunction (Self C) "new_commitment" (new_commitment C).
      
      (*
          pub fn new_msm(msm: &'r MSM<C>, point: C::Scalar, rotation: Rotation, eval: C::Scalar) -> Self {
              VerifierQuery {
                  point,
                  rotation,
                  eval,
                  commitment: CommitmentReference::MSM(msm),
              }
          }
      *)
      Definition new_msm (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ msm; point; rotation; eval ] =>
          ltac:(M.monadic
            (let msm := M.alloc (| msm |) in
            let point := M.alloc (| point |) in
            let rotation := M.alloc (| rotation |) in
            let eval := M.alloc (| eval |) in
            Value.StructRecord
              "halo2_proofs::poly::multiopen::VerifierQuery"
              [
                ("point", M.read (| point |));
                ("rotation", M.read (| rotation |));
                ("eval", M.read (| eval |));
                ("commitment",
                  Value.StructTuple
                    "halo2_proofs::poly::multiopen::CommitmentReference::MSM"
                    [ M.read (| msm |) ])
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_msm :
        forall (C : Ty.t),
        M.IsAssociatedFunction (Self C) "new_msm" (new_msm C).
    End Impl_halo2_proofs_poly_multiopen_VerifierQuery_C.
    
    (*
    Enum CommitmentReference
    {
      ty_params := [ "C" ];
      variants :=
        [
          {
            name := "Commitment";
            item := StructTuple [ Ty.apply (Ty.path "&") [ C ] ];
            discriminant := None;
          };
          {
            name := "MSM";
            item :=
              StructTuple
                [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "halo2_proofs::poly::msm::MSM") [ C ] ]
                ];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_poly_multiopen_CommitmentReference_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::CommitmentReference") [ C ].
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_poly_multiopen_CommitmentReference_C.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_poly_multiopen_CommitmentReference_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::CommitmentReference") [ C ].
      
      (* Clone *)
      Definition clone (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::poly::multiopen::CommitmentReference::Commitment",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::poly::multiopen::CommitmentReference::Commitment"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply (Ty.path "&") [ C ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::poly::multiopen::CommitmentReference::MSM",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "halo2_proofs::poly::multiopen::CommitmentReference::MSM"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "&")
                                  [ Ty.apply (Ty.path "halo2_proofs::poly::msm::MSM") [ C ] ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone C)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_poly_multiopen_CommitmentReference_C.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_poly_multiopen_CommitmentReference_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::CommitmentReference") [ C ].
      
      (* Debug *)
      Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::poly::multiopen::CommitmentReference::Commitment",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "Commitment" |);
                            (* Unsize *) M.pointer_coercion __self_0
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "halo2_proofs::poly::multiopen::CommitmentReference::MSM",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            []
                          |),
                          [
                            M.read (| f |);
                            M.read (| Value.String "MSM" |);
                            (* Unsize *) M.pointer_coercion __self_0
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_poly_multiopen_CommitmentReference_C.
    
    Module Impl_core_cmp_PartialEq_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_poly_multiopen_CommitmentReference_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::CommitmentReference") [ C ].
      
      (*
          fn eq(&self, other: &Self) -> bool {
              match (self, other) {
                  (&CommitmentReference::Commitment(a), &CommitmentReference::Commitment(b)) => {
                      std::ptr::eq(a, b)
                  }
                  (&CommitmentReference::MSM(a), &CommitmentReference::MSM(b)) => std::ptr::eq(a, b),
                  _ => false,
              }
          }
      *)
      Definition eq (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_0 := M.read (| γ0_0 |) in
                      let γ2_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "halo2_proofs::poly::multiopen::CommitmentReference::Commitment",
                          0
                        |) in
                      let a := M.copy (| γ2_0 |) in
                      let γ0_1 := M.read (| γ0_1 |) in
                      let γ2_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "halo2_proofs::poly::multiopen::CommitmentReference::Commitment",
                          0
                        |) in
                      let b := M.copy (| γ2_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::ptr::eq", [ C ] |),
                          [ M.read (| a |); M.read (| b |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_0 := M.read (| γ0_0 |) in
                      let γ2_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_0,
                          "halo2_proofs::poly::multiopen::CommitmentReference::MSM",
                          0
                        |) in
                      let a := M.copy (| γ2_0 |) in
                      let γ0_1 := M.read (| γ0_1 |) in
                      let γ2_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ0_1,
                          "halo2_proofs::poly::multiopen::CommitmentReference::MSM",
                          0
                        |) in
                      let b := M.copy (| γ2_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::ptr::eq",
                            [ Ty.apply (Ty.path "halo2_proofs::poly::msm::MSM") [ C ] ]
                          |),
                          [ M.read (| a |); M.read (| b |) ]
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq C)) ].
    End Impl_core_cmp_PartialEq_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_poly_multiopen_CommitmentReference_C.
    
    (* Trait *)
    (* Empty module 'Query' *)
    
    (* StructRecord
      {
        name := "PolynomialPointer";
        ty_params := [ "C" ];
        fields :=
          [
            ("poly",
              Ty.apply
                (Ty.path "&")
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::poly::Polynomial")
                    [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]
                ])
          ];
      } *)
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_marker_Copy_associated_type_for_halo2_proofs_poly_multiopen_PolynomialPointer_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::PolynomialPointer") [ C ].
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_marker_Copy_associated_type_for_halo2_proofs_poly_multiopen_PolynomialPointer_C.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_associated_type_for_halo2_proofs_poly_multiopen_PolynomialPointer_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::PolynomialPointer") [ C ].
      
      (* Clone *)
      Definition clone (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::poly::multiopen::PolynomialPointer"
              [
                ("poly",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "&")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::poly::Polynomial")
                            [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::PolynomialPointer",
                        "poly"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone C)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_associated_type_for_halo2_proofs_poly_multiopen_PolynomialPointer_C.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_for_halo2_proofs_poly_multiopen_PolynomialPointer_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::PolynomialPointer") [ C ].
      
      (* Debug *)
      Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "PolynomialPointer" |);
                M.read (| Value.String "poly" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::PolynomialPointer",
                      "poly"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_associated_type_for_halo2_proofs_poly_multiopen_PolynomialPointer_C.
    
    Module Impl_core_cmp_PartialEq_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_poly_multiopen_PolynomialPointer_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::PolynomialPointer") [ C ].
      
      (*
          fn eq(&self, other: &Self) -> bool {
              std::ptr::eq(self.poly, other.poly)
          }
      *)
      Definition eq (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_function (|
                "core::ptr::eq",
                [
                  Ty.apply
                    (Ty.path "halo2_proofs::poly::Polynomial")
                    [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ]
                ]
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::multiopen::PolynomialPointer",
                    "poly"
                  |)
                |);
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "halo2_proofs::poly::multiopen::PolynomialPointer",
                    "poly"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq C)) ].
    End Impl_core_cmp_PartialEq_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_poly_multiopen_PolynomialPointer_C.
    
    Module Impl_halo2_proofs_poly_multiopen_Query_where_pairing_bn256_arithmetic_curves_CurveAffine_C_associated_type_for_halo2_proofs_poly_multiopen_ProverQuery_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::ProverQuery") [ C ].
      
      (*     type Commitment = PolynomialPointer<'a, C>; *)
      Definition _Commitment (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::PolynomialPointer") [ C ].
      
      (*
          fn get_point(&self) -> C::Scalar {
              self.point
          }
      *)
      Definition get_point (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::multiopen::ProverQuery",
                "point"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn get_rotation(&self) -> Rotation {
              self.rotation
          }
      *)
      Definition get_rotation (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::multiopen::ProverQuery",
                "rotation"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn get_eval(&self) -> C::Scalar {
              eval_polynomial(self.poly, self.get_point())
          }
      *)
      Definition get_eval (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (| "halo2_proofs::arithmetic::eval_polynomial", [ Ty.associated ] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply
                      (Ty.path "halo2_proofs::poly::Polynomial")
                      [ Ty.associated; Ty.path "halo2_proofs::poly::Coeff" ],
                    [],
                    "deref",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::ProverQuery",
                        "poly"
                      |)
                    |)
                  ]
                |);
                M.call_closure (|
                  M.get_trait_method (|
                    "halo2_proofs::poly::multiopen::Query",
                    Ty.apply (Ty.path "halo2_proofs::poly::multiopen::ProverQuery") [ C ],
                    [ Ty.associated ],
                    "get_point",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn get_commitment(&self) -> Self::Commitment {
              PolynomialPointer { poly: self.poly }
          }
      *)
      Definition get_commitment (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "halo2_proofs::poly::multiopen::PolynomialPointer"
              [
                ("poly",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::ProverQuery",
                      "poly"
                    |)
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "halo2_proofs::poly::multiopen::Query"
          (Self C)
          (* Trait polymorphic types *) [ (* F *) Ty.associated ]
          (* Instance *)
          [
            ("Commitment", InstanceField.Ty (_Commitment C));
            ("get_point", InstanceField.Method (get_point C));
            ("get_rotation", InstanceField.Method (get_rotation C));
            ("get_eval", InstanceField.Method (get_eval C));
            ("get_commitment", InstanceField.Method (get_commitment C))
          ].
    End Impl_halo2_proofs_poly_multiopen_Query_where_pairing_bn256_arithmetic_curves_CurveAffine_C_associated_type_for_halo2_proofs_poly_multiopen_ProverQuery_C.
    
    Module Impl_halo2_proofs_poly_multiopen_Query_where_pairing_bn256_arithmetic_curves_CurveAffine_C_associated_type_for_halo2_proofs_poly_multiopen_VerifierQuery_C.
      Definition Self (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::VerifierQuery") [ C ].
      
      (*     type Commitment = CommitmentReference<'a, C>; *)
      Definition _Commitment (C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "halo2_proofs::poly::multiopen::CommitmentReference") [ C ].
      
      (*
          fn get_point(&self) -> C::Scalar {
              self.point
          }
      *)
      Definition get_point (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::multiopen::VerifierQuery",
                "point"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn get_rotation(&self) -> Rotation {
              self.rotation
          }
      *)
      Definition get_rotation (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::multiopen::VerifierQuery",
                "rotation"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn get_eval(&self) -> C::Scalar {
              self.eval
          }
      *)
      Definition get_eval (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::multiopen::VerifierQuery",
                "eval"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn get_commitment(&self) -> Self::Commitment {
              self.commitment
          }
      *)
      Definition get_commitment (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self C in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "halo2_proofs::poly::multiopen::VerifierQuery",
                "commitment"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (C : Ty.t),
        M.IsTraitInstance
          "halo2_proofs::poly::multiopen::Query"
          (Self C)
          (* Trait polymorphic types *) [ (* F *) Ty.associated ]
          (* Instance *)
          [
            ("Commitment", InstanceField.Ty (_Commitment C));
            ("get_point", InstanceField.Method (get_point C));
            ("get_rotation", InstanceField.Method (get_rotation C));
            ("get_eval", InstanceField.Method (get_eval C));
            ("get_commitment", InstanceField.Method (get_commitment C))
          ].
    End Impl_halo2_proofs_poly_multiopen_Query_where_pairing_bn256_arithmetic_curves_CurveAffine_C_associated_type_for_halo2_proofs_poly_multiopen_VerifierQuery_C.
  End multiopen.
End poly.
