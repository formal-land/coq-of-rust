(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module poly.
  Module multiopen.
    Module gwc.
      (* StructTuple
        {
          name := "U";
          ty_params := [];
          fields := [];
        } *)
      
      Module Impl_core_clone_Clone_for_halo2_proofs_poly_multiopen_gwc_U.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::gwc::U".
        
        (* Clone *)
        Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| M.read (| self |) |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_halo2_proofs_poly_multiopen_gwc_U.
      
      Module Impl_core_marker_Copy_for_halo2_proofs_poly_multiopen_gwc_U.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::gwc::U".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_halo2_proofs_poly_multiopen_gwc_U.
      
      Module Impl_core_fmt_Debug_for_halo2_proofs_poly_multiopen_gwc_U.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::gwc::U".
        
        (* Debug *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
                [ M.read (| f |); M.read (| Value.String "U" |) ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_halo2_proofs_poly_multiopen_gwc_U.
      
      Axiom ChallengeU :
        forall (F : Ty.t),
        (Ty.apply (Ty.path "halo2_proofs::poly::multiopen::gwc::ChallengeU") [ F ]) =
          (Ty.apply
            (Ty.path "halo2_proofs::transcript::ChallengeScalar")
            [ F; Ty.path "halo2_proofs::poly::multiopen::gwc::U" ]).
      
      (* StructTuple
        {
          name := "V";
          ty_params := [];
          fields := [];
        } *)
      
      Module Impl_core_clone_Clone_for_halo2_proofs_poly_multiopen_gwc_V.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::gwc::V".
        
        (* Clone *)
        Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| M.read (| self |) |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_halo2_proofs_poly_multiopen_gwc_V.
      
      Module Impl_core_marker_Copy_for_halo2_proofs_poly_multiopen_gwc_V.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::gwc::V".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_halo2_proofs_poly_multiopen_gwc_V.
      
      Module Impl_core_fmt_Debug_for_halo2_proofs_poly_multiopen_gwc_V.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::gwc::V".
        
        (* Debug *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
                [ M.read (| f |); M.read (| Value.String "V" |) ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_halo2_proofs_poly_multiopen_gwc_V.
      
      Axiom ChallengeV :
        forall (F : Ty.t),
        (Ty.apply (Ty.path "halo2_proofs::poly::multiopen::gwc::ChallengeV") [ F ]) =
          (Ty.apply
            (Ty.path "halo2_proofs::transcript::ChallengeScalar")
            [ F; Ty.path "halo2_proofs::poly::multiopen::gwc::V" ]).
      
      (* StructRecord
        {
          name := "CommitmentData";
          ty_params := [ "F"; "Q" ];
          fields :=
            [
              ("queries",
                Ty.apply (Ty.path "alloc::vec::Vec") [ Q; Ty.path "alloc::alloc::Global" ]);
              ("point", F);
              ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ F ])
            ];
        } *)
      
      (*
      fn construct_intermediate_sets<F: FieldExt, I, Q: Query<F>>(queries: I) -> Vec<CommitmentData<F, Q>>
      where
          I: IntoIterator<Item = Q>,
      {
          let mut point_query_map: BTreeMap<Rotation, Vec<Q>> = BTreeMap::new();
          for query in queries {
              if let Some(queries) = point_query_map.get_mut(&query.get_rotation()) {
                  queries.push(query);
              } else {
                  point_query_map.insert(query.get_rotation(), vec![query]);
              }
          }
      
          point_query_map
              .into_iter()
              .map(|(_, queries)| {
                  let point = queries[0].get_point();
                  CommitmentData {
                      queries,
                      point,
                      _marker: PhantomData,
                  }
              })
              .collect()
      }
      *)
      Definition construct_intermediate_sets (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F; _ as I; Q ], [ queries ] =>
          ltac:(M.monadic
            (let queries := M.alloc (| queries |) in
            M.read (|
              let point_query_map :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        [
                          Ty.path "halo2_proofs::poly::Rotation";
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Q; Ty.path "alloc::alloc::Global" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |)
                |) in
              let _ :=
                M.use
                  (M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          I,
                          [],
                          "into_iter",
                          []
                        |),
                        [ M.read (| queries |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            ltac:(M.monadic
                              (let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.associated,
                                        [],
                                        "next",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let query := M.copy (| γ0_0 |) in
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::map::BTreeMap")
                                                          [
                                                            Ty.path "halo2_proofs::poly::Rotation";
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [ Q; Ty.path "alloc::alloc::Global" ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        "get_mut",
                                                        [ Ty.path "halo2_proofs::poly::Rotation" ]
                                                      |),
                                                      [
                                                        point_query_map;
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "halo2_proofs::poly::multiopen::Query",
                                                              Q,
                                                              [ F ],
                                                              "get_rotation",
                                                              []
                                                            |),
                                                            [ query ]
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let queries := M.copy (| γ0_0 |) in
                                                let _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          [ Q; Ty.path "alloc::alloc::Global" ],
                                                        "push",
                                                        []
                                                      |),
                                                      [ M.read (| queries |); M.read (| query |) ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::map::BTreeMap")
                                                          [
                                                            Ty.path "halo2_proofs::poly::Rotation";
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [ Q; Ty.path "alloc::alloc::Global" ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        "insert",
                                                        []
                                                      |),
                                                      [
                                                        point_query_map;
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "halo2_proofs::poly::multiopen::Query",
                                                            Q,
                                                            [ F ],
                                                            "get_rotation",
                                                            []
                                                          |),
                                                          [ query ]
                                                        |);
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [ Q ],
                                                            "into_vec",
                                                            [ Ty.path "alloc::alloc::Global" ]
                                                          |),
                                                          [
                                                            (* Unsize *)
                                                            M.pointer_coercion
                                                              (M.read (|
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "alloc::boxed::Box")
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "array")
                                                                          [ Q ];
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    "new",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.alloc (|
                                                                      Value.Array
                                                                        [ M.read (| query |) ]
                                                                    |)
                                                                  ]
                                                                |)
                                                              |))
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |)) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::IntoIter")
                          [
                            Ty.path "halo2_proofs::poly::Rotation";
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Q; Ty.path "alloc::alloc::Global" ];
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.tuple
                                  [
                                    Ty.path "halo2_proofs::poly::Rotation";
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [ Q; Ty.path "alloc::alloc::Global" ]
                                  ]
                              ]
                          ]
                          (Ty.apply
                            (Ty.path "halo2_proofs::poly::multiopen::gwc::CommitmentData")
                            [ F; Q ])
                      ],
                    [],
                    "collect",
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::poly::multiopen::gwc::CommitmentData")
                            [ F; Q ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::IntoIter")
                          [
                            Ty.path "halo2_proofs::poly::Rotation";
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Q; Ty.path "alloc::alloc::Global" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        "map",
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::poly::multiopen::gwc::CommitmentData")
                            [ F; Q ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "halo2_proofs::poly::Rotation";
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [ Q; Ty.path "alloc::alloc::Global" ]
                                    ]
                                ]
                            ]
                            (Ty.apply
                              (Ty.path "halo2_proofs::poly::multiopen::gwc::CommitmentData")
                              [ F; Q ])
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::BTreeMap")
                              [
                                Ty.path "halo2_proofs::poly::Rotation";
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [ Q; Ty.path "alloc::alloc::Global" ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            "into_iter",
                            []
                          |),
                          [ M.read (| point_query_map |) ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let queries := M.copy (| γ0_1 |) in
                                        M.read (|
                                          let point :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "halo2_proofs::poly::multiopen::Query",
                                                  Q,
                                                  [ F ],
                                                  "get_point",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::index::Index",
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [ Q; Ty.path "alloc::alloc::Global" ],
                                                      [ Ty.path "usize" ],
                                                      "index",
                                                      []
                                                    |),
                                                    [ queries; Value.Integer 0 ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          M.alloc (|
                                            Value.StructRecord
                                              "halo2_proofs::poly::multiopen::gwc::CommitmentData"
                                              [
                                                ("queries", M.read (| queries |));
                                                ("point", M.read (| point |));
                                                ("_marker",
                                                  Value.StructTuple "core::marker::PhantomData" [])
                                              ]
                                          |)
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
    End gwc.
  End multiopen.
End poly.
