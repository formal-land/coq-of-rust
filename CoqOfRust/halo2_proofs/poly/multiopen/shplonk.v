(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module poly.
  Module multiopen.
    Module shplonk.
      (* StructTuple
        {
          name := "U";
          ty_params := [];
          fields := [];
        } *)
      
      Module Impl_core_clone_Clone_for_halo2_proofs_poly_multiopen_shplonk_U.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::shplonk::U".
        
        (* Clone *)
        Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| M.read (| self |) |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_halo2_proofs_poly_multiopen_shplonk_U.
      
      Module Impl_core_marker_Copy_for_halo2_proofs_poly_multiopen_shplonk_U.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::shplonk::U".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_halo2_proofs_poly_multiopen_shplonk_U.
      
      Module Impl_core_fmt_Debug_for_halo2_proofs_poly_multiopen_shplonk_U.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::shplonk::U".
        
        (* Debug *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
                [ M.read (| f |); M.read (| Value.String "U" |) ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_halo2_proofs_poly_multiopen_shplonk_U.
      
      Axiom ChallengeU :
        forall (F : Ty.t),
        (Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::ChallengeU") [ F ]) =
          (Ty.apply
            (Ty.path "halo2_proofs::transcript::ChallengeScalar")
            [ F; Ty.path "halo2_proofs::poly::multiopen::shplonk::U" ]).
      
      (* StructTuple
        {
          name := "V";
          ty_params := [];
          fields := [];
        } *)
      
      Module Impl_core_clone_Clone_for_halo2_proofs_poly_multiopen_shplonk_V.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::shplonk::V".
        
        (* Clone *)
        Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| M.read (| self |) |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_halo2_proofs_poly_multiopen_shplonk_V.
      
      Module Impl_core_marker_Copy_for_halo2_proofs_poly_multiopen_shplonk_V.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::shplonk::V".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_halo2_proofs_poly_multiopen_shplonk_V.
      
      Module Impl_core_fmt_Debug_for_halo2_proofs_poly_multiopen_shplonk_V.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::shplonk::V".
        
        (* Debug *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
                [ M.read (| f |); M.read (| Value.String "V" |) ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_halo2_proofs_poly_multiopen_shplonk_V.
      
      Axiom ChallengeV :
        forall (F : Ty.t),
        (Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::ChallengeV") [ F ]) =
          (Ty.apply
            (Ty.path "halo2_proofs::transcript::ChallengeScalar")
            [ F; Ty.path "halo2_proofs::poly::multiopen::shplonk::V" ]).
      
      (* StructTuple
        {
          name := "Y";
          ty_params := [];
          fields := [];
        } *)
      
      Module Impl_core_clone_Clone_for_halo2_proofs_poly_multiopen_shplonk_Y.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::shplonk::Y".
        
        (* Clone *)
        Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| M.read (| self |) |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_halo2_proofs_poly_multiopen_shplonk_Y.
      
      Module Impl_core_marker_Copy_for_halo2_proofs_poly_multiopen_shplonk_Y.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::shplonk::Y".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::Copy"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_halo2_proofs_poly_multiopen_shplonk_Y.
      
      Module Impl_core_fmt_Debug_for_halo2_proofs_poly_multiopen_shplonk_Y.
        Definition Self : Ty.t := Ty.path "halo2_proofs::poly::multiopen::shplonk::Y".
        
        (* Debug *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
                [ M.read (| f |); M.read (| Value.String "Y" |) ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_halo2_proofs_poly_multiopen_shplonk_Y.
      
      Axiom ChallengeY :
        forall (F : Ty.t),
        (Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::ChallengeY") [ F ]) =
          (Ty.apply
            (Ty.path "halo2_proofs::transcript::ChallengeScalar")
            [ F; Ty.path "halo2_proofs::poly::multiopen::shplonk::Y" ]).
      
      (* StructTuple
        {
          name := "Commitment";
          ty_params := [ "F"; "T" ];
          fields :=
            [
              Ty.tuple
                [ T; Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ] ]
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_fmt_Debug_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_Commitment_F_T.
        Definition Self (F T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::Commitment") [ F; T ].
        
        (* Debug *)
        Definition fmt (F T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F T in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_tuple_field1_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "Commitment" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::shplonk::Commitment",
                        0
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_fmt_Debug_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_Commitment_F_T.
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_clone_Clone_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_Commitment_F_T.
        Definition Self (F T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::Commitment") [ F; T ].
        
        (* Clone *)
        Definition clone (F T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F T in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructTuple
                "halo2_proofs::poly::multiopen::shplonk::Commitment"
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.tuple
                        [
                          T;
                          Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ]
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_tuple_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::shplonk::Commitment",
                        0
                      |)
                    ]
                  |)
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self F T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone F T)) ].
      End Impl_core_clone_Clone_where_core_clone_Clone_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_clone_Clone_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_Commitment_F_T.
      
      Module Impl_core_marker_StructuralPartialEq_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_Commitment_F_T.
        Definition Self (F T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::Commitment") [ F; T ].
        
        Axiom Implements :
          forall (F T : Ty.t),
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            (Self F T)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_Commitment_F_T.
      
      Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_cmp_PartialEq_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_Commitment_F_T.
        Definition Self (F T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::Commitment") [ F; T ].
        
        (* PartialEq *)
        Definition eq (F T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F T in
          match τ, α with
          | [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.tuple
                    [ T; Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ]
                    ],
                  [
                    Ty.tuple
                      [
                        T;
                        Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ]
                      ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::poly::multiopen::shplonk::Commitment",
                    0
                  |);
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| other |),
                    "halo2_proofs::poly::multiopen::shplonk::Commitment",
                    0
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F T : Ty.t),
          M.IsTraitInstance
            "core::cmp::PartialEq"
            (Self F T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method (eq F T)) ].
      End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_cmp_PartialEq_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_Commitment_F_T.
      
      Module Impl_halo2_proofs_poly_multiopen_shplonk_Commitment_F_T.
        Definition Self (F T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::Commitment") [ F; T ].
        
        (*
            fn get(&self) -> T {
                self.0 .0.clone()
            }
        *)
        Definition get (F T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F T in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                [
                  M.SubPointer.get_tuple_field (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::shplonk::Commitment",
                      0
                    |),
                    0
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_get :
          forall (F T : Ty.t),
          M.IsAssociatedFunction (Self F T) "get" (get F T).
        
        (*
            fn evals(&self) -> Vec<F> {
                self.0 .1.clone()
            }
        *)
        Definition evals (F T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F T in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                  [],
                  "clone",
                  []
                |),
                [
                  M.SubPointer.get_tuple_field (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::shplonk::Commitment",
                      0
                    |),
                    1
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_evals :
          forall (F T : Ty.t),
          M.IsAssociatedFunction (Self F T) "evals" (evals F T).
      End Impl_halo2_proofs_poly_multiopen_shplonk_Commitment_F_T.
      
      (* StructRecord
        {
          name := "RotationSet";
          ty_params := [ "F"; "T" ];
          fields :=
            [
              ("commitments",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.apply
                      (Ty.path "halo2_proofs::poly::multiopen::shplonk::Commitment")
                      [ F; T ];
                    Ty.path "alloc::alloc::Global"
                  ]);
              ("points", Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_fmt_Debug_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_RotationSet_F_T.
        Definition Self (F T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet") [ F; T ].
        
        (* Debug *)
        Definition fmt (F T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F T in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field2_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "RotationSet" |);
                  M.read (| Value.String "commitments" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::shplonk::RotationSet",
                      "commitments"
                    |));
                  M.read (| Value.String "points" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::shplonk::RotationSet",
                        "points"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_fmt_Debug_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_RotationSet_F_T.
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_clone_Clone_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_RotationSet_F_T.
        Definition Self (F T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet") [ F; T ].
        
        (* Clone *)
        Definition clone (F T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F T in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "halo2_proofs::poly::multiopen::shplonk::RotationSet"
                [
                  ("commitments",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.apply
                              (Ty.path "halo2_proofs::poly::multiopen::shplonk::Commitment")
                              [ F; T ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::poly::multiopen::shplonk::RotationSet",
                          "commitments"
                        |)
                      ]
                    |));
                  ("points",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::poly::multiopen::shplonk::RotationSet",
                          "points"
                        |)
                      ]
                    |))
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self F T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone F T)) ].
      End Impl_core_clone_Clone_where_core_clone_Clone_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_clone_Clone_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_RotationSet_F_T.
      
      Module Impl_core_marker_StructuralPartialEq_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_RotationSet_F_T.
        Definition Self (F T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet") [ F; T ].
        
        Axiom Implements :
          forall (F T : Ty.t),
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            (Self F T)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_RotationSet_F_T.
      
      Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_cmp_PartialEq_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_RotationSet_F_T.
        Definition Self (F T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet") [ F; T ].
        
        (* PartialEq *)
        Definition eq (F T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F T in
          match τ, α with
          | [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              LogicalOp.and (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.apply
                          (Ty.path "halo2_proofs::poly::multiopen::shplonk::Commitment")
                          [ F; T ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::poly::multiopen::shplonk::Commitment")
                            [ F; T ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "eq",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::shplonk::RotationSet",
                      "commitments"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "halo2_proofs::poly::multiopen::shplonk::RotationSet",
                      "commitments"
                    |)
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                      [ Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ]
                      ],
                      "eq",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::shplonk::RotationSet",
                        "points"
                      |);
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "halo2_proofs::poly::multiopen::shplonk::RotationSet",
                        "points"
                      |)
                    ]
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F T : Ty.t),
          M.IsTraitInstance
            "core::cmp::PartialEq"
            (Self F T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method (eq F T)) ].
      End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_cmp_PartialEq_T_where_core_cmp_PartialEq_T_where_core_clone_Clone_T_for_halo2_proofs_poly_multiopen_shplonk_RotationSet_F_T.
      
      (* StructRecord
        {
          name := "IntermediateSets";
          ty_params := [ "F"; "Q" ];
          fields :=
            [
              ("rotation_sets",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.apply
                      (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet")
                      [ F; Ty.associated ];
                    Ty.path "alloc::alloc::Global"
                  ]);
              ("super_point_set",
                Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_fmt_Debug_Q_where_halo2_proofs_poly_multiopen_Query_Q_F_where_core_fmt_Debug_associated_type_for_halo2_proofs_poly_multiopen_shplonk_IntermediateSets_F_Q.
        Definition Self (F Q : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::IntermediateSets") [ F; Q ].
        
        (* Debug *)
        Definition fmt (F Q : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F Q in
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field2_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "IntermediateSets" |);
                  M.read (| Value.String "rotation_sets" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::shplonk::IntermediateSets",
                      "rotation_sets"
                    |));
                  M.read (| Value.String "super_point_set" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::shplonk::IntermediateSets",
                        "super_point_set"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F Q : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self F Q)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt F Q)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_fmt_Debug_Q_where_halo2_proofs_poly_multiopen_Query_Q_F_where_core_fmt_Debug_associated_type_for_halo2_proofs_poly_multiopen_shplonk_IntermediateSets_F_Q.
      
      Module Impl_core_marker_StructuralPartialEq_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_halo2_proofs_poly_multiopen_Query_Q_F_for_halo2_proofs_poly_multiopen_shplonk_IntermediateSets_F_Q.
        Definition Self (F Q : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::IntermediateSets") [ F; Q ].
        
        Axiom Implements :
          forall (F Q : Ty.t),
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            (Self F Q)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_halo2_proofs_poly_multiopen_Query_Q_F_for_halo2_proofs_poly_multiopen_shplonk_IntermediateSets_F_Q.
      
      Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_cmp_PartialEq_Q_where_halo2_proofs_poly_multiopen_Query_Q_F_where_core_cmp_PartialEq_associated_type_for_halo2_proofs_poly_multiopen_shplonk_IntermediateSets_F_Q.
        Definition Self (F Q : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "halo2_proofs::poly::multiopen::shplonk::IntermediateSets") [ F; Q ].
        
        (* PartialEq *)
        Definition eq (F Q : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F Q in
          match τ, α with
          | [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              LogicalOp.and (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.apply
                          (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet")
                          [ F; Ty.associated ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet")
                            [ F; Ty.associated ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "eq",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::poly::multiopen::shplonk::IntermediateSets",
                      "rotation_sets"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "halo2_proofs::poly::multiopen::shplonk::IntermediateSets",
                      "rotation_sets"
                    |)
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ],
                      [ Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ]
                      ],
                      "eq",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::poly::multiopen::shplonk::IntermediateSets",
                        "super_point_set"
                      |);
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "halo2_proofs::poly::multiopen::shplonk::IntermediateSets",
                        "super_point_set"
                      |)
                    ]
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F Q : Ty.t),
          M.IsTraitInstance
            "core::cmp::PartialEq"
            (Self F Q)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method (eq F Q)) ].
      End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_pairing_bn256_arithmetic_fields_FieldExt_F_where_core_cmp_PartialEq_Q_where_halo2_proofs_poly_multiopen_Query_Q_F_where_core_cmp_PartialEq_associated_type_for_halo2_proofs_poly_multiopen_shplonk_IntermediateSets_F_Q.
      
      (*
      fn construct_intermediate_sets<F: FieldExt, I, Q: Query<F>>(queries: I) -> IntermediateSets<F, Q>
      where
          I: IntoIterator<Item = Q> + Clone,
      {
          let queries = queries.into_iter().collect::<Vec<_>>();
      
          // Find evaluation of a commitment at a rotation
          let get_eval = |commitment: Q::Commitment, rotation: Rotation| -> F {
              queries
                  .iter()
                  .find(|query| query.get_commitment() == commitment && query.get_rotation() == rotation)
                  .unwrap()
                  .get_eval()
          };
      
          // Order points according to their rotation
          let mut rotation_point_map = BTreeMap::new();
          for query in queries.clone() {
              let point = rotation_point_map
                  .entry(query.get_rotation())
                  .or_insert_with(|| query.get_point());
      
              // Assert rotation point matching consistency
              assert_eq!( *point, query.get_point());
          }
          // All points appear in queries
          let super_point_set: Vec<F> = rotation_point_map.values().cloned().collect();
      
          // Collect rotation sets for each commitment
          // Example elements in the vector:
          // (C_0, {r_5}),
          // (C_1, {r_1, r_2, r_3}),
          // (C_2, {r_2, r_3, r_4}),
          // (C_3, {r_2, r_3, r_4}),
          // ...
          let mut commitment_rotation_set_map: Vec<(Q::Commitment, BTreeSet<Rotation>)> = vec![];
          for query in queries.clone() {
              let rotation = query.get_rotation();
              if let Some(pos) = commitment_rotation_set_map
                  .iter()
                  .position(|(commitment, _)| *commitment == query.get_commitment())
              {
                  let (_, rotation_set) = &mut commitment_rotation_set_map[pos];
                  rotation_set.insert(rotation);
              } else {
                  let rotation_set = BTreeSet::from([rotation]);
                  commitment_rotation_set_map.push((query.get_commitment(), rotation_set));
              };
          }
      
          // Flatten rotation sets and collect commitments that opens against each commitment set
          // Example elements in the vector:
          // {r_5}: [C_0],
          // {r_1, r_2, r_3} : [C_1]
          // {r_2, r_3, r_4} : [C_2, C_3],
          // ...
          let mut rotation_set_commitment_map = BTreeMap::<BTreeSet<_>, Vec<Q::Commitment>>::new();
          for (commitment, rotation_set) in commitment_rotation_set_map.iter() {
              let commitments = rotation_set_commitment_map
                  .entry(rotation_set.clone())
                  .or_insert_with(Vec::new);
              if !commitments.contains(commitment) {
                  commitments.push(commitment.clone());
              }
          }
      
          let rotation_sets = rotation_set_commitment_map
              .into_iter()
              .map(|(rotation_set, commitments)| {
                  let rotations: Vec<Rotation> = rotation_set.iter().cloned().collect();
      
                  let commitments: Vec<Commitment<F, Q::Commitment>> = commitments
                      .iter()
                      .map(|commitment| {
                          let evals: Vec<F> = rotations
                              .iter()
                              .map(|rotation| get_eval(commitment.clone(), *rotation))
                              .collect();
                          Commitment((commitment.clone(), evals))
                      })
                      .collect();
      
                  RotationSet {
                      commitments,
                      points: rotations
                          .iter()
                          .map(|rotation| *rotation_point_map.get(rotation).unwrap())
                          .collect(),
                  }
              })
              .collect::<Vec<RotationSet<_, _>>>();
      
          IntermediateSets {
              rotation_sets,
              super_point_set,
          }
      }
      *)
      Definition construct_intermediate_sets (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ F; _ as I; Q ], [ queries ] =>
          ltac:(M.monadic
            (let queries := M.alloc (| queries |) in
            M.read (|
              let queries :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.associated,
                      [],
                      "collect",
                      [ Ty.apply (Ty.path "alloc::vec::Vec") [ Q; Ty.path "alloc::alloc::Global" ] ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          I,
                          [],
                          "into_iter",
                          []
                        |),
                        [ M.read (| queries |) ]
                      |)
                    ]
                  |)
                |) in
              let get_eval :=
                M.alloc (|
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let commitment := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let rotation := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "halo2_proofs::poly::multiopen::Query",
                                              Q,
                                              [ F ],
                                              "get_eval",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    [ Ty.apply (Ty.path "&") [ Q ] ],
                                                  "unwrap",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        [ Q ],
                                                      [],
                                                      "find",
                                                      [
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [ Ty.apply (Ty.path "&") [ Q ] ]
                                                              ]
                                                          ]
                                                          (Ty.path "bool")
                                                      ]
                                                    |),
                                                    [
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [ Q ],
                                                            "iter",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::deref::Deref",
                                                                Ty.apply
                                                                  (Ty.path "alloc::vec::Vec")
                                                                  [
                                                                    Q;
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                [],
                                                                "deref",
                                                                []
                                                              |),
                                                              [ queries ]
                                                            |)
                                                          ]
                                                        |)
                                                      |);
                                                      M.closure
                                                        (fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [ α0 ] =>
                                                              M.match_operator (|
                                                                M.alloc (| α0 |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let query :=
                                                                        M.copy (| γ |) in
                                                                      LogicalOp.and (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::cmp::PartialEq",
                                                                            Ty.associated,
                                                                            [ Ty.associated ],
                                                                            "eq",
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.alloc (|
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "halo2_proofs::poly::multiopen::Query",
                                                                                  Q,
                                                                                  [ F ],
                                                                                  "get_commitment",
                                                                                  []
                                                                                |),
                                                                                [
                                                                                  M.read (|
                                                                                    M.read (|
                                                                                      query
                                                                                    |)
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            |);
                                                                            commitment
                                                                          ]
                                                                        |),
                                                                        ltac:(M.monadic
                                                                          (M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::cmp::PartialEq",
                                                                              Ty.path
                                                                                "halo2_proofs::poly::Rotation",
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::poly::Rotation"
                                                                              ],
                                                                              "eq",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.alloc (|
                                                                                M.call_closure (|
                                                                                  M.get_trait_method (|
                                                                                    "halo2_proofs::poly::multiopen::Query",
                                                                                    Q,
                                                                                    [ F ],
                                                                                    "get_rotation",
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.read (|
                                                                                      M.read (|
                                                                                        query
                                                                                      |)
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              |);
                                                                              rotation
                                                                            ]
                                                                          |)))
                                                                      |)))
                                                                ]
                                                              |)
                                                            | _ => M.impossible (||)
                                                            end))
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                |) in
              let rotation_point_map :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        [ Ty.path "halo2_proofs::poly::Rotation"; F; Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |)
                |) in
              let _ :=
                M.use
                  (M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Q; Ty.path "alloc::alloc::Global" ],
                          [],
                          "into_iter",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Q; Ty.path "alloc::alloc::Global" ],
                              [],
                              "clone",
                              []
                            |),
                            [ queries ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            ltac:(M.monadic
                              (let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [ Q; Ty.path "alloc::alloc::Global" ],
                                        [],
                                        "next",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let query := M.copy (| γ0_0 |) in
                                        let point :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::map::entry::Entry")
                                                  [
                                                    Ty.path "halo2_proofs::poly::Rotation";
                                                    F;
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                "or_insert_with",
                                                [ Ty.function [ Ty.tuple [] ] F ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::map::BTreeMap")
                                                      [
                                                        Ty.path "halo2_proofs::poly::Rotation";
                                                        F;
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "entry",
                                                    []
                                                  |),
                                                  [
                                                    rotation_point_map;
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "halo2_proofs::poly::multiopen::Query",
                                                        Q,
                                                        [ F ],
                                                        "get_rotation",
                                                        []
                                                      |),
                                                      [ query ]
                                                    |)
                                                  ]
                                                |);
                                                M.closure
                                                  (fun γ =>
                                                    ltac:(M.monadic
                                                      match γ with
                                                      | [ α0 ] =>
                                                        M.match_operator (|
                                                          M.alloc (| α0 |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "halo2_proofs::poly::multiopen::Query",
                                                                    Q,
                                                                    [ F ],
                                                                    "get_point",
                                                                    []
                                                                  |),
                                                                  [ query ]
                                                                |)))
                                                          ]
                                                        |)
                                                      | _ => M.impossible (||)
                                                      end))
                                              ]
                                            |)
                                          |) in
                                        let _ :=
                                          M.match_operator (|
                                            M.alloc (|
                                              Value.Tuple
                                                [
                                                  M.read (| point |);
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "halo2_proofs::poly::multiopen::Query",
                                                        Q,
                                                        [ F ],
                                                        "get_point",
                                                        []
                                                      |),
                                                      [ query ]
                                                    |)
                                                  |)
                                                ]
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                  let γ0_1 :=
                                                    M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                  let left_val := M.copy (| γ0_0 |) in
                                                  let right_val := M.copy (| γ0_1 |) in
                                                  M.match_operator (|
                                                    M.alloc (| Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use
                                                              (M.alloc (|
                                                                UnOp.Pure.not
                                                                  (M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::cmp::PartialEq",
                                                                      F,
                                                                      [ F ],
                                                                      "eq",
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.read (| left_val |);
                                                                      M.read (| right_val |)
                                                                    ]
                                                                  |))
                                                              |)) in
                                                          let _ :=
                                                            M.is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (|
                                                                let kind :=
                                                                  M.alloc (|
                                                                    Value.StructTuple
                                                                      "core::panicking::AssertKind::Eq"
                                                                      []
                                                                  |) in
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_function (|
                                                                      "core::panicking::assert_failed",
                                                                      [ F; F ]
                                                                    |),
                                                                    [
                                                                      M.read (| kind |);
                                                                      M.read (| left_val |);
                                                                      M.read (| right_val |);
                                                                      Value.StructTuple
                                                                        "core::option::Option::None"
                                                                        []
                                                                    ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |)))
                                            ]
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |)) in
              let super_point_set :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::cloned::Cloned")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::Values")
                            [ Ty.path "halo2_proofs::poly::Rotation"; F ]
                        ],
                      [],
                      "collect",
                      [ Ty.apply (Ty.path "alloc::vec::Vec") [ F; Ty.path "alloc::alloc::Global" ] ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::Values")
                            [ Ty.path "halo2_proofs::poly::Rotation"; F ],
                          [],
                          "cloned",
                          [ F ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::BTreeMap")
                                [
                                  Ty.path "halo2_proofs::poly::Rotation";
                                  F;
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "values",
                              []
                            |),
                            [ rotation_point_map ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              let commitment_rotation_set_map :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.tuple
                            [
                              Ty.associated;
                              Ty.apply
                                (Ty.path "alloc::collections::btree::set::BTreeSet")
                                [
                                  Ty.path "halo2_proofs::poly::Rotation";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |)
                |) in
              let _ :=
                M.use
                  (M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Q; Ty.path "alloc::alloc::Global" ],
                          [],
                          "into_iter",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Q; Ty.path "alloc::alloc::Global" ],
                              [],
                              "clone",
                              []
                            |),
                            [ queries ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            ltac:(M.monadic
                              (let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [ Q; Ty.path "alloc::alloc::Global" ],
                                        [],
                                        "next",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let query := M.copy (| γ0_0 |) in
                                        let rotation :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "halo2_proofs::poly::multiopen::Query",
                                                Q,
                                                [ F ],
                                                "get_rotation",
                                                []
                                              |),
                                              [ query ]
                                            |)
                                          |) in
                                        let _ :=
                                          M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::iter::traits::iterator::Iterator",
                                                          Ty.apply
                                                            (Ty.path "core::slice::iter::Iter")
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.associated;
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation";
                                                                      Ty.path "alloc::alloc::Global"
                                                                    ]
                                                                ]
                                                            ],
                                                          [],
                                                          "position",
                                                          [
                                                            Ty.function
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.associated;
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::collections::btree::set::BTreeSet")
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::poly::Rotation";
                                                                                Ty.path
                                                                                  "alloc::alloc::Global"
                                                                              ]
                                                                          ]
                                                                      ]
                                                                  ]
                                                              ]
                                                              (Ty.path "bool")
                                                          ]
                                                        |),
                                                        [
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.associated;
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::collections::btree::set::BTreeSet")
                                                                          [
                                                                            Ty.path
                                                                              "halo2_proofs::poly::Rotation";
                                                                            Ty.path
                                                                              "alloc::alloc::Global"
                                                                          ]
                                                                      ]
                                                                  ],
                                                                "iter",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::deref::Deref",
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.associated;
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::collections::btree::set::BTreeSet")
                                                                              [
                                                                                Ty.path
                                                                                  "halo2_proofs::poly::Rotation";
                                                                                Ty.path
                                                                                  "alloc::alloc::Global"
                                                                              ]
                                                                          ];
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    [],
                                                                    "deref",
                                                                    []
                                                                  |),
                                                                  [ commitment_rotation_set_map ]
                                                                |)
                                                              ]
                                                            |)
                                                          |);
                                                          M.closure
                                                            (fun γ =>
                                                              ltac:(M.monadic
                                                                match γ with
                                                                | [ α0 ] =>
                                                                  M.match_operator (|
                                                                    M.alloc (| α0 |),
                                                                    [
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (let γ :=
                                                                            M.read (| γ |) in
                                                                          let γ1_0 :=
                                                                            M.SubPointer.get_tuple_field (|
                                                                              γ,
                                                                              0
                                                                            |) in
                                                                          let γ1_1 :=
                                                                            M.SubPointer.get_tuple_field (|
                                                                              γ,
                                                                              1
                                                                            |) in
                                                                          let commitment :=
                                                                            M.alloc (| γ1_0 |) in
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::cmp::PartialEq",
                                                                              Ty.associated,
                                                                              [ Ty.associated ],
                                                                              "eq",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.read (|
                                                                                commitment
                                                                              |);
                                                                              M.alloc (|
                                                                                M.call_closure (|
                                                                                  M.get_trait_method (|
                                                                                    "halo2_proofs::poly::multiopen::Query",
                                                                                    Q,
                                                                                    [ F ],
                                                                                    "get_commitment",
                                                                                    []
                                                                                  |),
                                                                                  [ query ]
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)))
                                                                    ]
                                                                  |)
                                                                | _ => M.impossible (||)
                                                                end))
                                                        ]
                                                      |)
                                                    |) in
                                                  let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::option::Option::Some",
                                                      0
                                                    |) in
                                                  let pos := M.copy (| γ0_0 |) in
                                                  M.match_operator (|
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::index::IndexMut",
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.associated;
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation";
                                                                      Ty.path "alloc::alloc::Global"
                                                                    ]
                                                                ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          [ Ty.path "usize" ],
                                                          "index_mut",
                                                          []
                                                        |),
                                                        [
                                                          commitment_rotation_set_map;
                                                          M.read (| pos |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ := M.read (| γ |) in
                                                          let γ1_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ1_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let rotation_set := M.alloc (| γ1_1 |) in
                                                          let _ :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation";
                                                                      Ty.path "alloc::alloc::Global"
                                                                    ],
                                                                  "insert",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| rotation_set |);
                                                                  M.read (| rotation |)
                                                                ]
                                                              |)
                                                            |) in
                                                          M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let rotation_set :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::convert::From",
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::BTreeSet")
                                                            [
                                                              Ty.path
                                                                "halo2_proofs::poly::Rotation";
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          [
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::poly::Rotation"
                                                              ]
                                                          ],
                                                          "from",
                                                          []
                                                        |),
                                                        [ Value.Array [ M.read (| rotation |) ] ]
                                                      |)
                                                    |) in
                                                  let _ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.associated;
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    [
                                                                      Ty.path
                                                                        "halo2_proofs::poly::Rotation";
                                                                      Ty.path "alloc::alloc::Global"
                                                                    ]
                                                                ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          "push",
                                                          []
                                                        |),
                                                        [
                                                          commitment_rotation_set_map;
                                                          Value.Tuple
                                                            [
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "halo2_proofs::poly::multiopen::Query",
                                                                  Q,
                                                                  [ F ],
                                                                  "get_commitment",
                                                                  []
                                                                |),
                                                                [ query ]
                                                              |);
                                                              M.read (| rotation_set |)
                                                            ]
                                                        ]
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |)) in
              let rotation_set_commitment_map :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                            [ Ty.path "halo2_proofs::poly::Rotation"; Ty.path "alloc::alloc::Global"
                            ];
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.associated; Ty.path "alloc::alloc::Global" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    []
                  |)
                |) in
              let _ :=
                M.use
                  (M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            [
                              Ty.tuple
                                [
                                  Ty.associated;
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::set::BTreeSet")
                                    [
                                      Ty.path "halo2_proofs::poly::Rotation";
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ]
                            ],
                          [],
                          "into_iter",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                [
                                  Ty.tuple
                                    [
                                      Ty.associated;
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::set::BTreeSet")
                                        [
                                          Ty.path "halo2_proofs::poly::Rotation";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ]
                                ],
                              "iter",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.associated;
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            [
                                              Ty.path "halo2_proofs::poly::Rotation";
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ commitment_rotation_set_map ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            ltac:(M.monadic
                              (let _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.associated;
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::set::BTreeSet")
                                                  [
                                                    Ty.path "halo2_proofs::poly::Rotation";
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ]
                                          ],
                                        [],
                                        "next",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let γ0_0 := M.read (| γ0_0 |) in
                                        let γ2_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                        let γ2_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                        let commitment := M.alloc (| γ2_0 |) in
                                        let rotation_set := M.alloc (| γ2_1 |) in
                                        let commitments :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::map::entry::Entry")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::set::BTreeSet")
                                                      [
                                                        Ty.path "halo2_proofs::poly::Rotation";
                                                        Ty.path "alloc::alloc::Global"
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [
                                                        Ty.associated;
                                                        Ty.path "alloc::alloc::Global"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                "or_insert_with",
                                                [
                                                  Ty.function
                                                    []
                                                    (Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [
                                                        Ty.associated;
                                                        Ty.path "alloc::alloc::Global"
                                                      ])
                                                ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::map::BTreeMap")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::set::BTreeSet")
                                                          [
                                                            Ty.path "halo2_proofs::poly::Rotation";
                                                            Ty.path "alloc::alloc::Global"
                                                          ];
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          [
                                                            Ty.associated;
                                                            Ty.path "alloc::alloc::Global"
                                                          ];
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "entry",
                                                    []
                                                  |),
                                                  [
                                                    rotation_set_commitment_map;
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::clone::Clone",
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::set::BTreeSet")
                                                          [
                                                            Ty.path "halo2_proofs::poly::Rotation";
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        [],
                                                        "clone",
                                                        []
                                                      |),
                                                      [ M.read (| rotation_set |) ]
                                                    |)
                                                  ]
                                                |);
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    [ Ty.associated; Ty.path "alloc::alloc::Global"
                                                    ],
                                                  "new",
                                                  []
                                                |)
                                              ]
                                            |)
                                          |) in
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      UnOp.Pure.not
                                                        (M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              [ Ty.associated ],
                                                            "contains",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::deref::Deref",
                                                                Ty.apply
                                                                  (Ty.path "alloc::vec::Vec")
                                                                  [
                                                                    Ty.associated;
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                [],
                                                                "deref",
                                                                []
                                                              |),
                                                              [ M.read (| commitments |) ]
                                                            |);
                                                            M.read (| commitment |)
                                                          ]
                                                        |))
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                let _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          [
                                                            Ty.associated;
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        "push",
                                                        []
                                                      |),
                                                      [
                                                        M.read (| commitments |);
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::clone::Clone",
                                                            Ty.associated,
                                                            [],
                                                            "clone",
                                                            []
                                                          |),
                                                          [ M.read (| commitment |) ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |)) in
              let rotation_sets :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::IntoIter")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::set::BTreeSet")
                                [
                                  Ty.path "halo2_proofs::poly::Rotation";
                                  Ty.path "alloc::alloc::Global"
                                ];
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.associated; Ty.path "alloc::alloc::Global" ];
                              Ty.path "alloc::alloc::Global"
                            ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::set::BTreeSet")
                                        [
                                          Ty.path "halo2_proofs::poly::Rotation";
                                          Ty.path "alloc::alloc::Global"
                                        ];
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                                    ]
                                ]
                            ]
                            (Ty.apply
                              (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet")
                              [ F; Ty.associated ])
                        ],
                      [],
                      "collect",
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.apply
                              (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet")
                              [ F; Ty.associated ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::IntoIter")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::set::BTreeSet")
                                [
                                  Ty.path "halo2_proofs::poly::Rotation";
                                  Ty.path "alloc::alloc::Global"
                                ];
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.associated; Ty.path "alloc::alloc::Global" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "map",
                          [
                            Ty.apply
                              (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet")
                              [ F; Ty.associated ];
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::BTreeSet")
                                          [
                                            Ty.path "halo2_proofs::poly::Rotation";
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.associated; Ty.path "alloc::alloc::Global" ]
                                      ]
                                  ]
                              ]
                              (Ty.apply
                                (Ty.path "halo2_proofs::poly::multiopen::shplonk::RotationSet")
                                [ F; Ty.associated ])
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::BTreeMap")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::set::BTreeSet")
                                    [
                                      Ty.path "halo2_proofs::poly::Rotation";
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.associated; Ty.path "alloc::alloc::Global" ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "into_iter",
                              []
                            |),
                            [ M.read (| rotation_set_commitment_map |) ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                          let rotation_set := M.copy (| γ0_0 |) in
                                          let commitments := M.copy (| γ0_1 |) in
                                          M.read (|
                                            let rotations :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::iter::adapters::cloned::Cloned")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::set::Iter")
                                                          [ Ty.path "halo2_proofs::poly::Rotation" ]
                                                      ],
                                                    [],
                                                    "collect",
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "halo2_proofs::poly::Rotation";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::set::Iter")
                                                          [ Ty.path "halo2_proofs::poly::Rotation"
                                                          ],
                                                        [],
                                                        "cloned",
                                                        [ Ty.path "halo2_proofs::poly::Rotation" ]
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::set::BTreeSet")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::poly::Rotation";
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            "iter",
                                                            []
                                                          |),
                                                          [ rotation_set ]
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            let commitments :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::Iter")
                                                          [ Ty.associated ];
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [ Ty.associated ]
                                                              ]
                                                          ]
                                                          (Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::poly::multiopen::shplonk::Commitment")
                                                            [ F; Ty.associated ])
                                                      ],
                                                    [],
                                                    "collect",
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::poly::multiopen::shplonk::Commitment")
                                                            [ F; Ty.associated ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::Iter")
                                                          [ Ty.associated ],
                                                        [],
                                                        "map",
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "halo2_proofs::poly::multiopen::shplonk::Commitment")
                                                            [ F; Ty.associated ];
                                                          Ty.function
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [ Ty.associated ]
                                                                ]
                                                            ]
                                                            (Ty.apply
                                                              (Ty.path
                                                                "halo2_proofs::poly::multiopen::shplonk::Commitment")
                                                              [ F; Ty.associated ])
                                                        ]
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              [ Ty.associated ],
                                                            "iter",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::deref::Deref",
                                                                Ty.apply
                                                                  (Ty.path "alloc::vec::Vec")
                                                                  [
                                                                    Ty.associated;
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                [],
                                                                "deref",
                                                                []
                                                              |),
                                                              [ commitments ]
                                                            |)
                                                          ]
                                                        |);
                                                        M.closure
                                                          (fun γ =>
                                                            ltac:(M.monadic
                                                              match γ with
                                                              | [ α0 ] =>
                                                                M.match_operator (|
                                                                  M.alloc (| α0 |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let commitment :=
                                                                          M.copy (| γ |) in
                                                                        M.read (|
                                                                          let evals :=
                                                                            M.alloc (|
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "core::iter::traits::iterator::Iterator",
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "core::iter::adapters::map::Map")
                                                                                    [
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "core::slice::iter::Iter")
                                                                                        [
                                                                                          Ty.path
                                                                                            "halo2_proofs::poly::Rotation"
                                                                                        ];
                                                                                      Ty.function
                                                                                        [
                                                                                          Ty.tuple
                                                                                            [
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "&")
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::poly::Rotation"
                                                                                                ]
                                                                                            ]
                                                                                        ]
                                                                                        F
                                                                                    ],
                                                                                  [],
                                                                                  "collect",
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "alloc::vec::Vec")
                                                                                      [
                                                                                        F;
                                                                                        Ty.path
                                                                                          "alloc::alloc::Global"
                                                                                      ]
                                                                                  ]
                                                                                |),
                                                                                [
                                                                                  M.call_closure (|
                                                                                    M.get_trait_method (|
                                                                                      "core::iter::traits::iterator::Iterator",
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "core::slice::iter::Iter")
                                                                                        [
                                                                                          Ty.path
                                                                                            "halo2_proofs::poly::Rotation"
                                                                                        ],
                                                                                      [],
                                                                                      "map",
                                                                                      [
                                                                                        F;
                                                                                        Ty.function
                                                                                          [
                                                                                            Ty.tuple
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "&")
                                                                                                  [
                                                                                                    Ty.path
                                                                                                      "halo2_proofs::poly::Rotation"
                                                                                                  ]
                                                                                              ]
                                                                                          ]
                                                                                          F
                                                                                      ]
                                                                                    |),
                                                                                    [
                                                                                      M.call_closure (|
                                                                                        M.get_associated_function (|
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "slice")
                                                                                            [
                                                                                              Ty.path
                                                                                                "halo2_proofs::poly::Rotation"
                                                                                            ],
                                                                                          "iter",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            M.get_trait_method (|
                                                                                              "core::ops::deref::Deref",
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "alloc::vec::Vec")
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "halo2_proofs::poly::Rotation";
                                                                                                  Ty.path
                                                                                                    "alloc::alloc::Global"
                                                                                                ],
                                                                                              [],
                                                                                              "deref",
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              rotations
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                      |);
                                                                                      M.closure
                                                                                        (fun γ =>
                                                                                          ltac:(M.monadic
                                                                                            match γ
                                                                                            with
                                                                                            | [ α0
                                                                                                ] =>
                                                                                              M.match_operator (|
                                                                                                M.alloc (|
                                                                                                  α0
                                                                                                |),
                                                                                                [
                                                                                                  fun
                                                                                                      γ =>
                                                                                                    ltac:(M.monadic
                                                                                                      (let
                                                                                                            rotation :=
                                                                                                        M.copy (|
                                                                                                          γ
                                                                                                        |) in
                                                                                                      M.call_closure (|
                                                                                                        M.get_trait_method (|
                                                                                                          "core::ops::function::Fn",
                                                                                                          Ty.function
                                                                                                            [
                                                                                                              Ty.tuple
                                                                                                                [
                                                                                                                  Ty.associated;
                                                                                                                  Ty.path
                                                                                                                    "halo2_proofs::poly::Rotation"
                                                                                                                ]
                                                                                                            ]
                                                                                                            F,
                                                                                                          [
                                                                                                            Ty.tuple
                                                                                                              [
                                                                                                                Ty.associated;
                                                                                                                Ty.path
                                                                                                                  "halo2_proofs::poly::Rotation"
                                                                                                              ]
                                                                                                          ],
                                                                                                          "call",
                                                                                                          []
                                                                                                        |),
                                                                                                        [
                                                                                                          get_eval;
                                                                                                          Value.Tuple
                                                                                                            [
                                                                                                              M.call_closure (|
                                                                                                                M.get_trait_method (|
                                                                                                                  "core::clone::Clone",
                                                                                                                  Ty.associated,
                                                                                                                  [],
                                                                                                                  "clone",
                                                                                                                  []
                                                                                                                |),
                                                                                                                [
                                                                                                                  M.read (|
                                                                                                                    commitment
                                                                                                                  |)
                                                                                                                ]
                                                                                                              |);
                                                                                                              M.read (|
                                                                                                                M.read (|
                                                                                                                  rotation
                                                                                                                |)
                                                                                                              |)
                                                                                                            ]
                                                                                                        ]
                                                                                                      |)))
                                                                                                ]
                                                                                              |)
                                                                                            | _ =>
                                                                                              M.impossible (||)
                                                                                            end))
                                                                                    ]
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            |) in
                                                                          M.alloc (|
                                                                            Value.StructTuple
                                                                              "halo2_proofs::poly::multiopen::shplonk::Commitment"
                                                                              [
                                                                                Value.Tuple
                                                                                  [
                                                                                    M.call_closure (|
                                                                                      M.get_trait_method (|
                                                                                        "core::clone::Clone",
                                                                                        Ty.associated,
                                                                                        [],
                                                                                        "clone",
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.read (|
                                                                                          commitment
                                                                                        |)
                                                                                      ]
                                                                                    |);
                                                                                    M.read (|
                                                                                      evals
                                                                                    |)
                                                                                  ]
                                                                              ]
                                                                          |)
                                                                        |)))
                                                                  ]
                                                                |)
                                                              | _ => M.impossible (||)
                                                              end))
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            M.alloc (|
                                              Value.StructRecord
                                                "halo2_proofs::poly::multiopen::shplonk::RotationSet"
                                                [
                                                  ("commitments", M.read (| commitments |));
                                                  ("points",
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path "core::iter::adapters::map::Map")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::Iter")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::poly::Rotation"
                                                              ];
                                                            Ty.function
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation"
                                                                      ]
                                                                  ]
                                                              ]
                                                              F
                                                          ],
                                                        [],
                                                        "collect",
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            [ F; Ty.path "alloc::alloc::Global" ]
                                                        ]
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::iter::traits::iterator::Iterator",
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::Iter")
                                                              [
                                                                Ty.path
                                                                  "halo2_proofs::poly::Rotation"
                                                              ],
                                                            [],
                                                            "map",
                                                            [
                                                              F;
                                                              Ty.function
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        [
                                                                          Ty.path
                                                                            "halo2_proofs::poly::Rotation"
                                                                        ]
                                                                    ]
                                                                ]
                                                                F
                                                            ]
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  [
                                                                    Ty.path
                                                                      "halo2_proofs::poly::Rotation"
                                                                  ],
                                                                "iter",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::deref::Deref",
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      [
                                                                        Ty.path
                                                                          "halo2_proofs::poly::Rotation";
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    [],
                                                                    "deref",
                                                                    []
                                                                  |),
                                                                  [ rotations ]
                                                                |)
                                                              ]
                                                            |);
                                                            M.closure
                                                              (fun γ =>
                                                                ltac:(M.monadic
                                                                  match γ with
                                                                  | [ α0 ] =>
                                                                    M.match_operator (|
                                                                      M.alloc (| α0 |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let rotation :=
                                                                              M.copy (| γ |) in
                                                                            M.read (|
                                                                              M.call_closure (|
                                                                                M.get_associated_function (|
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "core::option::Option")
                                                                                    [
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "&")
                                                                                        [ F ]
                                                                                    ],
                                                                                  "unwrap",
                                                                                  []
                                                                                |),
                                                                                [
                                                                                  M.call_closure (|
                                                                                    M.get_associated_function (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "alloc::collections::btree::map::BTreeMap")
                                                                                        [
                                                                                          Ty.path
                                                                                            "halo2_proofs::poly::Rotation";
                                                                                          F;
                                                                                          Ty.path
                                                                                            "alloc::alloc::Global"
                                                                                        ],
                                                                                      "get",
                                                                                      [
                                                                                        Ty.path
                                                                                          "halo2_proofs::poly::Rotation"
                                                                                      ]
                                                                                    |),
                                                                                    [
                                                                                      rotation_point_map;
                                                                                      M.read (|
                                                                                        rotation
                                                                                      |)
                                                                                    ]
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            |)))
                                                                      ]
                                                                    |)
                                                                  | _ => M.impossible (||)
                                                                  end))
                                                          ]
                                                        |)
                                                      ]
                                                    |))
                                                ]
                                            |)
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "halo2_proofs::poly::multiopen::shplonk::IntermediateSets"
                  [
                    ("rotation_sets", M.read (| rotation_sets |));
                    ("super_point_set", M.read (| super_point_set |))
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
    End shplonk.
  End multiopen.
End poly.
