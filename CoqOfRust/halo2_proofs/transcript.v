(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module transcript.
  Definition value_BLAKE2B_PREFIX_CHALLENGE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 0 |))).
  
  Definition value_BLAKE2B_PREFIX_POINT : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 1 |))).
  
  Definition value_BLAKE2B_PREFIX_SCALAR : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 2 |))).
  
  (* Trait *)
  Module Transcript.
    Definition squeeze_challenge_scalar (C E Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "halo2_proofs::transcript::ChallengeScalar"
            [
              ("inner",
                M.call_closure (|
                  M.get_trait_method (|
                    "halo2_proofs::transcript::EncodedChallenge",
                    E,
                    [ C ],
                    "get_scalar",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "halo2_proofs::transcript::Transcript",
                          Self,
                          [ C; E ],
                          "squeeze_challenge",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |)
                  ]
                |));
              ("_marker", Value.StructTuple "core::marker::PhantomData" [])
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_squeeze_challenge_scalar :
      forall (C E : Ty.t),
      M.IsProvidedMethod
        "halo2_proofs::transcript::Transcript"
        "squeeze_challenge_scalar"
        (squeeze_challenge_scalar C E).
  End Transcript.
  
  (* Trait *)
  (* Empty module 'TranscriptRead' *)
  
  (* Trait *)
  (* Empty module 'TranscriptWrite' *)
  
  (* StructRecord
    {
      name := "Blake2bRead";
      ty_params := [ "R"; "C"; "E" ];
      fields :=
        [
          ("state", Ty.path "blake2b_simd::State");
          ("reader", R);
          ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.tuple [ C; E ] ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_R_where_std_io_Read_R_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_E_where_halo2_proofs_transcript_EncodedChallenge_E_C_for_halo2_proofs_transcript_Blake2bRead_R_C_E.
    Definition Self (R C E : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Blake2bRead") [ R; C; E ].
    
    (* Debug *)
    Definition fmt (R C E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self R C E in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "Blake2bRead" |);
              M.read (| Value.String "state" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::transcript::Blake2bRead",
                  "state"
                |));
              M.read (| Value.String "reader" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::transcript::Blake2bRead",
                  "reader"
                |));
              M.read (| Value.String "_marker" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::transcript::Blake2bRead",
                    "_marker"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (R C E : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self R C E)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt R C E)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_R_where_std_io_Read_R_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_E_where_halo2_proofs_transcript_EncodedChallenge_E_C_for_halo2_proofs_transcript_Blake2bRead_R_C_E.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_R_where_std_io_Read_R_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_E_where_halo2_proofs_transcript_EncodedChallenge_E_C_for_halo2_proofs_transcript_Blake2bRead_R_C_E.
    Definition Self (R C E : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Blake2bRead") [ R; C; E ].
    
    (* Clone *)
    Definition clone (R C E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self R C E in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "halo2_proofs::transcript::Blake2bRead"
            [
              ("state",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "blake2b_simd::State",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bRead",
                      "state"
                    |)
                  ]
                |));
              ("reader",
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", R, [], "clone", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bRead",
                      "reader"
                    |)
                  ]
                |));
              ("_marker",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.tuple [ C; E ] ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bRead",
                      "_marker"
                    |)
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (R C E : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self R C E)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone R C E)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_R_where_std_io_Read_R_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_E_where_halo2_proofs_transcript_EncodedChallenge_E_C_for_halo2_proofs_transcript_Blake2bRead_R_C_E.
  
  Module Impl_halo2_proofs_transcript_Blake2bRead_R_C_E.
    Definition Self (R C E : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Blake2bRead") [ R; C; E ].
    
    (*
        pub fn init(reader: R) -> Self {
            Blake2bRead {
                state: Blake2bParams::new()
                    .hash_length(64)
                    .personal(b"Halo2-Transcript")
                    .to_state(),
                reader,
                _marker: PhantomData,
            }
        }
    *)
    Definition init (R C E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self R C E in
      match τ, α with
      | [], [ reader ] =>
        ltac:(M.monadic
          (let reader := M.alloc (| reader |) in
          Value.StructRecord
            "halo2_proofs::transcript::Blake2bRead"
            [
              ("state",
                M.call_closure (|
                  M.get_associated_function (| Ty.path "blake2b_simd::Params", "to_state", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "blake2b_simd::Params",
                        "personal",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "blake2b_simd::Params",
                            "hash_length",
                            []
                          |),
                          [
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "blake2b_simd::Params",
                                  "new",
                                  []
                                |),
                                []
                              |)
                            |);
                            Value.Integer 64
                          ]
                        |);
                        (* Unsize *) M.pointer_coercion (M.read (| UnsupportedLiteral |))
                      ]
                    |)
                  ]
                |));
              ("reader", M.read (| reader |));
              ("_marker", Value.StructTuple "core::marker::PhantomData" [])
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_init :
      forall (R C E : Ty.t),
      M.IsAssociatedFunction (Self R C E) "init" (init R C E).
  End Impl_halo2_proofs_transcript_Blake2bRead_R_C_E.
  
  Module Impl_halo2_proofs_transcript_TranscriptRead_where_std_io_Read_R_where_pairing_bn256_arithmetic_curves_CurveAffine_C_C_halo2_proofs_transcript_Challenge255_C_for_halo2_proofs_transcript_Blake2bRead_R_C_halo2_proofs_transcript_Challenge255_C.
    Definition Self (R C : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "halo2_proofs::transcript::Blake2bRead")
        [ R; C; Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ] ].
    
    (*
        fn read_point(&mut self) -> io::Result<C> {
            let mut compressed = C::Repr::default();
            self.reader.read_exact(compressed.as_mut())?;
            let point: C = Option::from(C::from_bytes(&compressed)).ok_or_else(|| {
                io::Error::new(io::ErrorKind::Other, "invalid point encoding in proof")
            })?;
            self.common_point(point)?;
    
            Ok(point)
        }
    *)
    Definition read_point (R C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self R C in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let compressed :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.associated,
                        [],
                        "default",
                        []
                      |),
                      []
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (| "std::io::Read", R, [], "read_exact", [] |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::transcript::Blake2bRead",
                                "reader"
                              |);
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::convert::AsMut",
                                  Ty.associated,
                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                                  "as_mut",
                                  []
                                |),
                                [ compressed ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ C; Ty.path "std::io::error::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "std::io::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                let point :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [ C; Ty.path "std::io::error::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [ C ],
                                "ok_or_else",
                                [
                                  Ty.path "std::io::error::Error";
                                  Ty.function [ Ty.tuple [] ] (Ty.path "std::io::error::Error")
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::From",
                                    Ty.apply (Ty.path "core::option::Option") [ C ],
                                    [ Ty.apply (Ty.path "subtle::CtOption") [ C ] ],
                                    "from",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "group::GroupEncoding",
                                        C,
                                        [],
                                        "from_bytes",
                                        []
                                      |),
                                      [ compressed ]
                                    |)
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "std::io::error::Error",
                                                    "new",
                                                    [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                                  |),
                                                  [
                                                    Value.StructTuple
                                                      "std::io::error::ErrorKind::Other"
                                                      [];
                                                    M.read (|
                                                      Value.String "invalid point encoding in proof"
                                                    |)
                                                  ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end))
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ C; Ty.path "std::io::error::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "std::io::error::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "halo2_proofs::transcript::Transcript",
                              Ty.apply
                                (Ty.path "halo2_proofs::transcript::Blake2bRead")
                                [
                                  R;
                                  C;
                                  Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ]
                                ],
                              [ C; Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ]
                              ],
                              "common_point",
                              []
                            |),
                            [ M.read (| self |); M.read (| point |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ C; Ty.path "std::io::error::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "std::io::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| point |) ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn read_scalar(&mut self) -> io::Result<C::Scalar> {
            let mut data = <C::Scalar as PrimeField>::Repr::default();
            self.reader.read_exact(data.as_mut())?;
            let scalar: C::Scalar = Option::from(C::Scalar::from_repr(data)).ok_or_else(|| {
                io::Error::new(
                    io::ErrorKind::Other,
                    "invalid field element encoding in proof",
                )
            })?;
            self.common_scalar(scalar)?;
    
            Ok(scalar)
        }
    *)
    Definition read_scalar (R C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self R C in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let data :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.associated,
                        [],
                        "default",
                        []
                      |),
                      []
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (| "std::io::Read", R, [], "read_exact", [] |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::transcript::Blake2bRead",
                                "reader"
                              |);
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::convert::AsMut",
                                  Ty.associated,
                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                                  "as_mut",
                                  []
                                |),
                                [ data ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.associated; Ty.path "std::io::error::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "std::io::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                let scalar :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [ Ty.associated; Ty.path "std::io::error::Error" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [ Ty.associated ],
                                "ok_or_else",
                                [
                                  Ty.path "std::io::error::Error";
                                  Ty.function [ Ty.tuple [] ] (Ty.path "std::io::error::Error")
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::From",
                                    Ty.apply (Ty.path "core::option::Option") [ Ty.associated ],
                                    [ Ty.apply (Ty.path "subtle::CtOption") [ Ty.associated ] ],
                                    "from",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "ff::PrimeField",
                                        Ty.associated,
                                        [],
                                        "from_repr",
                                        []
                                      |),
                                      [ M.read (| data |) ]
                                    |)
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "std::io::error::Error",
                                                    "new",
                                                    [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                                  |),
                                                  [
                                                    Value.StructTuple
                                                      "std::io::error::ErrorKind::Other"
                                                      [];
                                                    M.read (|
                                                      Value.String
                                                        "invalid field element encoding in proof"
                                                    |)
                                                  ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end))
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.associated; Ty.path "std::io::error::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "std::io::error::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "halo2_proofs::transcript::Transcript",
                              Ty.apply
                                (Ty.path "halo2_proofs::transcript::Blake2bRead")
                                [
                                  R;
                                  C;
                                  Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ]
                                ],
                              [ C; Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ]
                              ],
                              "common_scalar",
                              []
                            |),
                            [ M.read (| self |); M.read (| scalar |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.associated; Ty.path "std::io::error::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "std::io::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| scalar |) ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (R C : Ty.t),
      M.IsTraitInstance
        "halo2_proofs::transcript::TranscriptRead"
        (Self R C)
        (* Trait polymorphic types *)
        [ (* C *) C; (* E *) Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ] ]
        (* Instance *)
        [
          ("read_point", InstanceField.Method (read_point R C));
          ("read_scalar", InstanceField.Method (read_scalar R C))
        ].
  End Impl_halo2_proofs_transcript_TranscriptRead_where_std_io_Read_R_where_pairing_bn256_arithmetic_curves_CurveAffine_C_C_halo2_proofs_transcript_Challenge255_C_for_halo2_proofs_transcript_Blake2bRead_R_C_halo2_proofs_transcript_Challenge255_C.
  
  Module Impl_halo2_proofs_transcript_Transcript_where_std_io_Read_R_where_pairing_bn256_arithmetic_curves_CurveAffine_C_C_halo2_proofs_transcript_Challenge255_C_for_halo2_proofs_transcript_Blake2bRead_R_C_halo2_proofs_transcript_Challenge255_C.
    Definition Self (R C : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "halo2_proofs::transcript::Blake2bRead")
        [ R; C; Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ] ].
    
    (*
        fn squeeze_challenge(&mut self) -> Challenge255<C> {
            self.state.update(&[BLAKE2B_PREFIX_CHALLENGE]);
            let hasher = self.state.clone();
            let result: [u8; 64] = hasher.finalize().as_bytes().try_into().unwrap();
            Challenge255::<C>::new(&result)
        }
    *)
    Definition squeeze_challenge (R C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self R C in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "blake2b_simd::State", "update", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bRead",
                      "state"
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        Value.Array
                          [
                            M.read (|
                              M.get_constant (|
                                "halo2_proofs::transcript::BLAKE2B_PREFIX_CHALLENGE"
                              |)
                            |)
                          ]
                      |))
                  ]
                |)
              |) in
            let hasher :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "blake2b_simd::State",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bRead",
                      "state"
                    |)
                  ]
                |)
              |) in
            let result :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [
                        Ty.apply (Ty.path "array") [ Ty.path "u8" ];
                        Ty.path "core::array::TryFromSliceError"
                      ],
                    "unwrap",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                        [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ],
                        "try_into",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "blake2b_simd::Hash",
                            "as_bytes",
                            []
                          |),
                          [
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "blake2b_simd::State",
                                  "finalize",
                                  []
                                |),
                                [ hasher ]
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "halo2_proofs::transcript::EncodedChallenge",
                  Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ],
                  [ C ],
                  "new",
                  []
                |),
                [ result ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn common_point(&mut self, point: C) -> io::Result<()> {
            self.state.update(&[BLAKE2B_PREFIX_POINT]);
            let coords: Coordinates<C> = Option::from(point.coordinates()).ok_or_else(|| {
                io::Error::new(
                    io::ErrorKind::Other,
                    "cannot write points at infinity to the transcript",
                )
            })?;
            coords.x().write(&mut self.state)?;
            coords.y().write(&mut self.state)?;
    
            Ok(())
        }
    *)
    Definition common_point (R C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self R C in
      match τ, α with
      | [], [ self; point ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let point := M.alloc (| point |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "blake2b_simd::State", "update", [] |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::transcript::Blake2bRead",
                          "state"
                        |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.alloc (|
                            Value.Array
                              [
                                M.read (|
                                  M.get_constant (|
                                    "halo2_proofs::transcript::BLAKE2B_PREFIX_POINT"
                                  |)
                                |)
                              ]
                          |))
                      ]
                    |)
                  |) in
                let coords :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "pairing_bn256::arithmetic::curves::Coordinates")
                                  [ C ];
                                Ty.path "std::io::error::Error"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.apply
                                      (Ty.path "pairing_bn256::arithmetic::curves::Coordinates")
                                      [ C ]
                                  ],
                                "ok_or_else",
                                [
                                  Ty.path "std::io::error::Error";
                                  Ty.function [ Ty.tuple [] ] (Ty.path "std::io::error::Error")
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::From",
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "pairing_bn256::arithmetic::curves::Coordinates")
                                          [ C ]
                                      ],
                                    [
                                      Ty.apply
                                        (Ty.path "subtle::CtOption")
                                        [
                                          Ty.apply
                                            (Ty.path
                                              "pairing_bn256::arithmetic::curves::Coordinates")
                                            [ C ]
                                        ]
                                    ],
                                    "from",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "pairing_bn256::arithmetic::curves::CurveAffine",
                                        C,
                                        [],
                                        "coordinates",
                                        []
                                      |),
                                      [ point ]
                                    |)
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "std::io::error::Error",
                                                    "new",
                                                    [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                                  |),
                                                  [
                                                    Value.StructTuple
                                                      "std::io::error::ErrorKind::Other"
                                                      [];
                                                    M.read (|
                                                      Value.String
                                                        "cannot write points at infinity to the transcript"
                                                    |)
                                                  ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end))
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "std::io::error::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "pairing_bn256::arithmetic::fields::BaseExt",
                              Ty.associated,
                              [],
                              "write",
                              [ Ty.path "blake2b_simd::State" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "pairing_bn256::arithmetic::curves::Coordinates")
                                    [ C ],
                                  "x",
                                  []
                                |),
                                [ coords ]
                              |);
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::transcript::Blake2bRead",
                                "state"
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "std::io::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "pairing_bn256::arithmetic::fields::BaseExt",
                              Ty.associated,
                              [],
                              "write",
                              [ Ty.path "blake2b_simd::State" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "pairing_bn256::arithmetic::curves::Coordinates")
                                    [ C ],
                                  "y",
                                  []
                                |),
                                [ coords ]
                              |);
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::transcript::Blake2bRead",
                                "state"
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "std::io::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn common_scalar(&mut self, scalar: C::Scalar) -> io::Result<()> {
            self.state.update(&[BLAKE2B_PREFIX_SCALAR]);
            self.state.update(scalar.to_repr().as_ref());
    
            Ok(())
        }
    *)
    Definition common_scalar (R C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self R C in
      match τ, α with
      | [], [ self; scalar ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let scalar := M.alloc (| scalar |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "blake2b_simd::State", "update", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bRead",
                      "state"
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        Value.Array
                          [
                            M.read (|
                              M.get_constant (| "halo2_proofs::transcript::BLAKE2B_PREFIX_SCALAR" |)
                            |)
                          ]
                      |))
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "blake2b_simd::State", "update", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bRead",
                      "state"
                    |);
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::AsRef",
                        Ty.associated,
                        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                        "as_ref",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "ff::PrimeField",
                              Ty.associated,
                              [],
                              "to_repr",
                              []
                            |),
                            [ scalar ]
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (R C : Ty.t),
      M.IsTraitInstance
        "halo2_proofs::transcript::Transcript"
        (Self R C)
        (* Trait polymorphic types *)
        [ (* C *) C; (* E *) Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ] ]
        (* Instance *)
        [
          ("squeeze_challenge", InstanceField.Method (squeeze_challenge R C));
          ("common_point", InstanceField.Method (common_point R C));
          ("common_scalar", InstanceField.Method (common_scalar R C))
        ].
  End Impl_halo2_proofs_transcript_Transcript_where_std_io_Read_R_where_pairing_bn256_arithmetic_curves_CurveAffine_C_C_halo2_proofs_transcript_Challenge255_C_for_halo2_proofs_transcript_Blake2bRead_R_C_halo2_proofs_transcript_Challenge255_C.
  
  (* StructRecord
    {
      name := "Blake2bWrite";
      ty_params := [ "W"; "C"; "E" ];
      fields :=
        [
          ("state", Ty.path "blake2b_simd::State");
          ("writer", W);
          ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.tuple [ C; E ] ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_W_where_std_io_Write_W_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_E_where_halo2_proofs_transcript_EncodedChallenge_E_C_for_halo2_proofs_transcript_Blake2bWrite_W_C_E.
    Definition Self (W C E : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Blake2bWrite") [ W; C; E ].
    
    (* Debug *)
    Definition fmt (W C E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self W C E in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "Blake2bWrite" |);
              M.read (| Value.String "state" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::transcript::Blake2bWrite",
                  "state"
                |));
              M.read (| Value.String "writer" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::transcript::Blake2bWrite",
                  "writer"
                |));
              M.read (| Value.String "_marker" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::transcript::Blake2bWrite",
                    "_marker"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (W C E : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self W C E)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt W C E)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_W_where_std_io_Write_W_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_E_where_halo2_proofs_transcript_EncodedChallenge_E_C_for_halo2_proofs_transcript_Blake2bWrite_W_C_E.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_W_where_std_io_Write_W_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_E_where_halo2_proofs_transcript_EncodedChallenge_E_C_for_halo2_proofs_transcript_Blake2bWrite_W_C_E.
    Definition Self (W C E : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Blake2bWrite") [ W; C; E ].
    
    (* Clone *)
    Definition clone (W C E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self W C E in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "halo2_proofs::transcript::Blake2bWrite"
            [
              ("state",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "blake2b_simd::State",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bWrite",
                      "state"
                    |)
                  ]
                |));
              ("writer",
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", W, [], "clone", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bWrite",
                      "writer"
                    |)
                  ]
                |));
              ("_marker",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.tuple [ C; E ] ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bWrite",
                      "_marker"
                    |)
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (W C E : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self W C E)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone W C E)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_W_where_std_io_Write_W_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_E_where_halo2_proofs_transcript_EncodedChallenge_E_C_for_halo2_proofs_transcript_Blake2bWrite_W_C_E.
  
  Module Impl_halo2_proofs_transcript_Blake2bWrite_W_C_E.
    Definition Self (W C E : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Blake2bWrite") [ W; C; E ].
    
    (*
        pub fn init(writer: W) -> Self {
            Blake2bWrite {
                state: Blake2bParams::new()
                    .hash_length(64)
                    .personal(b"Halo2-Transcript")
                    .to_state(),
                writer,
                _marker: PhantomData,
            }
        }
    *)
    Definition init (W C E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self W C E in
      match τ, α with
      | [], [ writer ] =>
        ltac:(M.monadic
          (let writer := M.alloc (| writer |) in
          Value.StructRecord
            "halo2_proofs::transcript::Blake2bWrite"
            [
              ("state",
                M.call_closure (|
                  M.get_associated_function (| Ty.path "blake2b_simd::Params", "to_state", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "blake2b_simd::Params",
                        "personal",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "blake2b_simd::Params",
                            "hash_length",
                            []
                          |),
                          [
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "blake2b_simd::Params",
                                  "new",
                                  []
                                |),
                                []
                              |)
                            |);
                            Value.Integer 64
                          ]
                        |);
                        (* Unsize *) M.pointer_coercion (M.read (| UnsupportedLiteral |))
                      ]
                    |)
                  ]
                |));
              ("writer", M.read (| writer |));
              ("_marker", Value.StructTuple "core::marker::PhantomData" [])
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_init :
      forall (W C E : Ty.t),
      M.IsAssociatedFunction (Self W C E) "init" (init W C E).
    
    (*
        pub fn finalize(self) -> W {
            // TODO: handle outstanding scalars? see issue #138
            self.writer
        }
    *)
    Definition finalize (W C E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self W C E in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              self,
              "halo2_proofs::transcript::Blake2bWrite",
              "writer"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_finalize :
      forall (W C E : Ty.t),
      M.IsAssociatedFunction (Self W C E) "finalize" (finalize W C E).
  End Impl_halo2_proofs_transcript_Blake2bWrite_W_C_E.
  
  Module Impl_halo2_proofs_transcript_TranscriptWrite_where_std_io_Write_W_where_pairing_bn256_arithmetic_curves_CurveAffine_C_C_halo2_proofs_transcript_Challenge255_C_for_halo2_proofs_transcript_Blake2bWrite_W_C_halo2_proofs_transcript_Challenge255_C.
    Definition Self (W C : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "halo2_proofs::transcript::Blake2bWrite")
        [ W; C; Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ] ].
    
    (*
        fn write_point(&mut self, point: C) -> io::Result<()> {
            self.common_point(point)?;
            let compressed = point.to_bytes();
            self.writer.write_all(compressed.as_ref())
        }
    *)
    Definition write_point (W C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self W C in
      match τ, α with
      | [], [ self; point ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let point := M.alloc (| point |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "halo2_proofs::transcript::Transcript",
                              Ty.apply
                                (Ty.path "halo2_proofs::transcript::Blake2bWrite")
                                [
                                  W;
                                  C;
                                  Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ]
                                ],
                              [ C; Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ]
                              ],
                              "common_point",
                              []
                            |),
                            [ M.read (| self |); M.read (| point |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "std::io::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                let compressed :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (| "group::GroupEncoding", C, [], "to_bytes", [] |),
                      [ point ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "std::io::Write", W, [], "write_all", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::transcript::Blake2bWrite",
                        "writer"
                      |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::AsRef",
                          Ty.associated,
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                          "as_ref",
                          []
                        |),
                        [ compressed ]
                      |)
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_scalar(&mut self, scalar: C::Scalar) -> io::Result<()> {
            self.common_scalar(scalar)?;
            let data = scalar.to_repr();
            self.writer.write_all(data.as_ref())
        }
    *)
    Definition write_scalar (W C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self W C in
      match τ, α with
      | [], [ self; scalar ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let scalar := M.alloc (| scalar |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "halo2_proofs::transcript::Transcript",
                              Ty.apply
                                (Ty.path "halo2_proofs::transcript::Blake2bWrite")
                                [
                                  W;
                                  C;
                                  Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ]
                                ],
                              [ C; Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ]
                              ],
                              "common_scalar",
                              []
                            |),
                            [ M.read (| self |); M.read (| scalar |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "std::io::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                let data :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (| "ff::PrimeField", Ty.associated, [], "to_repr", [] |),
                      [ scalar ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "std::io::Write", W, [], "write_all", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "halo2_proofs::transcript::Blake2bWrite",
                        "writer"
                      |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::AsRef",
                          Ty.associated,
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                          "as_ref",
                          []
                        |),
                        [ data ]
                      |)
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (W C : Ty.t),
      M.IsTraitInstance
        "halo2_proofs::transcript::TranscriptWrite"
        (Self W C)
        (* Trait polymorphic types *)
        [ (* C *) C; (* E *) Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ] ]
        (* Instance *)
        [
          ("write_point", InstanceField.Method (write_point W C));
          ("write_scalar", InstanceField.Method (write_scalar W C))
        ].
  End Impl_halo2_proofs_transcript_TranscriptWrite_where_std_io_Write_W_where_pairing_bn256_arithmetic_curves_CurveAffine_C_C_halo2_proofs_transcript_Challenge255_C_for_halo2_proofs_transcript_Blake2bWrite_W_C_halo2_proofs_transcript_Challenge255_C.
  
  Module Impl_halo2_proofs_transcript_Transcript_where_std_io_Write_W_where_pairing_bn256_arithmetic_curves_CurveAffine_C_C_halo2_proofs_transcript_Challenge255_C_for_halo2_proofs_transcript_Blake2bWrite_W_C_halo2_proofs_transcript_Challenge255_C.
    Definition Self (W C : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "halo2_proofs::transcript::Blake2bWrite")
        [ W; C; Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ] ].
    
    (*
        fn squeeze_challenge(&mut self) -> Challenge255<C> {
            self.state.update(&[BLAKE2B_PREFIX_CHALLENGE]);
            let hasher = self.state.clone();
            let result: [u8; 64] = hasher.finalize().as_bytes().try_into().unwrap();
            Challenge255::<C>::new(&result)
        }
    *)
    Definition squeeze_challenge (W C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self W C in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "blake2b_simd::State", "update", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bWrite",
                      "state"
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        Value.Array
                          [
                            M.read (|
                              M.get_constant (|
                                "halo2_proofs::transcript::BLAKE2B_PREFIX_CHALLENGE"
                              |)
                            |)
                          ]
                      |))
                  ]
                |)
              |) in
            let hasher :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "blake2b_simd::State",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bWrite",
                      "state"
                    |)
                  ]
                |)
              |) in
            let result :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [
                        Ty.apply (Ty.path "array") [ Ty.path "u8" ];
                        Ty.path "core::array::TryFromSliceError"
                      ],
                    "unwrap",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                        [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ],
                        "try_into",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "blake2b_simd::Hash",
                            "as_bytes",
                            []
                          |),
                          [
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "blake2b_simd::State",
                                  "finalize",
                                  []
                                |),
                                [ hasher ]
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "halo2_proofs::transcript::EncodedChallenge",
                  Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ],
                  [ C ],
                  "new",
                  []
                |),
                [ result ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn common_point(&mut self, point: C) -> io::Result<()> {
            self.state.update(&[BLAKE2B_PREFIX_POINT]);
            let coords: Coordinates<C> = Option::from(point.coordinates()).ok_or_else(|| {
                io::Error::new(
                    io::ErrorKind::Other,
                    "cannot write points at infinity to the transcript",
                )
            })?;
            coords.x().write(&mut self.state)?;
            coords.y().write(&mut self.state)?;
    
            Ok(())
        }
    *)
    Definition common_point (W C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self W C in
      match τ, α with
      | [], [ self; point ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let point := M.alloc (| point |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "blake2b_simd::State", "update", [] |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "halo2_proofs::transcript::Blake2bWrite",
                          "state"
                        |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.alloc (|
                            Value.Array
                              [
                                M.read (|
                                  M.get_constant (|
                                    "halo2_proofs::transcript::BLAKE2B_PREFIX_POINT"
                                  |)
                                |)
                              ]
                          |))
                      ]
                    |)
                  |) in
                let coords :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "pairing_bn256::arithmetic::curves::Coordinates")
                                  [ C ];
                                Ty.path "std::io::error::Error"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [
                                    Ty.apply
                                      (Ty.path "pairing_bn256::arithmetic::curves::Coordinates")
                                      [ C ]
                                  ],
                                "ok_or_else",
                                [
                                  Ty.path "std::io::error::Error";
                                  Ty.function [ Ty.tuple [] ] (Ty.path "std::io::error::Error")
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::From",
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "pairing_bn256::arithmetic::curves::Coordinates")
                                          [ C ]
                                      ],
                                    [
                                      Ty.apply
                                        (Ty.path "subtle::CtOption")
                                        [
                                          Ty.apply
                                            (Ty.path
                                              "pairing_bn256::arithmetic::curves::Coordinates")
                                            [ C ]
                                        ]
                                    ],
                                    "from",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "pairing_bn256::arithmetic::curves::CurveAffine",
                                        C,
                                        [],
                                        "coordinates",
                                        []
                                      |),
                                      [ point ]
                                    |)
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "std::io::error::Error",
                                                    "new",
                                                    [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                                  |),
                                                  [
                                                    Value.StructTuple
                                                      "std::io::error::ErrorKind::Other"
                                                      [];
                                                    M.read (|
                                                      Value.String
                                                        "cannot write points at infinity to the transcript"
                                                    |)
                                                  ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end))
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "std::io::error::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "pairing_bn256::arithmetic::fields::BaseExt",
                              Ty.associated,
                              [],
                              "write",
                              [ Ty.path "blake2b_simd::State" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "pairing_bn256::arithmetic::curves::Coordinates")
                                    [ C ],
                                  "x",
                                  []
                                |),
                                [ coords ]
                              |);
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::transcript::Blake2bWrite",
                                "state"
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "std::io::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "pairing_bn256::arithmetic::fields::BaseExt",
                              Ty.associated,
                              [],
                              "write",
                              [ Ty.path "blake2b_simd::State" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "pairing_bn256::arithmetic::curves::Coordinates")
                                    [ C ],
                                  "y",
                                  []
                                |),
                                [ coords ]
                              |);
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "halo2_proofs::transcript::Blake2bWrite",
                                "state"
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "std::io::error::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn common_scalar(&mut self, scalar: C::Scalar) -> io::Result<()> {
            self.state.update(&[BLAKE2B_PREFIX_SCALAR]);
            self.state.update(scalar.to_repr().as_ref());
    
            Ok(())
        }
    *)
    Definition common_scalar (W C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self W C in
      match τ, α with
      | [], [ self; scalar ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let scalar := M.alloc (| scalar |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "blake2b_simd::State", "update", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bWrite",
                      "state"
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        Value.Array
                          [
                            M.read (|
                              M.get_constant (| "halo2_proofs::transcript::BLAKE2B_PREFIX_SCALAR" |)
                            |)
                          ]
                      |))
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "blake2b_simd::State", "update", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::Blake2bWrite",
                      "state"
                    |);
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::AsRef",
                        Ty.associated,
                        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                        "as_ref",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "ff::PrimeField",
                              Ty.associated,
                              [],
                              "to_repr",
                              []
                            |),
                            [ scalar ]
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (W C : Ty.t),
      M.IsTraitInstance
        "halo2_proofs::transcript::Transcript"
        (Self W C)
        (* Trait polymorphic types *)
        [ (* C *) C; (* E *) Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ] ]
        (* Instance *)
        [
          ("squeeze_challenge", InstanceField.Method (squeeze_challenge W C));
          ("common_point", InstanceField.Method (common_point W C));
          ("common_scalar", InstanceField.Method (common_scalar W C))
        ].
  End Impl_halo2_proofs_transcript_Transcript_where_std_io_Write_W_where_pairing_bn256_arithmetic_curves_CurveAffine_C_C_halo2_proofs_transcript_Challenge255_C_for_halo2_proofs_transcript_Blake2bWrite_W_C_halo2_proofs_transcript_Challenge255_C.
  
  (* StructRecord
    {
      name := "ChallengeScalar";
      ty_params := [ "C"; "T" ];
      fields :=
        [
          ("inner", Ty.associated);
          ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ T ])
        ];
    } *)
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_marker_Copy_T_where_core_marker_Copy_associated_type_for_halo2_proofs_transcript_ChallengeScalar_C_T.
    Definition Self (C T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::ChallengeScalar") [ C; T ].
    
    Axiom Implements :
      forall (C T : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (Self C T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_marker_Copy_T_where_core_marker_Copy_associated_type_for_halo2_proofs_transcript_ChallengeScalar_C_T.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_T_where_core_clone_Clone_associated_type_for_halo2_proofs_transcript_ChallengeScalar_C_T.
    Definition Self (C T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::ChallengeScalar") [ C; T ].
    
    (* Clone *)
    Definition clone (C T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "halo2_proofs::transcript::ChallengeScalar"
            [
              ("inner",
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", Ty.associated, [], "clone", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::ChallengeScalar",
                      "inner"
                    |)
                  ]
                |));
              ("_marker",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::marker::PhantomData") [ T ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "halo2_proofs::transcript::ChallengeScalar",
                      "_marker"
                    |)
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (C T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self C T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone C T)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_clone_Clone_T_where_core_clone_Clone_associated_type_for_halo2_proofs_transcript_ChallengeScalar_C_T.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_T_where_core_fmt_Debug_associated_type_for_halo2_proofs_transcript_ChallengeScalar_C_T.
    Definition Self (C T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::ChallengeScalar") [ C; T ].
    
    (* Debug *)
    Definition fmt (C T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C T in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "ChallengeScalar" |);
              M.read (| Value.String "inner" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "halo2_proofs::transcript::ChallengeScalar",
                  "inner"
                |));
              M.read (| Value.String "_marker" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "halo2_proofs::transcript::ChallengeScalar",
                    "_marker"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (C T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self C T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt C T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_where_core_fmt_Debug_T_where_core_fmt_Debug_associated_type_for_halo2_proofs_transcript_ChallengeScalar_C_T.
  
  Module Impl_core_ops_deref_Deref_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_transcript_ChallengeScalar_C_T.
    Definition Self (C T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::ChallengeScalar") [ C; T ].
    
    (*     type Target = C::Scalar; *)
    Definition _Target (C T : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn deref(&self) -> &Self::Target {
            &self.inner
        }
    *)
    Definition deref (C T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "halo2_proofs::transcript::ChallengeScalar",
            "inner"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (C T : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (Self C T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target C T)); ("deref", InstanceField.Method (deref C T)) ].
  End Impl_core_ops_deref_Deref_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_transcript_ChallengeScalar_C_T.
  
  (* Trait *)
  Module EncodedChallenge.
    Definition as_challenge_scalar (C Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "halo2_proofs::transcript::ChallengeScalar"
            [
              ("inner",
                M.call_closure (|
                  M.get_trait_method (|
                    "halo2_proofs::transcript::EncodedChallenge",
                    Self,
                    [ C ],
                    "get_scalar",
                    []
                  |),
                  [ M.read (| self |) ]
                |));
              ("_marker", Value.StructTuple "core::marker::PhantomData" [])
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_as_challenge_scalar :
      forall (C : Ty.t),
      M.IsProvidedMethod
        "halo2_proofs::transcript::EncodedChallenge"
        "as_challenge_scalar"
        (as_challenge_scalar C).
  End EncodedChallenge.
  
  (* StructTuple
    {
      name := "Challenge255";
      ty_params := [ "C" ];
      fields :=
        [
          Ty.apply (Ty.path "array") [ Ty.path "u8" ];
          Ty.apply (Ty.path "core::marker::PhantomData") [ C ]
        ];
    } *)
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_transcript_Challenge255_C.
    Definition Self (C : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ].
    
    Axiom Implements :
      forall (C : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (Self C)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_transcript_Challenge255_C.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_transcript_Challenge255_C.
    Definition Self (C : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ].
    
    (* Clone *)
    Definition clone (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "halo2_proofs::transcript::Challenge255"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply (Ty.path "array") [ Ty.path "u8" ],
                  [],
                  "clone",
                  []
                |),
                [
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::transcript::Challenge255",
                    0
                  |)
                ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply (Ty.path "core::marker::PhantomData") [ C ],
                  [],
                  "clone",
                  []
                |),
                [
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::transcript::Challenge255",
                    1
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (C : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self C)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone C)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_transcript_Challenge255_C.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_transcript_Challenge255_C.
    Definition Self (C : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ].
    
    (* Debug *)
    Definition fmt (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "Challenge255" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_tuple_field (|
                  M.read (| self |),
                  "halo2_proofs::transcript::Challenge255",
                  0
                |));
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "halo2_proofs::transcript::Challenge255",
                    1
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (C : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self C)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt C)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_C_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_transcript_Challenge255_C.
  
  Module Impl_core_ops_deref_Deref_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_transcript_Challenge255_C.
    Definition Self (C : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ].
    
    (*     type Target = [u8; 32]; *)
    Definition _Target (C : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ Ty.path "u8" ].
    
    (*
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    *)
    Definition deref (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_tuple_field (|
            M.read (| self |),
            "halo2_proofs::transcript::Challenge255",
            0
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (C : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (Self C)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target C)); ("deref", InstanceField.Method (deref C)) ].
  End Impl_core_ops_deref_Deref_where_pairing_bn256_arithmetic_curves_CurveAffine_C_for_halo2_proofs_transcript_Challenge255_C.
  
  Module Impl_halo2_proofs_transcript_EncodedChallenge_where_pairing_bn256_arithmetic_curves_CurveAffine_C_C_for_halo2_proofs_transcript_Challenge255_C.
    Definition Self (C : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "halo2_proofs::transcript::Challenge255") [ C ].
    
    (*     type Input = [u8; 64]; *)
    Definition _Input (C : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ Ty.path "u8" ].
    
    (*
        fn new(challenge_input: &[u8; 64]) -> Self {
            Challenge255(
                C::Scalar::from_bytes_wide(challenge_input)
                    .to_repr()
                    .as_ref()
                    .try_into()
                    .expect("Scalar fits into 256 bits"),
                PhantomData,
            )
        }
    *)
    Definition new (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match τ, α with
      | [], [ challenge_input ] =>
        ltac:(M.monadic
          (let challenge_input := M.alloc (| challenge_input |) in
          Value.StructTuple
            "halo2_proofs::transcript::Challenge255"
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply (Ty.path "array") [ Ty.path "u8" ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  "expect",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryInto",
                      Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                      [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ],
                      "try_into",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::AsRef",
                          Ty.associated,
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                          "as_ref",
                          []
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "ff::PrimeField",
                                Ty.associated,
                                [],
                                "to_repr",
                                []
                              |),
                              [
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "pairing_bn256::arithmetic::fields::BaseExt",
                                      Ty.associated,
                                      [],
                                      "from_bytes_wide",
                                      []
                                    |),
                                    [ M.read (| challenge_input |) ]
                                  |)
                                |)
                              ]
                            |)
                          |)
                        ]
                      |)
                    ]
                  |);
                  M.read (| Value.String "Scalar fits into 256 bits" |)
                ]
              |);
              Value.StructTuple "core::marker::PhantomData" []
            ]))
      | _, _ => M.impossible
      end.
    
    (*
        fn get_scalar(&self) -> C::Scalar {
            let mut repr = <C::Scalar as PrimeField>::Repr::default();
            repr.as_mut().copy_from_slice(&self.0);
            C::Scalar::from_repr(repr).unwrap()
        }
    *)
    Definition get_scalar (C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let repr :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.associated,
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                    "copy_from_slice",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::AsMut",
                        Ty.associated,
                        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                        "as_mut",
                        []
                      |),
                      [ repr ]
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.SubPointer.get_struct_tuple_field (|
                        M.read (| self |),
                        "halo2_proofs::transcript::Challenge255",
                        0
                      |))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "subtle::CtOption") [ Ty.associated ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (| "ff::PrimeField", Ty.associated, [], "from_repr", [] |),
                    [ M.read (| repr |) ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (C : Ty.t),
      M.IsTraitInstance
        "halo2_proofs::transcript::EncodedChallenge"
        (Self C)
        (* Trait polymorphic types *) [ (* C *) C ]
        (* Instance *)
        [
          ("Input", InstanceField.Ty (_Input C));
          ("new", InstanceField.Method (new C));
          ("get_scalar", InstanceField.Method (get_scalar C))
        ].
  End Impl_halo2_proofs_transcript_EncodedChallenge_where_pairing_bn256_arithmetic_curves_CurveAffine_C_C_for_halo2_proofs_transcript_Challenge255_C.
  
  (*
  pub fn read_n_points<C: CurveAffine, E: EncodedChallenge<C>, T: TranscriptRead<C, E>>(
      transcript: &mut T,
      n: usize,
  ) -> io::Result<Vec<C>> {
      (0..n).map(|_| transcript.read_point()).collect()
  }
  *)
  Definition read_n_points (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ C; E; T ], [ transcript; n ] =>
      ltac:(M.monadic
        (let transcript := M.alloc (| transcript |) in
        let n := M.alloc (| n |) in
        M.call_closure (|
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply
              (Ty.path "core::iter::adapters::map::Map")
              [
                Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ];
                Ty.function
                  [ Ty.tuple [ Ty.path "usize" ] ]
                  (Ty.apply (Ty.path "core::result::Result") [ C; Ty.path "std::io::error::Error" ])
              ],
            [],
            "collect",
            [
              Ty.apply
                (Ty.path "core::result::Result")
                [
                  Ty.apply (Ty.path "alloc::vec::Vec") [ C; Ty.path "alloc::alloc::Global" ];
                  Ty.path "std::io::error::Error"
                ]
            ]
          |),
          [
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ],
                [],
                "map",
                [
                  Ty.apply (Ty.path "core::result::Result") [ C; Ty.path "std::io::error::Error" ];
                  Ty.function
                    [ Ty.tuple [ Ty.path "usize" ] ]
                    (Ty.apply
                      (Ty.path "core::result::Result")
                      [ C; Ty.path "std::io::error::Error" ])
                ]
              |),
              [
                Value.StructRecord
                  "core::ops::range::Range"
                  [ ("start", Value.Integer 0); ("end_", M.read (| n |)) ];
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        M.match_operator (|
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_point",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)))
                          ]
                        |)
                      | _ => M.impossible (||)
                      end))
              ]
            |)
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub fn read_n_scalars<C: CurveAffine, E: EncodedChallenge<C>, T: TranscriptRead<C, E>>(
      transcript: &mut T,
      n: usize,
  ) -> io::Result<Vec<C::Scalar>> {
      (0..n).map(|_| transcript.read_scalar()).collect()
  }
  *)
  Definition read_n_scalars (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ C; E; T ], [ transcript; n ] =>
      ltac:(M.monadic
        (let transcript := M.alloc (| transcript |) in
        let n := M.alloc (| n |) in
        M.call_closure (|
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply
              (Ty.path "core::iter::adapters::map::Map")
              [
                Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ];
                Ty.function
                  [ Ty.tuple [ Ty.path "usize" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.associated; Ty.path "std::io::error::Error" ])
              ],
            [],
            "collect",
            [
              Ty.apply
                (Ty.path "core::result::Result")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.associated; Ty.path "alloc::alloc::Global" ];
                  Ty.path "std::io::error::Error"
                ]
            ]
          |),
          [
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ],
                [],
                "map",
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.associated; Ty.path "std::io::error::Error" ];
                  Ty.function
                    [ Ty.tuple [ Ty.path "usize" ] ]
                    (Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.associated; Ty.path "std::io::error::Error" ])
                ]
              |),
              [
                Value.StructRecord
                  "core::ops::range::Range"
                  [ ("start", Value.Integer 0); ("end_", M.read (| n |)) ];
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        M.match_operator (|
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.call_closure (|
                                  M.get_trait_method (|
                                    "halo2_proofs::transcript::TranscriptRead",
                                    T,
                                    [ C; E ],
                                    "read_scalar",
                                    []
                                  |),
                                  [ M.read (| transcript |) ]
                                |)))
                          ]
                        |)
                      | _ => M.impossible (||)
                      end))
              ]
            |)
          ]
        |)))
    | _, _ => M.impossible
    end.
End transcript.
