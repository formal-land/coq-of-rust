(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module erc20.
  Module Impl_ink_env_contract_ContractEnv_for_erc20_erc20_Erc20.
    Definition Self := erc20.erc20.Erc20.
    
    Definition Env : Set := ink_env.types.DefaultEnvironment.
    
    Global Instance I : ink_env.contract.ContractEnv.Trait Self := {
    }.
  End Impl_ink_env_contract_ContractEnv_for_erc20_erc20_Erc20.
  
  Definition Environment : Set := ink_env.contract.ContractEnv.Env.
  
  Definition AccountId : Set := ink_env.types.Environment.AccountId.
  
  Definition Balance : Set := ink_env.types.Environment.Balance.
  
  Definition Hash : Set := ink_env.types.Environment.Hash.
  
  Definition Timestamp : Set := ink_env.types.Environment.Timestamp.
  
  Definition BlockNumber : Set := ink_env.types.Environment.BlockNumber.
  
  Definition ChainExtension : Set := ink_env.types.Environment.ChainExtension.
  
  Definition MAX_EVENT_TOPICS `{H : State.Trait} : usize :=
    run (Pure ink_env.types.Environment.MAX_EVENT_TOPICS).
  
  Module Erc20.
    Unset Primitive Projections.
    Record t : Set := {
      total_supply : ink_storage_traits.storage.AutoStorableHint.Type_;
      balances : ink_storage_traits.storage.AutoStorableHint.Type_;
      allowances : ink_storage_traits.storage.AutoStorableHint.Type_;
    }.
    Global Set Primitive Projections.
    
    Global Instance Get_total_supply : Notation.Dot "total_supply" := {
      Notation.dot '(Build_t x0 _ _) := x0;
    }.
    Global Instance Get_balances : Notation.Dot "balances" := {
      Notation.dot '(Build_t _ x1 _) := x1;
    }.
    Global Instance Get_allowances : Notation.Dot "allowances" := {
      Notation.dot '(Build_t _ _ x2) := x2;
    }.
  End Erc20.
  Definition Erc20 : Set := @Erc20.t.
  
  Module Impl_core_default_Default_for_erc20_erc20_Erc20.
    Definition Self := erc20.erc20.Erc20.
    
    Definition default `{H : State.Trait} : M (H := H) erc20.erc20.Erc20 :=
      let* α0 := core.default.Default.default in
      let* α1 := core.default.Default.default in
      let* α2 := core.default.Default.default in
      Pure
        {|
          erc20.erc20.Erc20.total_supply := α0;
          erc20.erc20.Erc20.balances := α1;
          erc20.erc20.Erc20.allowances := α2;
        |}.
    
    Global Instance AssociatedFunction_default `{H : State.Trait} :
      Notation.DoubleColon Self "default" := {
      Notation.double_colon := default;
    }.
    
    Global Instance I : core.default.Default.Trait Self := {
      core.default.Default.default `{H : State.Trait} := default;
    }.
  End Impl_core_default_Default_for_erc20_erc20_Erc20.
  
  Module __ink_EventBase.
    Inductive t : Set :=
    | Transfer (_ : erc20.erc20.Transfer)
    | Approval (_ : erc20.erc20.Approval).
  End __ink_EventBase.
  Definition __ink_EventBase := __ink_EventBase.t.
  
  Module Impl_ink_codegen_event_topics_EventLenTopics_for_erc20_erc20_Transfer.
    Definition Self := erc20.erc20.Transfer.
    
    Definition LenTopics : Set := ink.codegen.event.topics.EventTopics.
    
    Global Instance I : ink.codegen.event.topics.EventLenTopics.Trait Self := {
    }.
  End Impl_ink_codegen_event_topics_EventLenTopics_for_erc20_erc20_Transfer.
  
  Module Impl_ink_codegen_event_topics_EventLenTopics_for_erc20_erc20_Approval.
    Definition Self := erc20.erc20.Approval.
    
    Definition LenTopics : Set := ink.codegen.event.topics.EventTopics.
    
    Global Instance I : ink.codegen.event.topics.EventLenTopics.Trait Self := {
    }.
  End Impl_ink_codegen_event_topics_EventLenTopics_for_erc20_erc20_Approval.
  
  Module Transfer.
    Unset Primitive Projections.
    Record t : Set := {
      from : core.option.Option erc20.erc20.AccountId;
      to : core.option.Option erc20.erc20.AccountId;
      value : erc20.erc20.Balance;
    }.
    Global Set Primitive Projections.
    
    Global Instance Get_from : Notation.Dot "from" := {
      Notation.dot '(Build_t x0 _ _) := x0;
    }.
    Global Instance Get_to : Notation.Dot "to" := {
      Notation.dot '(Build_t _ x1 _) := x1;
    }.
    Global Instance Get_value : Notation.Dot "value" := {
      Notation.dot '(Build_t _ _ x2) := x2;
    }.
  End Transfer.
  Definition Transfer : Set := @Transfer.t.
  
  Module Approval.
    Unset Primitive Projections.
    Record t : Set := {
      owner : erc20.erc20.AccountId;
      spender : erc20.erc20.AccountId;
      value : erc20.erc20.Balance;
    }.
    Global Set Primitive Projections.
    
    Global Instance Get_owner : Notation.Dot "owner" := {
      Notation.dot '(Build_t x0 _ _) := x0;
    }.
    Global Instance Get_spender : Notation.Dot "spender" := {
      Notation.dot '(Build_t _ x1 _) := x1;
    }.
    Global Instance Get_value : Notation.Dot "value" := {
      Notation.dot '(Build_t _ _ x2) := x2;
    }.
  End Approval.
  Definition Approval : Set := @Approval.t.
  
  Module
    Impl_ink_reflect_dispatch_DispatchableConstructorInfo_for_erc20_erc20_Erc20.
    Definition Self := erc20.erc20.Erc20.
    
    Definition Input : Set := erc20.erc20.Balance.
    
    Definition Output : Set := Self.
    
    Definition Storage : Set := erc20.erc20.Erc20.
    
    Definition Error : Set := ink.reflect.dispatch.ConstructorOutput.Error.
    
    Definition
      IS_RESULT := Pure ink.reflect.dispatch.ConstructorOutput.IS_RESULT.
    
    Global Instance AssociatedFunction_IS_RESULT `{H : State.Trait} :
      Notation.DoubleColon Self "IS_RESULT" := {
      Notation.double_colon := IS_RESULT;
    }.
    
    Definition
      CALLABLE := Pure
        (fun __ink_binding_0 => erc20.erc20.Erc20::["new"] __ink_binding_0).
    
    Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition PAYABLE := Pure false.
    
    Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition SELECTOR := Pure [ 155; 174; 157; 94 ].
    
    Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition LABEL := Pure "new".
    
    Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I :
        ink.reflect.dispatch.DispatchableConstructorInfo.Trait Self := {
      ink.reflect.dispatch.DispatchableConstructorInfo.IS_RESULT
        `{H : State.Trait}
        :=
        IS_RESULT;
      ink.reflect.dispatch.DispatchableConstructorInfo.CALLABLE
        `{H : State.Trait}
        :=
        CALLABLE;
      ink.reflect.dispatch.DispatchableConstructorInfo.PAYABLE
        `{H : State.Trait}
        :=
        PAYABLE;
      ink.reflect.dispatch.DispatchableConstructorInfo.SELECTOR
        `{H : State.Trait}
        :=
        SELECTOR;
      ink.reflect.dispatch.DispatchableConstructorInfo.LABEL
        `{H : State.Trait}
        :=
        LABEL;
    }.
  End
    Impl_ink_reflect_dispatch_DispatchableConstructorInfo_for_erc20_erc20_Erc20.
  
  Module
    Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
    Definition Self := erc20.erc20.Erc20.
    
    Definition Input : Set := unit.
    
    Definition Output : Set := erc20.erc20.Balance.
    
    Definition Storage : Set := erc20.erc20.Erc20.
    
    Definition
      CALLABLE := Pure
        (fun storage _ => erc20.erc20.Erc20::["total_supply"] storage).
    
    Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := Pure [ 219; 99; 117; 168 ].
    
    Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := Pure false.
    
    Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := Pure false.
    
    Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := Pure "total_supply".
    
    Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I :
        ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
      ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
        `{H : State.Trait}
        :=
        CALLABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
        `{H : State.Trait}
        :=
        MUTATES;
      ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
        `{H : State.Trait}
        :=
        PAYABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
        `{H : State.Trait}
        :=
        SELECTOR;
      ink.reflect.dispatch.DispatchableMessageInfo.LABEL
        `{H : State.Trait}
        :=
        LABEL;
    }.
  End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  
  Module
    Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
    Definition Self := erc20.erc20.Erc20.
    
    Definition Input : Set := erc20.erc20.AccountId.
    
    Definition Output : Set := erc20.erc20.Balance.
    
    Definition Storage : Set := erc20.erc20.Erc20.
    
    Definition
      CALLABLE := Pure
        (fun storage __ink_binding_0 =>
          erc20.erc20.Erc20::["balance_of"] storage __ink_binding_0).
    
    Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := Pure [ 15; 117; 90; 86 ].
    
    Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := Pure false.
    
    Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := Pure false.
    
    Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := Pure "balance_of".
    
    Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I :
        ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
      ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
        `{H : State.Trait}
        :=
        CALLABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
        `{H : State.Trait}
        :=
        MUTATES;
      ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
        `{H : State.Trait}
        :=
        PAYABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
        `{H : State.Trait}
        :=
        SELECTOR;
      ink.reflect.dispatch.DispatchableMessageInfo.LABEL
        `{H : State.Trait}
        :=
        LABEL;
    }.
  End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  
  Module
    Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
    Definition Self := erc20.erc20.Erc20.
    
    Definition Input : Set := erc20.erc20.AccountId * erc20.erc20.AccountId.
    
    Definition Output : Set := erc20.erc20.Balance.
    
    Definition Storage : Set := erc20.erc20.Erc20.
    
    Definition
      CALLABLE := Pure
        (fun storage (__ink_binding_0, __ink_binding_1) =>
          erc20.erc20.Erc20::["allowance"]
            storage
            __ink_binding_0
            __ink_binding_1).
    
    Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := Pure [ 106; 0; 22; 94 ].
    
    Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := Pure false.
    
    Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := Pure false.
    
    Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := Pure "allowance".
    
    Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I :
        ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
      ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
        `{H : State.Trait}
        :=
        CALLABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
        `{H : State.Trait}
        :=
        MUTATES;
      ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
        `{H : State.Trait}
        :=
        PAYABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
        `{H : State.Trait}
        :=
        SELECTOR;
      ink.reflect.dispatch.DispatchableMessageInfo.LABEL
        `{H : State.Trait}
        :=
        LABEL;
    }.
  End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  
  Module
    Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
    Definition Self := erc20.erc20.Erc20.
    
    Definition Input : Set := erc20.erc20.AccountId * erc20.erc20.Balance.
    
    Definition Output : Set := erc20.erc20.Result unit.
    
    Definition Storage : Set := erc20.erc20.Erc20.
    
    Definition
      CALLABLE := Pure
        (fun storage (__ink_binding_0, __ink_binding_1) =>
          erc20.erc20.Erc20::["transfer"]
            storage
            __ink_binding_0
            __ink_binding_1).
    
    Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := Pure [ 132; 161; 93; 161 ].
    
    Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := Pure false.
    
    Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := Pure true.
    
    Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := Pure "transfer".
    
    Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I :
        ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
      ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
        `{H : State.Trait}
        :=
        CALLABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
        `{H : State.Trait}
        :=
        MUTATES;
      ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
        `{H : State.Trait}
        :=
        PAYABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
        `{H : State.Trait}
        :=
        SELECTOR;
      ink.reflect.dispatch.DispatchableMessageInfo.LABEL
        `{H : State.Trait}
        :=
        LABEL;
    }.
  End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  
  Module
    Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
    Definition Self := erc20.erc20.Erc20.
    
    Definition Input : Set := erc20.erc20.AccountId * erc20.erc20.Balance.
    
    Definition Output : Set := erc20.erc20.Result unit.
    
    Definition Storage : Set := erc20.erc20.Erc20.
    
    Definition
      CALLABLE := Pure
        (fun storage (__ink_binding_0, __ink_binding_1) =>
          erc20.erc20.Erc20::["approve"]
            storage
            __ink_binding_0
            __ink_binding_1).
    
    Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := Pure [ 104; 18; 102; 160 ].
    
    Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := Pure false.
    
    Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := Pure true.
    
    Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := Pure "approve".
    
    Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I :
        ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
      ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
        `{H : State.Trait}
        :=
        CALLABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
        `{H : State.Trait}
        :=
        MUTATES;
      ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
        `{H : State.Trait}
        :=
        PAYABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
        `{H : State.Trait}
        :=
        SELECTOR;
      ink.reflect.dispatch.DispatchableMessageInfo.LABEL
        `{H : State.Trait}
        :=
        LABEL;
    }.
  End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  
  Module
    Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
    Definition Self := erc20.erc20.Erc20.
    
    Definition Input : Set :=
      erc20.erc20.AccountId * erc20.erc20.AccountId * erc20.erc20.Balance.
    
    Definition Output : Set := erc20.erc20.Result unit.
    
    Definition Storage : Set := erc20.erc20.Erc20.
    
    Definition
      CALLABLE := Pure
        (fun storage (__ink_binding_0, __ink_binding_1, __ink_binding_2) =>
          erc20.erc20.Erc20::["transfer_from"]
            storage
            __ink_binding_0
            __ink_binding_1
            __ink_binding_2).
    
    Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := Pure [ 11; 57; 111; 24 ].
    
    Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := Pure false.
    
    Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := Pure true.
    
    Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := Pure "transfer_from".
    
    Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I :
        ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
      ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
        `{H : State.Trait}
        :=
        CALLABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
        `{H : State.Trait}
        :=
        MUTATES;
      ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
        `{H : State.Trait}
        :=
        PAYABLE;
      ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
        `{H : State.Trait}
        :=
        SELECTOR;
      ink.reflect.dispatch.DispatchableMessageInfo.LABEL
        `{H : State.Trait}
        :=
        LABEL;
    }.
  End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  
  Module Erc20Ref.
    Unset Primitive Projections.
    Record t : Set := {
      inner : ink.codegen.dispatch.info.ContractCallBuilder.Type_;
    }.
    Global Set Primitive Projections.
    
    Global Instance Get_inner : Notation.Dot "inner" := {
      Notation.dot '(Build_t x0) := x0;
    }.
  End Erc20Ref.
  Definition Erc20Ref : Set := @Erc20Ref.t.
  
  Module Impl_core_fmt_Debug_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Parameter debug_struct_field1_finish : core.fmt.Formatter -> string -> 
      string -> ink_codegen_dispatch_info_ContractCallBuilder_Type_ -> 
      M (H := H) core.fmt.Result.
    
    Global Instance Deb_debug_struct_field1_finish : Notation.DoubleColon
      core.fmt.Formatter "debug_struct_field1_finish" := {
      Notation.double_colon := debug_struct_field1_finish; }.
    
    Definition fmt
        `{H : State.Trait}
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter)
        : M (H := H) core.fmt.Result :=
      core.fmt.Formatter::["debug_struct_field1_finish"]
        f
        "Erc20Ref"
        "inner"
        (addr_of (addr_of self.["inner"])).
    
    Global Instance Method_fmt `{H : State.Trait} : Notation.Dot "fmt" := {
      Notation.dot := fmt;
    }.
    
    Global Instance I : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt `{H : State.Trait} := fmt;
    }.
  End Impl_core_fmt_Debug_for_erc20_erc20_Erc20Ref.
  
  Module Impl_core_hash_Hash_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Definition hash
        `{H : State.Trait}
        {__H : Set}
        `{core.hash.Hasher.Trait __H}
        (self : ref Self)
        (state : mut_ref __H)
        : M (H := H) unit :=
      core.hash.Hash.hash (addr_of self.["inner"]) state.
    
    Global Instance Method_hash `{H : State.Trait} : Notation.Dot "hash" := {
      Notation.dot := hash;
    }.
    
    Global Instance I : core.hash.Hash.Trait Self := {
      core.hash.Hash.hash `{H : State.Trait} := hash;
    }.
  End Impl_core_hash_Hash_for_erc20_erc20_Erc20Ref.
  
  Module Impl_core_marker_StructuralPartialEq_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Global Instance I : core.marker.StructuralPartialEq.Trait Self :=
      core.marker.StructuralPartialEq.Build_Trait _.
  End Impl_core_marker_StructuralPartialEq_for_erc20_erc20_Erc20Ref.
  
  Module Impl_core_cmp_PartialEq_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Definition eq
        `{H : State.Trait}
        (self : ref Self)
        (other : ref erc20.erc20.Erc20Ref)
        : M (H := H) bool :=
      self.["inner"].["eq"] other.["inner"].
    
    Global Instance Method_eq `{H : State.Trait} : Notation.Dot "eq" := {
      Notation.dot := eq;
    }.
    
    Global Instance I : core.cmp.PartialEq.Trait Self (Rhs := None) := {
      core.cmp.PartialEq.eq `{H : State.Trait} := eq;
    }.
  End Impl_core_cmp_PartialEq_for_erc20_erc20_Erc20Ref.
  
  Module Impl_core_marker_StructuralEq_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Global Instance I : core.marker.StructuralEq.Trait Self :=
      core.marker.StructuralEq.Build_Trait _.
  End Impl_core_marker_StructuralEq_for_erc20_erc20_Erc20Ref.
  
  Module Impl_core_cmp_Eq_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Definition assert_receiver_is_total_eq
        `{H : State.Trait}
        (self : ref Self)
        : M (H := H) unit :=
      let
          _ :
          core.cmp.AssertParamIsEq
            ink.codegen.dispatch.info.ContractCallBuilder.Type_ :=
        tt in
      Pure tt.
    
    Global Instance Method_assert_receiver_is_total_eq `{H : State.Trait} :
      Notation.Dot "assert_receiver_is_total_eq" := {
      Notation.dot := assert_receiver_is_total_eq;
    }.
    
    Global Instance I : core.cmp.Eq.Trait Self := {
    }.
  End Impl_core_cmp_Eq_for_erc20_erc20_Erc20Ref.
  
  Module Impl_core_clone_Clone_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Definition clone
        `{H : State.Trait}
        (self : ref Self)
        : M (H := H) erc20.erc20.Erc20Ref :=
      let* α0 := core.clone.Clone.clone (addr_of self.["inner"]) in
      Pure {| erc20.erc20.Erc20Ref.inner := α0; |}.
    
    Global Instance Method_clone `{H : State.Trait} : Notation.Dot "clone" := {
      Notation.dot := clone;
    }.
    
    Global Instance I : core.clone.Clone.Trait Self := {
      core.clone.Clone.clone `{H : State.Trait} := clone;
    }.
  End Impl_core_clone_Clone_for_erc20_erc20_Erc20Ref.
  
  Module Impl_erc20_erc20_Erc20Ref_8.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Definition new
        `{H : State.Trait}
        (__ink_binding_0 : erc20.erc20.Balance)
        :
          M (H := H)
            (ink_env.call.create_builder.CreateBuilder
              erc20.erc20.Environment
              Self
              (ink_env.call.common.Unset erc20.erc20.Hash)
              (ink_env.call.common.Unset u64)
              (ink_env.call.common.Unset erc20.erc20.Balance)
              (ink_env.call.common.Set
                (ink_env.call.execution_input.ExecutionInput
                  (ink_env.call.execution_input.ArgumentList
                    (ink_env.call.execution_input.Argument erc20.erc20.Balance)
                    ink_env.call.execution_input.EmptyArgumentList)))
              (ink_env.call.common.Unset ink_env.call.create_builder.state.Salt)
              (ink_env.call.common.Set
                (ink_env.call.common.ReturnType Self))) :=
      let* α0 := ink_env.call.create_builder.build_create in
      let* α1 :=
        ink_env.call.selector.Selector::["new"] [ 155; 174; 157; 94 ] in
      let* α2 := ink_env.call.execution_input.ExecutionInput::["new"] α1 in
      let* α3 := α2.["push_arg"] __ink_binding_0 in
      let* α4 := α0.["exec_input"] α3 in
      α4.["returns"] : M Self.
    
    Global Instance AssociatedFunction_new `{H : State.Trait} :
      Notation.DoubleColon Self "new" := {
      Notation.double_colon := new;
    }.
    
    Definition total_supply
        `{H : State.Trait}
        (self : ref Self)
        : M (H := H) erc20.erc20.Balance :=
      let* α0 := self.["try_total_supply"] in
      α0.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::total_supply: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_total_supply `{H : State.Trait} :
      Notation.Dot "total_supply" := {
      Notation.dot := total_supply;
    }.
    
    Definition try_total_supply
        `{H : State.Trait}
        (self : ref Self)
        : M (H := H) (ink_primitives.MessageResult erc20.erc20.Balance) :=
      let* α0 :=
        ink.codegen.trait_def.call_builder.TraitCallBuilder.call self in
      let* α1 := α0.["total_supply"] in
      let* α2 := α1.["try_invoke"] in
      α2.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::total_supply: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_try_total_supply `{H : State.Trait} :
      Notation.Dot "try_total_supply" := {
      Notation.dot := try_total_supply;
    }.
    
    Definition balance_of
        `{H : State.Trait}
        (self : ref Self)
        (owner : erc20.erc20.AccountId)
        : M (H := H) erc20.erc20.Balance :=
      let* α0 := self.["try_balance_of"] owner in
      α0.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::balance_of: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_balance_of `{H : State.Trait} :
      Notation.Dot "balance_of" := {
      Notation.dot := balance_of;
    }.
    
    Definition try_balance_of
        `{H : State.Trait}
        (self : ref Self)
        (owner : erc20.erc20.AccountId)
        : M (H := H) (ink_primitives.MessageResult erc20.erc20.Balance) :=
      let* α0 :=
        ink.codegen.trait_def.call_builder.TraitCallBuilder.call self in
      let* α1 := α0.["balance_of"] owner in
      let* α2 := α1.["try_invoke"] in
      α2.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::balance_of: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_try_balance_of `{H : State.Trait} :
      Notation.Dot "try_balance_of" := {
      Notation.dot := try_balance_of;
    }.
    
    Definition allowance
        `{H : State.Trait}
        (self : ref Self)
        (owner : erc20.erc20.AccountId)
        (spender : erc20.erc20.AccountId)
        : M (H := H) erc20.erc20.Balance :=
      let* α0 := self.["try_allowance"] owner spender in
      α0.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::allowance: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_allowance `{H : State.Trait} :
      Notation.Dot "allowance" := {
      Notation.dot := allowance;
    }.
    
    Definition try_allowance
        `{H : State.Trait}
        (self : ref Self)
        (owner : erc20.erc20.AccountId)
        (spender : erc20.erc20.AccountId)
        : M (H := H) (ink_primitives.MessageResult erc20.erc20.Balance) :=
      let* α0 :=
        ink.codegen.trait_def.call_builder.TraitCallBuilder.call self in
      let* α1 := α0.["allowance"] owner spender in
      let* α2 := α1.["try_invoke"] in
      α2.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::allowance: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_try_allowance `{H : State.Trait} :
      Notation.Dot "try_allowance" := {
      Notation.dot := try_allowance;
    }.
    
    Definition transfer
        `{H : State.Trait}
        (self : mut_ref Self)
        (to : erc20.erc20.AccountId)
        (value : erc20.erc20.Balance)
        : M (H := H) (erc20.erc20.Result unit) :=
      let* α0 := self.["try_transfer"] to value in
      α0.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::transfer: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_transfer `{H : State.Trait} :
      Notation.Dot "transfer" := {
      Notation.dot := transfer;
    }.
    
    Definition try_transfer
        `{H : State.Trait}
        (self : mut_ref Self)
        (to : erc20.erc20.AccountId)
        (value : erc20.erc20.Balance)
        : M (H := H) (ink_primitives.MessageResult (erc20.erc20.Result unit)) :=
      let* α0 :=
        ink.codegen.trait_def.call_builder.TraitCallBuilder.call_mut self in
      let* α1 := α0.["transfer"] to value in
      let* α2 := α1.["try_invoke"] in
      α2.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::transfer: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_try_transfer `{H : State.Trait} :
      Notation.Dot "try_transfer" := {
      Notation.dot := try_transfer;
    }.
    
    Definition approve
        `{H : State.Trait}
        (self : mut_ref Self)
        (spender : erc20.erc20.AccountId)
        (value : erc20.erc20.Balance)
        : M (H := H) (erc20.erc20.Result unit) :=
      let* α0 := self.["try_approve"] spender value in
      α0.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::approve: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_approve `{H : State.Trait} :
      Notation.Dot "approve" := {
      Notation.dot := approve;
    }.
    
    Definition try_approve
        `{H : State.Trait}
        (self : mut_ref Self)
        (spender : erc20.erc20.AccountId)
        (value : erc20.erc20.Balance)
        : M (H := H) (ink_primitives.MessageResult (erc20.erc20.Result unit)) :=
      let* α0 :=
        ink.codegen.trait_def.call_builder.TraitCallBuilder.call_mut self in
      let* α1 := α0.["approve"] spender value in
      let* α2 := α1.["try_invoke"] in
      α2.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::approve: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_try_approve `{H : State.Trait} :
      Notation.Dot "try_approve" := {
      Notation.dot := try_approve;
    }.
    
    Definition transfer_from
        `{H : State.Trait}
        (self : mut_ref Self)
        (from : erc20.erc20.AccountId)
        (to : erc20.erc20.AccountId)
        (value : erc20.erc20.Balance)
        : M (H := H) (erc20.erc20.Result unit) :=
      let* α0 := self.["try_transfer_from"] from to value in
      α0.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::transfer_from: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_transfer_from `{H : State.Trait} :
      Notation.Dot "transfer_from" := {
      Notation.dot := transfer_from;
    }.
    
    Definition try_transfer_from
        `{H : State.Trait}
        (self : mut_ref Self)
        (from : erc20.erc20.AccountId)
        (to : erc20.erc20.AccountId)
        (value : erc20.erc20.Balance)
        : M (H := H) (ink_primitives.MessageResult (erc20.erc20.Result unit)) :=
      let* α0 :=
        ink.codegen.trait_def.call_builder.TraitCallBuilder.call_mut self in
      let* α1 := α0.["transfer_from"] from to value in
      let* α2 := α1.["try_invoke"] in
      α2.["unwrap_or_else"]
        (fun error =>
          let* α0 := format_argument::["new_debug"] (addr_of error) in
          let* α1 :=
            format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::transfer_from: " ])
              (addr_of [ α0 ]) in
          core.panicking.panic_fmt α1).
    
    Global Instance Method_try_transfer_from `{H : State.Trait} :
      Notation.Dot "try_transfer_from" := {
      Notation.dot := try_transfer_from;
    }.
  End Impl_erc20_erc20_Erc20Ref_8.
  
  Module
    Impl_ink_env_call_create_builder_FromAccountId_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Definition from_account_id
        `{H : State.Trait}
        (account_id : erc20.erc20.AccountId)
        : M (H := H) Self :=
      let* α0 :=
        ink_env.call.create_builder.FromAccountId.from_account_id account_id in
      Pure {| Self.inner := α0; |}.
    
    Global Instance AssociatedFunction_from_account_id `{H : State.Trait} :
      Notation.DoubleColon Self "from_account_id" := {
      Notation.double_colon := from_account_id;
    }.
    
    Global Instance I :
        ink_env.call.create_builder.FromAccountId.Trait
          Self
          (T := erc20.erc20.Environment) := {
      ink_env.call.create_builder.FromAccountId.from_account_id
        `{H : State.Trait}
        :=
        from_account_id;
    }.
  End Impl_ink_env_call_create_builder_FromAccountId_for_erc20_erc20_Erc20Ref.
  
  Module Impl_ink_contract_ref_ToAccountId_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Definition to_account_id
        `{H : State.Trait}
        (self : ref Self)
        : M (H := H) erc20.erc20.AccountId :=
      ink.contract_ref.ToAccountId.to_account_id (addr_of self.["inner"]).
    
    Global Instance Method_to_account_id `{H : State.Trait} :
      Notation.Dot "to_account_id" := {
      Notation.dot := to_account_id;
    }.
    
    Global Instance I :
        ink.contract_ref.ToAccountId.Trait
          Self
          (T := erc20.erc20.Environment) := {
      ink.contract_ref.ToAccountId.to_account_id
        `{H : State.Trait}
        :=
        to_account_id;
    }.
  End Impl_ink_contract_ref_ToAccountId_for_erc20_erc20_Erc20Ref.
  
  Module Impl_core_convert_AsRef_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Definition as_ref
        `{H : State.Trait}
        (self : ref Self)
        : M (H := H) (ref erc20.erc20.AccountId) :=
      core.convert.AsRef.as_ref (addr_of self.["inner"]).
    
    Global Instance Method_as_ref `{H : State.Trait} :
      Notation.Dot "as_ref" := {
      Notation.dot := as_ref;
    }.
    
    Global Instance I :
        core.convert.AsRef.Trait Self (T := erc20.erc20.AccountId) := {
      core.convert.AsRef.as_ref `{H : State.Trait} := as_ref;
    }.
  End Impl_core_convert_AsRef_for_erc20_erc20_Erc20Ref.
  
  Module Impl_core_convert_AsMut_for_erc20_erc20_Erc20Ref.
    Definition Self := erc20.erc20.Erc20Ref.
    
    Definition as_mut
        `{H : State.Trait}
        (self : mut_ref Self)
        : M (H := H) (mut_ref erc20.erc20.AccountId) :=
      core.convert.AsMut.as_mut (addr_of self.["inner"]).
    
    Global Instance Method_as_mut `{H : State.Trait} :
      Notation.Dot "as_mut" := {
      Notation.dot := as_mut;
    }.
    
    Global Instance I :
        core.convert.AsMut.Trait Self (T := erc20.erc20.AccountId) := {
      core.convert.AsMut.as_mut `{H : State.Trait} := as_mut;
    }.
  End Impl_core_convert_AsMut_for_erc20_erc20_Erc20Ref.
  
  Module Error.
    Inductive t : Set :=
    | InsufficientBalance
    | InsufficientAllowance.
  End Error.
  Definition Error := Error.t.
  
  Module Impl_core_fmt_Debug_for_erc20_erc20_Error.
    Definition Self := erc20.erc20.Error.
    
    Definition fmt
        `{H : State.Trait}
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter)
        : M (H := H) core.fmt.Result :=
      let* α0 :=
        match self with
        | erc20.erc20.Error.InsufficientBalance => Pure "InsufficientBalance"
        | erc20.erc20.Error.InsufficientAllowance =>
          Pure "InsufficientAllowance"
        end in
      core.fmt.Formatter::["write_str"] f α0.
    
    Global Instance Method_fmt `{H : State.Trait} : Notation.Dot "fmt" := {
      Notation.dot := fmt;
    }.
    
    Global Instance I : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt `{H : State.Trait} := fmt;
    }.
  End Impl_core_fmt_Debug_for_erc20_erc20_Error.
  
  Module Impl_core_marker_StructuralPartialEq_for_erc20_erc20_Error.
    Definition Self := erc20.erc20.Error.
    
    Global Instance I : core.marker.StructuralPartialEq.Trait Self :=
      core.marker.StructuralPartialEq.Build_Trait _.
  End Impl_core_marker_StructuralPartialEq_for_erc20_erc20_Error.
  
  Module Impl_core_cmp_PartialEq_for_erc20_erc20_Error.
    Definition Self := erc20.erc20.Error.
    
    Definition eq
        `{H : State.Trait}
        (self : ref Self)
        (other : ref erc20.erc20.Error)
        : M (H := H) bool :=
      let* __self_tag := core.intrinsics.discriminant_value self in
      let* __arg1_tag := core.intrinsics.discriminant_value other in
      __self_tag.["eq"] __arg1_tag.
    
    Global Instance Method_eq `{H : State.Trait} : Notation.Dot "eq" := {
      Notation.dot := eq;
    }.
    
    Global Instance I : core.cmp.PartialEq.Trait Self (Rhs := None) := {
      core.cmp.PartialEq.eq `{H : State.Trait} := eq;
    }.
  End Impl_core_cmp_PartialEq_for_erc20_erc20_Error.
  
  Module Impl_core_marker_StructuralEq_for_erc20_erc20_Error.
    Definition Self := erc20.erc20.Error.
    
    Global Instance I : core.marker.StructuralEq.Trait Self :=
      core.marker.StructuralEq.Build_Trait _.
  End Impl_core_marker_StructuralEq_for_erc20_erc20_Error.
  
  Module Impl_core_cmp_Eq_for_erc20_erc20_Error.
    Definition Self := erc20.erc20.Error.
    
    Definition assert_receiver_is_total_eq
        `{H : State.Trait}
        (self : ref Self)
        : M (H := H) unit :=
      Pure tt.
    
    Global Instance Method_assert_receiver_is_total_eq `{H : State.Trait} :
      Notation.Dot "assert_receiver_is_total_eq" := {
      Notation.dot := assert_receiver_is_total_eq;
    }.
    
    Global Instance I : core.cmp.Eq.Trait Self := {
    }.
  End Impl_core_cmp_Eq_for_erc20_erc20_Error.
  
  Definition Result (T : Set) : Set := core.result.Result T erc20.erc20.Error.
End erc20.

Module Impl_ink_env_contract_ContractEnv_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Env : Set := ink_env.types.DefaultEnvironment.
  
  Global Instance I : ink_env.contract.ContractEnv.Trait Self := {
  }.
End Impl_ink_env_contract_ContractEnv_for_erc20_erc20_Erc20.

Definition Environment : Set := ink_env.contract.ContractEnv.Env.

Definition AccountId : Set := ink_env.types.Environment.AccountId.

Definition Balance : Set := ink_env.types.Environment.Balance.

Definition Hash : Set := ink_env.types.Environment.Hash.

Definition Timestamp : Set := ink_env.types.Environment.Timestamp.

Definition BlockNumber : Set := ink_env.types.Environment.BlockNumber.

Definition ChainExtension : Set := ink_env.types.Environment.ChainExtension.

Definition MAX_EVENT_TOPICS `{H : State.Trait} : usize :=
  run (Pure ink_env.types.Environment.MAX_EVENT_TOPICS).

Module Check.
  Unset Primitive Projections.
  Record t : Set := {
    salt : unit;
    field_0 : erc20.erc20.Balance;
    field_1
      :
      ink_storage.lazy.mapping.Mapping
        erc20.erc20.AccountId
        erc20.erc20.Balance;
    field_2
      :
      ink_storage.lazy.mapping.Mapping
        (erc20.erc20.AccountId * erc20.erc20.AccountId)
        erc20.erc20.Balance;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_salt : Notation.Dot "salt" := {
    Notation.dot '(Build_t x0 _ _ _) := x0;
  }.
  Global Instance Get_field_0 : Notation.Dot "field_0" := {
    Notation.dot '(Build_t _ x1 _ _) := x1;
  }.
  Global Instance Get_field_1 : Notation.Dot "field_1" := {
    Notation.dot '(Build_t _ _ x2 _) := x2;
  }.
  Global Instance Get_field_2 : Notation.Dot "field_2" := {
    Notation.dot '(Build_t _ _ _ x3) := x3;
  }.
End Check.
Definition Check : Set := @Check.t.

Module Erc20.
  Unset Primitive Projections.
  Record t : Set := {
    total_supply : ink_storage_traits.storage.AutoStorableHint.Type_;
    balances : ink_storage_traits.storage.AutoStorableHint.Type_;
    allowances : ink_storage_traits.storage.AutoStorableHint.Type_;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_total_supply : Notation.Dot "total_supply" := {
    Notation.dot '(Build_t x0 _ _) := x0;
  }.
  Global Instance Get_balances : Notation.Dot "balances" := {
    Notation.dot '(Build_t _ x1 _) := x1;
  }.
  Global Instance Get_allowances : Notation.Dot "allowances" := {
    Notation.dot '(Build_t _ _ x2) := x2;
  }.
End Erc20.
Definition Erc20 : Set := @Erc20.t.

Module Impl_ink_storage_traits_storage_StorableHint_for_erc20_erc20_Erc20.
Section Impl_ink_storage_traits_storage_StorableHint_for_erc20_erc20_Erc20.
  Context {__ink_generic_salt : Set}.
  
  Definition Self := erc20.erc20.Erc20.
  
  Definition Type : Set := erc20.erc20.Erc20.
  
  Definition PreferredKey : Set := ink_storage_traits.impls.AutoKey.
  
  Global Instance I :
      ink_storage_traits.storage.StorableHint.Trait
        Self
        (Key := __ink_generic_salt) := {
  }.
End Impl_ink_storage_traits_storage_StorableHint_for_erc20_erc20_Erc20.
End Impl_ink_storage_traits_storage_StorableHint_for_erc20_erc20_Erc20.

Module Impl_ink_storage_traits_storage_StorageKey_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition KEY := Pure ink_storage_traits.storage.StorageKey.KEY.
  
  Global Instance AssociatedFunction_KEY `{H : State.Trait} :
    Notation.DoubleColon Self "KEY" := {
    Notation.double_colon := KEY;
  }.
  
  Global Instance I : ink_storage_traits.storage.StorageKey.Trait Self := {
    ink_storage_traits.storage.StorageKey.KEY `{H : State.Trait} := KEY;
  }.
End Impl_ink_storage_traits_storage_StorageKey_for_erc20_erc20_Erc20.

Module Impl_ink_storage_traits_storage_Storable_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition decode
      `{H : State.Trait}
      {__ink_I : Set}
      `{parity_scale_codec.codec.Input.Trait __ink_I}
      (__input : mut_ref __ink_I)
      : M (H := H) (core.result.Result Self parity_scale_codec.error.Error) :=
    let* α0 := ink_storage_traits.storage.Storable.decode __input in
    let* α1 := α0.["branch"] in
    let* α2 :=
      match α1 with
      | LanguageItem.Break residual =>
        let* α0 := residual.["from_residual"] in
        Return α0
      | LanguageItem.Continue val => Pure val
      end in
    let* α3 := ink_storage_traits.storage.Storable.decode __input in
    let* α4 := α3.["branch"] in
    let* α5 :=
      match α4 with
      | LanguageItem.Break residual =>
        let* α0 := residual.["from_residual"] in
        Return α0
      | LanguageItem.Continue val => Pure val
      end in
    let* α6 := ink_storage_traits.storage.Storable.decode __input in
    let* α7 := α6.["branch"] in
    let* α8 :=
      match α7 with
      | LanguageItem.Break residual =>
        let* α0 := residual.["from_residual"] in
        Return α0
      | LanguageItem.Continue val => Pure val
      end in
    Pure
      (core.result.Result.Ok
        {|
          erc20.erc20.Erc20.total_supply := α2;
          erc20.erc20.Erc20.balances := α5;
          erc20.erc20.Erc20.allowances := α8;
        |}).
  
  Global Instance AssociatedFunction_decode `{H : State.Trait} :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Definition encode
      `{H : State.Trait}
      {__ink_O : Set}
      `{parity_scale_codec.codec.Output.Trait __ink_O}
      `{core.marker.Sized.Trait __ink_O}
      (self : ref Self)
      (__dest : mut_ref __ink_O)
      : M (H := H) unit :=
    match self with
    |
        {|
          erc20.erc20.Erc20.total_supply := __binding_0;
          erc20.erc20.Erc20.balances := __binding_1;
          erc20.erc20.Erc20.allowances := __binding_2;
        |}
        =>
      let* _ :=
        let* _ :=
          ink_storage_traits.storage.Storable.encode __binding_0 __dest in
        Pure tt in
      let* _ :=
        let* _ :=
          ink_storage_traits.storage.Storable.encode __binding_1 __dest in
        Pure tt in
      let* _ := ink_storage_traits.storage.Storable.encode __binding_2 __dest in
      Pure tt
    end.
  
  Global Instance Method_encode `{H : State.Trait} : Notation.Dot "encode" := {
    Notation.dot := encode;
  }.
  
  Global Instance I : ink_storage_traits.storage.Storable.Trait Self := {
    ink_storage_traits.storage.Storable.encode `{H : State.Trait} := encode;
    ink_storage_traits.storage.Storable.decode `{H : State.Trait} := decode;
  }.
End Impl_ink_storage_traits_storage_Storable_for_erc20_erc20_Erc20.

Module Impl_scale_info_TypeInfo_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Identity : Set := Self.
  
  Definition type_info `{H : State.Trait} : M (H := H) scale_info.ty.Type_ :=
    let* α0 := scale_info.ty.Type_::["builder"] in
    let* α1 := scale_info.ty.path.Path::["new"] "Erc20" "erc20::erc20" in
    let* α2 := α0.["path"] α1 in
    let* α3 := alloc.vec.Vec::["new"] in
    let* α4 := α2.["type_params"] α3 in
    let* α5 := α4.["docs"] (addr_of [ "A simple ERC-20 contract." ]) in
    let* α6 := scale_info.build.Fields::["named"] in
    let* α7 :=
      α6.["field"]
        (fun f =>
          let* α0 :=
            f.["ty"] : M ink_storage_traits.storage.AutoStorableHint.Type_ in
          let* α1 := α0.["name"] "total_supply" in
          let* α2 :=
            α1.["type_name"]
              "<Balance as::ink::storage::traits::AutoStorableHint<::ink::
storage::traits::ManualKey<375105693u32, ()>,>>::Type" in
          α2.["docs"] (addr_of [ "Total token supply." ])) in
    let* α8 :=
      α7.["field"]
        (fun f =>
          let* α0 :=
            f.["ty"] : M ink_storage_traits.storage.AutoStorableHint.Type_ in
          let* α1 := α0.["name"] "balances" in
          let* α2 :=
            α1.["type_name"]
              "<Mapping<AccountId, Balance> as::ink::storage::traits::
AutoStorableHint<::ink::storage::traits::ManualKey<639884519u32, ()
>,>>::Type" in
          α2.["docs"]
            (addr_of [ "Mapping from owner to number of owned token." ])) in
    let* α9 :=
      α8.["field"]
        (fun f =>
          let* α0 :=
            f.["ty"] : M ink_storage_traits.storage.AutoStorableHint.Type_ in
          let* α1 := α0.["name"] "allowances" in
          let* α2 :=
            α1.["type_name"]
              "<Mapping<(AccountId, AccountId), Balance> as::ink::storage::traits
::AutoStorableHint<::ink::storage::traits::ManualKey<
3969917367u32, ()>,>>::Type" in
          α2.["docs"]
            (addr_of
              [
                "Mapping of the token amount which an account is allowed to withdraw";
                "from another account."
              ])) in
    α5.["composite"] α9.
  
  Global Instance AssociatedFunction_type_info `{H : State.Trait} :
    Notation.DoubleColon Self "type_info" := {
    Notation.double_colon := type_info;
  }.
  
  Global Instance I : scale_info.TypeInfo.Trait Self := {
    scale_info.TypeInfo.type_info `{H : State.Trait} := type_info;
  }.
End Impl_scale_info_TypeInfo_for_erc20_erc20_Erc20.

Module Impl_ink_storage_traits_layout_StorageLayout_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition layout
      `{H : State.Trait}
      (__key : ref ink_primitives.key.Key)
      : M (H := H) ink_metadata.layout.Layout :=
    let* α0 := ink_storage_traits.layout.StorageLayout.layout __key in
    let* α1 := ink_metadata.layout.FieldLayout::["new"] "total_supply" α0 in
    let* α2 := ink_storage_traits.layout.StorageLayout.layout __key in
    let* α3 := ink_metadata.layout.FieldLayout::["new"] "balances" α2 in
    let* α4 := ink_storage_traits.layout.StorageLayout.layout __key in
    let* α5 := ink_metadata.layout.FieldLayout::["new"] "allowances" α4 in
    let* α6 :=
      ink_metadata.layout.StructLayout::["new"] "Erc20" [ α1; α3; α5 ] in
    Pure (ink_metadata.layout.Layout.Struct α6).
  
  Global Instance AssociatedFunction_layout `{H : State.Trait} :
    Notation.DoubleColon Self "layout" := {
    Notation.double_colon := layout;
  }.
  
  Global Instance I : ink_storage_traits.layout.StorageLayout.Trait Self := {
    ink_storage_traits.layout.StorageLayout.layout `{H : State.Trait} := layout;
  }.
End Impl_ink_storage_traits_layout_StorageLayout_for_erc20_erc20_Erc20.

Module Impl_core_default_Default_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition default `{H : State.Trait} : M (H := H) erc20.erc20.Erc20 :=
    let* α0 := core.default.Default.default in
    let* α1 := core.default.Default.default in
    let* α2 := core.default.Default.default in
    Pure
      {|
        erc20.erc20.Erc20.total_supply := α0;
        erc20.erc20.Erc20.balances := α1;
        erc20.erc20.Erc20.allowances := α2;
      |}.
  
  Global Instance AssociatedFunction_default `{H : State.Trait} :
    Notation.DoubleColon Self "default" := {
    Notation.double_colon := default;
  }.
  
  Global Instance I : core.default.Default.Trait Self := {
    core.default.Default.default `{H : State.Trait} := default;
  }.
End Impl_core_default_Default_for_erc20_erc20_Erc20.

Module Impl_ink_reflect_contract_ContractName_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition NAME := Pure "Erc20".
  
  Global Instance AssociatedFunction_NAME `{H : State.Trait} :
    Notation.DoubleColon Self "NAME" := {
    Notation.double_colon := NAME;
  }.
  
  Global Instance I : ink.reflect.contract.ContractName.Trait Self := {
    ink.reflect.contract.ContractName.NAME `{H : State.Trait} := NAME;
  }.
End Impl_ink_reflect_contract_ContractName_for_erc20_erc20_Erc20.

Module Impl_ink_codegen_env_Env_for_StaticRef_erc20_erc20_Erc20.
  Definition Self := ref erc20.erc20.Erc20.
  
  Definition EnvAccess : Set :=
    ink.env_access.EnvAccess ink_env.contract.ContractEnv.Env.
  
  Definition env `{H : State.Trait} (self : Self) : M (H := H) EnvAccess :=
    core.default.Default.default.
  
  Global Instance Method_env `{H : State.Trait} : Notation.Dot "env" := {
    Notation.dot := env;
  }.
  
  Global Instance I : ink.codegen.env.Env.Trait Self := {
    ink.codegen.env.Env.env `{H : State.Trait} := env;
  }.
End Impl_ink_codegen_env_Env_for_StaticRef_erc20_erc20_Erc20.

Module Impl_ink_codegen_env_StaticEnv_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition EnvAccess : Set :=
    ink.env_access.EnvAccess ink_env.contract.ContractEnv.Env.
  
  Definition env `{H : State.Trait} : M (H := H) EnvAccess :=
    core.default.Default.default.
  
  Global Instance AssociatedFunction_env `{H : State.Trait} :
    Notation.DoubleColon Self "env" := {
    Notation.double_colon := env;
  }.
  
  Global Instance I : ink.codegen.env.StaticEnv.Trait Self := {
    ink.codegen.env.StaticEnv.env `{H : State.Trait} := env;
  }.
End Impl_ink_codegen_env_StaticEnv_for_erc20_erc20_Erc20.

Module
  Impl_ink_codegen_event_emit_EmitEvent_for_ink_env_access_EnvAccess_erc20_erc20_Environment.
  Definition Self := ink.env_access.EnvAccess erc20.erc20.Environment.
  
  Definition emit_event
      `{H : State.Trait}
      {E : Set}
      `{core.convert.Into.Trait
        E
        (T := ink.reflect.event.ContractEventBase.Type_)}
      (self : Self)
      (event : E)
      : M (H := H) unit :=
    let* _ :=
      let* α0 := event.["into"] in
      ink_env.api.emit_event α0 in
    Pure tt.
  
  Global Instance Method_emit_event `{H : State.Trait} :
    Notation.Dot "emit_event" := {
    Notation.dot := emit_event;
  }.
  
  Global Instance I :
      ink.codegen.event.emit.EmitEvent.Trait Self (C := erc20.erc20.Erc20) := {
    ink.codegen.event.emit.EmitEvent.emit_event
      `{H : State.Trait}
      :=
      emit_event;
  }.
End
  Impl_ink_codegen_event_emit_EmitEvent_for_ink_env_access_EnvAccess_erc20_erc20_Environment.

Module __ink_EventBase.
  Inductive t : Set :=
  | Transfer (_ : erc20.erc20.Transfer)
  | Approval (_ : erc20.erc20.Approval).
End __ink_EventBase.
Definition __ink_EventBase := __ink_EventBase.t.

Module Impl_parity_scale_codec_codec_Encode_for_erc20_erc20___ink_EventBase.
  Definition Self := erc20.erc20.__ink_EventBase.
  
  Definition encode_to
      `{H : State.Trait}
      {__CodecOutputEdqy : Set}
      `{parity_scale_codec.codec.Output.Trait __CodecOutputEdqy}
      `{core.marker.Sized.Trait __CodecOutputEdqy}
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : M (H := H) unit :=
    let* α0 := self.["deref"] in
    match α0 with
    | erc20.erc20.__ink_EventBase.Transfer aa =>
      let* _ :=
        __codec_dest_edqy.["push_byte"] (cast 0 Root.core.primitive.u8) in
      let* _ :=
        parity_scale_codec.codec.Encode.encode_to aa __codec_dest_edqy in
      Pure tt
    | erc20.erc20.__ink_EventBase.Approval aa =>
      let* _ :=
        __codec_dest_edqy.["push_byte"] (cast 1 Root.core.primitive.u8) in
      let* _ :=
        parity_scale_codec.codec.Encode.encode_to aa __codec_dest_edqy in
      Pure tt
    | _ => Pure tt
    end.
  
  Global Instance Method_encode_to `{H : State.Trait} :
    Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Global Instance I : parity_scale_codec.codec.Encode.Trait Self := {
  }.
End Impl_parity_scale_codec_codec_Encode_for_erc20_erc20___ink_EventBase.

Module
  Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20___ink_EventBase.
  Definition Self := erc20.erc20.__ink_EventBase.
  
  Global Instance I :
      parity_scale_codec.encode_like.EncodeLike.Trait Self (T := None) :=
    parity_scale_codec.encode_like.EncodeLike.Build_Trait _.
End
  Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20___ink_EventBase.

Module Impl_parity_scale_codec_codec_Decode_for_erc20_erc20___ink_EventBase.
  Definition Self := erc20.erc20.__ink_EventBase.
  
  Definition decode
      `{H : State.Trait}
      {__CodecInputEdqy : Set}
      `{parity_scale_codec.codec.Input.Trait __CodecInputEdqy}
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : M (H := H) (core.result.Result Self parity_scale_codec.error.Error) :=
    let* α0 := __codec_input_edqy.["read_byte"] in
    let* α1 :=
      α0.["map_err"]
        (fun e =>
          e.["chain"]
            "Could not decode `__ink_EventBase`, failed to read variant byte") in
    let* α2 := α1.["branch"] in
    let* α3 :=
      match α2 with
      | LanguageItem.Break residual =>
        let* α0 := residual.["from_residual"] in
        Return α0
      | LanguageItem.Continue val => Pure val
      end in
    match α3 with
    | __codec_x_edqy =>
      let* _ :=
        let* α0 :=
          (fun  =>
              let* __codec_res_edqy :=
                parity_scale_codec.codec.Decode.decode __codec_input_edqy in
              let* α0 :=
                match __codec_res_edqy with
                | core.result.Result.Err e =>
                  let* α0 :=
                    e.["chain"]
                      "Could not decode `__ink_EventBase::Transfer.0`" in
                  Return (core.result.Result.Err α0)
                | core.result.Result.Ok __codec_res_edqy =>
                  Pure __codec_res_edqy
                end in
              Pure
                (core.result.Result.Ok
                  (erc20.erc20.__ink_EventBase.Transfer α0))) in
        Return α0 in
      Pure tt
    | __codec_x_edqy =>
      let* _ :=
        let* α0 :=
          (fun  =>
              let* __codec_res_edqy :=
                parity_scale_codec.codec.Decode.decode __codec_input_edqy in
              let* α0 :=
                match __codec_res_edqy with
                | core.result.Result.Err e =>
                  let* α0 :=
                    e.["chain"]
                      "Could not decode `__ink_EventBase::Approval.0`" in
                  Return (core.result.Result.Err α0)
                | core.result.Result.Ok __codec_res_edqy =>
                  Pure __codec_res_edqy
                end in
              Pure
                (core.result.Result.Ok
                  (erc20.erc20.__ink_EventBase.Approval α0))) in
        Return α0 in
      Pure tt
    | _ =>
      let* _ :=
        let* α0 :=
          (fun  =>
              let* α0 :=
                core.convert.Into.into
                  "Could not decode `__ink_EventBase`, variant doesn't exist" in
              Pure (core.result.Result.Err α0)) in
        Return α0 in
      Pure tt
    end.
  
  Global Instance AssociatedFunction_decode `{H : State.Trait} :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : parity_scale_codec.codec.Decode.Trait Self := {
    parity_scale_codec.codec.Decode.decode `{H : State.Trait} := decode;
  }.
End Impl_parity_scale_codec_codec_Decode_for_erc20_erc20___ink_EventBase.

Module Impl_ink_reflect_event_ContractEventBase_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Type : Set := erc20.erc20.__ink_EventBase.
  
  Global Instance I : ink.reflect.event.ContractEventBase.Trait Self := {
  }.
End Impl_ink_reflect_event_ContractEventBase_for_erc20_erc20_Erc20.

Module Impl_core_convert_From_for_erc20_erc20___ink_EventBase.
  Definition Self := erc20.erc20.__ink_EventBase.
  
  Definition from
      `{H : State.Trait}
      (event : erc20.erc20.Transfer)
      : M (H := H) Self :=
    Self::["Transfer"] event.
  
  Global Instance AssociatedFunction_from `{H : State.Trait} :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I :
      core.convert.From.Trait Self (T := erc20.erc20.Transfer) := {
    core.convert.From.from `{H : State.Trait} := from;
  }.
End Impl_core_convert_From_for_erc20_erc20___ink_EventBase.

Module Impl_core_convert_From_for_erc20_erc20___ink_EventBase.
  Definition Self := erc20.erc20.__ink_EventBase.
  
  Definition from
      `{H : State.Trait}
      (event : erc20.erc20.Approval)
      : M (H := H) Self :=
    Self::["Approval"] event.
  
  Global Instance AssociatedFunction_from `{H : State.Trait} :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I :
      core.convert.From.Trait Self (T := erc20.erc20.Approval) := {
    core.convert.From.from `{H : State.Trait} := from;
  }.
End Impl_core_convert_From_for_erc20_erc20___ink_EventBase.

Module __ink_UndefinedAmountOfTopics.
  Inductive t : Set :=
  .
End __ink_UndefinedAmountOfTopics.
Definition __ink_UndefinedAmountOfTopics := __ink_UndefinedAmountOfTopics.t.

Module
  Impl_ink_env_topics_EventTopicsAmount_for_erc20_erc20_____ink_UndefinedAmountOfTopics.
  Definition Self := erc20.erc20._.__ink_UndefinedAmountOfTopics.
  
  Definition AMOUNT := Pure 0.
  
  Global Instance AssociatedFunction_AMOUNT `{H : State.Trait} :
    Notation.DoubleColon Self "AMOUNT" := {
    Notation.double_colon := AMOUNT;
  }.
  
  Global Instance I : ink_env.topics.EventTopicsAmount.Trait Self := {
    ink_env.topics.EventTopicsAmount.AMOUNT `{H : State.Trait} := AMOUNT;
  }.
End
  Impl_ink_env_topics_EventTopicsAmount_for_erc20_erc20_____ink_UndefinedAmountOfTopics.

Module Impl_ink_env_topics_Topics_for_erc20_erc20___ink_EventBase.
  Definition Self := erc20.erc20.__ink_EventBase.
  
  Definition RemainingTopics : Set :=
    erc20.erc20._.__ink_UndefinedAmountOfTopics.
  
  Definition topics
      `{H : State.Trait}
      {E B : Set}
      `{ink_env.types.Environment.Trait E}
      `{ink_env.topics.TopicsBuilderBackend.Trait B (E := E)}
      (self : ref Self)
      (builder : ink_env.topics.TopicsBuilder ink_env.topics.state.Uninit E B)
      : M (H := H) ink_env.topics.TopicsBuilderBackend.Output :=
    match self with
    | Transfer.Build_t event => ink_env.topics.Topics.topics event builder
    | Approval.Build_t event => ink_env.topics.Topics.topics event builder
    | _ =>
      let* α0 :=
        format_arguments::["new_const"] (addr_of [ "Event does not exist!" ]) in
      core.panicking.panic_fmt α0
    end.
  
  Global Instance Method_topics `{H : State.Trait} : Notation.Dot "topics" := {
    Notation.dot := topics;
  }.
  
  Global Instance I : ink_env.topics.Topics.Trait Self := {
    ink_env.topics.Topics.topics `{H : State.Trait} := topics;
  }.
End Impl_ink_env_topics_Topics_for_erc20_erc20___ink_EventBase.

Module Impl_ink_codegen_event_topics_EventLenTopics_for_erc20_erc20_Transfer.
  Definition Self := erc20.erc20.Transfer.
  
  Definition LenTopics : Set := ink.codegen.event.topics.EventTopics.
  
  Global Instance I : ink.codegen.event.topics.EventLenTopics.Trait Self := {
  }.
End Impl_ink_codegen_event_topics_EventLenTopics_for_erc20_erc20_Transfer.

Module Impl_ink_codegen_event_topics_EventLenTopics_for_erc20_erc20_Approval.
  Definition Self := erc20.erc20.Approval.
  
  Definition LenTopics : Set := ink.codegen.event.topics.EventTopics.
  
  Global Instance I : ink.codegen.event.topics.EventLenTopics.Trait Self := {
  }.
End Impl_ink_codegen_event_topics_EventLenTopics_for_erc20_erc20_Approval.

Module Transfer.
  Unset Primitive Projections.
  Record t : Set := {
    from : core.option.Option erc20.erc20.AccountId;
    to : core.option.Option erc20.erc20.AccountId;
    value : erc20.erc20.Balance;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_from : Notation.Dot "from" := {
    Notation.dot '(Build_t x0 _ _) := x0;
  }.
  Global Instance Get_to : Notation.Dot "to" := {
    Notation.dot '(Build_t _ x1 _) := x1;
  }.
  Global Instance Get_value : Notation.Dot "value" := {
    Notation.dot '(Build_t _ _ x2) := x2;
  }.
End Transfer.
Definition Transfer : Set := @Transfer.t.

Module Impl_parity_scale_codec_codec_Encode_for_erc20_erc20_Transfer.
  Definition Self := erc20.erc20.Transfer.
  
  Definition encode_to
      `{H : State.Trait}
      {__CodecOutputEdqy : Set}
      `{parity_scale_codec.codec.Output.Trait __CodecOutputEdqy}
      `{core.marker.Sized.Trait __CodecOutputEdqy}
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : M (H := H) unit :=
    let* _ :=
      parity_scale_codec.codec.Encode.encode_to
        (addr_of self.["from"])
        __codec_dest_edqy in
    let* _ :=
      parity_scale_codec.codec.Encode.encode_to
        (addr_of self.["to"])
        __codec_dest_edqy in
    let* _ :=
      parity_scale_codec.codec.Encode.encode_to
        (addr_of self.["value"])
        __codec_dest_edqy in
    Pure tt.
  
  Global Instance Method_encode_to `{H : State.Trait} :
    Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Global Instance I : parity_scale_codec.codec.Encode.Trait Self := {
  }.
End Impl_parity_scale_codec_codec_Encode_for_erc20_erc20_Transfer.

Module Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20_Transfer.
  Definition Self := erc20.erc20.Transfer.
  
  Global Instance I :
      parity_scale_codec.encode_like.EncodeLike.Trait Self (T := None) :=
    parity_scale_codec.encode_like.EncodeLike.Build_Trait _.
End Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20_Transfer.

Module Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_Transfer.
  Definition Self := erc20.erc20.Transfer.
  
  Definition decode
      `{H : State.Trait}
      {__CodecInputEdqy : Set}
      `{parity_scale_codec.codec.Input.Trait __CodecInputEdqy}
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : M (H := H) (core.result.Result Self parity_scale_codec.error.Error) :=
    let* __codec_res_edqy :=
      parity_scale_codec.codec.Decode.decode __codec_input_edqy in
    let* α0 :=
      match __codec_res_edqy with
      | core.result.Result.Err e =>
        let* α0 := e.["chain"] "Could not decode `Transfer::from`" in
        Return (core.result.Result.Err α0)
      | core.result.Result.Ok __codec_res_edqy => Pure __codec_res_edqy
      end in
    let* __codec_res_edqy :=
      parity_scale_codec.codec.Decode.decode __codec_input_edqy in
    let* α1 :=
      match __codec_res_edqy with
      | core.result.Result.Err e =>
        let* α0 := e.["chain"] "Could not decode `Transfer::to`" in
        Return (core.result.Result.Err α0)
      | core.result.Result.Ok __codec_res_edqy => Pure __codec_res_edqy
      end in
    let* __codec_res_edqy :=
      parity_scale_codec.codec.Decode.decode __codec_input_edqy in
    let* α2 :=
      match __codec_res_edqy with
      | core.result.Result.Err e =>
        let* α0 := e.["chain"] "Could not decode `Transfer::value`" in
        Return (core.result.Result.Err α0)
      | core.result.Result.Ok __codec_res_edqy => Pure __codec_res_edqy
      end in
    Pure
      (core.result.Result.Ok
        {|
          erc20.erc20.Transfer.from := α0;
          erc20.erc20.Transfer.to := α1;
          erc20.erc20.Transfer.value := α2;
        |}).
  
  Global Instance AssociatedFunction_decode `{H : State.Trait} :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : parity_scale_codec.codec.Decode.Trait Self := {
    parity_scale_codec.codec.Decode.decode `{H : State.Trait} := decode;
  }.
End Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_Transfer.

Module Approval.
  Unset Primitive Projections.
  Record t : Set := {
    owner : erc20.erc20.AccountId;
    spender : erc20.erc20.AccountId;
    value : erc20.erc20.Balance;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_owner : Notation.Dot "owner" := {
    Notation.dot '(Build_t x0 _ _) := x0;
  }.
  Global Instance Get_spender : Notation.Dot "spender" := {
    Notation.dot '(Build_t _ x1 _) := x1;
  }.
  Global Instance Get_value : Notation.Dot "value" := {
    Notation.dot '(Build_t _ _ x2) := x2;
  }.
End Approval.
Definition Approval : Set := @Approval.t.

Module Impl_parity_scale_codec_codec_Encode_for_erc20_erc20_Approval.
  Definition Self := erc20.erc20.Approval.
  
  Definition encode_to
      `{H : State.Trait}
      {__CodecOutputEdqy : Set}
      `{parity_scale_codec.codec.Output.Trait __CodecOutputEdqy}
      `{core.marker.Sized.Trait __CodecOutputEdqy}
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : M (H := H) unit :=
    let* _ :=
      parity_scale_codec.codec.Encode.encode_to
        (addr_of self.["owner"])
        __codec_dest_edqy in
    let* _ :=
      parity_scale_codec.codec.Encode.encode_to
        (addr_of self.["spender"])
        __codec_dest_edqy in
    let* _ :=
      parity_scale_codec.codec.Encode.encode_to
        (addr_of self.["value"])
        __codec_dest_edqy in
    Pure tt.
  
  Global Instance Method_encode_to `{H : State.Trait} :
    Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Global Instance I : parity_scale_codec.codec.Encode.Trait Self := {
  }.
End Impl_parity_scale_codec_codec_Encode_for_erc20_erc20_Approval.

Module Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20_Approval.
  Definition Self := erc20.erc20.Approval.
  
  Global Instance I :
      parity_scale_codec.encode_like.EncodeLike.Trait Self (T := None) :=
    parity_scale_codec.encode_like.EncodeLike.Build_Trait _.
End Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20_Approval.

Module Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_Approval.
  Definition Self := erc20.erc20.Approval.
  
  Definition decode
      `{H : State.Trait}
      {__CodecInputEdqy : Set}
      `{parity_scale_codec.codec.Input.Trait __CodecInputEdqy}
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : M (H := H) (core.result.Result Self parity_scale_codec.error.Error) :=
    let* __codec_res_edqy :=
      parity_scale_codec.codec.Decode.decode __codec_input_edqy in
    let* α0 :=
      match __codec_res_edqy with
      | core.result.Result.Err e =>
        let* α0 := e.["chain"] "Could not decode `Approval::owner`" in
        Return (core.result.Result.Err α0)
      | core.result.Result.Ok __codec_res_edqy => Pure __codec_res_edqy
      end in
    let* __codec_res_edqy :=
      parity_scale_codec.codec.Decode.decode __codec_input_edqy in
    let* α1 :=
      match __codec_res_edqy with
      | core.result.Result.Err e =>
        let* α0 := e.["chain"] "Could not decode `Approval::spender`" in
        Return (core.result.Result.Err α0)
      | core.result.Result.Ok __codec_res_edqy => Pure __codec_res_edqy
      end in
    let* __codec_res_edqy :=
      parity_scale_codec.codec.Decode.decode __codec_input_edqy in
    let* α2 :=
      match __codec_res_edqy with
      | core.result.Result.Err e =>
        let* α0 := e.["chain"] "Could not decode `Approval::value`" in
        Return (core.result.Result.Err α0)
      | core.result.Result.Ok __codec_res_edqy => Pure __codec_res_edqy
      end in
    Pure
      (core.result.Result.Ok
        {|
          erc20.erc20.Approval.owner := α0;
          erc20.erc20.Approval.spender := α1;
          erc20.erc20.Approval.value := α2;
        |}).
  
  Global Instance AssociatedFunction_decode `{H : State.Trait} :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : parity_scale_codec.codec.Decode.Trait Self := {
    parity_scale_codec.codec.Decode.decode `{H : State.Trait} := decode;
  }.
End Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_Approval.

Module Impl_ink_env_topics_Topics_for_erc20_erc20_Transfer.
  Definition Self := erc20.erc20.Transfer.
  
  Definition RemainingTopics : Set :=
    list ink_env.topics.state.HasRemainingTopics.
  
  Definition topics
      `{H : State.Trait}
      {E B : Set}
      `{ink_env.types.Environment.Trait E}
      `{ink_env.topics.TopicsBuilderBackend.Trait B (E := E)}
      (self : ref Self)
      (builder : ink_env.topics.TopicsBuilder ink_env.topics.state.Uninit E B)
      : M (H := H) ink_env.topics.TopicsBuilderBackend.Output :=
    let* α0 := builder.["build"] : M Self in
    let* α1 :=
      α0.["push_topic"]
        (addr_of
          {|
            ink_env.topics.PrefixedValue.value :=
              [69, 114, 99, 50, 48, 58, 58, 84, 114, 97, 110, 115, 102, 101, 114];
            ink_env.topics.PrefixedValue.prefix := [];
          |}) : M
        (ink_env.topics.PrefixedValue (list u8)) in
    let* α2 :=
      α1.["push_topic"]
        (addr_of
          {|
            ink_env.topics.PrefixedValue.value := addr_of self.["from"];
            ink_env.topics.PrefixedValue.prefix :=
              [69, 114, 99, 50, 48, 58, 58, 84, 114, 97, 110, 115, 102, 101, 114, 58, 58, 102, 114, 111, 109];
          |}) : M
        (ink_env.topics.PrefixedValue
          (core.option.Option erc20.erc20.AccountId)) in
    let* α3 :=
      α2.["push_topic"]
        (addr_of
          {|
            ink_env.topics.PrefixedValue.value := addr_of self.["to"];
            ink_env.topics.PrefixedValue.prefix :=
              [69, 114, 99, 50, 48, 58, 58, 84, 114, 97, 110, 115, 102, 101, 114, 58, 58, 116, 111];
          |}) : M
        (ink_env.topics.PrefixedValue
          (core.option.Option erc20.erc20.AccountId)) in
    α3.["finish"].
  
  Global Instance Method_topics `{H : State.Trait} : Notation.Dot "topics" := {
    Notation.dot := topics;
  }.
  
  Global Instance I : ink_env.topics.Topics.Trait Self := {
    ink_env.topics.Topics.topics `{H : State.Trait} := topics;
  }.
End Impl_ink_env_topics_Topics_for_erc20_erc20_Transfer.

Module Impl_ink_env_topics_Topics_for_erc20_erc20_Approval.
  Definition Self := erc20.erc20.Approval.
  
  Definition RemainingTopics : Set :=
    list ink_env.topics.state.HasRemainingTopics.
  
  Definition topics
      `{H : State.Trait}
      {E B : Set}
      `{ink_env.types.Environment.Trait E}
      `{ink_env.topics.TopicsBuilderBackend.Trait B (E := E)}
      (self : ref Self)
      (builder : ink_env.topics.TopicsBuilder ink_env.topics.state.Uninit E B)
      : M (H := H) ink_env.topics.TopicsBuilderBackend.Output :=
    let* α0 := builder.["build"] : M Self in
    let* α1 :=
      α0.["push_topic"]
        (addr_of
          {|
            ink_env.topics.PrefixedValue.value :=
              [69, 114, 99, 50, 48, 58, 58, 65, 112, 112, 114, 111, 118, 97, 108];
            ink_env.topics.PrefixedValue.prefix := [];
          |}) : M
        (ink_env.topics.PrefixedValue (list u8)) in
    let* α2 :=
      α1.["push_topic"]
        (addr_of
          {|
            ink_env.topics.PrefixedValue.value := addr_of self.["owner"];
            ink_env.topics.PrefixedValue.prefix :=
              [69, 114, 99, 50, 48, 58, 58, 65, 112, 112, 114, 111, 118, 97, 108, 58, 58, 111, 119, 110, 101, 114];
          |}) : M
        (ink_env.topics.PrefixedValue erc20.erc20.AccountId) in
    let* α3 :=
      α2.["push_topic"]
        (addr_of
          {|
            ink_env.topics.PrefixedValue.value := addr_of self.["spender"];
            ink_env.topics.PrefixedValue.prefix :=
              [69, 114, 99, 50, 48, 58, 58, 65, 112, 112, 114, 111, 118, 97, 108, 58, 58, 115, 112, 101, 110, 100, 101, 114];
          |}) : M
        (ink_env.topics.PrefixedValue erc20.erc20.AccountId) in
    α3.["finish"].
  
  Global Instance Method_topics `{H : State.Trait} : Notation.Dot "topics" := {
    Notation.dot := topics;
  }.
  
  Global Instance I : ink_env.topics.Topics.Trait Self := {
    ink_env.topics.Topics.topics `{H : State.Trait} := topics;
  }.
End Impl_ink_env_topics_Topics_for_erc20_erc20_Approval.

Module
  Impl_ink_reflect_dispatch_DispatchableConstructorInfo_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Input : Set := erc20.erc20.Balance.
  
  Definition Output : Set := Self.
  
  Definition Storage : Set := erc20.erc20.Erc20.
  
  Definition Error : Set := ink.reflect.dispatch.ConstructorOutput.Error.
  
  Definition IS_RESULT := Pure ink.reflect.dispatch.ConstructorOutput.IS_RESULT.
  
  Global Instance AssociatedFunction_IS_RESULT `{H : State.Trait} :
    Notation.DoubleColon Self "IS_RESULT" := {
    Notation.double_colon := IS_RESULT;
  }.
  
  Definition
    CALLABLE := Pure
      (fun __ink_binding_0 => erc20.erc20.Erc20::["new"] __ink_binding_0).
  
  Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition PAYABLE := Pure false.
  
  Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition SELECTOR := Pure [ 155; 174; 157; 94 ].
  
  Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition LABEL := Pure "new".
  
  Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I :
      ink.reflect.dispatch.DispatchableConstructorInfo.Trait Self := {
    ink.reflect.dispatch.DispatchableConstructorInfo.IS_RESULT
      `{H : State.Trait}
      :=
      IS_RESULT;
    ink.reflect.dispatch.DispatchableConstructorInfo.CALLABLE
      `{H : State.Trait}
      :=
      CALLABLE;
    ink.reflect.dispatch.DispatchableConstructorInfo.PAYABLE
      `{H : State.Trait}
      :=
      PAYABLE;
    ink.reflect.dispatch.DispatchableConstructorInfo.SELECTOR
      `{H : State.Trait}
      :=
      SELECTOR;
    ink.reflect.dispatch.DispatchableConstructorInfo.LABEL
      `{H : State.Trait}
      :=
      LABEL;
  }.
End Impl_ink_reflect_dispatch_DispatchableConstructorInfo_for_erc20_erc20_Erc20.

Module Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Input : Set := unit.
  
  Definition Output : Set := erc20.erc20.Balance.
  
  Definition Storage : Set := erc20.erc20.Erc20.
  
  Definition
    CALLABLE := Pure
      (fun storage _ => erc20.erc20.Erc20::["total_supply"] storage).
  
  Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := Pure [ 219; 99; 117; 168 ].
  
  Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := Pure false.
  
  Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := Pure false.
  
  Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := Pure "total_supply".
  
  Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I :
      ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
    ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
      `{H : State.Trait}
      :=
      CALLABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
      `{H : State.Trait}
      :=
      MUTATES;
    ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
      `{H : State.Trait}
      :=
      PAYABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
      `{H : State.Trait}
      :=
      SELECTOR;
    ink.reflect.dispatch.DispatchableMessageInfo.LABEL
      `{H : State.Trait}
      :=
      LABEL;
  }.
End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.

Module Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Input : Set := erc20.erc20.AccountId.
  
  Definition Output : Set := erc20.erc20.Balance.
  
  Definition Storage : Set := erc20.erc20.Erc20.
  
  Definition
    CALLABLE := Pure
      (fun storage __ink_binding_0 =>
        erc20.erc20.Erc20::["balance_of"] storage __ink_binding_0).
  
  Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := Pure [ 15; 117; 90; 86 ].
  
  Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := Pure false.
  
  Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := Pure false.
  
  Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := Pure "balance_of".
  
  Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I :
      ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
    ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
      `{H : State.Trait}
      :=
      CALLABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
      `{H : State.Trait}
      :=
      MUTATES;
    ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
      `{H : State.Trait}
      :=
      PAYABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
      `{H : State.Trait}
      :=
      SELECTOR;
    ink.reflect.dispatch.DispatchableMessageInfo.LABEL
      `{H : State.Trait}
      :=
      LABEL;
  }.
End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.

Module Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Input : Set := erc20.erc20.AccountId * erc20.erc20.AccountId.
  
  Definition Output : Set := erc20.erc20.Balance.
  
  Definition Storage : Set := erc20.erc20.Erc20.
  
  Definition
    CALLABLE := Pure
      (fun storage (__ink_binding_0, __ink_binding_1) =>
        erc20.erc20.Erc20::["allowance"]
          storage
          __ink_binding_0
          __ink_binding_1).
  
  Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := Pure [ 106; 0; 22; 94 ].
  
  Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := Pure false.
  
  Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := Pure false.
  
  Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := Pure "allowance".
  
  Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I :
      ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
    ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
      `{H : State.Trait}
      :=
      CALLABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
      `{H : State.Trait}
      :=
      MUTATES;
    ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
      `{H : State.Trait}
      :=
      PAYABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
      `{H : State.Trait}
      :=
      SELECTOR;
    ink.reflect.dispatch.DispatchableMessageInfo.LABEL
      `{H : State.Trait}
      :=
      LABEL;
  }.
End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.

Module Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Input : Set := erc20.erc20.AccountId * erc20.erc20.Balance.
  
  Definition Output : Set := erc20.erc20.Result unit.
  
  Definition Storage : Set := erc20.erc20.Erc20.
  
  Definition
    CALLABLE := Pure
      (fun storage (__ink_binding_0, __ink_binding_1) =>
        erc20.erc20.Erc20::["transfer"]
          storage
          __ink_binding_0
          __ink_binding_1).
  
  Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := Pure [ 132; 161; 93; 161 ].
  
  Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := Pure false.
  
  Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := Pure true.
  
  Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := Pure "transfer".
  
  Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I :
      ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
    ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
      `{H : State.Trait}
      :=
      CALLABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
      `{H : State.Trait}
      :=
      MUTATES;
    ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
      `{H : State.Trait}
      :=
      PAYABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
      `{H : State.Trait}
      :=
      SELECTOR;
    ink.reflect.dispatch.DispatchableMessageInfo.LABEL
      `{H : State.Trait}
      :=
      LABEL;
  }.
End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.

Module Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Input : Set := erc20.erc20.AccountId * erc20.erc20.Balance.
  
  Definition Output : Set := erc20.erc20.Result unit.
  
  Definition Storage : Set := erc20.erc20.Erc20.
  
  Definition
    CALLABLE := Pure
      (fun storage (__ink_binding_0, __ink_binding_1) =>
        erc20.erc20.Erc20::["approve"] storage __ink_binding_0 __ink_binding_1).
  
  Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := Pure [ 104; 18; 102; 160 ].
  
  Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := Pure false.
  
  Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := Pure true.
  
  Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := Pure "approve".
  
  Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I :
      ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
    ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
      `{H : State.Trait}
      :=
      CALLABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
      `{H : State.Trait}
      :=
      MUTATES;
    ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
      `{H : State.Trait}
      :=
      PAYABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
      `{H : State.Trait}
      :=
      SELECTOR;
    ink.reflect.dispatch.DispatchableMessageInfo.LABEL
      `{H : State.Trait}
      :=
      LABEL;
  }.
End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.

Module Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Input : Set :=
    erc20.erc20.AccountId * erc20.erc20.AccountId * erc20.erc20.Balance.
  
  Definition Output : Set := erc20.erc20.Result unit.
  
  Definition Storage : Set := erc20.erc20.Erc20.
  
  Definition
    CALLABLE := Pure
      (fun storage (__ink_binding_0, __ink_binding_1, __ink_binding_2) =>
        erc20.erc20.Erc20::["transfer_from"]
          storage
          __ink_binding_0
          __ink_binding_1
          __ink_binding_2).
  
  Global Instance AssociatedFunction_CALLABLE `{H : State.Trait} :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := Pure [ 11; 57; 111; 24 ].
  
  Global Instance AssociatedFunction_SELECTOR `{H : State.Trait} :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := Pure false.
  
  Global Instance AssociatedFunction_PAYABLE `{H : State.Trait} :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := Pure true.
  
  Global Instance AssociatedFunction_MUTATES `{H : State.Trait} :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := Pure "transfer_from".
  
  Global Instance AssociatedFunction_LABEL `{H : State.Trait} :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I :
      ink.reflect.dispatch.DispatchableMessageInfo.Trait Self := {
    ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
      `{H : State.Trait}
      :=
      CALLABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.MUTATES
      `{H : State.Trait}
      :=
      MUTATES;
    ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE
      `{H : State.Trait}
      :=
      PAYABLE;
    ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR
      `{H : State.Trait}
      :=
      SELECTOR;
    ink.reflect.dispatch.DispatchableMessageInfo.LABEL
      `{H : State.Trait}
      :=
      LABEL;
  }.
End Impl_ink_reflect_dispatch_DispatchableMessageInfo_for_erc20_erc20_Erc20.

Module __ink_ConstructorDecoder.
  Inductive t : Set :=
  | Constructor0 (_ : ink.reflect.dispatch.DispatchableConstructorInfo.Input).
End __ink_ConstructorDecoder.
Definition __ink_ConstructorDecoder := __ink_ConstructorDecoder.t.

Module
  Impl_ink_reflect_dispatch_DecodeDispatch_for_erc20_erc20_____ink_ConstructorDecoder.
  Definition Self := erc20.erc20._.__ink_ConstructorDecoder.
  
  Definition decode_dispatch
      `{H : State.Trait}
      {I : Set}
      `{parity_scale_codec.codec.Input.Trait I}
      (input : mut_ref I)
      :
        M (H := H)
          (core.result.Result Self ink.reflect.dispatch.DispatchError) :=
    let* α0 := parity_scale_codec.codec.Decode.decode input in
    let* α1 :=
      α0.["map_err"]
        (fun _ => Pure ink.reflect.dispatch.DispatchError.InvalidSelector) in
    let* α2 := α1.["branch"] in
    let* α3 :=
      match α2 with
      | LanguageItem.Break residual =>
        let* α0 := residual.["from_residual"] in
        Return α0
      | LanguageItem.Continue val => Pure val
      end in
    match α3 with
    | erc20.erc20._.decode_dispatch.CONSTRUCTOR_0 =>
      let* α0 := parity_scale_codec.codec.Decode.decode input in
      let* α1 :=
        α0.["map_err"]
          (fun _ =>
            Pure ink.reflect.dispatch.DispatchError.InvalidParameters) in
      let* α2 := α1.["branch"] in
      let* α3 :=
        match α2 with
        | LanguageItem.Break residual =>
          let* α0 := residual.["from_residual"] in
          Return α0
        | LanguageItem.Continue val => Pure val
        end in
      let* α4 := Self::["Constructor0"] α3 in
      Pure (core.result.Result.Ok α4)
    | _invalid =>
      Pure
        (core.result.Result.Err
          ink.reflect.dispatch.DispatchError.UnknownSelector)
    end.
  
  Global Instance AssociatedFunction_decode_dispatch `{H : State.Trait} :
    Notation.DoubleColon Self "decode_dispatch" := {
    Notation.double_colon := decode_dispatch;
  }.
  
  Global Instance I : ink.reflect.dispatch.DecodeDispatch.Trait Self := {
    ink.reflect.dispatch.DecodeDispatch.decode_dispatch
      `{H : State.Trait}
      :=
      decode_dispatch;
  }.
End
  Impl_ink_reflect_dispatch_DecodeDispatch_for_erc20_erc20_____ink_ConstructorDecoder.

Definition CONSTRUCTOR_0 `{H : State.Trait} : list Root.core.primitive.u8 :=
  run (Pure ink.reflect.dispatch.DispatchableConstructorInfo.SELECTOR).

Module
  Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_____ink_ConstructorDecoder.
  Definition Self := erc20.erc20._.__ink_ConstructorDecoder.
  
  Definition decode
      `{H : State.Trait}
      {I : Set}
      `{parity_scale_codec.codec.Input.Trait I}
      (input : mut_ref I)
      : M (H := H) (core.result.Result Self parity_scale_codec.error.Error) :=
    let* α0 := ink.reflect.dispatch.DecodeDispatch.decode_dispatch input in
    α0.["map_err"] core.convert.Into.into.
  
  Global Instance AssociatedFunction_decode `{H : State.Trait} :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : parity_scale_codec.codec.Decode.Trait Self := {
    parity_scale_codec.codec.Decode.decode `{H : State.Trait} := decode;
  }.
End
  Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_____ink_ConstructorDecoder.

Module
  Impl_ink_reflect_dispatch_ExecuteDispatchable_for_erc20_erc20_____ink_ConstructorDecoder.
  Definition Self := erc20.erc20._.__ink_ConstructorDecoder.
  
  Definition execute_dispatchable
      `{H : State.Trait}
      (self : Self)
      :
        M (H := H)
          (core.result.Result unit ink.reflect.dispatch.DispatchError) :=
    match self with
    | Constructor0.Build_t input =>
      let* _ :=
        let constructor_0 := false in
        let constructor_0 :=
          ink.reflect.dispatch.DispatchableConstructorInfo.PAYABLE in
        let* α0 := false.["or"] constructor_0 in
        let* α1 :=
          ink.reflect.dispatch.DispatchableConstructorInfo.PAYABLE.["not"] in
        let* α2 := α0.["andb"] α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := ink.codegen.dispatch.execution.deny_payment in
            let* α1 := α0.["branch"] in
            match α1 with
            | LanguageItem.Break residual =>
              let* α0 := residual.["from_residual"] in
              Return α0
            | LanguageItem.Continue val => Pure val
            end in
          Pure tt
        else
          Pure tt in
      let* result :=
        ink.reflect.dispatch.DispatchableConstructorInfo.CALLABLE input in
      let* output_value :=
        ink.reflect.dispatch.ConstructorOutputValue::["new"] result in
      let* output_result :=
        ink.reflect.dispatch.ConstructorOutput.as_result
          (addr_of output_value) in
      let* _ :=
        let* α0 := output_result.["as_ref"] in
        match α0 with
        | core.result.Result.Ok contract =>
          let* _ :=
            ink_env.api.set_contract_storage
              (addr_of ink_storage_traits.storage.StorageKey.KEY)
              contract in
          Pure tt
        | _ => Pure tt
        end in
      let* _ :=
        let* α0 := output_result.["is_err"] in
        let* α1 := ink_env.backend.ReturnFlags::["new_with_reverted"] α0 in
        let* α2 := output_result.["map"] (fun _ => Pure tt) in
        let* α3 := ink_primitives.ConstructorResult::["Ok"] α2 in
        ink_env.api.return_value α1 (addr_of α3) in
      Pure tt
    end.
  
  Global Instance Method_execute_dispatchable `{H : State.Trait} :
    Notation.Dot "execute_dispatchable" := {
    Notation.dot := execute_dispatchable;
  }.
  
  Global Instance I : ink.reflect.dispatch.ExecuteDispatchable.Trait Self := {
    ink.reflect.dispatch.ExecuteDispatchable.execute_dispatchable
      `{H : State.Trait}
      :=
      execute_dispatchable;
  }.
End
  Impl_ink_reflect_dispatch_ExecuteDispatchable_for_erc20_erc20_____ink_ConstructorDecoder.

Module
  Impl_ink_reflect_dispatch_ContractConstructorDecoder_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Type : Set := erc20.erc20._.__ink_ConstructorDecoder.
  
  Global Instance I :
      ink.reflect.dispatch.ContractConstructorDecoder.Trait Self := {
  }.
End Impl_ink_reflect_dispatch_ContractConstructorDecoder_for_erc20_erc20_Erc20.

Module __ink_MessageDecoder.
  Inductive t : Set :=
  | Message0 (_ : ink.reflect.dispatch.DispatchableMessageInfo.Input)
  | Message1 (_ : ink.reflect.dispatch.DispatchableMessageInfo.Input)
  | Message2 (_ : ink.reflect.dispatch.DispatchableMessageInfo.Input)
  | Message3 (_ : ink.reflect.dispatch.DispatchableMessageInfo.Input)
  | Message4 (_ : ink.reflect.dispatch.DispatchableMessageInfo.Input)
  | Message5 (_ : ink.reflect.dispatch.DispatchableMessageInfo.Input).
End __ink_MessageDecoder.
Definition __ink_MessageDecoder := __ink_MessageDecoder.t.

Module
  Impl_ink_reflect_dispatch_DecodeDispatch_for_erc20_erc20_____ink_MessageDecoder.
  Definition Self := erc20.erc20._.__ink_MessageDecoder.
  
  Definition decode_dispatch
      `{H : State.Trait}
      {I : Set}
      `{parity_scale_codec.codec.Input.Trait I}
      (input : mut_ref I)
      :
        M (H := H)
          (core.result.Result Self ink.reflect.dispatch.DispatchError) :=
    let* α0 := parity_scale_codec.codec.Decode.decode input in
    let* α1 :=
      α0.["map_err"]
        (fun _ => Pure ink.reflect.dispatch.DispatchError.InvalidSelector) in
    let* α2 := α1.["branch"] in
    let* α3 :=
      match α2 with
      | LanguageItem.Break residual =>
        let* α0 := residual.["from_residual"] in
        Return α0
      | LanguageItem.Continue val => Pure val
      end in
    match α3 with
    | erc20.erc20._.decode_dispatch.MESSAGE_0 =>
      let* α0 := parity_scale_codec.codec.Decode.decode input in
      let* α1 :=
        α0.["map_err"]
          (fun _ =>
            Pure ink.reflect.dispatch.DispatchError.InvalidParameters) in
      let* α2 := α1.["branch"] in
      let* α3 :=
        match α2 with
        | LanguageItem.Break residual =>
          let* α0 := residual.["from_residual"] in
          Return α0
        | LanguageItem.Continue val => Pure val
        end in
      let* α4 := Self::["Message0"] α3 in
      Pure (core.result.Result.Ok α4)
    | erc20.erc20._.decode_dispatch.MESSAGE_1 =>
      let* α0 := parity_scale_codec.codec.Decode.decode input in
      let* α1 :=
        α0.["map_err"]
          (fun _ =>
            Pure ink.reflect.dispatch.DispatchError.InvalidParameters) in
      let* α2 := α1.["branch"] in
      let* α3 :=
        match α2 with
        | LanguageItem.Break residual =>
          let* α0 := residual.["from_residual"] in
          Return α0
        | LanguageItem.Continue val => Pure val
        end in
      let* α4 := Self::["Message1"] α3 in
      Pure (core.result.Result.Ok α4)
    | erc20.erc20._.decode_dispatch.MESSAGE_2 =>
      let* α0 := parity_scale_codec.codec.Decode.decode input in
      let* α1 :=
        α0.["map_err"]
          (fun _ =>
            Pure ink.reflect.dispatch.DispatchError.InvalidParameters) in
      let* α2 := α1.["branch"] in
      let* α3 :=
        match α2 with
        | LanguageItem.Break residual =>
          let* α0 := residual.["from_residual"] in
          Return α0
        | LanguageItem.Continue val => Pure val
        end in
      let* α4 := Self::["Message2"] α3 in
      Pure (core.result.Result.Ok α4)
    | erc20.erc20._.decode_dispatch.MESSAGE_3 =>
      let* α0 := parity_scale_codec.codec.Decode.decode input in
      let* α1 :=
        α0.["map_err"]
          (fun _ =>
            Pure ink.reflect.dispatch.DispatchError.InvalidParameters) in
      let* α2 := α1.["branch"] in
      let* α3 :=
        match α2 with
        | LanguageItem.Break residual =>
          let* α0 := residual.["from_residual"] in
          Return α0
        | LanguageItem.Continue val => Pure val
        end in
      let* α4 := Self::["Message3"] α3 in
      Pure (core.result.Result.Ok α4)
    | erc20.erc20._.decode_dispatch.MESSAGE_4 =>
      let* α0 := parity_scale_codec.codec.Decode.decode input in
      let* α1 :=
        α0.["map_err"]
          (fun _ =>
            Pure ink.reflect.dispatch.DispatchError.InvalidParameters) in
      let* α2 := α1.["branch"] in
      let* α3 :=
        match α2 with
        | LanguageItem.Break residual =>
          let* α0 := residual.["from_residual"] in
          Return α0
        | LanguageItem.Continue val => Pure val
        end in
      let* α4 := Self::["Message4"] α3 in
      Pure (core.result.Result.Ok α4)
    | erc20.erc20._.decode_dispatch.MESSAGE_5 =>
      let* α0 := parity_scale_codec.codec.Decode.decode input in
      let* α1 :=
        α0.["map_err"]
          (fun _ =>
            Pure ink.reflect.dispatch.DispatchError.InvalidParameters) in
      let* α2 := α1.["branch"] in
      let* α3 :=
        match α2 with
        | LanguageItem.Break residual =>
          let* α0 := residual.["from_residual"] in
          Return α0
        | LanguageItem.Continue val => Pure val
        end in
      let* α4 := Self::["Message5"] α3 in
      Pure (core.result.Result.Ok α4)
    | _invalid =>
      Pure
        (core.result.Result.Err
          ink.reflect.dispatch.DispatchError.UnknownSelector)
    end.
  
  Global Instance AssociatedFunction_decode_dispatch `{H : State.Trait} :
    Notation.DoubleColon Self "decode_dispatch" := {
    Notation.double_colon := decode_dispatch;
  }.
  
  Global Instance I : ink.reflect.dispatch.DecodeDispatch.Trait Self := {
    ink.reflect.dispatch.DecodeDispatch.decode_dispatch
      `{H : State.Trait}
      :=
      decode_dispatch;
  }.
End
  Impl_ink_reflect_dispatch_DecodeDispatch_for_erc20_erc20_____ink_MessageDecoder.

Definition MESSAGE_0 `{H : State.Trait} : list Root.core.primitive.u8 :=
  run (Pure ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR).

Definition MESSAGE_1 `{H : State.Trait} : list Root.core.primitive.u8 :=
  run (Pure ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR).

Definition MESSAGE_2 `{H : State.Trait} : list Root.core.primitive.u8 :=
  run (Pure ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR).

Definition MESSAGE_3 `{H : State.Trait} : list Root.core.primitive.u8 :=
  run (Pure ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR).

Definition MESSAGE_4 `{H : State.Trait} : list Root.core.primitive.u8 :=
  run (Pure ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR).

Definition MESSAGE_5 `{H : State.Trait} : list Root.core.primitive.u8 :=
  run (Pure ink.reflect.dispatch.DispatchableMessageInfo.SELECTOR).

Module
  Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_____ink_MessageDecoder.
  Definition Self := erc20.erc20._.__ink_MessageDecoder.
  
  Definition decode
      `{H : State.Trait}
      {I : Set}
      `{parity_scale_codec.codec.Input.Trait I}
      (input : mut_ref I)
      : M (H := H) (core.result.Result Self parity_scale_codec.error.Error) :=
    let* α0 := ink.reflect.dispatch.DecodeDispatch.decode_dispatch input in
    α0.["map_err"] core.convert.Into.into.
  
  Global Instance AssociatedFunction_decode `{H : State.Trait} :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : parity_scale_codec.codec.Decode.Trait Self := {
    parity_scale_codec.codec.Decode.decode `{H : State.Trait} := decode;
  }.
End Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_____ink_MessageDecoder.

Definition push_contract
    `{H : State.Trait}
    (contract : core.mem.manually_drop.ManuallyDrop erc20.erc20.Erc20)
    (mutates : bool)
    : M (H := H) unit :=
  if (mutates : bool) then
    let* _ :=
      ink_env.api.set_contract_storage
        (addr_of ink_storage_traits.storage.StorageKey.KEY)
        (addr_of contract) in
    Pure tt
  else
    Pure tt.

Module
  Impl_ink_reflect_dispatch_ExecuteDispatchable_for_erc20_erc20_____ink_MessageDecoder.
  Definition Self := erc20.erc20._.__ink_MessageDecoder.
  
  Definition execute_dispatchable
      `{H : State.Trait}
      (self : Self)
      :
        M (H := H)
          (core.result.Result unit ink.reflect.dispatch.DispatchError) :=
    let key := ink_storage_traits.storage.StorageKey.KEY in
    let* contract :=
      let* α0 := ink_env.api.get_contract_storage (addr_of key) in
      let* α1 :=
        match α0 with
        | core.result.Result.Ok core.option.Option.Some value => Pure value
        | core.result.Result.Ok core.option.Option.None =>
          let* α0 :=
            format_arguments::["new_const"]
              (addr_of [ "storage entry was empty" ]) in
          core.panicking.panic_fmt α0
        | core.result.Result.Err _ =>
          let* α0 :=
            format_arguments::["new_const"]
              (addr_of [ "could not properly decode storage entry" ]) in
          core.panicking.panic_fmt α0
        end in
      core.mem.manually_drop.ManuallyDrop::["new"] α1 in
    let* _ :=
      match self with
      | Message0.Build_t input =>
        let* _ :=
          let message_0 := false in
          let message_0 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := false.["or"] message_0 in
          let message_1 := false in
          let message_1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α1 := α0.["or"] message_1 in
          let message_2 := false in
          let message_2 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α2 := α1.["or"] message_2 in
          let message_3 := false in
          let message_3 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α3 := α2.["or"] message_3 in
          let message_4 := false in
          let message_4 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α4 := α3.["or"] message_4 in
          let message_5 := false in
          let message_5 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := α4.["or"] message_5 in
          let* α1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE.["not"] in
          let* α2 := α0.["andb"] α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := ink.codegen.dispatch.execution.deny_payment in
              let* α1 := α0.["branch"] in
              match α1 with
              | LanguageItem.Break residual =>
                let* α0 := residual.["from_residual"] in
                Return α0
              | LanguageItem.Continue val => Pure val
              end in
            Pure tt
          else
            Pure tt in
        let* result :=
          ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let* is_reverted :=
          let* α0 :=
            (ink.result_info.IsResultErr.Build_t (addr_of result)).["value"] in
          (ink.result_info.IsResultType
                ink.reflect.dispatch.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            α0 in
        let* _ :=
          let* α0 := is_reverted.["not"] in
          if (α0 : bool) then
            let* _ :=
              erc20.erc20._.push_contract
                contract
                ink.reflect.dispatch.DispatchableMessageInfo.MUTATES in
            Pure tt
          else
            Pure tt in
        let* α0 :=
          ink_env.backend.ReturnFlags::["new_with_reverted"] is_reverted in
        let* α1 := ink_primitives.MessageResult::["Ok"] result in
        ink_env.api.return_value α0 (addr_of α1)
      | Message1.Build_t input =>
        let* _ :=
          let message_0 := false in
          let message_0 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := false.["or"] message_0 in
          let message_1 := false in
          let message_1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α1 := α0.["or"] message_1 in
          let message_2 := false in
          let message_2 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α2 := α1.["or"] message_2 in
          let message_3 := false in
          let message_3 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α3 := α2.["or"] message_3 in
          let message_4 := false in
          let message_4 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α4 := α3.["or"] message_4 in
          let message_5 := false in
          let message_5 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := α4.["or"] message_5 in
          let* α1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE.["not"] in
          let* α2 := α0.["andb"] α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := ink.codegen.dispatch.execution.deny_payment in
              let* α1 := α0.["branch"] in
              match α1 with
              | LanguageItem.Break residual =>
                let* α0 := residual.["from_residual"] in
                Return α0
              | LanguageItem.Continue val => Pure val
              end in
            Pure tt
          else
            Pure tt in
        let* result :=
          ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let* is_reverted :=
          let* α0 :=
            (ink.result_info.IsResultErr.Build_t (addr_of result)).["value"] in
          (ink.result_info.IsResultType
                ink.reflect.dispatch.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            α0 in
        let* _ :=
          let* α0 := is_reverted.["not"] in
          if (α0 : bool) then
            let* _ :=
              erc20.erc20._.push_contract
                contract
                ink.reflect.dispatch.DispatchableMessageInfo.MUTATES in
            Pure tt
          else
            Pure tt in
        let* α0 :=
          ink_env.backend.ReturnFlags::["new_with_reverted"] is_reverted in
        let* α1 := ink_primitives.MessageResult::["Ok"] result in
        ink_env.api.return_value α0 (addr_of α1)
      | Message2.Build_t input =>
        let* _ :=
          let message_0 := false in
          let message_0 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := false.["or"] message_0 in
          let message_1 := false in
          let message_1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α1 := α0.["or"] message_1 in
          let message_2 := false in
          let message_2 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α2 := α1.["or"] message_2 in
          let message_3 := false in
          let message_3 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α3 := α2.["or"] message_3 in
          let message_4 := false in
          let message_4 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α4 := α3.["or"] message_4 in
          let message_5 := false in
          let message_5 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := α4.["or"] message_5 in
          let* α1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE.["not"] in
          let* α2 := α0.["andb"] α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := ink.codegen.dispatch.execution.deny_payment in
              let* α1 := α0.["branch"] in
              match α1 with
              | LanguageItem.Break residual =>
                let* α0 := residual.["from_residual"] in
                Return α0
              | LanguageItem.Continue val => Pure val
              end in
            Pure tt
          else
            Pure tt in
        let* result :=
          ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let* is_reverted :=
          let* α0 :=
            (ink.result_info.IsResultErr.Build_t (addr_of result)).["value"] in
          (ink.result_info.IsResultType
                ink.reflect.dispatch.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            α0 in
        let* _ :=
          let* α0 := is_reverted.["not"] in
          if (α0 : bool) then
            let* _ :=
              erc20.erc20._.push_contract
                contract
                ink.reflect.dispatch.DispatchableMessageInfo.MUTATES in
            Pure tt
          else
            Pure tt in
        let* α0 :=
          ink_env.backend.ReturnFlags::["new_with_reverted"] is_reverted in
        let* α1 := ink_primitives.MessageResult::["Ok"] result in
        ink_env.api.return_value α0 (addr_of α1)
      | Message3.Build_t input =>
        let* _ :=
          let message_0 := false in
          let message_0 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := false.["or"] message_0 in
          let message_1 := false in
          let message_1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α1 := α0.["or"] message_1 in
          let message_2 := false in
          let message_2 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α2 := α1.["or"] message_2 in
          let message_3 := false in
          let message_3 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α3 := α2.["or"] message_3 in
          let message_4 := false in
          let message_4 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α4 := α3.["or"] message_4 in
          let message_5 := false in
          let message_5 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := α4.["or"] message_5 in
          let* α1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE.["not"] in
          let* α2 := α0.["andb"] α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := ink.codegen.dispatch.execution.deny_payment in
              let* α1 := α0.["branch"] in
              match α1 with
              | LanguageItem.Break residual =>
                let* α0 := residual.["from_residual"] in
                Return α0
              | LanguageItem.Continue val => Pure val
              end in
            Pure tt
          else
            Pure tt in
        let* result :=
          ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let* is_reverted :=
          let* α0 :=
            (ink.result_info.IsResultErr.Build_t (addr_of result)).["value"] in
          (ink.result_info.IsResultType
                ink.reflect.dispatch.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            α0 in
        let* _ :=
          let* α0 := is_reverted.["not"] in
          if (α0 : bool) then
            let* _ :=
              erc20.erc20._.push_contract
                contract
                ink.reflect.dispatch.DispatchableMessageInfo.MUTATES in
            Pure tt
          else
            Pure tt in
        let* α0 :=
          ink_env.backend.ReturnFlags::["new_with_reverted"] is_reverted in
        let* α1 := ink_primitives.MessageResult::["Ok"] result in
        ink_env.api.return_value α0 (addr_of α1)
      | Message4.Build_t input =>
        let* _ :=
          let message_0 := false in
          let message_0 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := false.["or"] message_0 in
          let message_1 := false in
          let message_1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α1 := α0.["or"] message_1 in
          let message_2 := false in
          let message_2 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α2 := α1.["or"] message_2 in
          let message_3 := false in
          let message_3 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α3 := α2.["or"] message_3 in
          let message_4 := false in
          let message_4 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α4 := α3.["or"] message_4 in
          let message_5 := false in
          let message_5 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := α4.["or"] message_5 in
          let* α1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE.["not"] in
          let* α2 := α0.["andb"] α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := ink.codegen.dispatch.execution.deny_payment in
              let* α1 := α0.["branch"] in
              match α1 with
              | LanguageItem.Break residual =>
                let* α0 := residual.["from_residual"] in
                Return α0
              | LanguageItem.Continue val => Pure val
              end in
            Pure tt
          else
            Pure tt in
        let* result :=
          ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let* is_reverted :=
          let* α0 :=
            (ink.result_info.IsResultErr.Build_t (addr_of result)).["value"] in
          (ink.result_info.IsResultType
                ink.reflect.dispatch.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            α0 in
        let* _ :=
          let* α0 := is_reverted.["not"] in
          if (α0 : bool) then
            let* _ :=
              erc20.erc20._.push_contract
                contract
                ink.reflect.dispatch.DispatchableMessageInfo.MUTATES in
            Pure tt
          else
            Pure tt in
        let* α0 :=
          ink_env.backend.ReturnFlags::["new_with_reverted"] is_reverted in
        let* α1 := ink_primitives.MessageResult::["Ok"] result in
        ink_env.api.return_value α0 (addr_of α1)
      | Message5.Build_t input =>
        let* _ :=
          let message_0 := false in
          let message_0 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := false.["or"] message_0 in
          let message_1 := false in
          let message_1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α1 := α0.["or"] message_1 in
          let message_2 := false in
          let message_2 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α2 := α1.["or"] message_2 in
          let message_3 := false in
          let message_3 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α3 := α2.["or"] message_3 in
          let message_4 := false in
          let message_4 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α4 := α3.["or"] message_4 in
          let message_5 := false in
          let message_5 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE in
          let* α0 := α4.["or"] message_5 in
          let* α1 :=
            ink.reflect.dispatch.DispatchableMessageInfo.PAYABLE.["not"] in
          let* α2 := α0.["andb"] α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := ink.codegen.dispatch.execution.deny_payment in
              let* α1 := α0.["branch"] in
              match α1 with
              | LanguageItem.Break residual =>
                let* α0 := residual.["from_residual"] in
                Return α0
              | LanguageItem.Continue val => Pure val
              end in
            Pure tt
          else
            Pure tt in
        let* result :=
          ink.reflect.dispatch.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let* is_reverted :=
          let* α0 :=
            (ink.result_info.IsResultErr.Build_t (addr_of result)).["value"] in
          (ink.result_info.IsResultType
                ink.reflect.dispatch.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            α0 in
        let* _ :=
          let* α0 := is_reverted.["not"] in
          if (α0 : bool) then
            let* _ :=
              erc20.erc20._.push_contract
                contract
                ink.reflect.dispatch.DispatchableMessageInfo.MUTATES in
            Pure tt
          else
            Pure tt in
        let* α0 :=
          ink_env.backend.ReturnFlags::["new_with_reverted"] is_reverted in
        let* α1 := ink_primitives.MessageResult::["Ok"] result in
        ink_env.api.return_value α0 (addr_of α1)
      end in
    Pure tt.
  
  Global Instance Method_execute_dispatchable `{H : State.Trait} :
    Notation.Dot "execute_dispatchable" := {
    Notation.dot := execute_dispatchable;
  }.
  
  Global Instance I : ink.reflect.dispatch.ExecuteDispatchable.Trait Self := {
    ink.reflect.dispatch.ExecuteDispatchable.execute_dispatchable
      `{H : State.Trait}
      :=
      execute_dispatchable;
  }.
End
  Impl_ink_reflect_dispatch_ExecuteDispatchable_for_erc20_erc20_____ink_MessageDecoder.

Module Impl_ink_reflect_dispatch_ContractMessageDecoder_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Type : Set := erc20.erc20._.__ink_MessageDecoder.
  
  Global Instance I :
      ink.reflect.dispatch.ContractMessageDecoder.Trait Self := {
  }.
End Impl_ink_reflect_dispatch_ContractMessageDecoder_for_erc20_erc20_Erc20.

Definition
    _
    `{H : State.Trait} :
    ink.codegen.utils.same_type.IsSameType erc20.erc20.Erc20 :=
  run ((ink.codegen.utils.same_type.IsSameType erc20.erc20.Erc20)::["new"]).

Module Impl_erc20_erc20_Erc20_29.
  Definition Self := erc20.erc20.Erc20.
  
  Definition new
      `{H : State.Trait}
      (total_supply : erc20.erc20.Balance)
      : M (H := H) Self :=
    let* balances := ink_storage.lazy.mapping.Mapping::["default"] in
    let* caller :=
      let* α0 := Self::["env"] in
      α0.["caller"] in
    let* _ := balances.["insert"] caller (addr_of total_supply) in
    let* _ :=
      let* α0 := Self::["env"] in
      α0.["emit_event"]
        {|
          erc20.erc20.Transfer.from := core.option.Option.None;
          erc20.erc20.Transfer.to := core.option.Option.Some caller;
          erc20.erc20.Transfer.value := total_supply;
        |} in
    let* α0 := core.default.Default.default in
    Pure
      {|
        Self.total_supply := total_supply;
        Self.balances := balances;
        Self.allowances := α0;
      |}.
  
  Global Instance AssociatedFunction_new `{H : State.Trait} :
    Notation.DoubleColon Self "new" := {
    Notation.double_colon := new;
  }.
  
  Definition total_supply
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) erc20.erc20.Balance :=
    Pure self.["total_supply"].
  
  Global Instance Method_total_supply `{H : State.Trait} :
    Notation.Dot "total_supply" := {
    Notation.dot := total_supply;
  }.
  
  Definition balance_of
      `{H : State.Trait}
      (self : ref Self)
      (owner : erc20.erc20.AccountId)
      : M (H := H) erc20.erc20.Balance :=
    self.["balance_of_impl"] (addr_of owner).
  
  Global Instance Method_balance_of `{H : State.Trait} :
    Notation.Dot "balance_of" := {
    Notation.dot := balance_of;
  }.
  
  Definition allowance
      `{H : State.Trait}
      (self : ref Self)
      (owner : erc20.erc20.AccountId)
      (spender : erc20.erc20.AccountId)
      : M (H := H) erc20.erc20.Balance :=
    self.["allowance_impl"] (addr_of owner) (addr_of spender).
  
  Global Instance Method_allowance `{H : State.Trait} :
    Notation.Dot "allowance" := {
    Notation.dot := allowance;
  }.
  
  Definition transfer
      `{H : State.Trait}
      (self : mut_ref Self)
      (to : erc20.erc20.AccountId)
      (value : erc20.erc20.Balance)
      : M (H := H) (erc20.erc20.Result unit) :=
    let* from :=
      let* α0 := self.["env"] in
      α0.["caller"] in
    self.["transfer_from_to"] (addr_of from) (addr_of to) value.
  
  Global Instance Method_transfer `{H : State.Trait} :
    Notation.Dot "transfer" := {
    Notation.dot := transfer;
  }.
  
  Definition approve
      `{H : State.Trait}
      (self : mut_ref Self)
      (spender : erc20.erc20.AccountId)
      (value : erc20.erc20.Balance)
      : M (H := H) (erc20.erc20.Result unit) :=
    let* owner :=
      let* α0 := self.["env"] in
      α0.["caller"] in
    let* _ :=
      self.["allowances"].["insert"]
        (addr_of owner, addr_of spender)
        (addr_of value) in
    let* _ :=
      let* α0 := self.["env"] in
      α0.["emit_event"]
        {|
          erc20.erc20.Approval.owner := owner;
          erc20.erc20.Approval.spender := spender;
          erc20.erc20.Approval.value := value;
        |} in
    Pure (core.result.Result.Ok tt).
  
  Global Instance Method_approve `{H : State.Trait} :
    Notation.Dot "approve" := {
    Notation.dot := approve;
  }.
  
  Definition transfer_from
      `{H : State.Trait}
      (self : mut_ref Self)
      (from : erc20.erc20.AccountId)
      (to : erc20.erc20.AccountId)
      (value : erc20.erc20.Balance)
      : M (H := H) (erc20.erc20.Result unit) :=
    let* caller :=
      let* α0 := self.["env"] in
      α0.["caller"] in
    let* allowance := self.["allowance_impl"] (addr_of from) (addr_of caller) in
    let* _ :=
      let* α0 := allowance.["lt"] value in
      if (α0 : bool) then
        Return (core.result.Result.Err erc20.erc20.Error.InsufficientAllowance)
      else
        Pure tt in
    let* _ :=
      let* α0 := self.["transfer_from_to"] (addr_of from) (addr_of to) value in
      let* α1 := α0.["branch"] in
      match α1 with
      | LanguageItem.Break residual =>
        let* α0 := residual.["from_residual"] in
        Return α0
      | LanguageItem.Continue val => Pure val
      end in
    let* _ :=
      let* α0 := allowance.["sub"] value in
      self.["allowances"].["insert"]
        (addr_of from, addr_of caller)
        (addr_of α0) in
    Pure (core.result.Result.Ok tt).
  
  Global Instance Method_transfer_from `{H : State.Trait} :
    Notation.Dot "transfer_from" := {
    Notation.dot := transfer_from;
  }.
  
  Definition balance_of_impl
      `{H : State.Trait}
      (self : ref Self)
      (owner : ref erc20.erc20.AccountId)
      : M (H := H) erc20.erc20.Balance :=
    let* α0 := self.["balances"].["get"] owner in
    α0.["unwrap_or_default"].
  
  Global Instance Method_balance_of_impl `{H : State.Trait} :
    Notation.Dot "balance_of_impl" := {
    Notation.dot := balance_of_impl;
  }.
  
  Definition allowance_impl
      `{H : State.Trait}
      (self : ref Self)
      (owner : ref erc20.erc20.AccountId)
      (spender : ref erc20.erc20.AccountId)
      : M (H := H) erc20.erc20.Balance :=
    let* α0 := self.["allowances"].["get"] (owner, spender) in
    α0.["unwrap_or_default"].
  
  Global Instance Method_allowance_impl `{H : State.Trait} :
    Notation.Dot "allowance_impl" := {
    Notation.dot := allowance_impl;
  }.
  
  Definition transfer_from_to
      `{H : State.Trait}
      (self : mut_ref Self)
      (from : ref erc20.erc20.AccountId)
      (to : ref erc20.erc20.AccountId)
      (value : erc20.erc20.Balance)
      : M (H := H) (erc20.erc20.Result unit) :=
    let* from_balance := self.["balance_of_impl"] from in
    let* _ :=
      let* α0 := from_balance.["lt"] value in
      if (α0 : bool) then
        Return (core.result.Result.Err erc20.erc20.Error.InsufficientBalance)
      else
        Pure tt in
    let* _ :=
      let* α0 := from_balance.["sub"] value in
      self.["balances"].["insert"] from (addr_of α0) in
    let* to_balance := self.["balance_of_impl"] to in
    let* _ :=
      let* α0 := to_balance.["add"] value in
      self.["balances"].["insert"] to (addr_of α0) in
    let* _ :=
      let* α0 := self.["env"] in
      let* α1 := from.["deref"] in
      let* α2 := to.["deref"] in
      α0.["emit_event"]
        {|
          erc20.erc20.Transfer.from := core.option.Option.Some α1;
          erc20.erc20.Transfer.to := core.option.Option.Some α2;
          erc20.erc20.Transfer.value := value;
        |} in
    Pure (core.result.Result.Ok tt).
  
  Global Instance Method_transfer_from_to `{H : State.Trait} :
    Notation.Dot "transfer_from_to" := {
    Notation.dot := transfer_from_to;
  }.
End Impl_erc20_erc20_Erc20_29.

Module CallBuilder.
  Unset Primitive Projections.
  Record t : Set := {
    account_id : erc20.erc20.AccountId;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_account_id : Notation.Dot "account_id" := {
    Notation.dot '(Build_t x0) := x0;
  }.
End CallBuilder.
Definition CallBuilder : Set := @CallBuilder.t.

Module Impl_core_fmt_Debug_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Parameter debug_struct_field1_finish : core.fmt.Formatter -> string -> 
    string -> erc20_erc20_AccountId -> 
    M (H := H) core.fmt.Result.
  
  Global Instance Deb_debug_struct_field1_finish : Notation.DoubleColon
    core.fmt.Formatter "debug_struct_field1_finish" := {
    Notation.double_colon := debug_struct_field1_finish; }.
  
  Definition fmt
      `{H : State.Trait}
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter)
      : M (H := H) core.fmt.Result :=
    core.fmt.Formatter::["debug_struct_field1_finish"]
      f
      "CallBuilder"
      "account_id"
      (addr_of (addr_of self.["account_id"])).
  
  Global Instance Method_fmt `{H : State.Trait} : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt `{H : State.Trait} := fmt;
  }.
End Impl_core_fmt_Debug_for_erc20_erc20___CallBuilder.

Module Impl_parity_scale_codec_codec_Encode_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition encode_to
      `{H : State.Trait}
      {__CodecOutputEdqy : Set}
      `{parity_scale_codec.codec.Output.Trait __CodecOutputEdqy}
      `{core.marker.Sized.Trait __CodecOutputEdqy}
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : M (H := H) unit :=
    parity_scale_codec.codec.Encode.encode_to
      (addr_of (addr_of self.["account_id"]))
      __codec_dest_edqy.
  
  Global Instance Method_encode_to `{H : State.Trait} :
    Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Definition encode
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) (alloc.vec.Vec Root.core.primitive.u8) :=
    parity_scale_codec.codec.Encode.encode
      (addr_of (addr_of self.["account_id"])).
  
  Global Instance Method_encode `{H : State.Trait} : Notation.Dot "encode" := {
    Notation.dot := encode;
  }.
  
  Definition using_encoded
      `{H : State.Trait}
      {R F : Set}
      `{core.ops.function.FnOnce.Trait
        F
        (Args := (ref (Slice Root.core.primitive.u8)))}
      (self : ref Self)
      (f : F)
      : M (H := H) R :=
    parity_scale_codec.codec.Encode.using_encoded
      (addr_of (addr_of self.["account_id"]))
      f.
  
  Global Instance Method_using_encoded `{H : State.Trait} :
    Notation.Dot "using_encoded" := {
    Notation.dot := using_encoded;
  }.
  
  Global Instance I : parity_scale_codec.codec.Encode.Trait Self := {
  }.
End Impl_parity_scale_codec_codec_Encode_for_erc20_erc20___CallBuilder.

Module
  Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Global Instance I :
      parity_scale_codec.encode_like.EncodeLike.Trait Self (T := None) :=
    parity_scale_codec.encode_like.EncodeLike.Build_Trait _.
End
  Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20___CallBuilder.

Module Impl_parity_scale_codec_codec_Decode_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition decode
      `{H : State.Trait}
      {__CodecInputEdqy : Set}
      `{parity_scale_codec.codec.Input.Trait __CodecInputEdqy}
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : M (H := H) (core.result.Result Self parity_scale_codec.error.Error) :=
    let* __codec_res_edqy :=
      parity_scale_codec.codec.Decode.decode __codec_input_edqy in
    let* α0 :=
      match __codec_res_edqy with
      | core.result.Result.Err e =>
        let* α0 := e.["chain"] "Could not decode `CallBuilder::account_id`" in
        Return (core.result.Result.Err α0)
      | core.result.Result.Ok __codec_res_edqy => Pure __codec_res_edqy
      end in
    Pure
      (core.result.Result.Ok {| erc20.erc20._.CallBuilder.account_id := α0; |}).
  
  Global Instance AssociatedFunction_decode `{H : State.Trait} :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Definition decode_into
      `{H : State.Trait}
      {__CodecInputEdqy : Set}
      `{parity_scale_codec.codec.Input.Trait __CodecInputEdqy}
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      (dst_ : mut_ref (core.mem.maybe_uninit.MaybeUninit Self))
      :
        M (H := H)
          (core.result.Result
            parity_scale_codec.decode_finished.DecodeFinished
            parity_scale_codec.error.Error) :=
    let* _ :=
      let* α0 := core.mem.size_of in
      let* α1 := core.mem.size_of in
      match (addr_of α0, addr_of α1) with
      | (left_val, right_val) =>
        let* α0 := left_val.["deref"] in
        let* α1 := right_val.["deref"] in
        let* α2 := α0.["eq"] α1 in
        let* α3 := α2.["not"] in
        if (α3 : bool) then
          let kind := core.panicking.AssertKind.Eq in
          let* _ :=
            let* α0 := left_val.["deref"] in
            let* α1 := right_val.["deref"] in
            core.panicking.assert_failed
              kind
              (addr_of α0)
              (addr_of α1)
              core.option.Option.None in
          Pure tt
        else
          Pure tt
      end in
    let* _ :=
      let* α0 := core.mem.size_of in
      let* α1 := α0.["gt"] 0 in
      let* α2 :=
        if (α1 : bool) then
          Pure 1
        else
          Pure 0 in
      let* α3 := α2.["le"] 1 in
      let* α4 := α3.["not"] in
      if (α4 : bool) then
        core.panicking.panic
          "assertion failed: if ::core::mem::size_of::<AccountId>() > 0 { 1 } else { 0 } <= 1"
      else
        Pure tt in
    let* _ :=
      let dst_ : mut_ref (core.mem.maybe_uninit.MaybeUninit Self) := dst_ in
      let* dst_ :=
        let* α0 := dst_.["as_mut_ptr"] in
        let* α1 :=
          α0.["cast"] : M
            (core.mem.maybe_uninit.MaybeUninit erc20.erc20.AccountId) in
        let* α2 := α1.["deref"] in
        Pure (addr_of α2) in
      let* _ :=
        let* α0 :=
          parity_scale_codec.codec.Decode.decode_into __codec_input_edqy dst_ in
        let* α1 := α0.["branch"] in
        match α1 with
        | LanguageItem.Break residual =>
          let* α0 := residual.["from_residual"] in
          Return α0
        | LanguageItem.Continue val => Pure val
        end in
      Pure tt in
    let* α0 :=
      parity_scale_codec.decode_finished.DecodeFinished::["assert_decoding_finished"] in
    Pure (core.result.Result.Ok α0).
  
  Global Instance AssociatedFunction_decode_into `{H : State.Trait} :
    Notation.DoubleColon Self "decode_into" := {
    Notation.double_colon := decode_into;
  }.
  
  Global Instance I : parity_scale_codec.codec.Decode.Trait Self := {
    parity_scale_codec.codec.Decode.decode `{H : State.Trait} := decode;
  }.
End Impl_parity_scale_codec_codec_Decode_for_erc20_erc20___CallBuilder.

Module Impl_core_hash_Hash_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition hash
      `{H : State.Trait}
      {__H : Set}
      `{core.hash.Hasher.Trait __H}
      (self : ref Self)
      (state : mut_ref __H)
      : M (H := H) unit :=
    core.hash.Hash.hash (addr_of self.["account_id"]) state.
  
  Global Instance Method_hash `{H : State.Trait} : Notation.Dot "hash" := {
    Notation.dot := hash;
  }.
  
  Global Instance I : core.hash.Hash.Trait Self := {
    core.hash.Hash.hash `{H : State.Trait} := hash;
  }.
End Impl_core_hash_Hash_for_erc20_erc20___CallBuilder.

Module Impl_core_marker_StructuralPartialEq_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Global Instance I : core.marker.StructuralPartialEq.Trait Self :=
    core.marker.StructuralPartialEq.Build_Trait _.
End Impl_core_marker_StructuralPartialEq_for_erc20_erc20___CallBuilder.

Module Impl_core_cmp_PartialEq_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref erc20.erc20._.CallBuilder)
      : M (H := H) bool :=
    self.["account_id"].["eq"] other.["account_id"].
  
  Global Instance Method_eq `{H : State.Trait} : Notation.Dot "eq" := {
    Notation.dot := eq;
  }.
  
  Global Instance I : core.cmp.PartialEq.Trait Self (Rhs := None) := {
    core.cmp.PartialEq.eq `{H : State.Trait} := eq;
  }.
End Impl_core_cmp_PartialEq_for_erc20_erc20___CallBuilder.

Module Impl_core_marker_StructuralEq_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Global Instance I : core.marker.StructuralEq.Trait Self :=
    core.marker.StructuralEq.Build_Trait _.
End Impl_core_marker_StructuralEq_for_erc20_erc20___CallBuilder.

Module Impl_core_cmp_Eq_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition assert_receiver_is_total_eq
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) unit :=
    let _ : core.cmp.AssertParamIsEq erc20.erc20.AccountId := tt in
    Pure tt.
  
  Global Instance Method_assert_receiver_is_total_eq `{H : State.Trait} :
    Notation.Dot "assert_receiver_is_total_eq" := {
    Notation.dot := assert_receiver_is_total_eq;
  }.
  
  Global Instance I : core.cmp.Eq.Trait Self := {
  }.
End Impl_core_cmp_Eq_for_erc20_erc20___CallBuilder.

Module Impl_core_clone_Clone_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition clone
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) erc20.erc20._.CallBuilder :=
    let* α0 := core.clone.Clone.clone (addr_of self.["account_id"]) in
    Pure {| erc20.erc20._.CallBuilder.account_id := α0; |}.
  
  Global Instance Method_clone `{H : State.Trait} : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I : core.clone.Clone.Trait Self := {
    core.clone.Clone.clone `{H : State.Trait} := clone;
  }.
End Impl_core_clone_Clone_for_erc20_erc20___CallBuilder.

Module Impl_scale_info_TypeInfo_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition Identity : Set := Self.
  
  Definition type_info `{H : State.Trait} : M (H := H) scale_info.ty.Type_ :=
    let* α0 := scale_info.ty.Type_::["builder"] in
    let* α1 := scale_info.ty.path.Path::["new"] "CallBuilder" "erc20::erc20" in
    let* α2 := α0.["path"] α1 in
    let* α3 := alloc.vec.Vec::["new"] in
    let* α4 := α2.["type_params"] α3 in
    let* α5 :=
      α4.["docs"]
        (addr_of
          [
            "The ink! smart contract's call builder.";
            "";
            "Implements the underlying on-chain calling of the ink! smart contract";
            "messages and trait implementations in a type safe way."
          ]) in
    let* α6 := scale_info.build.Fields::["named"] in
    let* α7 :=
      α6.["field"]
        (fun f =>
          let* α0 := f.["ty"] : M erc20.erc20.AccountId in
          let* α1 := α0.["name"] "account_id" in
          α1.["type_name"] "AccountId") in
    α5.["composite"] α7.
  
  Global Instance AssociatedFunction_type_info `{H : State.Trait} :
    Notation.DoubleColon Self "type_info" := {
    Notation.double_colon := type_info;
  }.
  
  Global Instance I : scale_info.TypeInfo.Trait Self := {
    scale_info.TypeInfo.type_info `{H : State.Trait} := type_info;
  }.
End Impl_scale_info_TypeInfo_for_erc20_erc20___CallBuilder.

Module
  Impl_ink_storage_traits_layout_StorageLayout_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition layout
      `{H : State.Trait}
      (__key : ref ink_primitives.key.Key)
      : M (H := H) ink_metadata.layout.Layout :=
    let* α0 := ink_storage_traits.layout.StorageLayout.layout __key in
    let* α1 := ink_metadata.layout.FieldLayout::["new"] "account_id" α0 in
    let* α2 := ink_metadata.layout.StructLayout::["new"] "CallBuilder" [ α1 ] in
    Pure (ink_metadata.layout.Layout.Struct α2).
  
  Global Instance AssociatedFunction_layout `{H : State.Trait} :
    Notation.DoubleColon Self "layout" := {
    Notation.double_colon := layout;
  }.
  
  Global Instance I : ink_storage_traits.layout.StorageLayout.Trait Self := {
    ink_storage_traits.layout.StorageLayout.layout `{H : State.Trait} := layout;
  }.
End Impl_ink_storage_traits_layout_StorageLayout_for_erc20_erc20___CallBuilder.

Module Impl_ink_codegen_dispatch_info_ContractCallBuilder_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Type : Set := erc20.erc20._.CallBuilder.
  
  Global Instance I :
      ink.codegen.dispatch.info.ContractCallBuilder.Trait Self := {
  }.
End Impl_ink_codegen_dispatch_info_ContractCallBuilder_for_erc20_erc20_Erc20.

Module Impl_ink_env_contract_ContractEnv_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition Env : Set := ink_env.contract.ContractEnv.Env.
  
  Global Instance I : ink_env.contract.ContractEnv.Trait Self := {
  }.
End Impl_ink_env_contract_ContractEnv_for_erc20_erc20___CallBuilder.

Module
  Impl_ink_env_call_create_builder_FromAccountId_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition from_account_id
      `{H : State.Trait}
      (account_id : erc20.erc20.AccountId)
      : M (H := H) Self :=
    Pure {| Self.account_id := account_id; |}.
  
  Global Instance AssociatedFunction_from_account_id `{H : State.Trait} :
    Notation.DoubleColon Self "from_account_id" := {
    Notation.double_colon := from_account_id;
  }.
  
  Global Instance I :
      ink_env.call.create_builder.FromAccountId.Trait
        Self
        (T := erc20.erc20.Environment) := {
    ink_env.call.create_builder.FromAccountId.from_account_id
      `{H : State.Trait}
      :=
      from_account_id;
  }.
End
  Impl_ink_env_call_create_builder_FromAccountId_for_erc20_erc20___CallBuilder.

Module Impl_ink_contract_ref_ToAccountId_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition to_account_id
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) erc20.erc20.AccountId :=
    core.clone.Clone.clone (addr_of self.["account_id"]).
  
  Global Instance Method_to_account_id `{H : State.Trait} :
    Notation.Dot "to_account_id" := {
    Notation.dot := to_account_id;
  }.
  
  Global Instance I :
      ink.contract_ref.ToAccountId.Trait
        Self
        (T := erc20.erc20.Environment) := {
    ink.contract_ref.ToAccountId.to_account_id
      `{H : State.Trait}
      :=
      to_account_id;
  }.
End Impl_ink_contract_ref_ToAccountId_for_erc20_erc20___CallBuilder.

Module Impl_core_convert_AsRef_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition as_ref
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) (ref erc20.erc20.AccountId) :=
    Pure (addr_of self.["account_id"]).
  
  Global Instance Method_as_ref `{H : State.Trait} : Notation.Dot "as_ref" := {
    Notation.dot := as_ref;
  }.
  
  Global Instance I :
      core.convert.AsRef.Trait Self (T := erc20.erc20.AccountId) := {
    core.convert.AsRef.as_ref `{H : State.Trait} := as_ref;
  }.
End Impl_core_convert_AsRef_for_erc20_erc20___CallBuilder.

Module Impl_core_convert_AsMut_for_erc20_erc20___CallBuilder.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition as_mut
      `{H : State.Trait}
      (self : mut_ref Self)
      : M (H := H) (mut_ref erc20.erc20.AccountId) :=
    Pure (addr_of self.["account_id"]).
  
  Global Instance Method_as_mut `{H : State.Trait} : Notation.Dot "as_mut" := {
    Notation.dot := as_mut;
  }.
  
  Global Instance I :
      core.convert.AsMut.Trait Self (T := erc20.erc20.AccountId) := {
    core.convert.AsMut.as_mut `{H : State.Trait} := as_mut;
  }.
End Impl_core_convert_AsMut_for_erc20_erc20___CallBuilder.

Module Impl_erc20_erc20___CallBuilder_18.
  Definition Self := erc20.erc20._.CallBuilder.
  
  Definition total_supply
      `{H : State.Trait}
      (self : ref Self)
      :
        M (H := H)
          (ink_env.call.call_builder.CallBuilder
            erc20.erc20.Environment
            (ink_env.call.common.Set
              (ink_env.call.call_builder.Call erc20.erc20.Environment))
            (ink_env.call.common.Set
              (ink_env.call.execution_input.ExecutionInput
                ink_env.call.execution_input.EmptyArgumentList))
            (ink_env.call.common.Set
              (ink_env.call.common.ReturnType erc20.erc20.Balance))) :=
    let* α0 := ink_env.call.call_builder.build_call in
    let* α1 := ink.contract_ref.ToAccountId.to_account_id self in
    let* α2 := α0.["call"] α1 in
    let* α3 := ink_env.call.selector.Selector::["new"] [ 219; 99; 117; 168 ] in
    let* α4 := ink_env.call.execution_input.ExecutionInput::["new"] α3 in
    let* α5 := α2.["exec_input"] α4 in
    α5.["returns"] : M erc20.erc20.Balance.
  
  Global Instance Method_total_supply `{H : State.Trait} :
    Notation.Dot "total_supply" := {
    Notation.dot := total_supply;
  }.
  
  Definition balance_of
      `{H : State.Trait}
      (self : ref Self)
      (__ink_binding_0 : erc20.erc20.AccountId)
      :
        M (H := H)
          (ink_env.call.call_builder.CallBuilder
            erc20.erc20.Environment
            (ink_env.call.common.Set
              (ink_env.call.call_builder.Call erc20.erc20.Environment))
            (ink_env.call.common.Set
              (ink_env.call.execution_input.ExecutionInput
                (ink_env.call.execution_input.ArgumentList
                  (ink_env.call.execution_input.Argument erc20.erc20.AccountId)
                  ink_env.call.execution_input.EmptyArgumentList)))
            (ink_env.call.common.Set
              (ink_env.call.common.ReturnType erc20.erc20.Balance))) :=
    let* α0 := ink_env.call.call_builder.build_call in
    let* α1 := ink.contract_ref.ToAccountId.to_account_id self in
    let* α2 := α0.["call"] α1 in
    let* α3 := ink_env.call.selector.Selector::["new"] [ 15; 117; 90; 86 ] in
    let* α4 := ink_env.call.execution_input.ExecutionInput::["new"] α3 in
    let* α5 := α4.["push_arg"] __ink_binding_0 in
    let* α6 := α2.["exec_input"] α5 in
    α6.["returns"] : M erc20.erc20.Balance.
  
  Global Instance Method_balance_of `{H : State.Trait} :
    Notation.Dot "balance_of" := {
    Notation.dot := balance_of;
  }.
  
  Definition allowance
      `{H : State.Trait}
      (self : ref Self)
      (__ink_binding_0 : erc20.erc20.AccountId)
      (__ink_binding_1 : erc20.erc20.AccountId)
      :
        M (H := H)
          (ink_env.call.call_builder.CallBuilder
            erc20.erc20.Environment
            (ink_env.call.common.Set
              (ink_env.call.call_builder.Call erc20.erc20.Environment))
            (ink_env.call.common.Set
              (ink_env.call.execution_input.ExecutionInput
                (ink_env.call.execution_input.ArgumentList
                  (ink_env.call.execution_input.Argument erc20.erc20.AccountId)
                  (ink_env.call.execution_input.ArgumentList
                    (ink_env.call.execution_input.Argument
                      erc20.erc20.AccountId)
                    ink_env.call.execution_input.EmptyArgumentList))))
            (ink_env.call.common.Set
              (ink_env.call.common.ReturnType erc20.erc20.Balance))) :=
    let* α0 := ink_env.call.call_builder.build_call in
    let* α1 := ink.contract_ref.ToAccountId.to_account_id self in
    let* α2 := α0.["call"] α1 in
    let* α3 := ink_env.call.selector.Selector::["new"] [ 106; 0; 22; 94 ] in
    let* α4 := ink_env.call.execution_input.ExecutionInput::["new"] α3 in
    let* α5 := α4.["push_arg"] __ink_binding_0 in
    let* α6 := α5.["push_arg"] __ink_binding_1 in
    let* α7 := α2.["exec_input"] α6 in
    α7.["returns"] : M erc20.erc20.Balance.
  
  Global Instance Method_allowance `{H : State.Trait} :
    Notation.Dot "allowance" := {
    Notation.dot := allowance;
  }.
  
  Definition transfer
      `{H : State.Trait}
      (self : mut_ref Self)
      (__ink_binding_0 : erc20.erc20.AccountId)
      (__ink_binding_1 : erc20.erc20.Balance)
      :
        M (H := H)
          (ink_env.call.call_builder.CallBuilder
            erc20.erc20.Environment
            (ink_env.call.common.Set
              (ink_env.call.call_builder.Call erc20.erc20.Environment))
            (ink_env.call.common.Set
              (ink_env.call.execution_input.ExecutionInput
                (ink_env.call.execution_input.ArgumentList
                  (ink_env.call.execution_input.Argument erc20.erc20.Balance)
                  (ink_env.call.execution_input.ArgumentList
                    (ink_env.call.execution_input.Argument
                      erc20.erc20.AccountId)
                    ink_env.call.execution_input.EmptyArgumentList))))
            (ink_env.call.common.Set
              (ink_env.call.common.ReturnType (erc20.erc20.Result unit)))) :=
    let* α0 := ink_env.call.call_builder.build_call in
    let* α1 := ink.contract_ref.ToAccountId.to_account_id self in
    let* α2 := α0.["call"] α1 in
    let* α3 := ink_env.call.selector.Selector::["new"] [ 132; 161; 93; 161 ] in
    let* α4 := ink_env.call.execution_input.ExecutionInput::["new"] α3 in
    let* α5 := α4.["push_arg"] __ink_binding_0 in
    let* α6 := α5.["push_arg"] __ink_binding_1 in
    let* α7 := α2.["exec_input"] α6 in
    α7.["returns"] : M (erc20.erc20.Result unit).
  
  Global Instance Method_transfer `{H : State.Trait} :
    Notation.Dot "transfer" := {
    Notation.dot := transfer;
  }.
  
  Definition approve
      `{H : State.Trait}
      (self : mut_ref Self)
      (__ink_binding_0 : erc20.erc20.AccountId)
      (__ink_binding_1 : erc20.erc20.Balance)
      :
        M (H := H)
          (ink_env.call.call_builder.CallBuilder
            erc20.erc20.Environment
            (ink_env.call.common.Set
              (ink_env.call.call_builder.Call erc20.erc20.Environment))
            (ink_env.call.common.Set
              (ink_env.call.execution_input.ExecutionInput
                (ink_env.call.execution_input.ArgumentList
                  (ink_env.call.execution_input.Argument erc20.erc20.Balance)
                  (ink_env.call.execution_input.ArgumentList
                    (ink_env.call.execution_input.Argument
                      erc20.erc20.AccountId)
                    ink_env.call.execution_input.EmptyArgumentList))))
            (ink_env.call.common.Set
              (ink_env.call.common.ReturnType (erc20.erc20.Result unit)))) :=
    let* α0 := ink_env.call.call_builder.build_call in
    let* α1 := ink.contract_ref.ToAccountId.to_account_id self in
    let* α2 := α0.["call"] α1 in
    let* α3 := ink_env.call.selector.Selector::["new"] [ 104; 18; 102; 160 ] in
    let* α4 := ink_env.call.execution_input.ExecutionInput::["new"] α3 in
    let* α5 := α4.["push_arg"] __ink_binding_0 in
    let* α6 := α5.["push_arg"] __ink_binding_1 in
    let* α7 := α2.["exec_input"] α6 in
    α7.["returns"] : M (erc20.erc20.Result unit).
  
  Global Instance Method_approve `{H : State.Trait} :
    Notation.Dot "approve" := {
    Notation.dot := approve;
  }.
  
  Definition transfer_from
      `{H : State.Trait}
      (self : mut_ref Self)
      (__ink_binding_0 : erc20.erc20.AccountId)
      (__ink_binding_1 : erc20.erc20.AccountId)
      (__ink_binding_2 : erc20.erc20.Balance)
      :
        M (H := H)
          (ink_env.call.call_builder.CallBuilder
            erc20.erc20.Environment
            (ink_env.call.common.Set
              (ink_env.call.call_builder.Call erc20.erc20.Environment))
            (ink_env.call.common.Set
              (ink_env.call.execution_input.ExecutionInput
                (ink_env.call.execution_input.ArgumentList
                  (ink_env.call.execution_input.Argument erc20.erc20.Balance)
                  (ink_env.call.execution_input.ArgumentList
                    (ink_env.call.execution_input.Argument
                      erc20.erc20.AccountId)
                    (ink_env.call.execution_input.ArgumentList
                      (ink_env.call.execution_input.Argument
                        erc20.erc20.AccountId)
                      ink_env.call.execution_input.EmptyArgumentList)))))
            (ink_env.call.common.Set
              (ink_env.call.common.ReturnType (erc20.erc20.Result unit)))) :=
    let* α0 := ink_env.call.call_builder.build_call in
    let* α1 := ink.contract_ref.ToAccountId.to_account_id self in
    let* α2 := α0.["call"] α1 in
    let* α3 := ink_env.call.selector.Selector::["new"] [ 11; 57; 111; 24 ] in
    let* α4 := ink_env.call.execution_input.ExecutionInput::["new"] α3 in
    let* α5 := α4.["push_arg"] __ink_binding_0 in
    let* α6 := α5.["push_arg"] __ink_binding_1 in
    let* α7 := α6.["push_arg"] __ink_binding_2 in
    let* α8 := α2.["exec_input"] α7 in
    α8.["returns"] : M (erc20.erc20.Result unit).
  
  Global Instance Method_transfer_from `{H : State.Trait} :
    Notation.Dot "transfer_from" := {
    Notation.dot := transfer_from;
  }.
End Impl_erc20_erc20___CallBuilder_18.

Module Erc20Ref.
  Unset Primitive Projections.
  Record t : Set := {
    inner : ink.codegen.dispatch.info.ContractCallBuilder.Type_;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_inner : Notation.Dot "inner" := {
    Notation.dot '(Build_t x0) := x0;
  }.
End Erc20Ref.
Definition Erc20Ref : Set := @Erc20Ref.t.

Module Impl_core_fmt_Debug_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Parameter debug_struct_field1_finish : core.fmt.Formatter -> string -> 
    string -> ink_codegen_dispatch_info_ContractCallBuilder_Type_ -> 
    M (H := H) core.fmt.Result.
  
  Global Instance Deb_debug_struct_field1_finish : Notation.DoubleColon
    core.fmt.Formatter "debug_struct_field1_finish" := {
    Notation.double_colon := debug_struct_field1_finish; }.
  
  Definition fmt
      `{H : State.Trait}
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter)
      : M (H := H) core.fmt.Result :=
    core.fmt.Formatter::["debug_struct_field1_finish"]
      f
      "Erc20Ref"
      "inner"
      (addr_of (addr_of self.["inner"])).
  
  Global Instance Method_fmt `{H : State.Trait} : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt `{H : State.Trait} := fmt;
  }.
End Impl_core_fmt_Debug_for_erc20_erc20_Erc20Ref.

Module Impl_parity_scale_codec_codec_Encode_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition encode_to
      `{H : State.Trait}
      {__CodecOutputEdqy : Set}
      `{parity_scale_codec.codec.Output.Trait __CodecOutputEdqy}
      `{core.marker.Sized.Trait __CodecOutputEdqy}
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : M (H := H) unit :=
    parity_scale_codec.codec.Encode.encode_to
      (addr_of (addr_of self.["inner"]))
      __codec_dest_edqy.
  
  Global Instance Method_encode_to `{H : State.Trait} :
    Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Definition encode
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) (alloc.vec.Vec Root.core.primitive.u8) :=
    parity_scale_codec.codec.Encode.encode (addr_of (addr_of self.["inner"])).
  
  Global Instance Method_encode `{H : State.Trait} : Notation.Dot "encode" := {
    Notation.dot := encode;
  }.
  
  Definition using_encoded
      `{H : State.Trait}
      {R F : Set}
      `{core.ops.function.FnOnce.Trait
        F
        (Args := (ref (Slice Root.core.primitive.u8)))}
      (self : ref Self)
      (f : F)
      : M (H := H) R :=
    parity_scale_codec.codec.Encode.using_encoded
      (addr_of (addr_of self.["inner"]))
      f.
  
  Global Instance Method_using_encoded `{H : State.Trait} :
    Notation.Dot "using_encoded" := {
    Notation.dot := using_encoded;
  }.
  
  Global Instance I : parity_scale_codec.codec.Encode.Trait Self := {
  }.
End Impl_parity_scale_codec_codec_Encode_for_erc20_erc20_Erc20Ref.

Module Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Global Instance I :
      parity_scale_codec.encode_like.EncodeLike.Trait Self (T := None) :=
    parity_scale_codec.encode_like.EncodeLike.Build_Trait _.
End Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20_Erc20Ref.

Module Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition decode
      `{H : State.Trait}
      {__CodecInputEdqy : Set}
      `{parity_scale_codec.codec.Input.Trait __CodecInputEdqy}
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : M (H := H) (core.result.Result Self parity_scale_codec.error.Error) :=
    let* __codec_res_edqy :=
      parity_scale_codec.codec.Decode.decode __codec_input_edqy in
    let* α0 :=
      match __codec_res_edqy with
      | core.result.Result.Err e =>
        let* α0 := e.["chain"] "Could not decode `Erc20Ref::inner`" in
        Return (core.result.Result.Err α0)
      | core.result.Result.Ok __codec_res_edqy => Pure __codec_res_edqy
      end in
    Pure (core.result.Result.Ok {| erc20.erc20.Erc20Ref.inner := α0; |}).
  
  Global Instance AssociatedFunction_decode `{H : State.Trait} :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : parity_scale_codec.codec.Decode.Trait Self := {
    parity_scale_codec.codec.Decode.decode `{H : State.Trait} := decode;
  }.
End Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_Erc20Ref.

Module Impl_core_hash_Hash_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition hash
      `{H : State.Trait}
      {__H : Set}
      `{core.hash.Hasher.Trait __H}
      (self : ref Self)
      (state : mut_ref __H)
      : M (H := H) unit :=
    core.hash.Hash.hash (addr_of self.["inner"]) state.
  
  Global Instance Method_hash `{H : State.Trait} : Notation.Dot "hash" := {
    Notation.dot := hash;
  }.
  
  Global Instance I : core.hash.Hash.Trait Self := {
    core.hash.Hash.hash `{H : State.Trait} := hash;
  }.
End Impl_core_hash_Hash_for_erc20_erc20_Erc20Ref.

Module Impl_core_marker_StructuralPartialEq_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Global Instance I : core.marker.StructuralPartialEq.Trait Self :=
    core.marker.StructuralPartialEq.Build_Trait _.
End Impl_core_marker_StructuralPartialEq_for_erc20_erc20_Erc20Ref.

Module Impl_core_cmp_PartialEq_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref erc20.erc20.Erc20Ref)
      : M (H := H) bool :=
    self.["inner"].["eq"] other.["inner"].
  
  Global Instance Method_eq `{H : State.Trait} : Notation.Dot "eq" := {
    Notation.dot := eq;
  }.
  
  Global Instance I : core.cmp.PartialEq.Trait Self (Rhs := None) := {
    core.cmp.PartialEq.eq `{H : State.Trait} := eq;
  }.
End Impl_core_cmp_PartialEq_for_erc20_erc20_Erc20Ref.

Module Impl_core_marker_StructuralEq_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Global Instance I : core.marker.StructuralEq.Trait Self :=
    core.marker.StructuralEq.Build_Trait _.
End Impl_core_marker_StructuralEq_for_erc20_erc20_Erc20Ref.

Module Impl_core_cmp_Eq_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition assert_receiver_is_total_eq
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) unit :=
    let
        _ :
        core.cmp.AssertParamIsEq
          ink.codegen.dispatch.info.ContractCallBuilder.Type_ :=
      tt in
    Pure tt.
  
  Global Instance Method_assert_receiver_is_total_eq `{H : State.Trait} :
    Notation.Dot "assert_receiver_is_total_eq" := {
    Notation.dot := assert_receiver_is_total_eq;
  }.
  
  Global Instance I : core.cmp.Eq.Trait Self := {
  }.
End Impl_core_cmp_Eq_for_erc20_erc20_Erc20Ref.

Module Impl_core_clone_Clone_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition clone
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) erc20.erc20.Erc20Ref :=
    let* α0 := core.clone.Clone.clone (addr_of self.["inner"]) in
    Pure {| erc20.erc20.Erc20Ref.inner := α0; |}.
  
  Global Instance Method_clone `{H : State.Trait} : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I : core.clone.Clone.Trait Self := {
    core.clone.Clone.clone `{H : State.Trait} := clone;
  }.
End Impl_core_clone_Clone_for_erc20_erc20_Erc20Ref.

Module Impl_scale_info_TypeInfo_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition Identity : Set := Self.
  
  Definition type_info `{H : State.Trait} : M (H := H) scale_info.ty.Type_ :=
    let* α0 := scale_info.ty.Type_::["builder"] in
    let* α1 := scale_info.ty.path.Path::["new"] "Erc20Ref" "erc20::erc20" in
    let* α2 := α0.["path"] α1 in
    let* α3 := alloc.vec.Vec::["new"] in
    let* α4 := α2.["type_params"] α3 in
    let* α5 := α4.["docs"] (addr_of [ "A simple ERC-20 contract." ]) in
    let* α6 := scale_info.build.Fields::["named"] in
    let* α7 :=
      α6.["field"]
        (fun f =>
          let* α0 :=
            f.["ty"] : M ink.codegen.dispatch.info.ContractCallBuilder.Type_ in
          let* α1 := α0.["name"] "inner" in
          α1.["type_name"]
            "<Erc20 as::ink::codegen::ContractCallBuilder>::Type") in
    α5.["composite"] α7.
  
  Global Instance AssociatedFunction_type_info `{H : State.Trait} :
    Notation.DoubleColon Self "type_info" := {
    Notation.double_colon := type_info;
  }.
  
  Global Instance I : scale_info.TypeInfo.Trait Self := {
    scale_info.TypeInfo.type_info `{H : State.Trait} := type_info;
  }.
End Impl_scale_info_TypeInfo_for_erc20_erc20_Erc20Ref.

Module Impl_ink_storage_traits_layout_StorageLayout_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition layout
      `{H : State.Trait}
      (__key : ref ink_primitives.key.Key)
      : M (H := H) ink_metadata.layout.Layout :=
    let* α0 := ink_storage_traits.layout.StorageLayout.layout __key in
    let* α1 := ink_metadata.layout.FieldLayout::["new"] "inner" α0 in
    let* α2 := ink_metadata.layout.StructLayout::["new"] "Erc20Ref" [ α1 ] in
    Pure (ink_metadata.layout.Layout.Struct α2).
  
  Global Instance AssociatedFunction_layout `{H : State.Trait} :
    Notation.DoubleColon Self "layout" := {
    Notation.double_colon := layout;
  }.
  
  Global Instance I : ink_storage_traits.layout.StorageLayout.Trait Self := {
    ink_storage_traits.layout.StorageLayout.layout `{H : State.Trait} := layout;
  }.
End Impl_ink_storage_traits_layout_StorageLayout_for_erc20_erc20_Erc20Ref.

Module Impl_ink_env_contract_ContractReference_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Type : Set := erc20.erc20.Erc20Ref.
  
  Global Instance I : ink_env.contract.ContractReference.Trait Self := {
  }.
End Impl_ink_env_contract_ContractReference_for_erc20_erc20_Erc20.

Module
  Impl_ink_env_call_create_builder_ConstructorReturnType_for_erc20_erc20_Erc20.
  Definition Self := erc20.erc20.Erc20.
  
  Definition Output : Set := erc20.erc20.Erc20Ref.
  
  Definition Error : Set := unit.
  
  Definition ok
      `{H : State.Trait}
      (value : erc20.erc20.Erc20Ref)
      : M (H := H) Output :=
    Pure value.
  
  Global Instance AssociatedFunction_ok `{H : State.Trait} :
    Notation.DoubleColon Self "ok" := {
    Notation.double_colon := ok;
  }.
  
  Global Instance I :
      ink_env.call.create_builder.ConstructorReturnType.Trait
        Self
        (C := erc20.erc20.Erc20Ref) := {
    ink_env.call.create_builder.ConstructorReturnType.ok
      `{H : State.Trait}
      :=
      ok;
  }.
End
  Impl_ink_env_call_create_builder_ConstructorReturnType_for_erc20_erc20_Erc20.

Module
  Impl_ink_env_call_create_builder_ConstructorReturnType_for_core_result_Result_erc20_erc20_Erc20_E.
Section
  Impl_ink_env_call_create_builder_ConstructorReturnType_for_core_result_Result_erc20_erc20_Erc20_E.
  Context {E : Set}.
  
  Definition Self := core.result.Result erc20.erc20.Erc20 E.
  
  Definition IS_RESULT := Pure true.
  
  Global Instance AssociatedFunction_IS_RESULT `{H : State.Trait} :
    Notation.DoubleColon Self "IS_RESULT" := {
    Notation.double_colon := IS_RESULT;
  }.
  
  Definition Output : Set := core.result.Result erc20.erc20.Erc20Ref E.
  
  Definition Error : Set := E.
  
  Definition ok
      `{H : State.Trait}
      (value : erc20.erc20.Erc20Ref)
      : M (H := H) Output :=
    Pure (core.result.Result.Ok value).
  
  Global Instance AssociatedFunction_ok `{H : State.Trait} :
    Notation.DoubleColon Self "ok" := {
    Notation.double_colon := ok;
  }.
  
  Definition err
      `{H : State.Trait}
      (err : Error)
      : M (H := H) (core.option.Option Output) :=
    Pure (core.option.Option.Some (core.result.Result.Err err)).
  
  Global Instance AssociatedFunction_err `{H : State.Trait} :
    Notation.DoubleColon Self "err" := {
    Notation.double_colon := err;
  }.
  
  Global Instance I :
      ink_env.call.create_builder.ConstructorReturnType.Trait
        Self
        (C := erc20.erc20.Erc20Ref) := {
    ink_env.call.create_builder.ConstructorReturnType.ok
      `{H : State.Trait}
      :=
      ok;
  }.
End
  Impl_ink_env_call_create_builder_ConstructorReturnType_for_core_result_Result_erc20_erc20_Erc20_E.
End
  Impl_ink_env_call_create_builder_ConstructorReturnType_for_core_result_Result_erc20_erc20_Erc20_E.

Module Impl_ink_env_contract_ContractEnv_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition Env : Set := ink_env.contract.ContractEnv.Env.
  
  Global Instance I : ink_env.contract.ContractEnv.Trait Self := {
  }.
End Impl_ink_env_contract_ContractEnv_for_erc20_erc20_Erc20Ref.

Module Impl_erc20_erc20_Erc20Ref_26.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition new
      `{H : State.Trait}
      (__ink_binding_0 : erc20.erc20.Balance)
      :
        M (H := H)
          (ink_env.call.create_builder.CreateBuilder
            erc20.erc20.Environment
            Self
            (ink_env.call.common.Unset erc20.erc20.Hash)
            (ink_env.call.common.Unset u64)
            (ink_env.call.common.Unset erc20.erc20.Balance)
            (ink_env.call.common.Set
              (ink_env.call.execution_input.ExecutionInput
                (ink_env.call.execution_input.ArgumentList
                  (ink_env.call.execution_input.Argument erc20.erc20.Balance)
                  ink_env.call.execution_input.EmptyArgumentList)))
            (ink_env.call.common.Unset ink_env.call.create_builder.state.Salt)
            (ink_env.call.common.Set (ink_env.call.common.ReturnType Self))) :=
    let* α0 := ink_env.call.create_builder.build_create in
    let* α1 := ink_env.call.selector.Selector::["new"] [ 155; 174; 157; 94 ] in
    let* α2 := ink_env.call.execution_input.ExecutionInput::["new"] α1 in
    let* α3 := α2.["push_arg"] __ink_binding_0 in
    let* α4 := α0.["exec_input"] α3 in
    α4.["returns"] : M Self.
  
  Global Instance AssociatedFunction_new `{H : State.Trait} :
    Notation.DoubleColon Self "new" := {
    Notation.double_colon := new;
  }.
  
  Definition total_supply
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) erc20.erc20.Balance :=
    let* α0 := self.["try_total_supply"] in
    α0.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of
              [ "encountered error while calling Erc20::total_supply: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_total_supply `{H : State.Trait} :
    Notation.Dot "total_supply" := {
    Notation.dot := total_supply;
  }.
  
  Definition try_total_supply
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) (ink_primitives.MessageResult erc20.erc20.Balance) :=
    let* α0 := ink.codegen.trait_def.call_builder.TraitCallBuilder.call self in
    let* α1 := α0.["total_supply"] in
    let* α2 := α1.["try_invoke"] in
    α2.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of
              [ "encountered error while calling Erc20::total_supply: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_try_total_supply `{H : State.Trait} :
    Notation.Dot "try_total_supply" := {
    Notation.dot := try_total_supply;
  }.
  
  Definition balance_of
      `{H : State.Trait}
      (self : ref Self)
      (owner : erc20.erc20.AccountId)
      : M (H := H) erc20.erc20.Balance :=
    let* α0 := self.["try_balance_of"] owner in
    α0.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::balance_of: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_balance_of `{H : State.Trait} :
    Notation.Dot "balance_of" := {
    Notation.dot := balance_of;
  }.
  
  Definition try_balance_of
      `{H : State.Trait}
      (self : ref Self)
      (owner : erc20.erc20.AccountId)
      : M (H := H) (ink_primitives.MessageResult erc20.erc20.Balance) :=
    let* α0 := ink.codegen.trait_def.call_builder.TraitCallBuilder.call self in
    let* α1 := α0.["balance_of"] owner in
    let* α2 := α1.["try_invoke"] in
    α2.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::balance_of: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_try_balance_of `{H : State.Trait} :
    Notation.Dot "try_balance_of" := {
    Notation.dot := try_balance_of;
  }.
  
  Definition allowance
      `{H : State.Trait}
      (self : ref Self)
      (owner : erc20.erc20.AccountId)
      (spender : erc20.erc20.AccountId)
      : M (H := H) erc20.erc20.Balance :=
    let* α0 := self.["try_allowance"] owner spender in
    α0.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::allowance: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_allowance `{H : State.Trait} :
    Notation.Dot "allowance" := {
    Notation.dot := allowance;
  }.
  
  Definition try_allowance
      `{H : State.Trait}
      (self : ref Self)
      (owner : erc20.erc20.AccountId)
      (spender : erc20.erc20.AccountId)
      : M (H := H) (ink_primitives.MessageResult erc20.erc20.Balance) :=
    let* α0 := ink.codegen.trait_def.call_builder.TraitCallBuilder.call self in
    let* α1 := α0.["allowance"] owner spender in
    let* α2 := α1.["try_invoke"] in
    α2.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::allowance: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_try_allowance `{H : State.Trait} :
    Notation.Dot "try_allowance" := {
    Notation.dot := try_allowance;
  }.
  
  Definition transfer
      `{H : State.Trait}
      (self : mut_ref Self)
      (to : erc20.erc20.AccountId)
      (value : erc20.erc20.Balance)
      : M (H := H) (erc20.erc20.Result unit) :=
    let* α0 := self.["try_transfer"] to value in
    α0.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::transfer: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_transfer `{H : State.Trait} :
    Notation.Dot "transfer" := {
    Notation.dot := transfer;
  }.
  
  Definition try_transfer
      `{H : State.Trait}
      (self : mut_ref Self)
      (to : erc20.erc20.AccountId)
      (value : erc20.erc20.Balance)
      : M (H := H) (ink_primitives.MessageResult (erc20.erc20.Result unit)) :=
    let* α0 :=
      ink.codegen.trait_def.call_builder.TraitCallBuilder.call_mut self in
    let* α1 := α0.["transfer"] to value in
    let* α2 := α1.["try_invoke"] in
    α2.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::transfer: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_try_transfer `{H : State.Trait} :
    Notation.Dot "try_transfer" := {
    Notation.dot := try_transfer;
  }.
  
  Definition approve
      `{H : State.Trait}
      (self : mut_ref Self)
      (spender : erc20.erc20.AccountId)
      (value : erc20.erc20.Balance)
      : M (H := H) (erc20.erc20.Result unit) :=
    let* α0 := self.["try_approve"] spender value in
    α0.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::approve: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_approve `{H : State.Trait} :
    Notation.Dot "approve" := {
    Notation.dot := approve;
  }.
  
  Definition try_approve
      `{H : State.Trait}
      (self : mut_ref Self)
      (spender : erc20.erc20.AccountId)
      (value : erc20.erc20.Balance)
      : M (H := H) (ink_primitives.MessageResult (erc20.erc20.Result unit)) :=
    let* α0 :=
      ink.codegen.trait_def.call_builder.TraitCallBuilder.call_mut self in
    let* α1 := α0.["approve"] spender value in
    let* α2 := α1.["try_invoke"] in
    α2.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::approve: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_try_approve `{H : State.Trait} :
    Notation.Dot "try_approve" := {
    Notation.dot := try_approve;
  }.
  
  Definition transfer_from
      `{H : State.Trait}
      (self : mut_ref Self)
      (from : erc20.erc20.AccountId)
      (to : erc20.erc20.AccountId)
      (value : erc20.erc20.Balance)
      : M (H := H) (erc20.erc20.Result unit) :=
    let* α0 := self.["try_transfer_from"] from to value in
    α0.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of
              [ "encountered error while calling Erc20::transfer_from: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_transfer_from `{H : State.Trait} :
    Notation.Dot "transfer_from" := {
    Notation.dot := transfer_from;
  }.
  
  Definition try_transfer_from
      `{H : State.Trait}
      (self : mut_ref Self)
      (from : erc20.erc20.AccountId)
      (to : erc20.erc20.AccountId)
      (value : erc20.erc20.Balance)
      : M (H := H) (ink_primitives.MessageResult (erc20.erc20.Result unit)) :=
    let* α0 :=
      ink.codegen.trait_def.call_builder.TraitCallBuilder.call_mut self in
    let* α1 := α0.["transfer_from"] from to value in
    let* α2 := α1.["try_invoke"] in
    α2.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_debug"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of
              [ "encountered error while calling Erc20::transfer_from: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1).
  
  Global Instance Method_try_transfer_from `{H : State.Trait} :
    Notation.Dot "try_transfer_from" := {
    Notation.dot := try_transfer_from;
  }.
End Impl_erc20_erc20_Erc20Ref_26.

Module
  Impl_ink_codegen_trait_def_call_builder_TraitCallBuilder_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition Builder : Set :=
    ink.codegen.dispatch.info.ContractCallBuilder.Type_.
  
  Definition call
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) (ref Builder) :=
    Pure (addr_of self.["inner"]).
  
  Global Instance Method_call `{H : State.Trait} : Notation.Dot "call" := {
    Notation.dot := call;
  }.
  
  Definition call_mut
      `{H : State.Trait}
      (self : mut_ref Self)
      : M (H := H) (mut_ref Builder) :=
    Pure (addr_of self.["inner"]).
  
  Global Instance Method_call_mut `{H : State.Trait} :
    Notation.Dot "call_mut" := {
    Notation.dot := call_mut;
  }.
  
  Global Instance I :
      ink.codegen.trait_def.call_builder.TraitCallBuilder.Trait Self := {
    ink.codegen.trait_def.call_builder.TraitCallBuilder.call
      `{H : State.Trait}
      :=
      call;
    ink.codegen.trait_def.call_builder.TraitCallBuilder.call_mut
      `{H : State.Trait}
      :=
      call_mut;
  }.
End
  Impl_ink_codegen_trait_def_call_builder_TraitCallBuilder_for_erc20_erc20_Erc20Ref.

Module Impl_ink_env_call_create_builder_FromAccountId_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition from_account_id
      `{H : State.Trait}
      (account_id : erc20.erc20.AccountId)
      : M (H := H) Self :=
    let* α0 :=
      ink_env.call.create_builder.FromAccountId.from_account_id account_id in
    Pure {| Self.inner := α0; |}.
  
  Global Instance AssociatedFunction_from_account_id `{H : State.Trait} :
    Notation.DoubleColon Self "from_account_id" := {
    Notation.double_colon := from_account_id;
  }.
  
  Global Instance I :
      ink_env.call.create_builder.FromAccountId.Trait
        Self
        (T := erc20.erc20.Environment) := {
    ink_env.call.create_builder.FromAccountId.from_account_id
      `{H : State.Trait}
      :=
      from_account_id;
  }.
End Impl_ink_env_call_create_builder_FromAccountId_for_erc20_erc20_Erc20Ref.

Module Impl_ink_contract_ref_ToAccountId_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition to_account_id
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) erc20.erc20.AccountId :=
    ink.contract_ref.ToAccountId.to_account_id (addr_of self.["inner"]).
  
  Global Instance Method_to_account_id `{H : State.Trait} :
    Notation.Dot "to_account_id" := {
    Notation.dot := to_account_id;
  }.
  
  Global Instance I :
      ink.contract_ref.ToAccountId.Trait
        Self
        (T := erc20.erc20.Environment) := {
    ink.contract_ref.ToAccountId.to_account_id
      `{H : State.Trait}
      :=
      to_account_id;
  }.
End Impl_ink_contract_ref_ToAccountId_for_erc20_erc20_Erc20Ref.

Module Impl_core_convert_AsRef_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition as_ref
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) (ref erc20.erc20.AccountId) :=
    core.convert.AsRef.as_ref (addr_of self.["inner"]).
  
  Global Instance Method_as_ref `{H : State.Trait} : Notation.Dot "as_ref" := {
    Notation.dot := as_ref;
  }.
  
  Global Instance I :
      core.convert.AsRef.Trait Self (T := erc20.erc20.AccountId) := {
    core.convert.AsRef.as_ref `{H : State.Trait} := as_ref;
  }.
End Impl_core_convert_AsRef_for_erc20_erc20_Erc20Ref.

Module Impl_core_convert_AsMut_for_erc20_erc20_Erc20Ref.
  Definition Self := erc20.erc20.Erc20Ref.
  
  Definition as_mut
      `{H : State.Trait}
      (self : mut_ref Self)
      : M (H := H) (mut_ref erc20.erc20.AccountId) :=
    core.convert.AsMut.as_mut (addr_of self.["inner"]).
  
  Global Instance Method_as_mut `{H : State.Trait} : Notation.Dot "as_mut" := {
    Notation.dot := as_mut;
  }.
  
  Global Instance I :
      core.convert.AsMut.Trait Self (T := erc20.erc20.AccountId) := {
    core.convert.AsMut.as_mut `{H : State.Trait} := as_mut;
  }.
End Impl_core_convert_AsMut_for_erc20_erc20_Erc20Ref.

Definition __ink_generate_metadata
    `{H : State.Trait}
    : M (H := H) ink_metadata.InkProject :=
  let* layout :=
    let* α0 :=
      core.convert.From.from ink_storage_traits.storage.StorageKey.KEY in
    let* α1 :=
      ink_storage_traits.layout.StorageLayout.layout
        (addr_of ink_storage_traits.storage.StorageKey.KEY) in
    let* α2 := ink_metadata.layout.RootLayout::["new"] α0 α1 in
    Pure (ink_metadata.layout.Layout.Root α2) in
  let* _ :=
    let* α0 :=
      ink_metadata.layout.validate.ValidateLayout::["validate"]
        (addr_of layout) in
    α0.["unwrap_or_else"]
      (fun error =>
        let* α0 := format_argument::["new_display"] (addr_of error) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "metadata ink! generation failed: " ])
            (addr_of [ α0 ]) in
        core.panicking.panic_fmt α1) in
  let* α0 := ink_metadata.specs.ContractSpec::["new"] in
  let* α1 := ink_metadata.specs.ConstructorSpec::["from_label"] "new" in
  let* α2 := α1.["selector"] [ 155; 174; 157; 94 ] in
  let* α3 := ink_metadata.specs.MessageParamSpec::["new"] "total_supply" in
  let* α4 := core.iter.traits.collect.IntoIterator.into_iter [ "Balance" ] in
  let* α5 :=
    core.iter.traits.iterator.Iterator.map α4 core.convert.AsRef.as_ref in
  let* α6 := ink_metadata.specs.TypeSpec::["with_name_segs"] α5 in
  let* α7 := α3.["of_type"] α6 in
  let* α8 := α7.["done"] in
  let* α9 := α2.["args"] [ α8 ] in
  let* α10 := α9.["payable"] false in
  let* α11 := α10.["default"] false in
  let* α12 :=
    if (ink.reflect.dispatch.DispatchableConstructorInfo.IS_RESULT : bool) then
      let* α0 :=
        ink_metadata.specs.TypeSpec::["with_name_str"]
          "ink_primitives::ConstructorResult" in
      Pure (core.option.Option.Some α0)
    else
      let* α0 :=
        ink_metadata.specs.TypeSpec::["with_name_str"]
          "ink_primitives::ConstructorResult" in
      Pure (core.option.Option.Some α0) in
  let* α13 := ink_metadata.specs.ReturnTypeSpec::["new"] α12 in
  let* α14 := α11.["returns"] α13 in
  let* α15 :=
    α14.["docs"]
      [ " Creates a new ERC-20 contract with the specified initial supply." ] in
  let* α16 := α15.["done"] in
  let* α17 := α0.["constructors"] [ α16 ] in
  let* α18 := ink_metadata.specs.MessageSpec::["from_label"] "total_supply" in
  let* α19 := α18.["selector"] [ 219; 99; 117; 168 ] in
  let* α20 := α19.["args"] [ ] in
  let* α21 :=
    core.iter.traits.collect.IntoIterator.into_iter
      [ "ink"; "MessageResult" ] in
  let* α22 :=
    core.iter.traits.iterator.Iterator.map α21 core.convert.AsRef.as_ref in
  let* α23 := ink_metadata.specs.TypeSpec::["with_name_segs"] α22 in
  let* α24 := ink_metadata.specs.ReturnTypeSpec::["new"] α23 in
  let* α25 := α20.["returns"] α24 in
  let* α26 := α25.["mutates"] false in
  let* α27 := α26.["payable"] false in
  let* α28 := α27.["default"] false in
  let* α29 := α28.["docs"] [ " Returns the total token supply." ] in
  let* α30 := α29.["done"] in
  let* α31 := ink_metadata.specs.MessageSpec::["from_label"] "balance_of" in
  let* α32 := α31.["selector"] [ 15; 117; 90; 86 ] in
  let* α33 := ink_metadata.specs.MessageParamSpec::["new"] "owner" in
  let* α34 := core.iter.traits.collect.IntoIterator.into_iter [ "AccountId" ] in
  let* α35 :=
    core.iter.traits.iterator.Iterator.map α34 core.convert.AsRef.as_ref in
  let* α36 := ink_metadata.specs.TypeSpec::["with_name_segs"] α35 in
  let* α37 := α33.["of_type"] α36 in
  let* α38 := α37.["done"] in
  let* α39 := α32.["args"] [ α38 ] in
  let* α40 :=
    core.iter.traits.collect.IntoIterator.into_iter
      [ "ink"; "MessageResult" ] in
  let* α41 :=
    core.iter.traits.iterator.Iterator.map α40 core.convert.AsRef.as_ref in
  let* α42 := ink_metadata.specs.TypeSpec::["with_name_segs"] α41 in
  let* α43 := ink_metadata.specs.ReturnTypeSpec::["new"] α42 in
  let* α44 := α39.["returns"] α43 in
  let* α45 := α44.["mutates"] false in
  let* α46 := α45.["payable"] false in
  let* α47 := α46.["default"] false in
  let* α48 :=
    α47.["docs"]
      [
        " Returns the account balance for the specified `owner`.";
        "";
        " Returns `0` if the account is non-existent."
      ] in
  let* α49 := α48.["done"] in
  let* α50 := ink_metadata.specs.MessageSpec::["from_label"] "allowance" in
  let* α51 := α50.["selector"] [ 106; 0; 22; 94 ] in
  let* α52 := ink_metadata.specs.MessageParamSpec::["new"] "owner" in
  let* α53 := core.iter.traits.collect.IntoIterator.into_iter [ "AccountId" ] in
  let* α54 :=
    core.iter.traits.iterator.Iterator.map α53 core.convert.AsRef.as_ref in
  let* α55 := ink_metadata.specs.TypeSpec::["with_name_segs"] α54 in
  let* α56 := α52.["of_type"] α55 in
  let* α57 := α56.["done"] in
  let* α58 := ink_metadata.specs.MessageParamSpec::["new"] "spender" in
  let* α59 := core.iter.traits.collect.IntoIterator.into_iter [ "AccountId" ] in
  let* α60 :=
    core.iter.traits.iterator.Iterator.map α59 core.convert.AsRef.as_ref in
  let* α61 := ink_metadata.specs.TypeSpec::["with_name_segs"] α60 in
  let* α62 := α58.["of_type"] α61 in
  let* α63 := α62.["done"] in
  let* α64 := α51.["args"] [ α57; α63 ] in
  let* α65 :=
    core.iter.traits.collect.IntoIterator.into_iter
      [ "ink"; "MessageResult" ] in
  let* α66 :=
    core.iter.traits.iterator.Iterator.map α65 core.convert.AsRef.as_ref in
  let* α67 := ink_metadata.specs.TypeSpec::["with_name_segs"] α66 in
  let* α68 := ink_metadata.specs.ReturnTypeSpec::["new"] α67 in
  let* α69 := α64.["returns"] α68 in
  let* α70 := α69.["mutates"] false in
  let* α71 := α70.["payable"] false in
  let* α72 := α71.["default"] false in
  let* α73 :=
    α72.["docs"]
      [
        " Returns the amount which `spender` is still allowed to withdraw from `owner`.";
        "";
        " Returns `0` if no allowance has been set."
      ] in
  let* α74 := α73.["done"] in
  let* α75 := ink_metadata.specs.MessageSpec::["from_label"] "transfer" in
  let* α76 := α75.["selector"] [ 132; 161; 93; 161 ] in
  let* α77 := ink_metadata.specs.MessageParamSpec::["new"] "to" in
  let* α78 := core.iter.traits.collect.IntoIterator.into_iter [ "AccountId" ] in
  let* α79 :=
    core.iter.traits.iterator.Iterator.map α78 core.convert.AsRef.as_ref in
  let* α80 := ink_metadata.specs.TypeSpec::["with_name_segs"] α79 in
  let* α81 := α77.["of_type"] α80 in
  let* α82 := α81.["done"] in
  let* α83 := ink_metadata.specs.MessageParamSpec::["new"] "value" in
  let* α84 := core.iter.traits.collect.IntoIterator.into_iter [ "Balance" ] in
  let* α85 :=
    core.iter.traits.iterator.Iterator.map α84 core.convert.AsRef.as_ref in
  let* α86 := ink_metadata.specs.TypeSpec::["with_name_segs"] α85 in
  let* α87 := α83.["of_type"] α86 in
  let* α88 := α87.["done"] in
  let* α89 := α76.["args"] [ α82; α88 ] in
  let* α90 :=
    core.iter.traits.collect.IntoIterator.into_iter
      [ "ink"; "MessageResult" ] in
  let* α91 :=
    core.iter.traits.iterator.Iterator.map α90 core.convert.AsRef.as_ref in
  let* α92 := ink_metadata.specs.TypeSpec::["with_name_segs"] α91 in
  let* α93 := ink_metadata.specs.ReturnTypeSpec::["new"] α92 in
  let* α94 := α89.["returns"] α93 in
  let* α95 := α94.["mutates"] true in
  let* α96 := α95.["payable"] false in
  let* α97 := α96.["default"] false in
  let* α98 :=
    α97.["docs"]
      [
        " Transfers `value` amount of tokens from the caller's account to account `to`.";
        "";
        " On success a `Transfer` event is emitted.";
        "";
        " # Errors";
        "";
        " Returns `InsufficientBalance` error if there are not enough tokens on";
        " the caller's account balance."
      ] in
  let* α99 := α98.["done"] in
  let* α100 := ink_metadata.specs.MessageSpec::["from_label"] "approve" in
  let* α101 := α100.["selector"] [ 104; 18; 102; 160 ] in
  let* α102 := ink_metadata.specs.MessageParamSpec::["new"] "spender" in
  let* α103 :=
    core.iter.traits.collect.IntoIterator.into_iter [ "AccountId" ] in
  let* α104 :=
    core.iter.traits.iterator.Iterator.map α103 core.convert.AsRef.as_ref in
  let* α105 := ink_metadata.specs.TypeSpec::["with_name_segs"] α104 in
  let* α106 := α102.["of_type"] α105 in
  let* α107 := α106.["done"] in
  let* α108 := ink_metadata.specs.MessageParamSpec::["new"] "value" in
  let* α109 := core.iter.traits.collect.IntoIterator.into_iter [ "Balance" ] in
  let* α110 :=
    core.iter.traits.iterator.Iterator.map α109 core.convert.AsRef.as_ref in
  let* α111 := ink_metadata.specs.TypeSpec::["with_name_segs"] α110 in
  let* α112 := α108.["of_type"] α111 in
  let* α113 := α112.["done"] in
  let* α114 := α101.["args"] [ α107; α113 ] in
  let* α115 :=
    core.iter.traits.collect.IntoIterator.into_iter
      [ "ink"; "MessageResult" ] in
  let* α116 :=
    core.iter.traits.iterator.Iterator.map α115 core.convert.AsRef.as_ref in
  let* α117 := ink_metadata.specs.TypeSpec::["with_name_segs"] α116 in
  let* α118 := ink_metadata.specs.ReturnTypeSpec::["new"] α117 in
  let* α119 := α114.["returns"] α118 in
  let* α120 := α119.["mutates"] true in
  let* α121 := α120.["payable"] false in
  let* α122 := α121.["default"] false in
  let* α123 :=
    α122.["docs"]
      [
        " Allows `spender` to withdraw from the caller's account multiple times, up to";
        " the `value` amount.";
        "";
        " If this function is called again it overwrites the current allowance with";
        " `value`.";
        "";
        " An `Approval` event is emitted."
      ] in
  let* α124 := α123.["done"] in
  let* α125 := ink_metadata.specs.MessageSpec::["from_label"] "transfer_from" in
  let* α126 := α125.["selector"] [ 11; 57; 111; 24 ] in
  let* α127 := ink_metadata.specs.MessageParamSpec::["new"] "from" in
  let* α128 :=
    core.iter.traits.collect.IntoIterator.into_iter [ "AccountId" ] in
  let* α129 :=
    core.iter.traits.iterator.Iterator.map α128 core.convert.AsRef.as_ref in
  let* α130 := ink_metadata.specs.TypeSpec::["with_name_segs"] α129 in
  let* α131 := α127.["of_type"] α130 in
  let* α132 := α131.["done"] in
  let* α133 := ink_metadata.specs.MessageParamSpec::["new"] "to" in
  let* α134 :=
    core.iter.traits.collect.IntoIterator.into_iter [ "AccountId" ] in
  let* α135 :=
    core.iter.traits.iterator.Iterator.map α134 core.convert.AsRef.as_ref in
  let* α136 := ink_metadata.specs.TypeSpec::["with_name_segs"] α135 in
  let* α137 := α133.["of_type"] α136 in
  let* α138 := α137.["done"] in
  let* α139 := ink_metadata.specs.MessageParamSpec::["new"] "value" in
  let* α140 := core.iter.traits.collect.IntoIterator.into_iter [ "Balance" ] in
  let* α141 :=
    core.iter.traits.iterator.Iterator.map α140 core.convert.AsRef.as_ref in
  let* α142 := ink_metadata.specs.TypeSpec::["with_name_segs"] α141 in
  let* α143 := α139.["of_type"] α142 in
  let* α144 := α143.["done"] in
  let* α145 := α126.["args"] [ α132; α138; α144 ] in
  let* α146 :=
    core.iter.traits.collect.IntoIterator.into_iter
      [ "ink"; "MessageResult" ] in
  let* α147 :=
    core.iter.traits.iterator.Iterator.map α146 core.convert.AsRef.as_ref in
  let* α148 := ink_metadata.specs.TypeSpec::["with_name_segs"] α147 in
  let* α149 := ink_metadata.specs.ReturnTypeSpec::["new"] α148 in
  let* α150 := α145.["returns"] α149 in
  let* α151 := α150.["mutates"] true in
  let* α152 := α151.["payable"] false in
  let* α153 := α152.["default"] false in
  let* α154 :=
    α153.["docs"]
      [
        " Transfers `value` tokens on the behalf of `from` to the account `to`.";
        "";
        " This can be used to allow a contract to transfer tokens on ones behalf and/or";
        " to charge fees in sub-currencies, for example.";
        "";
        " On success a `Transfer` event is emitted.";
        "";
        " # Errors";
        "";
        " Returns `InsufficientAllowance` error if there are not enough tokens allowed";
        " for the caller to withdraw from `from`.";
        "";
        " Returns `InsufficientBalance` error if there are not enough tokens on";
        " the account balance of `from`."
      ] in
  let* α155 := α154.["done"] in
  let* α156 := α17.["messages"] [ α30; α49; α74; α99; α124; α155 ] in
  let* α157 := ink_metadata.specs.EventSpec::["new"] "Transfer" in
  let* α158 := ink_metadata.specs.EventParamSpec::["new"] "from" in
  let* α159 := core.iter.traits.collect.IntoIterator.into_iter [ "Option" ] in
  let* α160 :=
    core.iter.traits.iterator.Iterator.map α159 core.convert.AsRef.as_ref in
  let* α161 := ink_metadata.specs.TypeSpec::["with_name_segs"] α160 in
  let* α162 := α158.["of_type"] α161 in
  let* α163 := α162.["indexed"] true in
  let* α164 := α163.["docs"] [ ] in
  let* α165 := α164.["done"] in
  let* α166 := ink_metadata.specs.EventParamSpec::["new"] "to" in
  let* α167 := core.iter.traits.collect.IntoIterator.into_iter [ "Option" ] in
  let* α168 :=
    core.iter.traits.iterator.Iterator.map α167 core.convert.AsRef.as_ref in
  let* α169 := ink_metadata.specs.TypeSpec::["with_name_segs"] α168 in
  let* α170 := α166.["of_type"] α169 in
  let* α171 := α170.["indexed"] true in
  let* α172 := α171.["docs"] [ ] in
  let* α173 := α172.["done"] in
  let* α174 := ink_metadata.specs.EventParamSpec::["new"] "value" in
  let* α175 := core.iter.traits.collect.IntoIterator.into_iter [ "Balance" ] in
  let* α176 :=
    core.iter.traits.iterator.Iterator.map α175 core.convert.AsRef.as_ref in
  let* α177 := ink_metadata.specs.TypeSpec::["with_name_segs"] α176 in
  let* α178 := α174.["of_type"] α177 in
  let* α179 := α178.["indexed"] false in
  let* α180 := α179.["docs"] [ ] in
  let* α181 := α180.["done"] in
  let* α182 := α157.["args"] [ α165; α173; α181 ] in
  let* α183 :=
    α182.["docs"] [ " Event emitted when a token transfer occurs." ] in
  let* α184 := α183.["done"] in
  let* α185 := ink_metadata.specs.EventSpec::["new"] "Approval" in
  let* α186 := ink_metadata.specs.EventParamSpec::["new"] "owner" in
  let* α187 :=
    core.iter.traits.collect.IntoIterator.into_iter [ "AccountId" ] in
  let* α188 :=
    core.iter.traits.iterator.Iterator.map α187 core.convert.AsRef.as_ref in
  let* α189 := ink_metadata.specs.TypeSpec::["with_name_segs"] α188 in
  let* α190 := α186.["of_type"] α189 in
  let* α191 := α190.["indexed"] true in
  let* α192 := α191.["docs"] [ ] in
  let* α193 := α192.["done"] in
  let* α194 := ink_metadata.specs.EventParamSpec::["new"] "spender" in
  let* α195 :=
    core.iter.traits.collect.IntoIterator.into_iter [ "AccountId" ] in
  let* α196 :=
    core.iter.traits.iterator.Iterator.map α195 core.convert.AsRef.as_ref in
  let* α197 := ink_metadata.specs.TypeSpec::["with_name_segs"] α196 in
  let* α198 := α194.["of_type"] α197 in
  let* α199 := α198.["indexed"] true in
  let* α200 := α199.["docs"] [ ] in
  let* α201 := α200.["done"] in
  let* α202 := ink_metadata.specs.EventParamSpec::["new"] "value" in
  let* α203 := core.iter.traits.collect.IntoIterator.into_iter [ "Balance" ] in
  let* α204 :=
    core.iter.traits.iterator.Iterator.map α203 core.convert.AsRef.as_ref in
  let* α205 := ink_metadata.specs.TypeSpec::["with_name_segs"] α204 in
  let* α206 := α202.["of_type"] α205 in
  let* α207 := α206.["indexed"] false in
  let* α208 := α207.["docs"] [ ] in
  let* α209 := α208.["done"] in
  let* α210 := α185.["args"] [ α193; α201; α209 ] in
  let* α211 :=
    α210.["docs"]
      [
        " Event emitted when an approval occurs that `spender` is allowed to withdraw";
        " up to the amount of `value` tokens from `owner`."
      ] in
  let* α212 := α211.["done"] in
  let* α213 := α156.["events"] [ α184; α212 ] in
  let* α214 := α213.["docs"] [ ] in
  let* α215 :=
    core.iter.traits.collect.IntoIterator.into_iter [ "ink"; "LangError" ] in
  let* α216 :=
    core.iter.traits.iterator.Iterator.map α215 core.convert.AsRef.as_ref in
  let* α217 := ink_metadata.specs.TypeSpec::["with_name_segs"] α216 in
  let* α218 := α214.["lang_error"] α217 in
  let* α219 := ink_metadata.specs.EnvironmentSpec::["new"] in
  let* α220 :=
    core.iter.traits.collect.IntoIterator.into_iter [ "AccountId" ] in
  let* α221 :=
    core.iter.traits.iterator.Iterator.map α220 core.convert.AsRef.as_ref in
  let* α222 := ink_metadata.specs.TypeSpec::["with_name_segs"] α221 in
  let* α223 := α219.["account_id"] α222 in
  let* α224 := core.iter.traits.collect.IntoIterator.into_iter [ "Balance" ] in
  let* α225 :=
    core.iter.traits.iterator.Iterator.map α224 core.convert.AsRef.as_ref in
  let* α226 := ink_metadata.specs.TypeSpec::["with_name_segs"] α225 in
  let* α227 := α223.["balance"] α226 in
  let* α228 := core.iter.traits.collect.IntoIterator.into_iter [ "Hash" ] in
  let* α229 :=
    core.iter.traits.iterator.Iterator.map α228 core.convert.AsRef.as_ref in
  let* α230 := ink_metadata.specs.TypeSpec::["with_name_segs"] α229 in
  let* α231 := α227.["hash"] α230 in
  let* α232 :=
    core.iter.traits.collect.IntoIterator.into_iter [ "Timestamp" ] in
  let* α233 :=
    core.iter.traits.iterator.Iterator.map α232 core.convert.AsRef.as_ref in
  let* α234 := ink_metadata.specs.TypeSpec::["with_name_segs"] α233 in
  let* α235 := α231.["timestamp"] α234 in
  let* α236 :=
    core.iter.traits.collect.IntoIterator.into_iter [ "BlockNumber" ] in
  let* α237 :=
    core.iter.traits.iterator.Iterator.map α236 core.convert.AsRef.as_ref in
  let* α238 := ink_metadata.specs.TypeSpec::["with_name_segs"] α237 in
  let* α239 := α235.["block_number"] α238 in
  let* α240 :=
    core.iter.traits.collect.IntoIterator.into_iter [ "ChainExtension" ] in
  let* α241 :=
    core.iter.traits.iterator.Iterator.map α240 core.convert.AsRef.as_ref in
  let* α242 := ink_metadata.specs.TypeSpec::["with_name_segs"] α241 in
  let* α243 := α239.["chain_extension"] α242 in
  let* α244 := α243.["max_event_topics"] erc20.erc20.MAX_EVENT_TOPICS in
  let* α245 := α244.["done"] in
  let* α246 := α218.["environment"] α245 in
  let* α247 := α246.["done"] in
  ink_metadata.InkProject::["new"] layout α247.

Module Error.
  Inductive t : Set :=
  | InsufficientBalance
  | InsufficientAllowance.
End Error.
Definition Error := Error.t.

Module Impl_scale_info_TypeInfo_for_erc20_erc20_Error.
  Definition Self := erc20.erc20.Error.
  
  Definition Identity : Set := Self.
  
  Definition type_info `{H : State.Trait} : M (H := H) scale_info.ty.Type_ :=
    let* α0 := scale_info.ty.Type_::["builder"] in
    let* α1 := scale_info.ty.path.Path::["new"] "Error" "erc20::erc20" in
    let* α2 := α0.["path"] α1 in
    let* α3 := alloc.vec.Vec::["new"] in
    let* α4 := α2.["type_params"] α3 in
    let* α5 := α4.["docs"] (addr_of [ "The ERC-20 error types." ]) in
    let* α6 := scale_info.build.Variants::["new"] in
    let* α7 :=
      α6.["variant"]
        "InsufficientBalance"
        (fun v =>
          let* α0 := v.["index"] (cast 0 Root.core.primitive.u8) in
          α0.["docs"]
            (addr_of
              [
                "Returned if not enough balance to fulfill a request is available."
              ])) in
    let* α8 :=
      α7.["variant"]
        "InsufficientAllowance"
        (fun v =>
          let* α0 := v.["index"] (cast 1 Root.core.primitive.u8) in
          α0.["docs"]
            (addr_of
              [
                "Returned if not enough allowance to fulfill a request is available."
              ])) in
    α5.["variant"] α8.
  
  Global Instance AssociatedFunction_type_info `{H : State.Trait} :
    Notation.DoubleColon Self "type_info" := {
    Notation.double_colon := type_info;
  }.
  
  Global Instance I : scale_info.TypeInfo.Trait Self := {
    scale_info.TypeInfo.type_info `{H : State.Trait} := type_info;
  }.
End Impl_scale_info_TypeInfo_for_erc20_erc20_Error.

Module Impl_core_fmt_Debug_for_erc20_erc20_Error.
  Definition Self := erc20.erc20.Error.
  
  Definition fmt
      `{H : State.Trait}
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter)
      : M (H := H) core.fmt.Result :=
    let* α0 :=
      match self with
      | erc20.erc20.Error.InsufficientBalance => Pure "InsufficientBalance"
      | erc20.erc20.Error.InsufficientAllowance => Pure "InsufficientAllowance"
      end in
    core.fmt.Formatter::["write_str"] f α0.
  
  Global Instance Method_fmt `{H : State.Trait} : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt `{H : State.Trait} := fmt;
  }.
End Impl_core_fmt_Debug_for_erc20_erc20_Error.

Module Impl_core_marker_StructuralPartialEq_for_erc20_erc20_Error.
  Definition Self := erc20.erc20.Error.
  
  Global Instance I : core.marker.StructuralPartialEq.Trait Self :=
    core.marker.StructuralPartialEq.Build_Trait _.
End Impl_core_marker_StructuralPartialEq_for_erc20_erc20_Error.

Module Impl_core_cmp_PartialEq_for_erc20_erc20_Error.
  Definition Self := erc20.erc20.Error.
  
  Definition eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref erc20.erc20.Error)
      : M (H := H) bool :=
    let* __self_tag := core.intrinsics.discriminant_value self in
    let* __arg1_tag := core.intrinsics.discriminant_value other in
    __self_tag.["eq"] __arg1_tag.
  
  Global Instance Method_eq `{H : State.Trait} : Notation.Dot "eq" := {
    Notation.dot := eq;
  }.
  
  Global Instance I : core.cmp.PartialEq.Trait Self (Rhs := None) := {
    core.cmp.PartialEq.eq `{H : State.Trait} := eq;
  }.
End Impl_core_cmp_PartialEq_for_erc20_erc20_Error.

Module Impl_core_marker_StructuralEq_for_erc20_erc20_Error.
  Definition Self := erc20.erc20.Error.
  
  Global Instance I : core.marker.StructuralEq.Trait Self :=
    core.marker.StructuralEq.Build_Trait _.
End Impl_core_marker_StructuralEq_for_erc20_erc20_Error.

Module Impl_core_cmp_Eq_for_erc20_erc20_Error.
  Definition Self := erc20.erc20.Error.
  
  Definition assert_receiver_is_total_eq
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) unit :=
    Pure tt.
  
  Global Instance Method_assert_receiver_is_total_eq `{H : State.Trait} :
    Notation.Dot "assert_receiver_is_total_eq" := {
    Notation.dot := assert_receiver_is_total_eq;
  }.
  
  Global Instance I : core.cmp.Eq.Trait Self := {
  }.
End Impl_core_cmp_Eq_for_erc20_erc20_Error.

Module Impl_parity_scale_codec_codec_Encode_for_erc20_erc20_Error.
  Definition Self := erc20.erc20.Error.
  
  Definition encode_to
      `{H : State.Trait}
      {__CodecOutputEdqy : Set}
      `{parity_scale_codec.codec.Output.Trait __CodecOutputEdqy}
      `{core.marker.Sized.Trait __CodecOutputEdqy}
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : M (H := H) unit :=
    let* α0 := self.["deref"] in
    match α0 with
    | erc20.erc20.Error.InsufficientBalance =>
      let* _ :=
        __codec_dest_edqy.["push_byte"] (cast 0 Root.core.primitive.u8) in
      Pure tt
    | erc20.erc20.Error.InsufficientAllowance =>
      let* _ :=
        __codec_dest_edqy.["push_byte"] (cast 1 Root.core.primitive.u8) in
      Pure tt
    | _ => Pure tt
    end.
  
  Global Instance Method_encode_to `{H : State.Trait} :
    Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Global Instance I : parity_scale_codec.codec.Encode.Trait Self := {
  }.
End Impl_parity_scale_codec_codec_Encode_for_erc20_erc20_Error.

Module Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20_Error.
  Definition Self := erc20.erc20.Error.
  
  Global Instance I :
      parity_scale_codec.encode_like.EncodeLike.Trait Self (T := None) :=
    parity_scale_codec.encode_like.EncodeLike.Build_Trait _.
End Impl_parity_scale_codec_encode_like_EncodeLike_for_erc20_erc20_Error.

Module Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_Error.
  Definition Self := erc20.erc20.Error.
  
  Definition decode
      `{H : State.Trait}
      {__CodecInputEdqy : Set}
      `{parity_scale_codec.codec.Input.Trait __CodecInputEdqy}
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : M (H := H) (core.result.Result Self parity_scale_codec.error.Error) :=
    let* α0 := __codec_input_edqy.["read_byte"] in
    let* α1 :=
      α0.["map_err"]
        (fun e =>
          e.["chain"]
            "Could not decode `Error`, failed to read variant byte") in
    let* α2 := α1.["branch"] in
    let* α3 :=
      match α2 with
      | LanguageItem.Break residual =>
        let* α0 := residual.["from_residual"] in
        Return α0
      | LanguageItem.Continue val => Pure val
      end in
    match α3 with
    | __codec_x_edqy =>
      let* _ :=
        let* α0 :=
          (fun  =>
              Pure
                (core.result.Result.Ok
                  erc20.erc20.Error.InsufficientBalance)) in
        Return α0 in
      Pure tt
    | __codec_x_edqy =>
      let* _ :=
        let* α0 :=
          (fun  =>
              Pure
                (core.result.Result.Ok
                  erc20.erc20.Error.InsufficientAllowance)) in
        Return α0 in
      Pure tt
    | _ =>
      let* _ :=
        let* α0 :=
          (fun  =>
              let* α0 :=
                core.convert.Into.into
                  "Could not decode `Error`, variant doesn't exist" in
              Pure (core.result.Result.Err α0)) in
        Return α0 in
      Pure tt
    end.
  
  Global Instance AssociatedFunction_decode `{H : State.Trait} :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : parity_scale_codec.codec.Decode.Trait Self := {
    parity_scale_codec.codec.Decode.decode `{H : State.Trait} := decode;
  }.
End Impl_parity_scale_codec_codec_Decode_for_erc20_erc20_Error.

Definition Result (T : Set) : Set := core.result.Result T erc20.erc20.Error.
