(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bump.
  Definition PAGE_SIZE : usize := run (64.["mul"] 1024).
  
  Definition INNER : ink_allocator.bump.InnerAlloc :=
    run (ink_allocator.bump.InnerAlloc::["new"] tt).
  
  Module BumpAllocator.
    Inductive t : Set := Build.
  End BumpAllocator.
  Definition BumpAllocator := BumpAllocator.t.
  
  Module
    Impl_core_alloc_global_GlobalAlloc_for_ink_allocator_bump_BumpAllocator.
    Definition Self := ink_allocator.bump.BumpAllocator.
    
    Definition alloc
        (self : ref Self)
        (layout : core.alloc.layout.Layout)
        : M (mut_ref u8) :=
      let* α0 := ink_allocator.bump.INNER.["alloc"] layout in
      match α0 with
      | core.option.Option.Some start => Pure (cast start (mut_ref u8))
      | core.option.Option.None => core.ptr.null_mut tt
      end.
    
    Global Instance Method_alloc : Notation.Dot "alloc" := {
      Notation.dot := alloc;
    }.
    
    Definition alloc_zeroed
        (self : ref Self)
        (layout : core.alloc.layout.Layout)
        : M (mut_ref u8) :=
      self.["alloc"] layout.
    
    Global Instance Method_alloc_zeroed : Notation.Dot "alloc_zeroed" := {
      Notation.dot := alloc_zeroed;
    }.
    
    Definition dealloc
        (self : ref Self)
        (_ptr : mut_ref u8)
        (_layout : core.alloc.layout.Layout)
        : M unit :=
      Pure tt.
    
    Global Instance Method_dealloc : Notation.Dot "dealloc" := {
      Notation.dot := dealloc;
    }.
    
    Global Instance I : core.alloc.global.GlobalAlloc.Trait Self := {
      core.alloc.global.GlobalAlloc.alloc := alloc;
      core.alloc.global.GlobalAlloc.dealloc := dealloc;
    }.
  End Impl_core_alloc_global_GlobalAlloc_for_ink_allocator_bump_BumpAllocator.
  
  Module InnerAlloc.
    Unset Primitive Projections.
    Record t : Set := {
      next : usize;
      upper_limit : usize;
    }.
    Global Set Primitive Projections.
    
    Global Instance Get_next : Notation.Dot "next" := {
      Notation.dot '(Build_t x0 _) := x0;
    }.
    Global Instance Get_upper_limit : Notation.Dot "upper_limit" := {
      Notation.dot '(Build_t _ x1) := x1;
    }.
  End InnerAlloc.
  Definition InnerAlloc : Set := InnerAlloc.t.
  
  Module Impl_core_fmt_Debug_for_ink_allocator_bump_InnerAlloc.
    Definition Self := ink_allocator.bump.InnerAlloc.
    
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter)
        : M core.fmt.Result :=
      core.fmt.Formatter::["debug_struct_field2_finish"]
        f
        "InnerAlloc"
        "next"
        (addr_of self.["next"])
        "upper_limit"
        (addr_of (addr_of self.["upper_limit"])).
    
    Global Instance Method_fmt : Notation.Dot "fmt" := {
      Notation.dot := fmt;
    }.
    
    Global Instance I : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_ink_allocator_bump_InnerAlloc.
  
  Module Impl_core_marker_Copy_for_ink_allocator_bump_InnerAlloc.
    Definition Self := ink_allocator.bump.InnerAlloc.
    
    Global Instance I : core.marker.Copy.Trait Self :=
      core.marker.Copy.Build_Trait _.
  End Impl_core_marker_Copy_for_ink_allocator_bump_InnerAlloc.
  
  Module Impl_core_clone_Clone_for_ink_allocator_bump_InnerAlloc.
    Definition Self := ink_allocator.bump.InnerAlloc.
    
    Definition clone (self : ref Self) : M ink_allocator.bump.InnerAlloc :=
      let _ := tt in
      self.["deref"].
    
    Global Instance Method_clone : Notation.Dot "clone" := {
      Notation.dot := clone;
    }.
    
    Global Instance I : core.clone.Clone.Trait Self := {
      core.clone.Clone.clone := clone;
    }.
  End Impl_core_clone_Clone_for_ink_allocator_bump_InnerAlloc.
  
  Module Impl_ink_allocator_bump_InnerAlloc.
    Definition Self := ink_allocator.bump.InnerAlloc.
    
    Definition new (_ : unit) : M Self :=
      let* α0 := Self::["heap_start"] tt in
      let* α1 := Self::["heap_end"] tt in
      Pure {| Self.next := α0; Self.upper_limit := α1; |}.
    
    Global Instance AssociatedFunction_new :
      Notation.DoubleColon Self "new" := {
      Notation.double_colon := new;
    }.
    
    Definition heap_start (_ : unit) : M usize := Pure 0.
    
    Global Instance AssociatedFunction_heap_start :
      Notation.DoubleColon Self "heap_start" := {
      Notation.double_colon := heap_start;
    }.
    
    Definition heap_end (_ : unit) : M usize := Pure 0.
    
    Global Instance AssociatedFunction_heap_end :
      Notation.DoubleColon Self "heap_end" := {
      Notation.double_colon := heap_end;
    }.
    
    Definition request_pages
        (self : mut_ref Self)
        (_pages : usize)
        : M (core.option.Option usize) :=
      let* α0 :=
        format_arguments::["new_v1"]
          (addr_of
            [
              "internal error: entered unreachable code: This branch is only used to keep the compiler happy when building tests, and
                     should never actually be called outside of a test run."
            ])
          (addr_of [ ]) in
      core.panicking.panic_fmt α0.
    
    Global Instance Method_request_pages : Notation.Dot "request_pages" := {
      Notation.dot := request_pages;
    }.
    
    Definition alloc
        (self : mut_ref Self)
        (layout : core.alloc.layout.Layout)
        : M (core.option.Option usize) :=
      let alloc_start := self.["next"] in
      let* aligned_size :=
        let* α0 := layout.["pad_to_align"] in
        α0.["size"] in
      let* alloc_end :=
        let* α0 := alloc_start.["checked_add"] aligned_size in
        let* α1 := LangItem α0 in
        match α1 with
        | Break {| Break.0 := residual; |} =>
          let* α0 := LangItem residual in
          Return α0
        | Continue {| Continue.0 := val; |} => Pure val
        end in
      let* α0 := alloc_end.["gt"] self.["upper_limit"] in
      if (α0 : bool) then
        let* required_pages :=
          let* α0 := ink_allocator.bump.required_pages aligned_size in
          let* α1 := LangItem α0 in
          match α1 with
          | Break {| Break.0 := residual; |} =>
            let* α0 := LangItem residual in
            Return α0
          | Continue {| Continue.0 := val; |} => Pure val
          end in
        let* page_start :=
          let* α0 := self.["request_pages"] required_pages in
          let* α1 := LangItem α0 in
          match α1 with
          | Break {| Break.0 := residual; |} =>
            let* α0 := LangItem residual in
            Return α0
          | Continue {| Continue.0 := val; |} => Pure val
          end in
        let* _ :=
          let* α0 :=
            required_pages.["checked_mul"] ink_allocator.bump.PAGE_SIZE in
          let* α1 :=
            α0.["and_then"] (fun pages => page_start.["checked_add"] pages) in
          let* α2 := LangItem α1 in
          let* α3 :=
            match α2 with
            | Break {| Break.0 := residual; |} =>
              let* α0 := LangItem residual in
              Return α0
            | Continue {| Continue.0 := val; |} => Pure val
            end in
          assign self.["upper_limit"] α3 in
        let* _ :=
          let* α0 := page_start.["checked_add"] aligned_size in
          let* α1 := LangItem α0 in
          let* α2 :=
            match α1 with
            | Break {| Break.0 := residual; |} =>
              let* α0 := LangItem residual in
              Return α0
            | Continue {| Continue.0 := val; |} => Pure val
            end in
          assign self.["next"] α2 in
        Pure (core.option.Option.Some page_start)
      else
        let* _ := assign self.["next"] alloc_end in
        Pure (core.option.Option.Some alloc_start).
    
    Global Instance Method_alloc : Notation.Dot "alloc" := {
      Notation.dot := alloc;
    }.
  End Impl_ink_allocator_bump_InnerAlloc.
  
  Definition required_pages (size : usize) : M (core.option.Option usize) :=
    let* α0 := ink_allocator.bump.PAGE_SIZE.["sub"] 1 in
    let* α1 := size.["checked_add"] α0 in
    α1.["and_then"]
      (fun num => num.["checked_div"] ink_allocator.bump.PAGE_SIZE).
End bump.

Definition PAGE_SIZE : usize := run (64.["mul"] 1024).

Definition INNER : ink_allocator.bump.InnerAlloc :=
  run (ink_allocator.bump.InnerAlloc::["new"] tt).

Module BumpAllocator.
  Inductive t : Set := Build.
End BumpAllocator.
Definition BumpAllocator := BumpAllocator.t.

Module Impl_core_alloc_global_GlobalAlloc_for_ink_allocator_bump_BumpAllocator.
  Definition Self := ink_allocator.bump.BumpAllocator.
  
  Definition alloc
      (self : ref Self)
      (layout : core.alloc.layout.Layout)
      : M (mut_ref u8) :=
    let* α0 := ink_allocator.bump.INNER.["alloc"] layout in
    match α0 with
    | core.option.Option.Some start => Pure (cast start (mut_ref u8))
    | core.option.Option.None => core.ptr.null_mut tt
    end.
  
  Global Instance Method_alloc : Notation.Dot "alloc" := {
    Notation.dot := alloc;
  }.
  
  Definition alloc_zeroed
      (self : ref Self)
      (layout : core.alloc.layout.Layout)
      : M (mut_ref u8) :=
    self.["alloc"] layout.
  
  Global Instance Method_alloc_zeroed : Notation.Dot "alloc_zeroed" := {
    Notation.dot := alloc_zeroed;
  }.
  
  Definition dealloc
      (self : ref Self)
      (_ptr : mut_ref u8)
      (_layout : core.alloc.layout.Layout)
      : M unit :=
    Pure tt.
  
  Global Instance Method_dealloc : Notation.Dot "dealloc" := {
    Notation.dot := dealloc;
  }.
  
  Global Instance I : core.alloc.global.GlobalAlloc.Trait Self := {
    core.alloc.global.GlobalAlloc.alloc := alloc;
    core.alloc.global.GlobalAlloc.dealloc := dealloc;
  }.
End Impl_core_alloc_global_GlobalAlloc_for_ink_allocator_bump_BumpAllocator.

Module InnerAlloc.
  Unset Primitive Projections.
  Record t : Set := {
    next : usize;
    upper_limit : usize;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_next : Notation.Dot "next" := {
    Notation.dot '(Build_t x0 _) := x0;
  }.
  Global Instance Get_upper_limit : Notation.Dot "upper_limit" := {
    Notation.dot '(Build_t _ x1) := x1;
  }.
End InnerAlloc.
Definition InnerAlloc : Set := InnerAlloc.t.

Module Impl_core_fmt_Debug_for_ink_allocator_bump_InnerAlloc.
  Definition Self := ink_allocator.bump.InnerAlloc.
  
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter)
      : M core.fmt.Result :=
    core.fmt.Formatter::["debug_struct_field2_finish"]
      f
      "InnerAlloc"
      "next"
      (addr_of self.["next"])
      "upper_limit"
      (addr_of (addr_of self.["upper_limit"])).
  
  Global Instance Method_fmt : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_ink_allocator_bump_InnerAlloc.

Module Impl_core_marker_Copy_for_ink_allocator_bump_InnerAlloc.
  Definition Self := ink_allocator.bump.InnerAlloc.
  
  Global Instance I : core.marker.Copy.Trait Self :=
    core.marker.Copy.Build_Trait _.
End Impl_core_marker_Copy_for_ink_allocator_bump_InnerAlloc.

Module Impl_core_clone_Clone_for_ink_allocator_bump_InnerAlloc.
  Definition Self := ink_allocator.bump.InnerAlloc.
  
  Definition clone (self : ref Self) : M ink_allocator.bump.InnerAlloc :=
    let _ := tt in
    self.["deref"].
  
  Global Instance Method_clone : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I : core.clone.Clone.Trait Self := {
    core.clone.Clone.clone := clone;
  }.
End Impl_core_clone_Clone_for_ink_allocator_bump_InnerAlloc.

Module Impl_ink_allocator_bump_InnerAlloc_2.
  Definition Self := ink_allocator.bump.InnerAlloc.
  
  Definition new (_ : unit) : M Self :=
    let* α0 := Self::["heap_start"] tt in
    let* α1 := Self::["heap_end"] tt in
    Pure {| Self.next := α0; Self.upper_limit := α1; |}.
  
  Global Instance AssociatedFunction_new : Notation.DoubleColon Self "new" := {
    Notation.double_colon := new;
  }.
  
  Definition heap_start (_ : unit) : M usize := Pure 0.
  
  Global Instance AssociatedFunction_heap_start :
    Notation.DoubleColon Self "heap_start" := {
    Notation.double_colon := heap_start;
  }.
  
  Definition heap_end (_ : unit) : M usize := Pure 0.
  
  Global Instance AssociatedFunction_heap_end :
    Notation.DoubleColon Self "heap_end" := {
    Notation.double_colon := heap_end;
  }.
  
  Definition request_pages
      (self : mut_ref Self)
      (_pages : usize)
      : M (core.option.Option usize) :=
    let* α0 :=
      format_arguments::["new_v1"]
        (addr_of
          [
            "internal error: entered unreachable code: This branch is only used to keep the compiler happy when building tests, and
                     should never actually be called outside of a test run."
          ])
        (addr_of [ ]) in
    core.panicking.panic_fmt α0.
  
  Global Instance Method_request_pages : Notation.Dot "request_pages" := {
    Notation.dot := request_pages;
  }.
  
  Definition alloc
      (self : mut_ref Self)
      (layout : core.alloc.layout.Layout)
      : M (core.option.Option usize) :=
    let alloc_start := self.["next"] in
    let* aligned_size :=
      let* α0 := layout.["pad_to_align"] in
      α0.["size"] in
    let* alloc_end :=
      let* α0 := alloc_start.["checked_add"] aligned_size in
      let* α1 := LangItem α0 in
      match α1 with
      | Break {| Break.0 := residual; |} =>
        let* α0 := LangItem residual in
        Return α0
      | Continue {| Continue.0 := val; |} => Pure val
      end in
    let* α0 := alloc_end.["gt"] self.["upper_limit"] in
    if (α0 : bool) then
      let* required_pages :=
        let* α0 := ink_allocator.bump.required_pages aligned_size in
        let* α1 := LangItem α0 in
        match α1 with
        | Break {| Break.0 := residual; |} =>
          let* α0 := LangItem residual in
          Return α0
        | Continue {| Continue.0 := val; |} => Pure val
        end in
      let* page_start :=
        let* α0 := self.["request_pages"] required_pages in
        let* α1 := LangItem α0 in
        match α1 with
        | Break {| Break.0 := residual; |} =>
          let* α0 := LangItem residual in
          Return α0
        | Continue {| Continue.0 := val; |} => Pure val
        end in
      let* _ :=
        let* α0 :=
          required_pages.["checked_mul"] ink_allocator.bump.PAGE_SIZE in
        let* α1 :=
          α0.["and_then"] (fun pages => page_start.["checked_add"] pages) in
        let* α2 := LangItem α1 in
        let* α3 :=
          match α2 with
          | Break {| Break.0 := residual; |} =>
            let* α0 := LangItem residual in
            Return α0
          | Continue {| Continue.0 := val; |} => Pure val
          end in
        assign self.["upper_limit"] α3 in
      let* _ :=
        let* α0 := page_start.["checked_add"] aligned_size in
        let* α1 := LangItem α0 in
        let* α2 :=
          match α1 with
          | Break {| Break.0 := residual; |} =>
            let* α0 := LangItem residual in
            Return α0
          | Continue {| Continue.0 := val; |} => Pure val
          end in
        assign self.["next"] α2 in
      Pure (core.option.Option.Some page_start)
    else
      let* _ := assign self.["next"] alloc_end in
      Pure (core.option.Option.Some alloc_start).
  
  Global Instance Method_alloc : Notation.Dot "alloc" := {
    Notation.dot := alloc;
  }.
End Impl_ink_allocator_bump_InnerAlloc_2.

Definition required_pages (size : usize) : M (core.option.Option usize) :=
  let* α0 := ink_allocator.bump.PAGE_SIZE.["sub"] 1 in
  let* α1 := size.["checked_add"] α0 in
  α1.["and_then"] (fun num => num.["checked_div"] ink_allocator.bump.PAGE_SIZE).
