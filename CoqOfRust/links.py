"""
Utility functions to generate links Coq files from the JSON generated by `coq-of-rust`.
"""


from typing import Any, Tuple


def find_top_level_item(prefix: list[str], top_level, condition) -> Tuple[list[str], Any] | None:
    for entry in top_level:
        item = entry["item"]
        if condition(item):
            return (prefix, item)
        if item["type"] == "Module":
            result = find_top_level_item(prefix + [item["name"]], item["body"], condition)
            if result:
                return result


def find_top_level_item_by_name(crate: str, top_level, name: str) -> Tuple[list[str], Any]:
    result = find_top_level_item(
        [crate],
        top_level,
        lambda item: "name" in item and item["name"] == name
    )
    if result:
        return result
    raise Exception("Item not found: " + name)


def get_header(imports: list[str]) -> str:
    return """(* Generated file for the links. Do not edit. *)
Require Import CoqOfRust.CoqOfRust.
Require Import links.M.
""" + "".join("Require " + import_ + ".\n" for import_ in imports) + """
Import Run.
"""


def indent(s: str) -> str:
    return "\n".join(
        # We do not indent empty lines
        "  " + line if len(line) > 0 else ""
        for line in s.split("\n")
    )


def paren(with_paren: bool, s: str) -> str:
    if with_paren:
        return "(" + s + ")"
    return s


def pp_path(path) -> str:
    return ".".join(path)


def pp_type(with_paren: bool, item) -> str:
    if item["type"] == "Var":
        return item["name"]
    if item["type"] == "Path":
        path = item["path"]
        if path == ["*const"]:
            return "Ref.t Pointer.Kind.ConstPointer"
        if path == ["bool"]:
            return "bool"
        return pp_path(path) + ".t"
    if item["type"] == "Application":
        return paren(
            with_paren and len(item["tys"]) > 0,
            " ".join(pp_type(True, ty) for ty in [item["func"]] + item["tys"])
        )
    return "Unknown type " + item["type"]


def pp_type_struct_struct(prefix: list[str], item) -> str:
    if len(item["ty_params"]) != 0:
        ty_params = "(" + " ".join(item["ty_params"]) + ": Set) "
    else:
        ty_params = ""
    ty_params_links = "".join("`{Link " + ty_param + "} " for ty_param in item["ty_params"])
    return pp_module(item["name"],
        "Record t " + ty_params + ty_params_links + ": Set := {\n" +
        indent("".join(
            field[0] + ": " + pp_type(False, field[1]) + ";\n"
            for field in item["fields"]
        )) +
        "}.\n" +
        ("Arguments Build_t {" + " ".join(["_ _"] * len(item["ty_params"])) + "}.\n"
        if len(item["ty_params"]) > 0
        else ""
        ) +
        "\n" +
        "Global Instance IsLink " + ty_params + ty_params_links + ": Link " +
        paren(len(item["ty_params"]) > 0, " ".join(["t"] + item["ty_params"])) +
        " := {\n" +
        indent(
            "to_ty := Ty.path \"" + "::".join(prefix + [item["name"]]) + "\";\n" +
            "to_value '(Build_t" + "".join(" " + field[0] for field in item["fields"]) + ") :=\n" +
            indent(
                "Value.StructRecord \"" + "::".join(prefix + [item["name"]]) + "\" [\n" +
                indent(";\n".join(
                    "(\"" + field[0] + "\", to_value " + field[0] + ")"
                    for field in item["fields"]
                )) + "\n" +
                "];\n"
            )
        ) +
        "}."
    )


def pp_type_struct_tuple(prefix: list[str], item) -> str:
    if len(item["ty_params"]) != 0:
        ty_params = "(" + " ".join(item["ty_params"]) + ": Set) "
    else:
        ty_params = ""
    ty_params_links = "".join("`{Link " + ty_param + "} " for ty_param in item["ty_params"])
    return pp_module(item["name"],
        "Inductive t " + ty_params + ty_params_links + ": Set :=\n" +
        "| Make :" +
        "".join(
            " " + pp_type(False, field) + " ->"
            for field in item["fields"]
        ) +
        " t" + "".join(" " + ty_param for ty_param in item["ty_params"]) + ".\n" +
        ("Arguments Make {" + " ".join(["_ _"] * len(item["ty_params"])) + "}.\n"
        if len(item["ty_params"]) > 0
        else ""
        ) +
        "\n" +
        "Global Instance IsLink " + ty_params + ty_params_links + ": Link " +
        paren(len(item["ty_params"]) > 0, " ".join(["t"] + item["ty_params"])) +
        " := {\n" +
        indent(
            "to_ty := Ty.path \"" + "::".join(prefix + [item["name"]]) + "\";\n" +
            "to_value '(Make" + "".join(" x" + str(index) for index in range(len(item["fields"]))) + ") :=\n" +
            indent(
                "Value.StructTuple \"" + "::".join(prefix + [item["name"]]) + "\" [" +
                "; ".join("to_value x" + str(index) for index in range(len(item["fields"]))) + "];\n"
            )
        ) +
        "}."
    )


def pp_top_level_item(prefix: list[str], item) -> str:
    if item["type"] == "TypeStructStruct":
        return pp_type_struct_struct(prefix, item)
    if item["type"] == "TypeStructTuple":
        return pp_type_struct_tuple(prefix, item)
    return "Unknown item type " + item["type"]


def pp_module(name: str, content: str) -> str:
    return \
        "Module " + name + ".\n" + \
        indent(content) + "\n" + \
        "End " + name + "."
