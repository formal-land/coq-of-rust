"""
Utility functions to generate links Coq files from the JSON generated by `coq-of-rust`.
"""


def find_top_level_item(top_level, condition):
    for entry in top_level:
        item = entry["item"]
        if condition(item):
            return item
        if item["type"] == "Module":
            result = find_top_level_item(item["body"], condition)
            if result:
                return result


def find_top_level_item_by_name(top_level, name):
    return find_top_level_item(
        top_level,
        lambda item: "name" in item and item["name"] == name
    )


def get_header(imports: list[str]) -> str:
    return """(* Generated file for the links. Do not edit. *)
Require Import CoqOfRust.CoqOfRust.
Require Import links.M.
""" + "".join("Require " + import_ + ".\n" for import_ in imports) + """
Import Run.
"""


def indent(level: int) -> str:
    return "  " * level


def paren(with_paren: bool, s: str) -> str:
    if with_paren:
        return "(" + s + ")"
    return s


def pp_path(path) -> str:
    return ".".join(path)


def pp_type(with_paren: bool, item) -> str:
    if item["type"] == "Var":
        return item["name"]
    if item["type"] == "Path":
        path = item["path"]
        if path == ["*const"]:
            return "Ref.t Pointer.Kind.ConstPointer"
        return pp_path(path) + ".t"
    if item["type"] == "Application":
        return paren(
            with_paren,
            " ".join(pp_type(True, ty) for ty in [item["func"]] + item["tys"])
        )
    return "Unknown type " + item["type"]


def pp_type_struct_struct(level: int, item) -> str:
    result = "Module " + item["name"] + ".\n"
    if len(item["ty_params"]) != 0:
        ty_params = "(" + " ".join(item["ty_params"]) + ": Set) "
    else:
        ty_params = ""
    ty_params_links = "".join("`{Link " + ty_param + "} " for ty_param in item["ty_params"])
    result += indent(level + 1) + "Record t " + ty_params + ty_params_links + ": Set := {\n"
    for field in item["fields"]:
        result += indent(level + 2) + field[0] + ": " + pp_type(False, field[1]) + ";\n"
    result += indent(level + 1) + "}.\n"
    result += indent(level) + "End " + item["name"] + "."
    return result


def pp_type_struct_tuple(level: int, item) -> str:
    result = "Module " + item["name"] + ".\n"
    if len(item["ty_params"]) != 0:
        ty_params = "(" + " ".join(item["ty_params"]) + ": Set) "
    else:
        ty_params = ""
    ty_params_links = "".join("`{Link " + ty_param + "} " for ty_param in item["ty_params"])
    result += indent(level + 1) + "Inductive t " + ty_params + ty_params_links + ": Set :=\n"
    result += \
        indent(level + 1) + "| Make :" + \
        "".join(" " + pp_type(False, field) + " ->" for field in item["fields"]) + \
        " t" + "".join(" " + ty_param for ty_param in item["ty_params"]) + ".\n"
    result += indent(level) + "End " + item["name"] + "."
    return result
